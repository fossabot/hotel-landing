(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{3:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// UNUSED EXPORTS: Masked, createMask, MaskedRegExp, MaskedPattern, MaskedRange, MaskedDate, MaskElement, HTMLMaskElement, HTMLContenteditableMaskElement, InputMask, MaskedEnum, MaskedNumber, MaskedFunction, MaskedDynamic, PIPE_TYPE, createPipe, pipe\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/_rollupPluginBabelHelpers-3c58f0e3.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.set) {\n    _rollupPluginBabelHelpers_3c58f0e3_set = Reflect.set;\n  } else {\n    _rollupPluginBabelHelpers_3c58f0e3_set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error(\'failed to set property\');\n  }\n\n  return value;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance");\n}\n\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/utils.js\n\n/** Checks if value is string */\n\nfunction isString(str) {\n  return typeof str === \'string\' || str instanceof String;\n}\n/**\r\n  Direction\r\n  @prop {string} NONE\r\n  @prop {string} LEFT\r\n  @prop {string} FORCE_LEFT\r\n  @prop {string} RIGHT\r\n  @prop {string} FORCE_RIGHT\r\n*/\n\n\nvar DIRECTION = {\n  NONE: \'NONE\',\n  LEFT: \'LEFT\',\n  FORCE_LEFT: \'FORCE_LEFT\',\n  RIGHT: \'RIGHT\',\n  FORCE_RIGHT: \'FORCE_RIGHT\'\n};\n/**\r\n  Direction\r\n  @enum {string}\r\n*/\n\n/** Returns next char index in direction */\n\nfunction indexInDirection(pos, direction) {\n  if (direction === DIRECTION.LEFT) --pos;\n  return pos;\n}\n/** Returns next char position in direction */\n\n\nfunction posInDirection(pos, direction) {\n  switch (direction) {\n    case DIRECTION.LEFT:\n    case DIRECTION.FORCE_LEFT:\n      return --pos;\n\n    case DIRECTION.RIGHT:\n    case DIRECTION.FORCE_RIGHT:\n      return ++pos;\n\n    default:\n      return pos;\n  }\n}\n/** */\n\n\nfunction forceDirection(direction) {\n  switch (direction) {\n    case DIRECTION.LEFT:\n      return DIRECTION.FORCE_LEFT;\n\n    case DIRECTION.RIGHT:\n      return DIRECTION.FORCE_RIGHT;\n\n    default:\n      return direction;\n  }\n}\n/** Escapes regular expression control chars */\n\n\nfunction escapeRegExp(str) {\n  return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, \'\\\\$1\');\n} // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes\n\n\nfunction objectIncludes(b, a) {\n  if (a === b) return true;\n  var arrA = Array.isArray(a),\n      arrB = Array.isArray(b),\n      i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n\n    for (i = 0; i < a.length; i++) {\n      if (!objectIncludes(a[i], b[i])) return false;\n    }\n\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && _typeof(a) === \'object\' && _typeof(b) === \'object\') {\n    var dateA = a instanceof Date,\n        dateB = b instanceof Date;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    if (dateA != dateB) return false;\n    var regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    if (regexpA != regexpB) return false;\n    var keys = Object.keys(a); // if (keys.length !== Object.keys(b).length) return false;\n\n    for (i = 0; i < keys.length; i++) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = 0; i < keys.length; i++) {\n      if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;\n    }\n\n    return true;\n  } else if (a && b && typeof a === \'function\' && typeof b === \'function\') {\n    return a.toString() === b.toString();\n  }\n\n  return false;\n}\n/** Selection range */\n\n\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/action-details.js\n\n\n/** Provides details of changing input */\n\nvar action_details_ActionDetails = /*#__PURE__*/function () {\n  /** Current input value */\n\n  /** Current cursor position */\n\n  /** Old input value */\n\n  /** Old selection */\n  function ActionDetails(value, cursorPos, oldValue, oldSelection) {\n    _classCallCheck(this, ActionDetails);\n\n    this.value = value;\n    this.cursorPos = cursorPos;\n    this.oldValue = oldValue;\n    this.oldSelection = oldSelection; // double check if left part was changed (autofilling, other non-standard input triggers)\n\n    while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {\n      --this.oldSelection.start;\n    }\n  }\n  /**\r\n    Start changing position\r\n    @readonly\r\n  */\n\n\n  _createClass(ActionDetails, [{\n    key: "startChangePos",\n    get: function get() {\n      return Math.min(this.cursorPos, this.oldSelection.start);\n    }\n    /**\r\n      Inserted symbols count\r\n      @readonly\r\n    */\n\n  }, {\n    key: "insertedCount",\n    get: function get() {\n      return this.cursorPos - this.startChangePos;\n    }\n    /**\r\n      Inserted symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "inserted",\n    get: function get() {\n      return this.value.substr(this.startChangePos, this.insertedCount);\n    }\n    /**\r\n      Removed symbols count\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removedCount",\n    get: function get() {\n      // Math.max for opposite operation\n      return Math.max(this.oldSelection.end - this.startChangePos || // for Delete\n      this.oldValue.length - this.value.length, 0);\n    }\n    /**\r\n      Removed symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removed",\n    get: function get() {\n      return this.oldValue.substr(this.startChangePos, this.removedCount);\n    }\n    /**\r\n      Unchanged head symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "head",\n    get: function get() {\n      return this.value.substring(0, this.startChangePos);\n    }\n    /**\r\n      Unchanged tail symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "tail",\n    get: function get() {\n      return this.value.substring(this.startChangePos + this.insertedCount);\n    }\n    /**\r\n      Remove direction\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removeDirection",\n    get: function get() {\n      if (!this.removedCount || this.insertedCount) return DIRECTION.NONE; // align right if delete at right or if range removed (event with backspace)\n\n      return this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? DIRECTION.RIGHT : DIRECTION.LEFT;\n    }\n  }]);\n\n  return ActionDetails;\n}();\n\n/* harmony default export */ var action_details = (action_details_ActionDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/change-details.js\n\n/**\r\n  Provides details of changing model value\r\n  @param {Object} [details]\r\n  @param {string} [details.inserted] - Inserted symbols\r\n  @param {boolean} [details.skip] - Can skip chars\r\n  @param {number} [details.removeCount] - Removed symbols count\r\n  @param {number} [details.tailShift] - Additional offset if any changes occurred before tail\r\n*/\n\nvar change_details_ChangeDetails = /*#__PURE__*/function () {\n  /** Inserted symbols */\n\n  /** Can skip chars */\n\n  /** Additional offset if any changes occurred before tail */\n\n  /** Raw inserted is used by dynamic mask */\n  function ChangeDetails(details) {\n    _classCallCheck(this, ChangeDetails);\n\n    Object.assign(this, {\n      inserted: \'\',\n      rawInserted: \'\',\n      skip: false,\n      tailShift: 0\n    }, details);\n  }\n  /**\r\n    Aggregate changes\r\n    @returns {ChangeDetails} `this`\r\n  */\n\n\n  _createClass(ChangeDetails, [{\n    key: "aggregate",\n    value: function aggregate(details) {\n      this.rawInserted += details.rawInserted;\n      this.skip = this.skip || details.skip;\n      this.inserted += details.inserted;\n      this.tailShift += details.tailShift;\n      return this;\n    }\n    /** Total offset considering all changes */\n\n  }, {\n    key: "offset",\n    get: function get() {\n      return this.tailShift + this.inserted.length;\n    }\n  }]);\n\n  return ChangeDetails;\n}();\n\n/* harmony default export */ var change_details = (change_details_ChangeDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/continuous-tail-details.js\n\n/** Provides details of continuous extracted tail */\n\nvar continuous_tail_details_ContinuousTailDetails = /*#__PURE__*/function () {\n  /** Tail value as string */\n\n  /** Tail start position */\n\n  /** Start position */\n  function ContinuousTailDetails() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var stop = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ContinuousTailDetails);\n\n    this.value = value;\n    this.from = from;\n    this.stop = stop;\n  }\n\n  _createClass(ContinuousTailDetails, [{\n    key: "toString",\n    value: function toString() {\n      return this.value;\n    }\n  }, {\n    key: "extend",\n    value: function extend(tail) {\n      this.value += String(tail);\n    }\n  }, {\n    key: "appendTo",\n    value: function appendTo(masked) {\n      return masked.append(this.toString(), {\n        tail: true\n      }).aggregate(masked._appendPlaceholder());\n    }\n  }, {\n    key: "shiftBefore",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.value.length) return \'\';\n      var shiftChar = this.value[0];\n      this.value = this.value.slice(1);\n      return shiftChar;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        value: this.value,\n        from: this.from,\n        stop: this.stop\n      };\n    },\n    set: function set(state) {\n      Object.assign(this, state);\n    }\n  }]);\n\n  return ContinuousTailDetails;\n}();\n\n/* harmony default export */ var continuous_tail_details = (continuous_tail_details_ContinuousTailDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/holder.js\n/**\r\n * Applies mask on element.\r\n * @constructor\r\n * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask\r\n * @param {Object} opts - Custom mask options\r\n * @return {InputMask}\r\n */\nfunction IMask(el) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // currently available only for input-like elements\n\n  return new IMask.InputMask(el, opts);\n}\n\n/* harmony default export */ var holder = (IMask);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/base.js\n\n\n\n\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar base_Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = \'\';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, {}, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: "updateOptions",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: "_update",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: "reset",\n\n    /** Resets value */\n    value: function reset() {\n      this._value = \'\';\n    }\n    /** */\n\n  }, {\n    key: "resolve",\n\n    /** Resolve new value */\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, \'\');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: "nearestInputPos",\n\n    /** Finds nearest input position in direction */\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new continuous_tail_details(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: "appendTail",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new continuous_tail_details(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n      if (!ch) return new change_details();\n      this._value += ch;\n      return new change_details({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(ch, flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new change_details();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      return new change_details();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: "append",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error(\'value should be string\');\n      var details = new change_details();\n      var checkTail = isString(tail) ? new continuous_tail_details(String(tail)) : tail;\n      if (flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it\'s a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new change_details();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: "withValueRefresh",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, \'\');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: "runIsolated",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: "doFormat",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: "doParse",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: "splice",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new change_details({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, \'\');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: "rawInputValue",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, \'\');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Masked;\n}();\n\nbase_Masked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nholder.Masked = base_Masked;\n/* harmony default export */ var base = (base_Masked);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/factory.js\n\n\n\n/** Get Masked class by mask type */\n\nfunction maskedClass(mask) {\n  if (mask == null) {\n    throw new Error(\'mask property should be defined\');\n  } // $FlowFixMe\n\n\n  if (mask instanceof RegExp) return holder.MaskedRegExp; // $FlowFixMe\n\n  if (isString(mask)) return holder.MaskedPattern; // $FlowFixMe\n\n  if (mask instanceof Date || mask === Date) return holder.MaskedDate; // $FlowFixMe\n\n  if (mask instanceof Number || typeof mask === \'number\' || mask === Number) return holder.MaskedNumber; // $FlowFixMe\n\n  if (Array.isArray(mask) || mask === Array) return holder.MaskedDynamic; // $FlowFixMe\n\n  if (holder.Masked && mask.prototype instanceof holder.Masked) return mask; // $FlowFixMe\n\n  if (mask instanceof Function) return holder.MaskedFunction; // $FlowFixMe\n\n  if (mask instanceof holder.Masked) return mask.constructor;\n  console.warn(\'Mask not found for mask\', mask); // eslint-disable-line no-console\n  // $FlowFixMe\n\n  return holder.Masked;\n}\n/** Creates new {@link Masked} depending on mask type */\n\n\nfunction createMask(opts) {\n  // $FlowFixMe\n  if (holder.Masked && opts instanceof holder.Masked) return opts;\n  opts = Object.assign({}, opts);\n  var mask = opts.mask; // $FlowFixMe\n\n  if (holder.Masked && mask instanceof holder.Masked) return mask;\n  var MaskedClass = maskedClass(mask);\n  if (!MaskedClass) throw new Error(\'Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.\');\n  return new MaskedClass(opts);\n}\n\nholder.createMask = createMask;\n/* harmony default export */ var factory = (createMask);\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/input-definition.js\n\n\n\n\n\nvar DEFAULT_INPUT_DEFINITIONS = {\n  \'0\': /\\d/,\n  \'a\': /[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n  // http://stackoverflow.com/a/22075070\n  \'*\': /./\n};\n/** */\n\nvar input_definition_PatternInputDefinition = /*#__PURE__*/function () {\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n  function PatternInputDefinition(opts) {\n    _classCallCheck(this, PatternInputDefinition);\n\n    var mask = opts.mask,\n        blockOpts = _objectWithoutProperties(opts, ["mask"]);\n\n    this.masked = factory({\n      mask: mask\n    });\n    Object.assign(this, blockOpts);\n  }\n\n  _createClass(PatternInputDefinition, [{\n    key: "reset",\n    value: function reset() {\n      this._isFilled = false;\n      this.masked.reset();\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      if (fromPos === 0 && toPos >= 1) {\n        this._isFilled = false;\n        return this.masked.remove(fromPos, toPos);\n      }\n\n      return new change_details();\n    }\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this._isFilled) return new change_details();\n      var state = this.masked.state; // simulate input\n\n      var details = this.masked._appendChar(str, flags);\n\n      if (details.inserted && this.doValidate(flags) === false) {\n        details.inserted = details.rawInserted = \'\';\n        this.masked.state = state;\n      }\n\n      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {\n        details.inserted = this.placeholderChar;\n      }\n\n      details.skip = !details.inserted && !this.isOptional;\n      this._isFilled = Boolean(details.inserted);\n      return details;\n    }\n  }, {\n    key: "append",\n    value: function append() {\n      var _this$masked;\n\n      return (_this$masked = this.masked).append.apply(_this$masked, arguments);\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = new change_details();\n      if (this._isFilled || this.isOptional) return details;\n      this._isFilled = true;\n      details.inserted = this.placeholderChar;\n      return details;\n    }\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this$masked2;\n\n      return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);\n    }\n  }, {\n    key: "appendTail",\n    value: function appendTail() {\n      var _this$masked3;\n\n      return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);\n    }\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 ? arguments[2] : undefined;\n      return this.masked.extractInput(fromPos, toPos, flags);\n    }\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      var minPos = 0;\n      var maxPos = this.value.length;\n      var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);\n\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return this.isComplete ? boundPos : minPos;\n\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          return this.isComplete ? boundPos : maxPos;\n\n        case DIRECTION.NONE:\n        default:\n          return boundPos;\n      }\n    }\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _this$masked4, _this$parent;\n\n      return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));\n    }\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      this.masked.doCommit();\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : \'\');\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.masked.unmaskedValue;\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return Boolean(this.masked.value) || this.isOptional;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        masked: this.masked.state,\n        _isFilled: this._isFilled\n      };\n    },\n    set: function set(state) {\n      this.masked.state = state.masked;\n      this._isFilled = state._isFilled;\n    }\n  }]);\n\n  return PatternInputDefinition;\n}();\n\n/* harmony default export */ var input_definition = (input_definition_PatternInputDefinition);\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/fixed-definition.js\n\n\n\n\n\nvar fixed_definition_PatternFixedDefinition = /*#__PURE__*/function () {\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n  function PatternFixedDefinition(opts) {\n    _classCallCheck(this, PatternFixedDefinition);\n\n    Object.assign(this, opts);\n    this._value = \'\';\n  }\n\n  _createClass(PatternFixedDefinition, [{\n    key: "reset",\n    value: function reset() {\n      this._isRawInput = false;\n      this._value = \'\';\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;\n      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);\n      if (!this._value) this._isRawInput = false;\n      return new change_details();\n    }\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      var minPos = 0;\n      var maxPos = this._value.length;\n\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return minPos;\n\n        case DIRECTION.NONE:\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n        default:\n          return maxPos;\n      }\n    }\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || \'\';\n    }\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var details = new change_details();\n      if (this._value) return details;\n      var appended = this.char === str[0];\n      var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !flags.tail;\n      if (isResolved) details.rawInserted = this.char;\n      this._value = details.inserted = this.char;\n      this._isRawInput = isResolved && (flags.raw || flags.input);\n      return details;\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = new change_details();\n      if (this._value) return details;\n      this._value = details.inserted = this.char;\n      return details;\n    }\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new continuous_tail_details(\'\');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: "appendTail",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new continuous_tail_details(String(tail));\n      return tail.appendTo(this);\n    }\n  }, {\n    key: "append",\n    value: function append(str, flags, tail) {\n      var details = this._appendChar(str, flags);\n\n      if (tail != null) {\n        details.tailShift += this.appendTail(tail).tailShift;\n      }\n\n      return details;\n    }\n  }, {\n    key: "doCommit",\n    value: function doCommit() {}\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.isUnmasking ? this.value : \'\';\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        _value: this._value,\n        _isRawInput: this._isRawInput\n      };\n    },\n    set: function set(state) {\n      Object.assign(this, state);\n    }\n  }]);\n\n  return PatternFixedDefinition;\n}();\n\n/* harmony default export */ var fixed_definition = (fixed_definition_PatternFixedDefinition);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/chunk-tail-details.js\n\n\n\n\n\n\nvar chunk_tail_details_ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: "toString",\n    value: function toString() {\n      return this.chunks.map(String).join(\'\');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: "extend",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new continuous_tail_details(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof continuous_tail_details) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: "appendTo",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof holder.MaskedPattern)) {\n        var tail = new continuous_tail_details(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new change_details();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: "shiftBefore",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.chunks.length) return \'\';\n      var chunkShiftPos = pos - this.from;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shiftBefore(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return \'\';\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, ["chunks"]);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = "chunks" in cstate ? new ChunksTailDetails() : new continuous_tail_details(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\n/* harmony default export */ var chunk_tail_details = (chunk_tail_details_ChunksTailDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/regexp.js\n\n\n\n\n\n\n/** Masking by RegExp */\n\nvar regexp_MaskedRegExp = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedRegExp, _Masked);\n\n  function MaskedRegExp() {\n    _classCallCheck(this, MaskedRegExp);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedRegExp).apply(this, arguments));\n  }\n\n  _createClass(MaskedRegExp, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      if (opts.mask) opts.validate = function (value) {\n        return value.search(opts.mask) >= 0;\n      };\n\n      _get(_getPrototypeOf(MaskedRegExp.prototype), "_update", this).call(this, opts);\n    }\n  }]);\n\n  return MaskedRegExp;\n}(base);\n\nholder.MaskedRegExp = regexp_MaskedRegExp;\n/* harmony default export */ var masked_regexp = (regexp_MaskedRegExp);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern.js\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\n\nvar pattern_MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedPattern).call(this, Object.assign({}, MaskedPattern.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: "_update",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), "_update", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: "_rebuildMask",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              var maskedBlock = factory(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return "continue";\n            }\n          }();\n\n          if (_ret === "continue") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === \'{\' || char === \'}\') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === \'[\' || char === \']\') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new input_definition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new fixed_definition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "reset",\n\n    /**\r\n      @override\r\n    */\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), "reset", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n\n    /**\r\n      @override\r\n    */\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), "doCommit", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "appendTail",\n\n    /**\r\n      @override\r\n    */\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new change_details();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new chunk_tail_details();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof chunk_tail_details) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return \'\';\n      var input = \'\';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: "_findStopBefore",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new change_details();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: "_mapPosToBlock",\n    value: function _mapPosToBlock(pos) {\n      var accVal = \'\';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: "_blockStartPos",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: "_forEachBlocksInRange",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), "remove", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE; // TODO refactor - extract alignblock\n\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: "maskedBlock",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: "maskedBlocks",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), "state", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, ["_blocks"]);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), "state", maskedState, this, true);\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, \'\');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), "unmaskedValue", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "value",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, \'\');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), "value", value, this, true);\n    }\n  }]);\n\n  return MaskedPattern;\n}(base);\n\npattern_MaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: \'_\'\n};\npattern_MaskedPattern.STOP_CHAR = \'`\';\npattern_MaskedPattern.ESCAPE_CHAR = \'\\\\\';\npattern_MaskedPattern.InputDefinition = input_definition;\npattern_MaskedPattern.FixedDefinition = fixed_definition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nholder.MaskedPattern = pattern_MaskedPattern;\n/* harmony default export */ var masked_pattern = (pattern_MaskedPattern);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/range.js\n\n\n\n\n\n\n\n\n\n\n\n\n/** Pattern which accepts ranges */\n\nvar range_MaskedRange = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedRange, _MaskedPattern);\n\n  function MaskedRange() {\n    _classCallCheck(this, MaskedRange);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedRange).apply(this, arguments));\n  }\n\n  _createClass(MaskedRange, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n    */\n    value: function _update(opts) {\n      // TODO type\n      opts = Object.assign({\n        to: this.to || 0,\n        from: this.from || 0\n      }, opts);\n      var maxLength = String(opts.to).length;\n      if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n      opts.maxLength = maxLength;\n      var fromStr = String(opts.from).padStart(maxLength, \'0\');\n      var toStr = String(opts.to).padStart(maxLength, \'0\');\n      var sameCharsCount = 0;\n\n      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {\n        ++sameCharsCount;\n      }\n\n      opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, \'\\\\0\') + \'0\'.repeat(maxLength - sameCharsCount);\n\n      _get(_getPrototypeOf(MaskedRange.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "boundaries",\n    value: function boundaries(str) {\n      var minstr = \'\';\n      var maxstr = \'\';\n\n      var _ref = str.match(/^(\\D*)(\\d*)(\\D*)/) || [],\n          _ref2 = _slicedToArray(_ref, 3),\n          placeholder = _ref2[1],\n          num = _ref2[2];\n\n      if (num) {\n        minstr = \'0\'.repeat(placeholder.length) + num;\n        maxstr = \'9\'.repeat(placeholder.length) + num;\n      }\n\n      minstr = minstr.padEnd(this.maxLength, \'0\');\n      maxstr = maxstr.padEnd(this.maxLength, \'9\');\n      return [minstr, maxstr];\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      str = _get(_getPrototypeOf(MaskedRange.prototype), "doPrepare", this).call(this, str, flags).replace(/\\D/g, \'\');\n      if (!this.autofix) return str;\n      var fromStr = String(this.from).padStart(this.maxLength, \'0\');\n      var toStr = String(this.to).padStart(this.maxLength, \'0\');\n      var val = this.value;\n      var prepStr = \'\';\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        var nextVal = val + prepStr + str[ci];\n\n        var _this$boundaries = this.boundaries(nextVal),\n            _this$boundaries2 = _slicedToArray(_this$boundaries, 2),\n            minstr = _this$boundaries2[0],\n            maxstr = _this$boundaries2[1];\n\n        if (Number(maxstr) < this.from) prepStr += fromStr[nextVal.length - 1];else if (Number(minstr) > this.to) prepStr += toStr[nextVal.length - 1];else prepStr += str[ci];\n      }\n\n      return prepStr;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2;\n\n      var str = this.value;\n      var firstNonZero = str.search(/[^0]/);\n      if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n\n      var _this$boundaries3 = this.boundaries(str),\n          _this$boundaries4 = _slicedToArray(_this$boundaries3, 2),\n          minstr = _this$boundaries4[0],\n          maxstr = _this$boundaries4[1];\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: "_matchFrom",\n\n    /**\r\n      Optionally sets max length of pattern.\r\n      Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\r\n    */\n\n    /** Min bound */\n\n    /** Max bound */\n\n    /** */\n    get: function get() {\n      return this.maxLength - String(this.from).length;\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return _get(_getPrototypeOf(MaskedRange.prototype), "isComplete", this) && Boolean(this.value);\n    }\n  }]);\n\n  return MaskedRange;\n}(masked_pattern);\n\nholder.MaskedRange = range_MaskedRange;\n/* harmony default export */ var range = (range_MaskedRange);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/date.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Date mask */\n\nvar date_MaskedDate = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedDate, _MaskedPattern);\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\r\n    @param {Object} opts\r\n  */\n\n\n  function MaskedDate(opts) {\n    _classCallCheck(this, MaskedDate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedDate).call(this, Object.assign({}, MaskedDate.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDate, [{\n    key: "_update",\n    value: function _update(opts) {\n      if (opts.mask === Date) delete opts.mask;\n      if (opts.pattern) opts.mask = opts.pattern;\n      var blocks = opts.blocks;\n      opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block\n\n      if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n      if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n\n      if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n        opts.blocks.m.from = opts.min.getMonth() + 1;\n        opts.blocks.m.to = opts.max.getMonth() + 1;\n\n        if (opts.blocks.m.from === opts.blocks.m.to) {\n          opts.blocks.d.from = opts.min.getDate();\n          opts.blocks.d.to = opts.max.getDate();\n        }\n      }\n\n      Object.assign(opts.blocks, blocks); // add autofix\n\n      Object.keys(opts.blocks).forEach(function (bk) {\n        var b = opts.blocks[bk];\n        if (!(\'autofix\' in b)) b.autofix = opts.autofix;\n      });\n\n      _get(_getPrototypeOf(MaskedDate.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2;\n\n      var date = this.date;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDate.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n    }\n    /** Checks if date is exists */\n\n  }, {\n    key: "isDateExist",\n    value: function isDateExist(str) {\n      return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n    }\n    /** Parsed Date */\n\n  }, {\n    key: "date",\n    get: function get() {\n      return this.typedValue;\n    },\n    set: function set(date) {\n      this.typedValue = date;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.isComplete ? _get(_getPrototypeOf(MaskedDate.prototype), "typedValue", this) : null;\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDate.prototype), "typedValue", value, this, true);\n    }\n  }]);\n\n  return MaskedDate;\n}(masked_pattern);\n\ndate_MaskedDate.DEFAULTS = {\n  pattern: \'d{.}`m{.}`Y\',\n  format: function format(date) {\n    var day = String(date.getDate()).padStart(2, \'0\');\n    var month = String(date.getMonth() + 1).padStart(2, \'0\');\n    var year = date.getFullYear();\n    return [day, month, year].join(\'.\');\n  },\n  parse: function parse(str) {\n    var _str$split = str.split(\'.\'),\n        _str$split2 = _slicedToArray(_str$split, 3),\n        day = _str$split2[0],\n        month = _str$split2[1],\n        year = _str$split2[2];\n\n    return new Date(year, month - 1, day);\n  }\n};\n\ndate_MaskedDate.GET_DEFAULT_BLOCKS = function () {\n  return {\n    d: {\n      mask: range,\n      from: 1,\n      to: 31,\n      maxLength: 2\n    },\n    m: {\n      mask: range,\n      from: 1,\n      to: 12,\n      maxLength: 2\n    },\n    Y: {\n      mask: range,\n      from: 1900,\n      to: 9999\n    }\n  };\n};\n\nholder.MaskedDate = date_MaskedDate;\n/* harmony default export */ var masked_date = (date_MaskedDate);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/mask-element.js\n\n\n/**\r\n  Generic element API to use with mask\r\n  @interface\r\n*/\n\nvar mask_element_MaskElement = /*#__PURE__*/function () {\n  function MaskElement() {\n    _classCallCheck(this, MaskElement);\n  }\n\n  _createClass(MaskElement, [{\n    key: "select",\n\n    /** Safely sets element selection */\n    value: function select(start, end) {\n      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;\n\n      try {\n        this._unsafeSelect(start, end);\n      } catch (e) {}\n    }\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "_unsafeSelect",\n    value: function _unsafeSelect(start, end) {}\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "bindEvents",\n\n    /** Should be overriden in subclasses */\n    value: function bindEvents(handlers) {}\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "unbindEvents",\n    value: function unbindEvents() {}\n  }, {\n    key: "selectionStart",\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** Safely returns selection start */\n    get: function get() {\n      var start;\n\n      try {\n        start = this._unsafeSelectionStart;\n      } catch (e) {}\n\n      return start != null ? start : this.value.length;\n    }\n    /** Safely returns selection end */\n\n  }, {\n    key: "selectionEnd",\n    get: function get() {\n      var end;\n\n      try {\n        end = this._unsafeSelectionEnd;\n      } catch (e) {}\n\n      return end != null ? end : this.value.length;\n    }\n  }, {\n    key: "isActive",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return MaskElement;\n}();\n\nholder.MaskElement = mask_element_MaskElement;\n/* harmony default export */ var mask_element = (mask_element_MaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/html-mask-element.js\n\n\n\n/** Bridge between HTMLElement and {@link Masked} */\n\nvar html_mask_element_HTMLMaskElement = /*#__PURE__*/function (_MaskElement) {\n  _inherits(HTMLMaskElement, _MaskElement);\n  /** Mapping between HTMLElement events and mask internal events */\n\n  /** HTMLElement to use mask on */\n\n  /**\r\n    @param {HTMLInputElement|HTMLTextAreaElement} input\r\n  */\n\n\n  function HTMLMaskElement(input) {\n    var _this;\n\n    _classCallCheck(this, HTMLMaskElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLMaskElement).call(this));\n    _this.input = input;\n    _this._handlers = {};\n    return _this;\n  }\n  /** */\n  // $FlowFixMe https://github.com/facebook/flow/issues/2839\n\n\n  _createClass(HTMLMaskElement, [{\n    key: "_unsafeSelect",\n\n    /**\r\n      Sets HTMLElement selection\r\n      @override\r\n    */\n    value: function _unsafeSelect(start, end) {\n      this.input.setSelectionRange(start, end);\n    }\n    /**\r\n      HTMLElement value\r\n      @override\r\n    */\n\n  }, {\n    key: "bindEvents",\n\n    /**\r\n      Binds HTMLElement events to mask internal events\r\n      @override\r\n    */\n    value: function bindEvents(handlers) {\n      var _this2 = this;\n\n      Object.keys(handlers).forEach(function (event) {\n        return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);\n      });\n    }\n    /**\r\n      Unbinds HTMLElement events to mask internal events\r\n      @override\r\n    */\n\n  }, {\n    key: "unbindEvents",\n    value: function unbindEvents() {\n      var _this3 = this;\n\n      Object.keys(this._handlers).forEach(function (event) {\n        return _this3._toggleEventHandler(event);\n      });\n    }\n    /** */\n\n  }, {\n    key: "_toggleEventHandler",\n    value: function _toggleEventHandler(event, handler) {\n      if (this._handlers[event]) {\n        this.input.removeEventListener(event, this._handlers[event]);\n        delete this._handlers[event];\n      }\n\n      if (handler) {\n        this.input.addEventListener(event, handler);\n        this._handlers[event] = handler;\n      }\n    }\n  }, {\n    key: "rootElement",\n    get: function get() {\n      return this.input.getRootNode ? this.input.getRootNode() : document;\n    }\n    /**\r\n      Is element in focus\r\n      @readonly\r\n    */\n\n  }, {\n    key: "isActive",\n    get: function get() {\n      //$FlowFixMe\n      return this.input === this.rootElement.activeElement;\n    }\n    /**\r\n      Returns HTMLElement selection start\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionStart",\n    get: function get() {\n      return this.input.selectionStart;\n    }\n    /**\r\n      Returns HTMLElement selection end\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionEnd",\n    get: function get() {\n      return this.input.selectionEnd;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.input.value;\n    },\n    set: function set(value) {\n      this.input.value = value;\n    }\n  }]);\n\n  return HTMLMaskElement;\n}(mask_element);\n\nhtml_mask_element_HTMLMaskElement.EVENTS_MAP = {\n  selectionChange: \'keydown\',\n  input: \'input\',\n  drop: \'drop\',\n  click: \'click\',\n  focus: \'focus\',\n  commit: \'blur\'\n};\nholder.HTMLMaskElement = html_mask_element_HTMLMaskElement;\n/* harmony default export */ var html_mask_element = (html_mask_element_HTMLMaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/html-contenteditable-mask-element.js\n\n\n\n\n\nvar html_contenteditable_mask_element_HTMLContenteditableMaskElement = /*#__PURE__*/function (_HTMLMaskElement) {\n  _inherits(HTMLContenteditableMaskElement, _HTMLMaskElement);\n\n  function HTMLContenteditableMaskElement() {\n    _classCallCheck(this, HTMLContenteditableMaskElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HTMLContenteditableMaskElement).apply(this, arguments));\n  }\n\n  _createClass(HTMLContenteditableMaskElement, [{\n    key: "_unsafeSelect",\n\n    /**\r\n      Sets HTMLElement selection\r\n      @override\r\n    */\n    value: function _unsafeSelect(start, end) {\n      if (!this.rootElement.createRange) return;\n      var range = this.rootElement.createRange();\n      range.setStart(this.input.firstChild || this.input, start);\n      range.setEnd(this.input.lastChild || this.input, end);\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n\n      if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    }\n    /**\r\n      HTMLElement value\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionStart",\n\n    /**\r\n      Returns HTMLElement selection start\r\n      @override\r\n    */\n    get: function get() {\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n      return selection && selection.anchorOffset;\n    }\n    /**\r\n      Returns HTMLElement selection end\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionEnd",\n    get: function get() {\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n      return selection && this._unsafeSelectionStart + String(selection).length;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      // $FlowFixMe\n      return this.input.textContent;\n    },\n    set: function set(value) {\n      this.input.textContent = value;\n    }\n  }]);\n\n  return HTMLContenteditableMaskElement;\n}(html_mask_element);\n\nholder.HTMLContenteditableMaskElement = html_contenteditable_mask_element_HTMLContenteditableMaskElement;\n/* harmony default export */ var html_contenteditable_mask_element = (html_contenteditable_mask_element_HTMLContenteditableMaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/input.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Listens to element events and controls changes between element and {@link Masked} */\n\nvar input_InputMask = /*#__PURE__*/function () {\n  /**\r\n    View element\r\n    @readonly\r\n  */\n\n  /**\r\n    Internal {@link Masked} model\r\n    @readonly\r\n  */\n\n  /**\r\n    @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el\r\n    @param {Object} opts\r\n  */\n  function InputMask(el, opts) {\n    _classCallCheck(this, InputMask);\n\n    this.el = el instanceof mask_element ? el : el.isContentEditable && el.tagName !== \'INPUT\' && el.tagName !== \'TEXTAREA\' ? new html_contenteditable_mask_element(el) : new html_mask_element(el);\n    this.masked = factory(opts);\n    this._listeners = {};\n    this._value = \'\';\n    this._unmaskedValue = \'\';\n    this._saveSelection = this._saveSelection.bind(this);\n    this._onInput = this._onInput.bind(this);\n    this._onChange = this._onChange.bind(this);\n    this._onDrop = this._onDrop.bind(this);\n    this._onFocus = this._onFocus.bind(this);\n    this._onClick = this._onClick.bind(this);\n    this.alignCursor = this.alignCursor.bind(this);\n    this.alignCursorFriendly = this.alignCursorFriendly.bind(this);\n\n    this._bindEvents(); // refresh\n\n\n    this.updateValue();\n\n    this._onChange();\n  }\n  /** Read or update mask */\n\n\n  _createClass(InputMask, [{\n    key: "maskEquals",\n    value: function maskEquals(mask) {\n      return mask == null || mask === this.masked.mask || mask === Date && this.masked instanceof masked_date;\n    }\n  }, {\n    key: "_bindEvents",\n\n    /**\r\n      Starts listening to element events\r\n      @protected\r\n    */\n    value: function _bindEvents() {\n      this.el.bindEvents({\n        selectionChange: this._saveSelection,\n        input: this._onInput,\n        drop: this._onDrop,\n        click: this._onClick,\n        focus: this._onFocus,\n        commit: this._onChange\n      });\n    }\n    /**\r\n      Stops listening to element events\r\n      @protected\r\n     */\n\n  }, {\n    key: "_unbindEvents",\n    value: function _unbindEvents() {\n      if (this.el) this.el.unbindEvents();\n    }\n    /**\r\n      Fires custom event\r\n      @protected\r\n     */\n\n  }, {\n    key: "_fireEvent",\n    value: function _fireEvent(ev) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var listeners = this._listeners[ev];\n      if (!listeners) return;\n      listeners.forEach(function (l) {\n        return l.apply(void 0, args);\n      });\n    }\n    /**\r\n      Current selection start\r\n      @readonly\r\n    */\n\n  }, {\n    key: "_saveSelection",\n\n    /**\r\n      Stores current selection\r\n      @protected\r\n    */\n    value: function _saveSelection()\n    /* ev */\n    {\n      if (this.value !== this.el.value) {\n        console.warn(\'Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.\'); // eslint-disable-line no-console\n      }\n\n      this._selection = {\n        start: this.selectionStart,\n        end: this.cursorPos\n      };\n    }\n    /** Syncronizes model value from view */\n\n  }, {\n    key: "updateValue",\n    value: function updateValue() {\n      this.masked.value = this.el.value;\n      this._value = this.masked.value;\n    }\n    /** Syncronizes view from model value, fires change events */\n\n  }, {\n    key: "updateControl",\n    value: function updateControl() {\n      var newUnmaskedValue = this.masked.unmaskedValue;\n      var newValue = this.masked.value;\n      var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;\n      this._unmaskedValue = newUnmaskedValue;\n      this._value = newValue;\n      if (this.el.value !== newValue) this.el.value = newValue;\n      if (isChanged) this._fireChangeEvents();\n    }\n    /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */\n\n  }, {\n    key: "updateOptions",\n    value: function updateOptions(opts) {\n      var mask = opts.mask,\n          restOpts = _objectWithoutProperties(opts, ["mask"]);\n\n      var updateMask = !this.maskEquals(mask);\n      var updateOpts = !objectIncludes(this.masked, restOpts);\n      if (updateMask) this.mask = mask;\n      if (updateOpts) this.masked.updateOptions(restOpts);\n      if (updateMask || updateOpts) this.updateControl();\n    }\n    /** Updates cursor */\n\n  }, {\n    key: "updateCursor",\n    value: function updateCursor(cursorPos) {\n      if (cursorPos == null) return;\n      this.cursorPos = cursorPos; // also queue change cursor for mobile browsers\n\n      this._delayUpdateCursor(cursorPos);\n    }\n    /**\r\n      Delays cursor update to support mobile browsers\r\n      @private\r\n    */\n\n  }, {\n    key: "_delayUpdateCursor",\n    value: function _delayUpdateCursor(cursorPos) {\n      var _this = this;\n\n      this._abortUpdateCursor();\n\n      this._changingCursorPos = cursorPos;\n      this._cursorChanging = setTimeout(function () {\n        if (!_this.el) return; // if was destroyed\n\n        _this.cursorPos = _this._changingCursorPos;\n\n        _this._abortUpdateCursor();\n      }, 10);\n    }\n    /**\r\n      Fires custom events\r\n      @protected\r\n    */\n\n  }, {\n    key: "_fireChangeEvents",\n    value: function _fireChangeEvents() {\n      this._fireEvent(\'accept\', this._inputEvent);\n\n      if (this.masked.isComplete) this._fireEvent(\'complete\', this._inputEvent);\n    }\n    /**\r\n      Aborts delayed cursor update\r\n      @private\r\n    */\n\n  }, {\n    key: "_abortUpdateCursor",\n    value: function _abortUpdateCursor() {\n      if (this._cursorChanging) {\n        clearTimeout(this._cursorChanging);\n        delete this._cursorChanging;\n      }\n    }\n    /** Aligns cursor to nearest available position */\n\n  }, {\n    key: "alignCursor",\n    value: function alignCursor() {\n      this.cursorPos = this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT);\n    }\n    /** Aligns cursor only if selection is empty */\n\n  }, {\n    key: "alignCursorFriendly",\n    value: function alignCursorFriendly() {\n      if (this.selectionStart !== this.cursorPos) return; // skip if range is selected\n\n      this.alignCursor();\n    }\n    /** Adds listener on custom event */\n\n  }, {\n    key: "on",\n    value: function on(ev, handler) {\n      if (!this._listeners[ev]) this._listeners[ev] = [];\n\n      this._listeners[ev].push(handler);\n\n      return this;\n    }\n    /** Removes custom event listener */\n\n  }, {\n    key: "off",\n    value: function off(ev, handler) {\n      if (!this._listeners[ev]) return this;\n\n      if (!handler) {\n        delete this._listeners[ev];\n        return this;\n      }\n\n      var hIndex = this._listeners[ev].indexOf(handler);\n\n      if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);\n      return this;\n    }\n    /** Handles view input event */\n\n  }, {\n    key: "_onInput",\n    value: function _onInput(e) {\n      this._inputEvent = e;\n\n      this._abortUpdateCursor(); // fix strange IE behavior\n\n\n      if (!this._selection) return this.updateValue();\n      var details = new action_details( // new state\n      this.el.value, this.cursorPos, // old state\n      this.value, this._selection);\n      var oldRawValue = this.masked.rawInputValue;\n      var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset; // force align in remove direction only if no input chars were removed\n      // otherwise we still need to align with NONE (to get out from fixed symbols for instance)\n\n      var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;\n      var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);\n      this.updateControl();\n      this.updateCursor(cursorPos);\n      delete this._inputEvent;\n    }\n    /** Handles view change event and commits model value */\n\n  }, {\n    key: "_onChange",\n    value: function _onChange() {\n      if (this.value !== this.el.value) {\n        this.updateValue();\n      }\n\n      this.masked.doCommit();\n      this.updateControl();\n\n      this._saveSelection();\n    }\n    /** Handles view drop event, prevents by default */\n\n  }, {\n    key: "_onDrop",\n    value: function _onDrop(ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    /** Restore last selection on focus */\n\n  }, {\n    key: "_onFocus",\n    value: function _onFocus(ev) {\n      this.alignCursorFriendly();\n    }\n    /** Restore last selection on focus */\n\n  }, {\n    key: "_onClick",\n    value: function _onClick(ev) {\n      this.alignCursorFriendly();\n    }\n    /** Unbind view events and removes element reference */\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._unbindEvents(); // $FlowFixMe why not do so?\n\n\n      this._listeners.length = 0; // $FlowFixMe\n\n      delete this.el;\n    }\n  }, {\n    key: "mask",\n    get: function get() {\n      return this.masked.mask;\n    },\n    set: function set(mask) {\n      if (this.maskEquals(mask)) return;\n\n      if (!(mask instanceof holder.Masked) && this.masked.constructor === maskedClass(mask)) {\n        this.masked.updateOptions({\n          mask: mask\n        });\n        return;\n      }\n\n      var masked = factory({\n        mask: mask\n      });\n      masked.unmaskedValue = this.masked.unmaskedValue;\n      this.masked = masked;\n    }\n    /** Raw value */\n\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(str) {\n      this.masked.value = str;\n      this.updateControl();\n      this.alignCursor();\n    }\n    /** Unmasked value */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._unmaskedValue;\n    },\n    set: function set(str) {\n      this.masked.unmaskedValue = str;\n      this.updateControl();\n      this.alignCursor();\n    }\n    /** Typed unmasked value */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.masked.typedValue;\n    },\n    set: function set(val) {\n      this.masked.typedValue = val;\n      this.updateControl();\n      this.alignCursor();\n    }\n  }, {\n    key: "selectionStart",\n    get: function get() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;\n    }\n    /** Current cursor position */\n\n  }, {\n    key: "cursorPos",\n    get: function get() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;\n    },\n    set: function set(pos) {\n      if (!this.el || !this.el.isActive) return;\n      this.el.select(pos, pos);\n\n      this._saveSelection();\n    }\n  }]);\n\n  return InputMask;\n}();\n\nholder.InputMask = input_InputMask;\n/* harmony default export */ var controls_input = (input_InputMask);\n// CONCATENATED MODULE: ./node_modules/imask/esm/imask.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var imask = (holder);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/enum.js\n\n\n\n\n\n\n\n\n\n\n\n\n/** Pattern which validates enum values */\n\nvar enum_MaskedEnum = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedEnum, _MaskedPattern);\n\n  function MaskedEnum() {\n    _classCallCheck(this, MaskedEnum);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedEnum).apply(this, arguments));\n  }\n\n  _createClass(MaskedEnum, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      // TODO type\n      if (opts.enum) opts.mask = \'*\'.repeat(opts.enum[0].length);\n\n      _get(_getPrototypeOf(MaskedEnum.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _this = this,\n          _get2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.enum.some(function (e) {\n        return e.indexOf(_this.unmaskedValue) >= 0;\n      }) && (_get2 = _get(_getPrototypeOf(MaskedEnum.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));\n    }\n  }]);\n\n  return MaskedEnum;\n}(masked_pattern);\n\nholder.MaskedEnum = enum_MaskedEnum;\n/* harmony default export */ var masked_enum = (enum_MaskedEnum);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/number.js\n\n\n\n\n\n\n/**\r\n  Number mask\r\n  @param {Object} opts\r\n  @param {string} opts.radix - Single char\r\n  @param {string} opts.thousandsSeparator - Single char\r\n  @param {Array<string>} opts.mapToRadix - Array of single chars\r\n  @param {number} opts.min\r\n  @param {number} opts.max\r\n  @param {number} opts.scale - Digits after point\r\n  @param {boolean} opts.signed - Allow negative\r\n  @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing\r\n  @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing\r\n*/\n\nvar number_MaskedNumber = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedNumber, _Masked);\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n\n  function MaskedNumber(opts) {\n    _classCallCheck(this, MaskedNumber);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedNumber).call(this, Object.assign({}, MaskedNumber.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedNumber, [{\n    key: "_update",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedNumber.prototype), "_update", this).call(this, opts);\n\n      this._updateRegExps();\n    }\n    /** */\n\n  }, {\n    key: "_updateRegExps",\n    value: function _updateRegExps() {\n      // use different regexp to process user input (more strict, input suffix) and tail shifting\n      var start = \'^\' + (this.allowNegative ? \'[+|\\\\-]?\' : \'\');\n      var midInput = \'(0|([1-9]+\\\\d*))?\';\n      var mid = \'\\\\d*\';\n      var end = (this.scale ? \'(\' + escapeRegExp(this.radix) + \'\\\\d{0,\' + this.scale + \'})?\' : \'\') + \'$\';\n      this._numberRegExpInput = new RegExp(start + midInput + end);\n      this._numberRegExp = new RegExp(start + mid + end);\n      this._mapToRadixRegExp = new RegExp(\'[\' + this.mapToRadix.map(escapeRegExp).join(\'\') + \']\', \'g\');\n      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), \'g\');\n    }\n    /** */\n\n  }, {\n    key: "_removeThousandsSeparators",\n    value: function _removeThousandsSeparators(value) {\n      return value.replace(this._thousandsSeparatorRegExp, \'\');\n    }\n    /** */\n\n  }, {\n    key: "_insertThousandsSeparators",\n    value: function _insertThousandsSeparators(value) {\n      // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n      var parts = value.split(this.radix);\n      parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n      return parts.join(this.radix);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var _get2;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedNumber.prototype), "doPrepare", this)).call.apply(_get2, [this, this._removeThousandsSeparators(str.replace(this._mapToRadixRegExp, this.radix))].concat(args));\n    }\n    /** */\n\n  }, {\n    key: "_separatorsCount",\n    value: function _separatorsCount(to) {\n      var extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var count = 0;\n\n      for (var pos = 0; pos < to; ++pos) {\n        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n          ++count;\n          if (extendOnSeparators) to += this.thousandsSeparator.length;\n        }\n      }\n\n      return count;\n    }\n    /** */\n\n  }, {\n    key: "_separatorsCountFromSlice",\n    value: function _separatorsCountFromSlice() {\n      var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;\n      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 ? arguments[2] : undefined;\n\n      var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);\n\n      var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);\n\n      fromPos = _this$_adjustRangeWit2[0];\n      toPos = _this$_adjustRangeWit2[1];\n      return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber.prototype), "extractInput", this).call(this, fromPos, toPos, flags));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!this.thousandsSeparator) return _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);\n      var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n      var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n\n      this._value = this._removeThousandsSeparators(this.value);\n\n      var appendDetails = _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);\n\n      this._value = this._insertThousandsSeparators(this._value);\n      var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n\n      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n      appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n      return appendDetails;\n    }\n    /** */\n\n  }, {\n    key: "_findSeparatorAround",\n    value: function _findSeparatorAround(pos) {\n      if (this.thousandsSeparator) {\n        var searchFrom = pos - this.thousandsSeparator.length + 1;\n        var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n        if (separatorPos <= pos) return separatorPos;\n      }\n\n      return -1;\n    }\n  }, {\n    key: "_adjustRangeWithSeparators",\n    value: function _adjustRangeWithSeparators(from, to) {\n      var separatorAroundFromPos = this._findSeparatorAround(from);\n\n      if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n\n      var separatorAroundToPos = this._findSeparatorAround(to);\n\n      if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n      return [from, to];\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);\n\n      var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);\n\n      fromPos = _this$_adjustRangeWit4[0];\n      toPos = _this$_adjustRangeWit4[1];\n      var valueBeforePos = this.value.slice(0, fromPos);\n      var valueAfterPos = this.value.slice(toPos);\n\n      var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n\n      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n\n      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n\n      return new change_details({\n        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos, direction) {\n      if (!this.thousandsSeparator) return cursorPos;\n\n      switch (direction) {\n        case DIRECTION.NONE:\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          {\n            var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n\n            if (separatorAtLeftPos >= 0) {\n              var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n\n              if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n                return separatorAtLeftPos;\n              }\n            }\n\n            break;\n          }\n\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          {\n            var separatorAtRightPos = this._findSeparatorAround(cursorPos);\n\n            if (separatorAtRightPos >= 0) {\n              return separatorAtRightPos + this.thousandsSeparator.length;\n            }\n          }\n      }\n\n      return cursorPos;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate(flags) {\n      var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp; // validate as string\n\n      var valid = regexp.test(this._removeThousandsSeparators(this.value));\n\n      if (valid) {\n        // validate as number\n        var number = this.number;\n        valid = valid && !isNaN(number) && ( // check min bound for negative values\n        this.min == null || this.min >= 0 || this.min <= this.number) && ( // check max bound for positive values\n        this.max == null || this.max <= 0 || this.number <= this.max);\n      }\n\n      return valid && _get(_getPrototypeOf(MaskedNumber.prototype), "doValidate", this).call(this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.value) {\n        var number = this.number;\n        var validnum = number; // check bounds\n\n        if (this.min != null) validnum = Math.max(validnum, this.min);\n        if (this.max != null) validnum = Math.min(validnum, this.max);\n        if (validnum !== number) this.unmaskedValue = String(validnum);\n        var formatted = this.value;\n        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n        if (this.padFractionalZeros) formatted = this._padFractionalZeros(formatted);\n        this._value = formatted;\n      }\n\n      _get(_getPrototypeOf(MaskedNumber.prototype), "doCommit", this).call(this);\n    }\n    /** */\n\n  }, {\n    key: "_normalizeZeros",\n    value: function _normalizeZeros(value) {\n      var parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros\n\n\n      parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, function (match, sign, zeros, num) {\n        return sign + num;\n      }); // add leading zero\n\n      if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + \'0\';\n\n      if (parts.length > 1) {\n        parts[1] = parts[1].replace(/0*$/, \'\'); // remove trailing zeros\n\n        if (!parts[1].length) parts.length = 1; // remove fractional\n      }\n\n      return this._insertThousandsSeparators(parts.join(this.radix));\n    }\n    /** */\n\n  }, {\n    key: "_padFractionalZeros",\n    value: function _padFractionalZeros(value) {\n      if (!value) return value;\n      var parts = value.split(this.radix);\n      if (parts.length < 2) parts.push(\'\');\n      parts[1] = parts[1].padEnd(this.scale, \'0\');\n      return parts.join(this.radix);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, \'.\');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", unmaskedValue.replace(\'.\', this.radix), this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return Number(this.unmaskedValue);\n    },\n    set: function set(n) {\n      _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", String(n), this, true);\n    }\n    /** Parsed Number */\n\n  }, {\n    key: "number",\n    get: function get() {\n      return this.typedValue;\n    },\n    set: function set(number) {\n      this.typedValue = number;\n    }\n    /**\r\n      Is negative allowed\r\n      @readonly\r\n    */\n\n  }, {\n    key: "allowNegative",\n    get: function get() {\n      return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;\n    }\n  }]);\n\n  return MaskedNumber;\n}(base);\n\nnumber_MaskedNumber.DEFAULTS = {\n  radix: \',\',\n  thousandsSeparator: \'\',\n  mapToRadix: [\'.\'],\n  scale: 2,\n  signed: false,\n  normalizeZeros: true,\n  padFractionalZeros: false\n};\nholder.MaskedNumber = number_MaskedNumber;\n/* harmony default export */ var masked_number = (number_MaskedNumber);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/function.js\n\n\n\n\n\n\n/** Masking by custom Function */\n\nvar function_MaskedFunction = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedFunction, _Masked);\n\n  function MaskedFunction() {\n    _classCallCheck(this, MaskedFunction);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedFunction).apply(this, arguments));\n  }\n\n  _createClass(MaskedFunction, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      if (opts.mask) opts.validate = opts.mask;\n\n      _get(_getPrototypeOf(MaskedFunction.prototype), "_update", this).call(this, opts);\n    }\n  }]);\n\n  return MaskedFunction;\n}(base);\n\nholder.MaskedFunction = function_MaskedFunction;\n/* harmony default export */ var masked_function = (function_MaskedFunction);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/dynamic.js\n\n\n\n\n\n\n\n/** Dynamic mask for choosing apropriate mask in run-time */\n\nvar dynamic_MaskedDynamic = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedDynamic, _Masked);\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\r\n    @param {Object} opts\r\n  */\n\n\n  function MaskedDynamic(opts) {\n    var _this;\n\n    _classCallCheck(this, MaskedDynamic);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MaskedDynamic).call(this, Object.assign({}, MaskedDynamic.DEFAULTS, {}, opts)));\n    _this.currentMask = null;\n    return _this;\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDynamic, [{\n    key: "_update",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedDynamic.prototype), "_update", this).call(this, opts);\n\n      if (\'mask\' in opts) {\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return factory(m);\n        }) : [];\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        var _this$currentMask;\n\n        details.aggregate((_this$currentMask = this.currentMask)._appendChar.apply(_this$currentMask, arguments));\n      }\n\n      return details;\n    }\n  }, {\n    key: "_applyDispatch",\n    value: function _applyDispatch() {\n      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      var inputValue = this.rawInputValue;\n      var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n      flags._beforeTailState._rawInputValue : inputValue;\n      var tailValue = inputValue.slice(insertValue.length);\n      var prevMask = this.currentMask;\n      var details = new change_details();\n      var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n      this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch\n\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset(); // $FlowFixMe - it\'s ok, we don\'t change current mask above\n\n          var d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n\n          if (tailValue) {\n            // $FlowFixMe - it\'s ok, we don\'t change current mask above\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doDispatch",\n    value: function doDispatch(appended) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.dispatch(appended, this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2, _this$currentMask2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask2 = this.currentMask).doValidate.apply(_this$currentMask2, args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "reset",\n    value: function reset() {\n      if (this.currentMask) this.currentMask.reset();\n      this.compiledMasks.forEach(function (m) {\n        return m.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n\n    /**\r\n      @override\r\n    */\n    value: function remove() {\n      var details = new change_details();\n\n      if (this.currentMask) {\n        var _this$currentMask3;\n\n        details.aggregate((_this$currentMask3 = this.currentMask).remove.apply(_this$currentMask3, arguments)) // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n\n    /**\r\n      @override\r\n    */\n    value: function extractInput() {\n      var _this$currentMask4;\n\n      return this.currentMask ? (_this$currentMask4 = this.currentMask).extractInput.apply(_this$currentMask4, arguments) : \'\';\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this$currentMask5, _get3;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.currentMask ? (_this$currentMask5 = this.currentMask).extractTail.apply(_this$currentMask5, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n\n      _get(_getPrototypeOf(MaskedDynamic.prototype), "doCommit", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos() {\n      var _this$currentMask6, _get4;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.currentMask ? (_this$currentMask6 = this.currentMask).nearestInputPos.apply(_this$currentMask6, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.currentMask ? this.currentMask.value : \'\';\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "value", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.currentMask ? this.currentMask.unmaskedValue : \'\';\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "unmaskedValue", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.currentMask ? this.currentMask.typedValue : \'\';\n    } // probably typedValue should not be used with dynamic\n    ,\n    set: function set(value) {\n      var unmaskedValue = String(value); // double check it\n\n      if (this.currentMask) {\n        this.currentMask.typedValue = value;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n\n      this.unmaskedValue = unmaskedValue;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return !!this.currentMask && this.currentMask.isComplete;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), "state", this), {\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(function (m) {\n          return m.state;\n        }),\n        currentMaskRef: this.currentMask,\n        currentMask: this.currentMask && this.currentMask.state\n      });\n    },\n    set: function set(state) {\n      var compiledMasks = state.compiledMasks,\n          currentMaskRef = state.currentMaskRef,\n          currentMask = state.currentMask,\n          maskedState = _objectWithoutProperties(state, ["compiledMasks", "currentMaskRef", "currentMask"]);\n\n      this.compiledMasks.forEach(function (m, mi) {\n        return m.state = compiledMasks[mi];\n      });\n\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "state", maskedState, this, true);\n    }\n  }, {\n    key: "overwrite",\n    get: function get() {\n      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), "overwrite", this);\n    },\n    set: function set(overwrite) {\n      console.warn(\'"overwrite" option is not available in dynamic mask, use this option in siblings\');\n    }\n  }]);\n\n  return MaskedDynamic;\n}(base);\n\ndynamic_MaskedDynamic.DEFAULTS = {\n  dispatch: function dispatch(appended, masked, flags) {\n    if (!masked.compiledMasks.length) return;\n    var inputValue = masked.rawInputValue; // simulate input\n\n    var inputs = masked.compiledMasks.map(function (m, index) {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, flags);\n      var weight = m.rawInputValue.length;\n      return {\n        weight: weight,\n        index: index\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort(function (i1, i2) {\n      return i2.weight - i1.weight;\n    });\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nholder.MaskedDynamic = dynamic_MaskedDynamic;\n/* harmony default export */ var dynamic = (dynamic_MaskedDynamic);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pipe.js\n\n\n\n\n/** Mask pipe source and destination types */\n\nvar PIPE_TYPE = {\n  MASKED: \'value\',\n  UNMASKED: \'unmaskedValue\',\n  TYPED: \'typedValue\'\n};\n/** Creates new pipe function depending on mask type, source and destination options */\n\nfunction createPipe(mask) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;\n  var masked = factory(mask);\n  return function (value) {\n    return masked.runIsolated(function (m) {\n      m[from] = value;\n      return m[to];\n    });\n  };\n}\n/** Pipes value through mask depending on mask type, source and destination options */\n\n\nfunction pipe(value) {\n  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pipeArgs[_key - 1] = arguments[_key];\n  }\n\n  return createPipe.apply(void 0, pipeArgs)(value);\n}\n\nholder.PIPE_TYPE = PIPE_TYPE;\nholder.createPipe = createPipe;\nholder.pipe = pipe;\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntry {\n  globalThis.IMask = imask;\n} catch (e) {}\n\n/* harmony default export */ var esm = __webpack_exports__["a"] = (imask);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanM/OWE2OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvdXRpbHMuanM/ZGZkNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvYWN0aW9uLWRldGFpbHMuanM/MzY3YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvY2hhbmdlLWRldGFpbHMuanM/MGUxYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanM/MjVjMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvaG9sZGVyLmpzPzQxNzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvYmFzZS5qcz8wMDAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2ZhY3RvcnkuanM/NWQ5ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanM/NGY2MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2ZpeGVkLWRlZmluaXRpb24uanM/NzFiZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcz9kODBmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3JlZ2V4cC5qcz8zYTc2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3BhdHRlcm4uanM/OTY3ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9yYW5nZS5qcz9mY2U4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2RhdGUuanM/YTA3YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvbnRyb2xzL21hc2stZWxlbWVudC5qcz81YTM3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vY29udHJvbHMvaHRtbC1tYXNrLWVsZW1lbnQuanM/YjE1MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvbnRyb2xzL2h0bWwtY29udGVudGVkaXRhYmxlLW1hc2stZWxlbWVudC5qcz84NTY1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vY29udHJvbHMvaW5wdXQuanM/NTQ4YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2ltYXNrLmpzPzFmOGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvZW51bS5qcz9iNGI1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL251bWJlci5qcz8yNGMyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2Z1bmN0aW9uLmpzPzc5MDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvZHluYW1pYy5qcz9iNzhhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3BpcGUuanM/NTE4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2luZGV4LmpzPzBkMTYiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX3N1cGVyUHJvcEJhc2UiLCJvYmplY3QiLCJwcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiX2dldCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImdldCIsImJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0IiwiX3NldCIsImlzU3RyaWN0IiwicyIsIkVycm9yIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwidG9TdHJpbmciLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicHVzaCIsImVyciIsImlzU3RyaW5nIiwic3RyIiwiU3RyaW5nIiwiRElSRUNUSU9OIiwiTk9ORSIsIkxFRlQiLCJGT1JDRV9MRUZUIiwiUklHSFQiLCJGT1JDRV9SSUdIVCIsImluZGV4SW5EaXJlY3Rpb24iLCJwb3MiLCJkaXJlY3Rpb24iLCJwb3NJbkRpcmVjdGlvbiIsImZvcmNlRGlyZWN0aW9uIiwiZXNjYXBlUmVnRXhwIiwicmVwbGFjZSIsIm9iamVjdEluY2x1ZGVzIiwiYiIsImEiLCJhcnJBIiwiYXJyQiIsImRhdGVBIiwiRGF0ZSIsImRhdGVCIiwiZ2V0VGltZSIsInJlZ2V4cEEiLCJSZWdFeHAiLCJyZWdleHBCIiwiQWN0aW9uRGV0YWlscyIsImN1cnNvclBvcyIsIm9sZFZhbHVlIiwib2xkU2VsZWN0aW9uIiwic2xpY2UiLCJzdGFydENoYW5nZVBvcyIsInN0YXJ0IiwiTWF0aCIsIm1pbiIsInN1YnN0ciIsImluc2VydGVkQ291bnQiLCJtYXgiLCJlbmQiLCJyZW1vdmVkQ291bnQiLCJzdWJzdHJpbmciLCJDaGFuZ2VEZXRhaWxzIiwiZGV0YWlscyIsImFzc2lnbiIsImluc2VydGVkIiwicmF3SW5zZXJ0ZWQiLCJza2lwIiwidGFpbFNoaWZ0IiwiYWdncmVnYXRlIiwiQ29udGludW91c1RhaWxEZXRhaWxzIiwiYXJndW1lbnRzIiwiZnJvbSIsInN0b3AiLCJleHRlbmQiLCJ0YWlsIiwiYXBwZW5kVG8iLCJtYXNrZWQiLCJhcHBlbmQiLCJfYXBwZW5kUGxhY2Vob2xkZXIiLCJzaGlmdEJlZm9yZSIsInNoaWZ0Q2hhciIsInN0YXRlIiwiSU1hc2siLCJlbCIsIm9wdHMiLCJJbnB1dE1hc2siLCJNYXNrZWQiLCJfdmFsdWUiLCJfdXBkYXRlIiwiREVGQVVMVFMiLCJpc0luaXRpYWxpemVkIiwidXBkYXRlT3B0aW9ucyIsIndpdGhWYWx1ZVJlZnJlc2giLCJiaW5kIiwicmVzZXQiLCJyZXNvbHZlIiwiaW5wdXQiLCJkb0NvbW1pdCIsIm5lYXJlc3RJbnB1dFBvcyIsImV4dHJhY3RJbnB1dCIsImZyb21Qb3MiLCJ0b1BvcyIsImV4dHJhY3RUYWlsIiwiYXBwZW5kVGFpbCIsIl9hcHBlbmRDaGFyUmF3IiwiY2giLCJmbGFncyIsImRvUHJlcGFyZSIsIl9hcHBlbmRDaGFyIiwiY2hlY2tUYWlsIiwiY29uc2lzdGVudFN0YXRlIiwiY29uc2lzdGVudFRhaWwiLCJhcHBlbmRlZCIsImRvVmFsaWRhdGUiLCJiZWZvcmVUYWlsU3RhdGUiLCJvdmVyd3JpdGUiLCJ0YWlsRGV0YWlscyIsIl9iZWZvcmVUYWlsU3RhdGUiLCJjaSIsInJlbW92ZSIsImZuIiwiX3JlZnJlc2hpbmciLCJyYXdJbnB1dCIsInJhd0lucHV0VmFsdWUiLCJyZXQiLCJydW5Jc29sYXRlZCIsIl9pc29sYXRlZCIsInByZXBhcmUiLCJ2YWxpZGF0ZSIsInBhcmVudCIsImNvbW1pdCIsImRvRm9ybWF0IiwiZm9ybWF0IiwiZG9QYXJzZSIsInBhcnNlIiwic3BsaWNlIiwiZGVsZXRlQ291bnQiLCJyZW1vdmVEaXJlY3Rpb24iLCJ0YWlsUG9zIiwiY2hhbmdlRGV0YWlscyIsInJhdyIsInYiLCJtYXNrZWRDbGFzcyIsIm1hc2siLCJNYXNrZWRSZWdFeHAiLCJNYXNrZWRQYXR0ZXJuIiwiTWFza2VkRGF0ZSIsIk51bWJlciIsIk1hc2tlZE51bWJlciIsIk1hc2tlZER5bmFtaWMiLCJGdW5jdGlvbiIsIk1hc2tlZEZ1bmN0aW9uIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVNYXNrIiwiTWFza2VkQ2xhc3MiLCJERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIiwiUGF0dGVybklucHV0RGVmaW5pdGlvbiIsImJsb2NrT3B0cyIsIl9pc0ZpbGxlZCIsImlzT3B0aW9uYWwiLCJsYXp5IiwicGxhY2Vob2xkZXJDaGFyIiwiQm9vbGVhbiIsIl90aGlzJG1hc2tlZCIsImFwcGx5IiwiX3RoaXMkbWFza2VkMiIsIl90aGlzJG1hc2tlZDMiLCJtaW5Qb3MiLCJtYXhQb3MiLCJib3VuZFBvcyIsImlzQ29tcGxldGUiLCJfdGhpcyRtYXNrZWQ0IiwiX3RoaXMkcGFyZW50IiwidW5tYXNrZWRWYWx1ZSIsIlBhdHRlcm5GaXhlZERlZmluaXRpb24iLCJfaXNSYXdJbnB1dCIsImNoYXIiLCJpc1Jlc29sdmVkIiwiaXNVbm1hc2tpbmciLCJDaHVua3NUYWlsRGV0YWlscyIsImNodW5rcyIsIm1hcCIsImpvaW4iLCJ0YWlsQ2h1bmsiLCJsYXN0Q2h1bmsiLCJleHRlbmRMYXN0IiwiZmlyc3RUYWlsQ2h1bmsiLCJzaGlmdCIsImJsb2NrSW5kZXgiLCJjaHVuayIsImxhc3RCbG9ja0l0ZXIiLCJfbWFwUG9zVG9CbG9jayIsImNodW5rQmxvY2siLCJpbmRleCIsIl9zdG9wcyIsIl9ibG9ja3MiLCJyZW1haW5DaGFycyIsImNodW5rU2hpZnRQb3MiLCJjIiwiY3N0YXRlIiwiX01hc2tlZCIsInNlYXJjaCIsImRlZmluaXRpb25zIiwiX3JlYnVpbGRNYXNrIiwiX3RoaXMiLCJkZWZzIiwiX21hc2tlZEJsb2NrcyIsInBhdHRlcm4iLCJ1bm1hc2tpbmdCbG9jayIsIm9wdGlvbmFsQmxvY2siLCJibG9ja3MiLCJfcmV0IiwiYk5hbWVzIiwiZmlsdGVyIiwiYk5hbWUiLCJzb3J0IiwibWFza2VkQmxvY2siLCJfaXNJbnB1dCIsIlNUT1BfQ0hBUiIsIkVTQ0FQRV9DSEFSIiwiZGVmIiwiZm9yRWFjaCIsImJsb2NrSXRlciIsImJpIiwiX2Jsb2NrIiwiYmxvY2tEZXRhaWxzIiwiX3RoaXMyIiwiY2h1bmtUYWlsIiwiX2ZvckVhY2hCbG9ja3NJblJhbmdlIiwiYkZyb21Qb3MiLCJiVG9Qb3MiLCJibG9ja0NodW5rIiwiX2ZpbmRTdG9wQmVmb3JlIiwiX2Jsb2NrU3RhcnRQb3MiLCJfIiwic3RvcEJlZm9yZSIsInNpIiwidG9CbG9ja0luZGV4IiwiX3RoaXMzIiwic3RhcnRCbG9ja0l0ZXIiLCJzdGFydEJsb2NrSW5kZXgiLCJlbmRCbG9ja0luZGV4IiwiYXJncyIsImJEZXRhaWxzIiwiYWNjVmFsIiwiX2Jsb2NrMiIsImJsb2NrU3RhcnRQb3MiLCJvZmZzZXQiLCJyZWR1Y2UiLCJmcm9tQmxvY2tJdGVyIiwidG9CbG9ja0l0ZXIiLCJpc1NhbWVCbG9jayIsImZyb21CbG9ja1N0YXJ0UG9zIiwiZnJvbUJsb2NrRW5kUG9zIiwicmVtb3ZlRGV0YWlscyIsImJlZ2luQmxvY2tEYXRhIiwiYmVnaW5CbG9ja09mZnNldCIsImJlZ2luQmxvY2tJbmRleCIsImJlZ2luQmxvY2siLCJiZWdpbkJsb2NrQ3Vyc29yUG9zIiwiY3Vyc29yQXRSaWdodCIsImN1cnNvckF0TGVmdCIsInNlYXJjaEJsb2NrSW5kZXgiLCJibG9ja0luZGV4QXRMZWZ0IiwiYmxvY2tBdExlZnQiLCJibG9ja0lucHV0UG9zIiwiZmlyc3RJbnB1dEF0UmlnaHQiLCJibG9ja0F0UmlnaHQiLCJfYmxvY2tJbnB1dFBvcyIsIl9iaSIsIl9ibG9jazMiLCJfYmxvY2tJbnB1dFBvczIiLCJmaXJzdEZpbGxlZEJsb2NrSW5kZXhBdFJpZ2h0IiwiX2JpMiIsImZpbGxlZEJsb2NrIiwiX2Jsb2NrSW5wdXRQb3MzIiwiZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXgiLCJmaXJzdEVtcHR5SW5wdXRCbG9ja0luZGV4IiwiX2JpMyIsIl9ibG9jazQiLCJfYmxvY2tJbnB1dFBvczQiLCJfYmk0IiwiX2Jsb2NrNSIsIl9ibG9ja0lucHV0UG9zNSIsImJsb2NrQWxpZ25lZFBvcyIsImlzSW5wdXQiLCJfYmk1IiwiX2Jsb2NrNiIsIl9ibG9ja0lucHV0UG9zNiIsImZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleCIsImZpcnN0SW5wdXRCbG9ja0FsaWduZWRQb3MiLCJfYmk2IiwiX2Jsb2NrNyIsIl9ibG9ja0lucHV0UG9zNyIsIl9iaTciLCJfYmxvY2s4IiwiX2Jsb2NrSW5wdXRQb3M4IiwiX2JpOCIsIl9ibG9jazkiLCJfYmxvY2tJbnB1dFBvczkiLCJhbGlnbmVkUG9zIiwibmFtZSIsIm1hc2tlZEJsb2NrcyIsIl90aGlzNCIsImluZGljZXMiLCJnaSIsIm1hc2tlZFN0YXRlIiwiZXZlcnkiLCJJbnB1dERlZmluaXRpb24iLCJGaXhlZERlZmluaXRpb24iLCJibG9jayIsIk1hc2tlZFJhbmdlIiwiX01hc2tlZFBhdHRlcm4iLCJ0byIsIm1heExlbmd0aCIsImZyb21TdHIiLCJwYWRTdGFydCIsInRvU3RyIiwic2FtZUNoYXJzQ291bnQiLCJyZXBlYXQiLCJib3VuZGFyaWVzIiwibWluc3RyIiwibWF4c3RyIiwiX3JlZiIsIm1hdGNoIiwiX3JlZjIiLCJwbGFjZWhvbGRlciIsIm51bSIsInBhZEVuZCIsImF1dG9maXgiLCJ2YWwiLCJwcmVwU3RyIiwibmV4dFZhbCIsIl90aGlzJGJvdW5kYXJpZXMiLCJfdGhpcyRib3VuZGFyaWVzMiIsIl9nZXQyIiwiZmlyc3ROb25aZXJvIiwiX21hdGNoRnJvbSIsIl90aGlzJGJvdW5kYXJpZXMzIiwiX3RoaXMkYm91bmRhcmllczQiLCJfbGVuIiwiX2tleSIsImNvbmNhdCIsIkdFVF9ERUZBVUxUX0JMT0NLUyIsIlkiLCJnZXRGdWxsWWVhciIsIm0iLCJnZXRNb250aCIsImQiLCJnZXREYXRlIiwiYmsiLCJkYXRlIiwiaXNEYXRlRXhpc3QiLCJ0eXBlZFZhbHVlIiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwiX3N0ciRzcGxpdCIsInNwbGl0IiwiX3N0ciRzcGxpdDIiLCJNYXNrRWxlbWVudCIsInNlbGVjdCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwiX3Vuc2FmZVNlbGVjdCIsImUiLCJiaW5kRXZlbnRzIiwiaGFuZGxlcnMiLCJ1bmJpbmRFdmVudHMiLCJfdW5zYWZlU2VsZWN0aW9uU3RhcnQiLCJfdW5zYWZlU2VsZWN0aW9uRW5kIiwiSFRNTE1hc2tFbGVtZW50IiwiX01hc2tFbGVtZW50IiwiX2hhbmRsZXJzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJldmVudCIsIl90b2dnbGVFdmVudEhhbmRsZXIiLCJFVkVOVFNfTUFQIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0Um9vdE5vZGUiLCJkb2N1bWVudCIsInJvb3RFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInNlbGVjdGlvbkNoYW5nZSIsImRyb3AiLCJjbGljayIsImZvY3VzIiwiSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50IiwiX0hUTUxNYXNrRWxlbWVudCIsImNyZWF0ZVJhbmdlIiwicmFuZ2UiLCJzZXRTdGFydCIsImZpcnN0Q2hpbGQiLCJzZXRFbmQiLCJsYXN0Q2hpbGQiLCJyb290Iiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJhbmNob3JPZmZzZXQiLCJ0ZXh0Q29udGVudCIsImlzQ29udGVudEVkaXRhYmxlIiwidGFnTmFtZSIsIl9saXN0ZW5lcnMiLCJfdW5tYXNrZWRWYWx1ZSIsIl9zYXZlU2VsZWN0aW9uIiwiX29uSW5wdXQiLCJfb25DaGFuZ2UiLCJfb25Ecm9wIiwiX29uRm9jdXMiLCJfb25DbGljayIsImFsaWduQ3Vyc29yIiwiYWxpZ25DdXJzb3JGcmllbmRseSIsIl9iaW5kRXZlbnRzIiwidXBkYXRlVmFsdWUiLCJtYXNrRXF1YWxzIiwiX3VuYmluZEV2ZW50cyIsIl9maXJlRXZlbnQiLCJldiIsImxpc3RlbmVycyIsImwiLCJfc2VsZWN0aW9uIiwidXBkYXRlQ29udHJvbCIsIm5ld1VubWFza2VkVmFsdWUiLCJuZXdWYWx1ZSIsImlzQ2hhbmdlZCIsIl9maXJlQ2hhbmdlRXZlbnRzIiwicmVzdE9wdHMiLCJ1cGRhdGVNYXNrIiwidXBkYXRlT3B0cyIsInVwZGF0ZUN1cnNvciIsIl9kZWxheVVwZGF0ZUN1cnNvciIsIl9hYm9ydFVwZGF0ZUN1cnNvciIsIl9jaGFuZ2luZ0N1cnNvclBvcyIsIl9jdXJzb3JDaGFuZ2luZyIsInNldFRpbWVvdXQiLCJfaW5wdXRFdmVudCIsImNsZWFyVGltZW91dCIsIm9uIiwib2ZmIiwiaEluZGV4Iiwib2xkUmF3VmFsdWUiLCJyZW1vdmVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJkZXN0cm95IiwiaXNBY3RpdmUiLCJNYXNrZWRFbnVtIiwiZW51bSIsInNvbWUiLCJfdXBkYXRlUmVnRXhwcyIsImFsbG93TmVnYXRpdmUiLCJtaWRJbnB1dCIsIm1pZCIsInNjYWxlIiwicmFkaXgiLCJfbnVtYmVyUmVnRXhwSW5wdXQiLCJfbnVtYmVyUmVnRXhwIiwiX21hcFRvUmFkaXhSZWdFeHAiLCJtYXBUb1JhZGl4IiwiX3Rob3VzYW5kc1NlcGFyYXRvclJlZ0V4cCIsInRob3VzYW5kc1NlcGFyYXRvciIsIl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzIiwiX2luc2VydFRob3VzYW5kc1NlcGFyYXRvcnMiLCJwYXJ0cyIsIl9zZXBhcmF0b3JzQ291bnQiLCJleHRlbmRPblNlcGFyYXRvcnMiLCJjb3VudCIsIl9zZXBhcmF0b3JzQ291bnRGcm9tU2xpY2UiLCJfdGhpcyRfYWRqdXN0UmFuZ2VXaXQiLCJfYWRqdXN0UmFuZ2VXaXRoU2VwYXJhdG9ycyIsIl90aGlzJF9hZGp1c3RSYW5nZVdpdDIiLCJwcmV2QmVmb3JlVGFpbFZhbHVlIiwicHJldkJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQiLCJhcHBlbmREZXRhaWxzIiwiYmVmb3JlVGFpbFZhbHVlIiwiYmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCIsIl9maW5kU2VwYXJhdG9yQXJvdW5kIiwic2VhcmNoRnJvbSIsInNlcGFyYXRvclBvcyIsInNlcGFyYXRvckFyb3VuZEZyb21Qb3MiLCJzZXBhcmF0b3JBcm91bmRUb1BvcyIsIl90aGlzJF9hZGp1c3RSYW5nZVdpdDMiLCJfdGhpcyRfYWRqdXN0UmFuZ2VXaXQ0IiwidmFsdWVCZWZvcmVQb3MiLCJ2YWx1ZUFmdGVyUG9zIiwic2VwYXJhdG9yQXRMZWZ0UG9zIiwic2VwYXJhdG9yQXRMZWZ0RW5kUG9zIiwic2VwYXJhdG9yQXRSaWdodFBvcyIsInJlZ2V4cCIsInZhbGlkIiwidGVzdCIsIm51bWJlciIsImlzTmFOIiwidmFsaWRudW0iLCJmb3JtYXR0ZWQiLCJub3JtYWxpemVaZXJvcyIsIl9ub3JtYWxpemVaZXJvcyIsInBhZEZyYWN0aW9uYWxaZXJvcyIsIl9wYWRGcmFjdGlvbmFsWmVyb3MiLCJzaWduIiwiemVyb3MiLCJuIiwic2lnbmVkIiwiY3VycmVudE1hc2siLCJjb21waWxlZE1hc2tzIiwiX2FwcGx5RGlzcGF0Y2giLCJfdGhpcyRjdXJyZW50TWFzayIsInByZXZWYWx1ZUJlZm9yZVRhaWwiLCJpbnB1dFZhbHVlIiwiaW5zZXJ0VmFsdWUiLCJfcmF3SW5wdXRWYWx1ZSIsInRhaWxWYWx1ZSIsInByZXZNYXNrIiwicHJldk1hc2tTdGF0ZSIsImRvRGlzcGF0Y2giLCJkaXNwYXRjaCIsIl90aGlzJGN1cnJlbnRNYXNrMiIsIl90aGlzJGN1cnJlbnRNYXNrMyIsIl90aGlzJGN1cnJlbnRNYXNrNCIsIl90aGlzJGN1cnJlbnRNYXNrNSIsIl9nZXQzIiwiX2xlbjIiLCJfa2V5MiIsIl90aGlzJGN1cnJlbnRNYXNrNiIsIl9nZXQ0IiwiX2xlbjMiLCJfa2V5MyIsImN1cnJlbnRNYXNrUmVmIiwibWkiLCJpbnB1dHMiLCJ3ZWlnaHQiLCJpMSIsImkyIiwiUElQRV9UWVBFIiwiTUFTS0VEIiwiVU5NQVNLRUQiLCJUWVBFRCIsImNyZWF0ZVBpcGUiLCJwaXBlIiwicGlwZUFyZ3MiLCJnbG9iYWxUaGlzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEI7O0FBRUEsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQ0MsUUFBZCxLQUEyQixRQUEvRCxFQUF5RTtBQUN2RUgsV0FBTyxHQUFHLFVBQVVDLEdBQVYsRUFBZTtBQUN2QixhQUFPLE9BQU9BLEdBQWQ7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPO0FBQ0xELFdBQU8sR0FBRyxVQUFVQyxHQUFWLEVBQWU7QUFDdkIsYUFBT0EsR0FBRyxJQUFJLE9BQU9DLE1B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QUE5QjtBQUNEOztBQUVELFNBQU93TSxVQUFVLENBQUN6WCxLQUFYLENBQWlCLEtBQUssQ0FBdEIsRUFBeUIyWCxRQUF6QixFQUFtQzVrQixLQUFuQyxDQUFQO0FBQ0Q7O0FBQ0Q4SCxNQUFLLENBQUN3YyxTQUFOLEdBQWtCQSxTQUFsQjtBQUNBeGMsTUFBSyxDQUFDNGMsVUFBTixHQUFtQkEsVUFBbkI7QUFDQTVjLE1BQUssQ0FBQzZjLElBQU4sR0FBYUEsSUFBYjs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDRkUsWUFBVSxDQUFDL2MsS0FBWCxHQUFtQkEsS0FBbkI7QUFDRCxDQUZELENBRUUsT0FBTzRSLENBQVAsRUFBVSxDQUFFOztBQUVDNVIsd0VBQWYiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5zZXQpIHtcbiAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgfSBlbHNlIHtcbiAgICBzZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICB2YXIgZGVzYztcblxuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xufVxuXG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2V0IHByb3BlcnR5Jyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbmV4cG9ydCB7IF90eXBlb2YgYXMgXywgX2NyZWF0ZUNsYXNzIGFzIGEsIF9jbGFzc0NhbGxDaGVjayBhcyBiLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgYXMgYywgX2luaGVyaXRzIGFzIGQsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGFzIGUsIF9nZXRQcm90b3R5cGVPZiBhcyBmLCBfZ2V0IGFzIGcsIF9zZXQgYXMgaCwgX3NsaWNlZFRvQXJyYXkgYXMgaSB9O1xuIiwiaW1wb3J0IHsgXyBhcyBfdHlwZW9mIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5cbi8qKiBDaGVja3MgaWYgdmFsdWUgaXMgc3RyaW5nICovXG5mdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZztcbn1cbi8qKlxyXG4gIERpcmVjdGlvblxyXG4gIEBwcm9wIHtzdHJpbmd9IE5PTkVcclxuICBAcHJvcCB7c3RyaW5nfSBMRUZUXHJcbiAgQHByb3Age3N0cmluZ30gRk9SQ0VfTEVGVFxyXG4gIEBwcm9wIHtzdHJpbmd9IFJJR0hUXHJcbiAgQHByb3Age3N0cmluZ30gRk9SQ0VfUklHSFRcclxuKi9cblxudmFyIERJUkVDVElPTiA9IHtcbiAgTk9ORTogJ05PTkUnLFxuICBMRUZUOiAnTEVGVCcsXG4gIEZPUkNFX0xFRlQ6ICdGT1JDRV9MRUZUJyxcbiAgUklHSFQ6ICdSSUdIVCcsXG4gIEZPUkNFX1JJR0hUOiAnRk9SQ0VfUklHSFQnXG59O1xuLyoqXHJcbiAgRGlyZWN0aW9uXHJcbiAgQGVudW0ge3N0cmluZ31cclxuKi9cblxuLyoqIFJldHVybnMgbmV4dCBjaGFyIGluZGV4IGluIGRpcmVjdGlvbiAqL1xuZnVuY3Rpb24gaW5kZXhJbkRpcmVjdGlvbihwb3MsIGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTEVGVCkgLS1wb3M7XG4gIHJldHVybiBwb3M7XG59XG4vKiogUmV0dXJucyBuZXh0IGNoYXIgcG9zaXRpb24gaW4gZGlyZWN0aW9uICovXG5cbmZ1bmN0aW9uIHBvc0luRGlyZWN0aW9uKHBvcywgZGlyZWN0aW9uKSB7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9MRUZUOlxuICAgICAgcmV0dXJuIC0tcG9zO1xuXG4gICAgY2FzZSBESVJFQ1RJT04uUklHSFQ6XG4gICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfUklHSFQ6XG4gICAgICByZXR1cm4gKytwb3M7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBvcztcbiAgfVxufVxuLyoqICovXG5cbmZ1bmN0aW9uIGZvcmNlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgRElSRUNUSU9OLkxFRlQ6XG4gICAgICByZXR1cm4gRElSRUNUSU9OLkZPUkNFX0xFRlQ7XG5cbiAgICBjYXNlIERJUkVDVElPTi5SSUdIVDpcbiAgICAgIHJldHVybiBESVJFQ1RJT04uRk9SQ0VfUklHSFQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxufVxuLyoqIEVzY2FwZXMgcmVndWxhciBleHByZXNzaW9uIGNvbnRyb2wgY2hhcnMgKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59IC8vIGNsb25lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWRlZXAtZXF1YWwgd2l0aCBzbWFsbCBjaGFuZ2VzXG5cbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKGIsIGEpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICB2YXIgYXJyQSA9IEFycmF5LmlzQXJyYXkoYSksXG4gICAgICBhcnJCID0gQXJyYXkuaXNBcnJheShiKSxcbiAgICAgIGk7XG5cbiAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqZWN0SW5jbHVkZXMoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhcnJBICE9IGFyckIpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYSAmJiBiICYmIF90eXBlb2YoYSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoYikgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGRhdGVBID0gYSBpbnN0YW5jZW9mIERhdGUsXG4gICAgICAgIGRhdGVCID0gYiBpbnN0YW5jZW9mIERhdGU7XG4gICAgaWYgKGRhdGVBICYmIGRhdGVCKSByZXR1cm4gYS5nZXRUaW1lKCkgPT0gYi5nZXRUaW1lKCk7XG4gICAgaWYgKGRhdGVBICE9IGRhdGVCKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlZ2V4cEEgPSBhIGluc3RhbmNlb2YgUmVnRXhwLFxuICAgICAgICByZWdleHBCID0gYiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICBpZiAocmVnZXhwQSAmJiByZWdleHBCKSByZXR1cm4gYS50b1N0cmluZygpID09IGIudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnZXhwQSAhPSByZWdleHBCKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTsgLy8gaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iamVjdEluY2x1ZGVzKGJba2V5c1tpXV0sIGFba2V5c1tpXV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqIFNlbGVjdGlvbiByYW5nZSAqL1xuXG5leHBvcnQgeyBESVJFQ1RJT04sIGVzY2FwZVJlZ0V4cCwgZm9yY2VEaXJlY3Rpb24sIGluZGV4SW5EaXJlY3Rpb24sIGlzU3RyaW5nLCBvYmplY3RJbmNsdWRlcywgcG9zSW5EaXJlY3Rpb24gfTtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKiBQcm92aWRlcyBkZXRhaWxzIG9mIGNoYW5naW5nIGlucHV0ICovXG5cbnZhciBBY3Rpb25EZXRhaWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqIEN1cnJlbnQgaW5wdXQgdmFsdWUgKi9cblxuICAvKiogQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gKi9cblxuICAvKiogT2xkIGlucHV0IHZhbHVlICovXG5cbiAgLyoqIE9sZCBzZWxlY3Rpb24gKi9cbiAgZnVuY3Rpb24gQWN0aW9uRGV0YWlscyh2YWx1ZSwgY3Vyc29yUG9zLCBvbGRWYWx1ZSwgb2xkU2VsZWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjdGlvbkRldGFpbHMpO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB0aGlzLm9sZFNlbGVjdGlvbiA9IG9sZFNlbGVjdGlvbjsgLy8gZG91YmxlIGNoZWNrIGlmIGxlZnQgcGFydCB3YXMgY2hhbmdlZCAoYXV0b2ZpbGxpbmcsIG90aGVyIG5vbi1zdGFuZGFyZCBpbnB1dCB0cmlnZ2VycylcblxuICAgIHdoaWxlICh0aGlzLnZhbHVlLnNsaWNlKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpICE9PSB0aGlzLm9sZFZhbHVlLnNsaWNlKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpKSB7XG4gICAgICAtLXRoaXMub2xkU2VsZWN0aW9uLnN0YXJ0O1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgIFN0YXJ0IGNoYW5naW5nIHBvc2l0aW9uXHJcbiAgICBAcmVhZG9ubHlcclxuICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFjdGlvbkRldGFpbHMsIFt7XG4gICAga2V5OiBcInN0YXJ0Q2hhbmdlUG9zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5jdXJzb3JQb3MsIHRoaXMub2xkU2VsZWN0aW9uLnN0YXJ0KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEluc2VydGVkIHN5bWJvbHMgY291bnRcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0ZWRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdGFydENoYW5nZVBvcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEluc2VydGVkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cih0aGlzLnN0YXJ0Q2hhbmdlUG9zLCB0aGlzLmluc2VydGVkQ291bnQpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUmVtb3ZlZCBzeW1ib2xzIGNvdW50XHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZWRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gTWF0aC5tYXggZm9yIG9wcG9zaXRlIG9wZXJhdGlvblxuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub2xkU2VsZWN0aW9uLmVuZCAtIHRoaXMuc3RhcnRDaGFuZ2VQb3MgfHwgLy8gZm9yIERlbGV0ZVxuICAgICAgdGhpcy5vbGRWYWx1ZS5sZW5ndGggLSB0aGlzLnZhbHVlLmxlbmd0aCwgMCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZW1vdmVkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub2xkVmFsdWUuc3Vic3RyKHRoaXMuc3RhcnRDaGFuZ2VQb3MsIHRoaXMucmVtb3ZlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFVuY2hhbmdlZCBoZWFkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgVW5jaGFuZ2VkIHRhaWwgc3ltYm9sc1xyXG4gICAgICBAcmVhZG9ubHlcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0YWlsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5zdGFydENoYW5nZVBvcyArIHRoaXMuaW5zZXJ0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZW1vdmUgZGlyZWN0aW9uXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZURpcmVjdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnJlbW92ZWRDb3VudCB8fCB0aGlzLmluc2VydGVkQ291bnQpIHJldHVybiBESVJFQ1RJT04uTk9ORTsgLy8gYWxpZ24gcmlnaHQgaWYgZGVsZXRlIGF0IHJpZ2h0IG9yIGlmIHJhbmdlIHJlbW92ZWQgKGV2ZW50IHdpdGggYmFja3NwYWNlKVxuXG4gICAgICByZXR1cm4gdGhpcy5vbGRTZWxlY3Rpb24uZW5kID09PSB0aGlzLmN1cnNvclBvcyB8fCB0aGlzLm9sZFNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy5jdXJzb3JQb3MgPyBESVJFQ1RJT04uUklHSFQgOiBESVJFQ1RJT04uTEVGVDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWN0aW9uRGV0YWlscztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aW9uRGV0YWlscztcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuXG4vKipcclxuICBQcm92aWRlcyBkZXRhaWxzIG9mIGNoYW5naW5nIG1vZGVsIHZhbHVlXHJcbiAgQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXVxyXG4gIEBwYXJhbSB7c3RyaW5nfSBbZGV0YWlscy5pbnNlcnRlZF0gLSBJbnNlcnRlZCBzeW1ib2xzXHJcbiAgQHBhcmFtIHtib29sZWFufSBbZGV0YWlscy5za2lwXSAtIENhbiBza2lwIGNoYXJzXHJcbiAgQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWxzLnJlbW92ZUNvdW50XSAtIFJlbW92ZWQgc3ltYm9scyBjb3VudFxyXG4gIEBwYXJhbSB7bnVtYmVyfSBbZGV0YWlscy50YWlsU2hpZnRdIC0gQWRkaXRpb25hbCBvZmZzZXQgaWYgYW55IGNoYW5nZXMgb2NjdXJyZWQgYmVmb3JlIHRhaWxcclxuKi9cbnZhciBDaGFuZ2VEZXRhaWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqIEluc2VydGVkIHN5bWJvbHMgKi9cblxuICAvKiogQ2FuIHNraXAgY2hhcnMgKi9cblxuICAvKiogQWRkaXRpb25hbCBvZmZzZXQgaWYgYW55IGNoYW5nZXMgb2NjdXJyZWQgYmVmb3JlIHRhaWwgKi9cblxuICAvKiogUmF3IGluc2VydGVkIGlzIHVzZWQgYnkgZHluYW1pYyBtYXNrICovXG4gIGZ1bmN0aW9uIENoYW5nZURldGFpbHMoZGV0YWlscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFuZ2VEZXRhaWxzKTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgaW5zZXJ0ZWQ6ICcnLFxuICAgICAgcmF3SW5zZXJ0ZWQ6ICcnLFxuICAgICAgc2tpcDogZmFsc2UsXG4gICAgICB0YWlsU2hpZnQ6IDBcbiAgICB9LCBkZXRhaWxzKTtcbiAgfVxuICAvKipcclxuICAgIEFnZ3JlZ2F0ZSBjaGFuZ2VzXHJcbiAgICBAcmV0dXJucyB7Q2hhbmdlRGV0YWlsc30gYHRoaXNgXHJcbiAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDaGFuZ2VEZXRhaWxzLCBbe1xuICAgIGtleTogXCJhZ2dyZWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWdncmVnYXRlKGRldGFpbHMpIHtcbiAgICAgIHRoaXMucmF3SW5zZXJ0ZWQgKz0gZGV0YWlscy5yYXdJbnNlcnRlZDtcbiAgICAgIHRoaXMuc2tpcCA9IHRoaXMuc2tpcCB8fCBkZXRhaWxzLnNraXA7XG4gICAgICB0aGlzLmluc2VydGVkICs9IGRldGFpbHMuaW5zZXJ0ZWQ7XG4gICAgICB0aGlzLnRhaWxTaGlmdCArPSBkZXRhaWxzLnRhaWxTaGlmdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogVG90YWwgb2Zmc2V0IGNvbnNpZGVyaW5nIGFsbCBjaGFuZ2VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWxTaGlmdCArIHRoaXMuaW5zZXJ0ZWQubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaGFuZ2VEZXRhaWxzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBDaGFuZ2VEZXRhaWxzO1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5cbi8qKiBQcm92aWRlcyBkZXRhaWxzIG9mIGNvbnRpbnVvdXMgZXh0cmFjdGVkIHRhaWwgKi9cbnZhciBDb250aW51b3VzVGFpbERldGFpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogVGFpbCB2YWx1ZSBhcyBzdHJpbmcgKi9cblxuICAvKiogVGFpbCBzdGFydCBwb3NpdGlvbiAqL1xuXG4gIC8qKiBTdGFydCBwb3NpdGlvbiAqL1xuICBmdW5jdGlvbiBDb250aW51b3VzVGFpbERldGFpbHMoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgc3RvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRpbnVvdXNUYWlsRGV0YWlscyk7XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnN0b3AgPSBzdG9wO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRpbnVvdXNUYWlsRGV0YWlscywgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZCh0YWlsKSB7XG4gICAgICB0aGlzLnZhbHVlICs9IFN0cmluZyh0YWlsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG8obWFza2VkKSB7XG4gICAgICByZXR1cm4gbWFza2VkLmFwcGVuZCh0aGlzLnRvU3RyaW5nKCksIHtcbiAgICAgICAgdGFpbDogdHJ1ZVxuICAgICAgfSkuYWdncmVnYXRlKG1hc2tlZC5fYXBwZW5kUGxhY2Vob2xkZXIoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0QmVmb3JlKHBvcykge1xuICAgICAgaWYgKHRoaXMuZnJvbSA+PSBwb3MgfHwgIXRoaXMudmFsdWUubGVuZ3RoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgc2hpZnRDaGFyID0gdGhpcy52YWx1ZVswXTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIHNoaWZ0Q2hhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHN0b3A6IHRoaXMuc3RvcFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGludW91c1RhaWxEZXRhaWxzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250aW51b3VzVGFpbERldGFpbHM7XG4iLCIvKipcclxuICogQXBwbGllcyBtYXNrIG9uIGVsZW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8SFRNTFRleHRBcmVhRWxlbWVudHxNYXNrRWxlbWVudH0gZWwgLSBFbGVtZW50IHRvIGFwcGx5IG1hc2tcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBDdXN0b20gbWFzayBvcHRpb25zXHJcbiAqIEByZXR1cm4ge0lucHV0TWFza31cclxuICovXG5mdW5jdGlvbiBJTWFzayhlbCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIC8vIGN1cnJlbnRseSBhdmFpbGFibGUgb25seSBmb3IgaW5wdXQtbGlrZSBlbGVtZW50c1xuICByZXR1cm4gbmV3IElNYXNrLklucHV0TWFzayhlbCwgb3B0cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IENoYW5nZURldGFpbHMgZnJvbSAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgQ29udGludW91c1RhaWxEZXRhaWxzIGZyb20gJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcblxuLyoqIFN1cHBvcnRlZCBtYXNrIHR5cGUgKi9cblxuLyoqIFByb3ZpZGVzIGNvbW1vbiBtYXNraW5nIHN0dWZmICovXG52YXIgTWFza2VkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gJFNoYXBlPE1hc2tlZE9wdGlvbnM+OyBUT0RPIGFmdGVyIGZpeCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDc3M1xuXG4gIC8qKiBAdHlwZSB7TWFza30gKi9cblxuICAvKiogKi9cbiAgLy8gJEZsb3dGaXhNZSBubyBpZGVhc1xuXG4gIC8qKiBUcmFuc2Zvcm1zIHZhbHVlIGJlZm9yZSBtYXNrIHByb2Nlc3NpbmcgKi9cblxuICAvKiogVmFsaWRhdGVzIGlmIHZhbHVlIGlzIGFjY2VwdGFibGUgKi9cblxuICAvKiogRG9lcyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgLyoqIEZvcm1hdCB0eXBlZCB2YWx1ZSB0byBzdHJpbmcgKi9cblxuICAvKiogUGFyc2Ugc3RyZ2luIHRvIGdldCB0eXBlZCB2YWx1ZSAqL1xuXG4gIC8qKiBFbmFibGUgY2hhcmFjdGVycyBvdmVyd3JpdGluZyAqL1xuXG4gIC8qKiAqL1xuICBmdW5jdGlvbiBNYXNrZWQob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWQpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSAnJztcblxuICAgIHRoaXMuX3VwZGF0ZShPYmplY3QuYXNzaWduKHt9LCBNYXNrZWQuREVGQVVMVFMsIHt9LCBvcHRzKSk7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIC8qKiBTZXRzIGFuZCBhcHBsaWVzIG5ldyBvcHRpb25zICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkLCBbe1xuICAgIGtleTogXCJ1cGRhdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0cykge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGgpIHJldHVybjtcbiAgICAgIHRoaXMud2l0aFZhbHVlUmVmcmVzaCh0aGlzLl91cGRhdGUuYmluZCh0aGlzLCBvcHRzKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBTZXRzIG5ldyBvcHRpb25zXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqIE1hc2sgc3RhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG5cbiAgICAvKiogUmVzZXRzIHZhbHVlICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG5cbiAgICAvKiogUmVzb2x2ZSBuZXcgdmFsdWUgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hcHBlbmQodmFsdWUsIHtcbiAgICAgICAgaW5wdXQ6IHRydWVcbiAgICAgIH0sICcnKTtcbiAgICAgIHRoaXMuZG9Db21taXQoKTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJlc3RJbnB1dFBvc1wiLFxuXG4gICAgLyoqIEZpbmRzIG5lYXJlc3QgaW5wdXQgcG9zaXRpb24gaW4gZGlyZWN0aW9uICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3RJbnB1dFBvcyhjdXJzb3JQb3MsIGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICB9XG4gICAgLyoqIEV4dHJhY3RzIHZhbHVlIGluIHJhbmdlIGNvbnNpZGVyaW5nIGZsYWdzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdElucHV0KCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2xpY2UoZnJvbVBvcywgdG9Qb3MpO1xuICAgIH1cbiAgICAvKiogRXh0cmFjdHMgdGFpbCBpbiByYW5nZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdFRhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdFRhaWwoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICByZXR1cm4gbmV3IENvbnRpbnVvdXNUYWlsRGV0YWlscyh0aGlzLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcyksIGZyb21Qb3MpO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyB0YWlsICovXG4gICAgLy8gJEZsb3dGaXhNZSBubyBpZGVhc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUYWlsKHRhaWwpIHtcbiAgICAgIGlmIChpc1N0cmluZyh0YWlsKSkgdGFpbCA9IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWwpKTtcbiAgICAgIHJldHVybiB0YWlsLmFwcGVuZFRvKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyBjaGFyICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhclJhdyhjaCkge1xuICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNoID0gdGhpcy5kb1ByZXBhcmUoY2gsIGZsYWdzKTtcbiAgICAgIGlmICghY2gpIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdGhpcy5fdmFsdWUgKz0gY2g7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICBpbnNlcnRlZDogY2gsXG4gICAgICAgIHJhd0luc2VydGVkOiBjaFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBBcHBlbmRzIGNoYXIgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRDaGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRDaGFyKGNoKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNoZWNrVGFpbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNvbnNpc3RlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5fYXBwZW5kQ2hhclJhdyhjaCwgZmxhZ3MpO1xuXG4gICAgICBpZiAoZGV0YWlscy5pbnNlcnRlZCkge1xuICAgICAgICB2YXIgY29uc2lzdGVudFRhaWw7XG4gICAgICAgIHZhciBhcHBlbmRlZCA9IHRoaXMuZG9WYWxpZGF0ZShmbGFncykgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmIChhcHBlbmRlZCAmJiBjaGVja1RhaWwgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2ssIGNoZWNrIHRhaWxcbiAgICAgICAgICB2YXIgYmVmb3JlVGFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgY29uc2lzdGVudFRhaWwgPSBjaGVja1RhaWwuc3RhdGU7XG4gICAgICAgICAgICBjaGVja1RhaWwuc2hpZnRCZWZvcmUodGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0YWlsRGV0YWlscyA9IHRoaXMuYXBwZW5kVGFpbChjaGVja1RhaWwpO1xuICAgICAgICAgIGFwcGVuZGVkID0gdGFpbERldGFpbHMucmF3SW5zZXJ0ZWQgPT09IGNoZWNrVGFpbC50b1N0cmluZygpOyAvLyBpZiBvaywgcm9sbGJhY2sgc3RhdGUgYWZ0ZXIgdGFpbFxuXG4gICAgICAgICAgaWYgKGFwcGVuZGVkICYmIHRhaWxEZXRhaWxzLmluc2VydGVkKSB0aGlzLnN0YXRlID0gYmVmb3JlVGFpbFN0YXRlO1xuICAgICAgICB9IC8vIHJldmVydCBhbGwgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmdcblxuXG4gICAgICAgIGlmICghYXBwZW5kZWQpIHtcbiAgICAgICAgICBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc2lzdGVudFN0YXRlO1xuICAgICAgICAgIGlmIChjaGVja1RhaWwgJiYgY29uc2lzdGVudFRhaWwpIGNoZWNrVGFpbC5zdGF0ZSA9IGNvbnNpc3RlbnRUYWlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyBvcHRpb25hbCBwbGFjZWhvbGRlciBhdCBlbmQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRQbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGxhY2Vob2xkZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICB9XG4gICAgLyoqIEFwcGVuZHMgc3ltYm9scyBjb25zaWRlcmluZyBmbGFncyAqL1xuICAgIC8vICRGbG93Rml4TWUgbm8gaWRlYXNcblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoc3RyLCBmbGFncywgdGFpbCkge1xuICAgICAgaWYgKCFpc1N0cmluZyhzdHIpKSB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgIHZhciBjaGVja1RhaWwgPSBpc1N0cmluZyh0YWlsKSA/IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWwpKSA6IHRhaWw7XG4gICAgICBpZiAoZmxhZ3MudGFpbCkgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBzdHIubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKHRoaXMuX2FwcGVuZENoYXIoc3RyW2NpXSwgZmxhZ3MsIGNoZWNrVGFpbCkpO1xuICAgICAgfSAvLyBhcHBlbmQgdGFpbCBidXQgYWdncmVnYXRlIG9ubHkgdGFpbFNoaWZ0XG5cblxuICAgICAgaWYgKGNoZWNrVGFpbCAhPSBudWxsKSB7XG4gICAgICAgIGRldGFpbHMudGFpbFNoaWZ0ICs9IHRoaXMuYXBwZW5kVGFpbChjaGVja1RhaWwpLnRhaWxTaGlmdDsgLy8gVE9ETyBpdCdzIGEgZ29vZCBpZGVhIHRvIGNsZWFyIHN0YXRlIGFmdGVyIGFwcGVuZGluZyBlbmRzXG4gICAgICAgIC8vIGJ1dCBpdCBjYXVzZXMgYnVncyB3aGVuIG9uZSBhcHBlbmQgY2FsbHMgYW5vdGhlciAod2hlbiBkeW5hbWljIGRpc3BhdGNoIHNldCByYXdJbnB1dFZhbHVlKVxuICAgICAgICAvLyB0aGlzLl9yZXNldEJlZm9yZVRhaWxTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpICsgdGhpcy52YWx1ZS5zbGljZSh0b1Bvcyk7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICB9XG4gICAgLyoqIENhbGxzIGZ1bmN0aW9uIGFuZCByZWFwcGxpZXMgY3VycmVudCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFZhbHVlUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoVmFsdWVSZWZyZXNoKGZuKSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaGluZyB8fCAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZm4oKTtcbiAgICAgIHRoaXMuX3JlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJhd0lucHV0ID0gdGhpcy5yYXdJbnB1dFZhbHVlO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciByZXQgPSBmbigpO1xuICAgICAgdGhpcy5yYXdJbnB1dFZhbHVlID0gcmF3SW5wdXQ7IC8vIGFwcGVuZCBsb3N0IHRyYWlsaW5nIGNoYXJzIGF0IGVuZFxuXG4gICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUgJiYgdmFsdWUuaW5kZXhPZih0aGlzLnZhbHVlKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZCh2YWx1ZS5zbGljZSh0aGlzLnZhbHVlLmxlbmd0aCksIHt9LCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoaW5nO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJydW5Jc29sYXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5Jc29sYXRlZChmbikge1xuICAgICAgaWYgKHRoaXMuX2lzb2xhdGVkIHx8ICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBmbih0aGlzKTtcbiAgICAgIHRoaXMuX2lzb2xhdGVkID0gdHJ1ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgcmV0ID0gZm4odGhpcyk7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICBkZWxldGUgdGhpcy5faXNvbGF0ZWQ7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUHJlcGFyZXMgc3RyaW5nIGJlZm9yZSBtYXNrIHByb2Nlc3NpbmdcclxuICAgICAgQHByb3RlY3RlZFxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvUHJlcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ByZXBhcmUoc3RyKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZSA/IHRoaXMucHJlcGFyZShzdHIsIHRoaXMsIGZsYWdzKSA6IHN0cjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFZhbGlkYXRlcyBpZiB2YWx1ZSBpcyBhY2NlcHRhYmxlXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgIHJldHVybiAoIXRoaXMudmFsaWRhdGUgfHwgdGhpcy52YWxpZGF0ZSh0aGlzLnZhbHVlLCB0aGlzLCBmbGFncykpICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuZG9WYWxpZGF0ZShmbGFncykpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgRG9lcyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgaW4gdGhlIGVuZCBvZiBlZGl0aW5nXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1pdCkgdGhpcy5jb21taXQodGhpcy52YWx1ZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9Gb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Gb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA/IHRoaXMuZm9ybWF0KHZhbHVlLCB0aGlzKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvUGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9QYXJzZShzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlID8gdGhpcy5wYXJzZShzdHIsIHRoaXMpIDogc3RyO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBpbnNlcnRlZCwgcmVtb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB2YXIgdGFpbFBvcyA9IHN0YXJ0ICsgZGVsZXRlQ291bnQ7XG4gICAgICB2YXIgdGFpbCA9IHRoaXMuZXh0cmFjdFRhaWwodGFpbFBvcyk7XG4gICAgICB2YXIgc3RhcnRDaGFuZ2VQb3MgPSB0aGlzLm5lYXJlc3RJbnB1dFBvcyhzdGFydCwgcmVtb3ZlRGlyZWN0aW9uKTtcbiAgICAgIHZhciBjaGFuZ2VEZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICB0YWlsU2hpZnQ6IHN0YXJ0Q2hhbmdlUG9zIC0gc3RhcnQgLy8gYWRqdXN0IHRhaWxTaGlmdCBpZiBzdGFydCB3YXMgYWxpZ25lZFxuXG4gICAgICB9KS5hZ2dyZWdhdGUodGhpcy5yZW1vdmUoc3RhcnRDaGFuZ2VQb3MpKS5hZ2dyZWdhdGUodGhpcy5hcHBlbmQoaW5zZXJ0ZWQsIHtcbiAgICAgICAgaW5wdXQ6IHRydWVcbiAgICAgIH0sIHRhaWwpKTtcbiAgICAgIHJldHVybiBjaGFuZ2VEZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3ZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gc3RhdGUuX3ZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVubWFza2VkVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuYXBwZW5kKHZhbHVlLCB7fSwgJycpO1xuICAgICAgdGhpcy5kb0NvbW1pdCgpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVkVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFyc2UodGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZG9Gb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogVmFsdWUgdGhhdCBpbmNsdWRlcyByYXcgdXNlciBpbnB1dCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmF3SW5wdXRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdElucHV0KDAsIHRoaXMudmFsdWUubGVuZ3RoLCB7XG4gICAgICAgIHJhdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hcHBlbmQodmFsdWUsIHtcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9LCAnJyk7XG4gICAgICB0aGlzLmRvQ29tbWl0KCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZDtcbn0oKTtcbk1hc2tlZC5ERUZBVUxUUyA9IHtcbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodikge1xuICAgIHJldHVybiB2O1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2Uodikge1xuICAgIHJldHVybiB2O1xuICB9XG59O1xuSU1hc2suTWFza2VkID0gTWFza2VkO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWQ7XG4iLCJpbXBvcnQgJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5cbi8qKiBHZXQgTWFza2VkIGNsYXNzIGJ5IG1hc2sgdHlwZSAqL1xuXG5mdW5jdGlvbiBtYXNrZWRDbGFzcyhtYXNrKSB7XG4gIGlmIChtYXNrID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgcHJvcGVydHkgc2hvdWxkIGJlIGRlZmluZWQnKTtcbiAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICBpZiAobWFzayBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIElNYXNrLk1hc2tlZFJlZ0V4cDsgLy8gJEZsb3dGaXhNZVxuXG4gIGlmIChpc1N0cmluZyhtYXNrKSkgcmV0dXJuIElNYXNrLk1hc2tlZFBhdHRlcm47IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIERhdGUgfHwgbWFzayA9PT0gRGF0ZSkgcmV0dXJuIElNYXNrLk1hc2tlZERhdGU7IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgbWFzayA9PT0gJ251bWJlcicgfHwgbWFzayA9PT0gTnVtYmVyKSByZXR1cm4gSU1hc2suTWFza2VkTnVtYmVyOyAvLyAkRmxvd0ZpeE1lXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWFzaykgfHwgbWFzayA9PT0gQXJyYXkpIHJldHVybiBJTWFzay5NYXNrZWREeW5hbWljOyAvLyAkRmxvd0ZpeE1lXG5cbiAgaWYgKElNYXNrLk1hc2tlZCAmJiBtYXNrLnByb3RvdHlwZSBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2s7IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gSU1hc2suTWFza2VkRnVuY3Rpb247IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2suY29uc3RydWN0b3I7XG4gIGNvbnNvbGUud2FybignTWFzayBub3QgZm91bmQgZm9yIG1hc2snLCBtYXNrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIC8vICRGbG93Rml4TWVcblxuICByZXR1cm4gSU1hc2suTWFza2VkO1xufVxuLyoqIENyZWF0ZXMgbmV3IHtAbGluayBNYXNrZWR9IGRlcGVuZGluZyBvbiBtYXNrIHR5cGUgKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFzayhvcHRzKSB7XG4gIC8vICRGbG93Rml4TWVcbiAgaWYgKElNYXNrLk1hc2tlZCAmJiBvcHRzIGluc3RhbmNlb2YgSU1hc2suTWFza2VkKSByZXR1cm4gb3B0cztcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICB2YXIgbWFzayA9IG9wdHMubWFzazsgLy8gJEZsb3dGaXhNZVxuXG4gIGlmIChJTWFzay5NYXNrZWQgJiYgbWFzayBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2s7XG4gIHZhciBNYXNrZWRDbGFzcyA9IG1hc2tlZENsYXNzKG1hc2spO1xuICBpZiAoIU1hc2tlZENsYXNzKSB0aHJvdyBuZXcgRXJyb3IoJ01hc2tlZCBjbGFzcyBpcyBub3QgZm91bmQgZm9yIHByb3ZpZGVkIG1hc2ssIGFwcHJvcHJpYXRlIG1vZHVsZSBuZWVkcyB0byBiZSBpbXBvcnQgbWFudWFsbHkgYmVmb3JlIGNyZWF0aW5nIG1hc2suJyk7XG4gIHJldHVybiBuZXcgTWFza2VkQ2xhc3Mob3B0cyk7XG59XG5JTWFzay5jcmVhdGVNYXNrID0gY3JlYXRlTWFzaztcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWFzaztcbmV4cG9ydCB7IG1hc2tlZENsYXNzIH07XG4iLCJpbXBvcnQgeyBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGMgYXMgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uLy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi8uLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgY3JlYXRlTWFzayBmcm9tICcuLi9mYWN0b3J5LmpzJztcblxudmFyIERFRkFVTFRfSU5QVVRfREVGSU5JVElPTlMgPSB7XG4gICcwJzogL1xcZC8sXG4gICdhJzogL1tcXHUwMDQxLVxcdTAwNUFcXHUwMDYxLVxcdTAwN0FcXHUwMEFBXFx1MDBCNVxcdTAwQkFcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLyxcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIwNzUwNzBcbiAgJyonOiAvLi9cbn07XG4vKiogKi9cblxudmFyIFBhdHRlcm5JbnB1dERlZmluaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cbiAgZnVuY3Rpb24gUGF0dGVybklucHV0RGVmaW5pdGlvbihvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdHRlcm5JbnB1dERlZmluaXRpb24pO1xuXG4gICAgdmFyIG1hc2sgPSBvcHRzLm1hc2ssXG4gICAgICAgIGJsb2NrT3B0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRzLCBbXCJtYXNrXCJdKTtcblxuICAgIHRoaXMubWFza2VkID0gY3JlYXRlTWFzayh7XG4gICAgICBtYXNrOiBtYXNrXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBibG9ja09wdHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdHRlcm5JbnB1dERlZmluaXRpb24sIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubWFza2VkLnJlc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmIChmcm9tUG9zID09PSAwICYmIHRvUG9zID49IDEpIHtcbiAgICAgICAgdGhpcy5faXNGaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFza2VkLnJlbW92ZShmcm9tUG9zLCB0b1Bvcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhcihzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBpZiAodGhpcy5faXNGaWxsZWQpIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5tYXNrZWQuc3RhdGU7IC8vIHNpbXVsYXRlIGlucHV0XG5cbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5tYXNrZWQuX2FwcGVuZENoYXIoc3RyLCBmbGFncyk7XG5cbiAgICAgIGlmIChkZXRhaWxzLmluc2VydGVkICYmIHRoaXMuZG9WYWxpZGF0ZShmbGFncykgPT09IGZhbHNlKSB7XG4gICAgICAgIGRldGFpbHMuaW5zZXJ0ZWQgPSBkZXRhaWxzLnJhd0luc2VydGVkID0gJyc7XG4gICAgICAgIHRoaXMubWFza2VkLnN0YXRlID0gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGV0YWlscy5pbnNlcnRlZCAmJiAhdGhpcy5pc09wdGlvbmFsICYmICF0aGlzLmxhenkgJiYgIWZsYWdzLmlucHV0KSB7XG4gICAgICAgIGRldGFpbHMuaW5zZXJ0ZWQgPSB0aGlzLnBsYWNlaG9sZGVyQ2hhcjtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscy5za2lwID0gIWRldGFpbHMuaW5zZXJ0ZWQgJiYgIXRoaXMuaXNPcHRpb25hbDtcbiAgICAgIHRoaXMuX2lzRmlsbGVkID0gQm9vbGVhbihkZXRhaWxzLmluc2VydGVkKTtcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDtcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQgPSB0aGlzLm1hc2tlZCkuYXBwZW5kLmFwcGx5KF90aGlzJG1hc2tlZCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcigpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgIGlmICh0aGlzLl9pc0ZpbGxlZCB8fCB0aGlzLmlzT3B0aW9uYWwpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSB0cnVlO1xuICAgICAgZGV0YWlscy5pbnNlcnRlZCA9IHRoaXMucGxhY2Vob2xkZXJDaGFyO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RUYWlsKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkbWFza2VkMiA9IHRoaXMubWFza2VkKS5leHRyYWN0VGFpbC5hcHBseShfdGhpcyRtYXNrZWQyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRhaWwoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFza2VkMztcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQzID0gdGhpcy5tYXNrZWQpLmFwcGVuZFRhaWwuYXBwbHkoX3RoaXMkbWFza2VkMywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMubWFza2VkLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcywgZmxhZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKGN1cnNvclBvcykge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRElSRUNUSU9OLk5PTkU7XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciBtYXhQb3MgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBib3VuZFBvcyA9IE1hdGgubWluKE1hdGgubWF4KGN1cnNvclBvcywgbWluUG9zKSwgbWF4UG9zKTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlID8gYm91bmRQb3MgOiBtaW5Qb3M7XG5cbiAgICAgICAgY2FzZSBESVJFQ1RJT04uUklHSFQ6XG4gICAgICAgIGNhc2UgRElSRUNUSU9OLkZPUkNFX1JJR0hUOlxuICAgICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGUgPyBib3VuZFBvcyA6IG1heFBvcztcblxuICAgICAgICBjYXNlIERJUkVDVElPTi5OT05FOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBib3VuZFBvcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDQsIF90aGlzJHBhcmVudDtcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQ0ID0gdGhpcy5tYXNrZWQpLmRvVmFsaWRhdGUuYXBwbHkoX3RoaXMkbWFza2VkNCwgYXJndW1lbnRzKSAmJiAoIXRoaXMucGFyZW50IHx8IChfdGhpcyRwYXJlbnQgPSB0aGlzLnBhcmVudCkuZG9WYWxpZGF0ZS5hcHBseShfdGhpcyRwYXJlbnQsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgIHRoaXMubWFza2VkLmRvQ29tbWl0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWQudmFsdWUgfHwgKHRoaXMuX2lzRmlsbGVkICYmICF0aGlzLmlzT3B0aW9uYWwgPyB0aGlzLnBsYWNlaG9sZGVyQ2hhciA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFza2VkLnVubWFza2VkVmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ29tcGxldGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMubWFza2VkLnZhbHVlKSB8fCB0aGlzLmlzT3B0aW9uYWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXNrZWQ6IHRoaXMubWFza2VkLnN0YXRlLFxuICAgICAgICBfaXNGaWxsZWQ6IHRoaXMuX2lzRmlsbGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHRoaXMubWFza2VkLnN0YXRlID0gc3RhdGUubWFza2VkO1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSBzdGF0ZS5faXNGaWxsZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhdHRlcm5JbnB1dERlZmluaXRpb247XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhdHRlcm5JbnB1dERlZmluaXRpb247XG5leHBvcnQgeyBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIH07XG4iLCJpbXBvcnQgeyBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2sgfSBmcm9tICcuLi8uLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IERJUkVDVElPTiwgaXNTdHJpbmcgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uLy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0IENvbnRpbnVvdXNUYWlsRGV0YWlscyBmcm9tICcuLi8uLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcblxudmFyIFBhdHRlcm5GaXhlZERlZmluaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cbiAgZnVuY3Rpb24gUGF0dGVybkZpeGVkRGVmaW5pdGlvbihvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdHRlcm5GaXhlZERlZmluaXRpb24pO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgICB0aGlzLl92YWx1ZSA9ICcnO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdHRlcm5GaXhlZERlZmluaXRpb24sIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5faXNSYXdJbnB1dCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl92YWx1ZS5sZW5ndGg7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpICsgdGhpcy5fdmFsdWUuc2xpY2UodG9Qb3MpO1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZSkgdGhpcy5faXNSYXdJbnB1dCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJlc3RJbnB1dFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWFyZXN0SW5wdXRQb3MoY3Vyc29yUG9zKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHZhciBtaW5Qb3MgPSAwO1xuICAgICAgdmFyIG1heFBvcyA9IHRoaXMuX3ZhbHVlLmxlbmd0aDtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICByZXR1cm4gbWluUG9zO1xuXG4gICAgICAgIGNhc2UgRElSRUNUSU9OLk5PTkU6XG4gICAgICAgIGNhc2UgRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9SSUdIVDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF4UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdElucHV0KCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX3ZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gZmxhZ3MucmF3ICYmIHRoaXMuX2lzUmF3SW5wdXQgJiYgdGhpcy5fdmFsdWUuc2xpY2UoZnJvbVBvcywgdG9Qb3MpIHx8ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhcihzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdmFyIGFwcGVuZGVkID0gdGhpcy5jaGFyID09PSBzdHJbMF07XG4gICAgICB2YXIgaXNSZXNvbHZlZCA9IGFwcGVuZGVkICYmICh0aGlzLmlzVW5tYXNraW5nIHx8IGZsYWdzLmlucHV0IHx8IGZsYWdzLnJhdykgJiYgIWZsYWdzLnRhaWw7XG4gICAgICBpZiAoaXNSZXNvbHZlZCkgZGV0YWlscy5yYXdJbnNlcnRlZCA9IHRoaXMuY2hhcjtcbiAgICAgIHRoaXMuX3ZhbHVlID0gZGV0YWlscy5pbnNlcnRlZCA9IHRoaXMuY2hhcjtcbiAgICAgIHRoaXMuX2lzUmF3SW5wdXQgPSBpc1Jlc29sdmVkICYmIChmbGFncy5yYXcgfHwgZmxhZ3MuaW5wdXQpO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRQbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGxhY2Vob2xkZXIoKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdGhpcy5fdmFsdWUgPSBkZXRhaWxzLmluc2VydGVkID0gdGhpcy5jaGFyO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RUYWlsKCkge1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHJldHVybiBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKCcnKTtcbiAgICB9IC8vICRGbG93Rml4TWUgbm8gaWRlYXNcblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFRhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVGFpbCh0YWlsKSB7XG4gICAgICBpZiAoaXNTdHJpbmcodGFpbCkpIHRhaWwgPSBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKFN0cmluZyh0YWlsKSk7XG4gICAgICByZXR1cm4gdGFpbC5hcHBlbmRUbyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZChzdHIsIGZsYWdzLCB0YWlsKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuX2FwcGVuZENoYXIoc3RyLCBmbGFncyk7XG5cbiAgICAgIGlmICh0YWlsICE9IG51bGwpIHtcbiAgICAgICAgZGV0YWlscy50YWlsU2hpZnQgKz0gdGhpcy5hcHBlbmRUYWlsKHRhaWwpLnRhaWxTaGlmdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvQ29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ29tbWl0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bm1hc2tlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1VubWFza2luZyA/IHRoaXMudmFsdWUgOiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdmFsdWU6IHRoaXMuX3ZhbHVlLFxuICAgICAgICBfaXNSYXdJbnB1dDogdGhpcy5faXNSYXdJbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgYyBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgfSBmcm9tICcuLi8uLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgQ2hhbmdlRGV0YWlscyBmcm9tICcuLi8uLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCBDb250aW51b3VzVGFpbERldGFpbHMgZnJvbSAnLi4vLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vLi4vY29yZS9ob2xkZXIuanMnO1xuXG52YXIgQ2h1bmtzVGFpbERldGFpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQ2h1bmtzVGFpbERldGFpbHMoKSB7XG4gICAgdmFyIGNodW5rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2h1bmtzVGFpbERldGFpbHMpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBjaHVua3M7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaHVua3NUYWlsRGV0YWlscywgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaHVua3MubWFwKFN0cmluZykuam9pbignJyk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG5vIGlkZWFzXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhaWxDaHVuaykge1xuICAgICAgaWYgKCFTdHJpbmcodGFpbENodW5rKSkgcmV0dXJuO1xuICAgICAgaWYgKGlzU3RyaW5nKHRhaWxDaHVuaykpIHRhaWxDaHVuayA9IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWxDaHVuaykpO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGV4dGVuZExhc3QgPSBsYXN0Q2h1bmsgJiYgKCAvLyBpZiBzdG9wcyBhcmUgc2FtZSBvciB0YWlsIGhhcyBubyBzdG9wXG4gICAgICBsYXN0Q2h1bmsuc3RvcCA9PT0gdGFpbENodW5rLnN0b3AgfHwgdGFpbENodW5rLnN0b3AgPT0gbnVsbCkgJiYgLy8gaWYgdGFpbCBjaHVuayBnb2VzIGp1c3QgYWZ0ZXIgbGFzdCBjaHVua1xuICAgICAgdGFpbENodW5rLmZyb20gPT09IGxhc3RDaHVuay5mcm9tICsgbGFzdENodW5rLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gICAgICBpZiAodGFpbENodW5rIGluc3RhbmNlb2YgQ29udGludW91c1RhaWxEZXRhaWxzKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBhYmlsaXR5IHRvIGV4dGVuZCBwcmV2aW91cyBjaHVua1xuICAgICAgICBpZiAoZXh0ZW5kTGFzdCkge1xuICAgICAgICAgIC8vIGV4dGVuZCBwcmV2aW91cyBjaHVua1xuICAgICAgICAgIGxhc3RDaHVuay5leHRlbmQodGFpbENodW5rLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFwcGVuZCBuZXcgY2h1bmtcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRhaWxDaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFpbENodW5rIGluc3RhbmNlb2YgQ2h1bmtzVGFpbERldGFpbHMpIHtcbiAgICAgICAgaWYgKHRhaWxDaHVuay5zdG9wID09IG51bGwpIHtcbiAgICAgICAgICAvLyB1bndyYXAgZmxvYXRpbmcgY2h1bmtzIHRvIHBhcmVudCwga2VlcGluZyBgZnJvbWAgcG9zXG4gICAgICAgICAgdmFyIGZpcnN0VGFpbENodW5rO1xuXG4gICAgICAgICAgd2hpbGUgKHRhaWxDaHVuay5jaHVua3MubGVuZ3RoICYmIHRhaWxDaHVuay5jaHVua3NbMF0uc3RvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaXJzdFRhaWxDaHVuayA9IHRhaWxDaHVuay5jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGZpcnN0VGFpbENodW5rLmZyb20gKz0gdGFpbENodW5rLmZyb207XG4gICAgICAgICAgICB0aGlzLmV4dGVuZChmaXJzdFRhaWxDaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRhaWwgY2h1bmsgc3RpbGwgaGFzIHZhbHVlXG5cblxuICAgICAgICBpZiAodGFpbENodW5rLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAvLyBpZiBjaHVua3MgY29udGFpbnMgc3RvcHMsIHRoZW4gcG9wdXAgc3RvcCB0byBjb250YWluZXJcbiAgICAgICAgICB0YWlsQ2h1bmsuc3RvcCA9IHRhaWxDaHVuay5ibG9ja0luZGV4O1xuICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godGFpbENodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUbyhtYXNrZWQpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGlmICghKG1hc2tlZCBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZFBhdHRlcm4pKSB7XG4gICAgICAgIHZhciB0YWlsID0gbmV3IENvbnRpbnVvdXNUYWlsRGV0YWlscyh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGFpbC5hcHBlbmRUbyhtYXNrZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCB0aGlzLmNodW5rcy5sZW5ndGggJiYgIWRldGFpbHMuc2tpcDsgKytjaSkge1xuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tjaV07XG5cbiAgICAgICAgdmFyIGxhc3RCbG9ja0l0ZXIgPSBtYXNrZWQuX21hcFBvc1RvQmxvY2sobWFza2VkLnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgdmFyIHN0b3AgPSBjaHVuay5zdG9wO1xuICAgICAgICB2YXIgY2h1bmtCbG9jayA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoc3RvcCAhPSBudWxsICYmICggLy8gaWYgYmxvY2sgbm90IGZvdW5kIG9yIHN0b3AgaXMgYmVoaW5kIGxhc3RCbG9ja1xuICAgICAgICAhbGFzdEJsb2NrSXRlciB8fCBsYXN0QmxvY2tJdGVyLmluZGV4IDw9IHN0b3ApKSB7XG4gICAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQ2h1bmtzVGFpbERldGFpbHMgfHwgLy8gZm9yIGNvbnRpbnVvdXMgYmxvY2sgYWxzbyBjaGVjayBpZiBzdG9wIGlzIGV4aXN0XG4gICAgICAgICAgbWFza2VkLl9zdG9wcy5pbmRleE9mKHN0b3ApID49IDApIHtcbiAgICAgICAgICAgIGRldGFpbHMuYWdncmVnYXRlKG1hc2tlZC5fYXBwZW5kUGxhY2Vob2xkZXIoc3RvcCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rQmxvY2sgPSBjaHVuayBpbnN0YW5jZW9mIENodW5rc1RhaWxEZXRhaWxzICYmIG1hc2tlZC5fYmxvY2tzW3N0b3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rQmxvY2spIHtcbiAgICAgICAgICB2YXIgdGFpbERldGFpbHMgPSBjaHVua0Jsb2NrLmFwcGVuZFRhaWwoY2h1bmspO1xuICAgICAgICAgIHRhaWxEZXRhaWxzLnNraXAgPSBmYWxzZTsgLy8gYWx3YXlzIGlnbm9yZSBza2lwLCBpdCB3aWxsIGJlIHNldCBvbiBsYXN0XG5cbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSh0YWlsRGV0YWlscyk7XG4gICAgICAgICAgbWFza2VkLl92YWx1ZSArPSB0YWlsRGV0YWlscy5pbnNlcnRlZDsgLy8gZ2V0IG5vdCBpbnNlcnRlZCBjaGFyc1xuXG4gICAgICAgICAgdmFyIHJlbWFpbkNoYXJzID0gY2h1bmsudG9TdHJpbmcoKS5zbGljZSh0YWlsRGV0YWlscy5yYXdJbnNlcnRlZC5sZW5ndGgpO1xuICAgICAgICAgIGlmIChyZW1haW5DaGFycykgZGV0YWlscy5hZ2dyZWdhdGUobWFza2VkLmFwcGVuZChyZW1haW5DaGFycywge1xuICAgICAgICAgICAgdGFpbDogdHJ1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZShtYXNrZWQuYXBwZW5kKGNodW5rLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHRhaWw6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdEJlZm9yZShwb3MpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gPj0gcG9zIHx8ICF0aGlzLmNodW5rcy5sZW5ndGgpIHJldHVybiAnJztcbiAgICAgIHZhciBjaHVua1NoaWZ0UG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgdmFyIGNpID0gMDtcblxuICAgICAgd2hpbGUgKGNpIDwgdGhpcy5jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHRoaXMuY2h1bmtzW2NpXTtcbiAgICAgICAgdmFyIHNoaWZ0Q2hhciA9IGNodW5rLnNoaWZ0QmVmb3JlKGNodW5rU2hpZnRQb3MpO1xuXG4gICAgICAgIGlmIChjaHVuay50b1N0cmluZygpKSB7XG4gICAgICAgICAgLy8gY2h1bmsgc3RpbGwgY29udGFpbnMgdmFsdWVcbiAgICAgICAgICAvLyBidXQgbm90IHNoaWZ0ZWQgLSBtZWFucyBubyBtb3JlIGF2YWlsYWJsZSBjaGFycyB0byBzaGlmdFxuICAgICAgICAgIGlmICghc2hpZnRDaGFyKSBicmVhaztcbiAgICAgICAgICArK2NpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNsZWFuIGlmIGNodW5rIGhhcyBubyB2YWx1ZVxuICAgICAgICAgIHRoaXMuY2h1bmtzLnNwbGljZShjaSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hpZnRDaGFyKSByZXR1cm4gc2hpZnRDaGFyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjLnN0YXRlO1xuICAgICAgICB9KSxcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICBzdG9wOiB0aGlzLnN0b3AsXG4gICAgICAgIGJsb2NrSW5kZXg6IHRoaXMuYmxvY2tJbmRleFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICB2YXIgY2h1bmtzID0gc3RhdGUuY2h1bmtzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHN0YXRlLCBbXCJjaHVua3NcIl0pO1xuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgIHRoaXMuY2h1bmtzID0gY2h1bmtzLm1hcChmdW5jdGlvbiAoY3N0YXRlKSB7XG4gICAgICAgIHZhciBjaHVuayA9IFwiY2h1bmtzXCIgaW4gY3N0YXRlID8gbmV3IENodW5rc1RhaWxEZXRhaWxzKCkgOiBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKCk7IC8vICRGbG93Rml4TWUgYWxyZWFkeSBjaGVja2VkIGFib3ZlXG5cbiAgICAgICAgY2h1bmsuc3RhdGUgPSBjc3RhdGU7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaHVua3NUYWlsRGV0YWlscztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2h1bmtzVGFpbERldGFpbHM7XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKiogTWFza2luZyBieSBSZWdFeHAgKi9cblxudmFyIE1hc2tlZFJlZ0V4cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hc2tlZCkge1xuICBfaW5oZXJpdHMoTWFza2VkUmVnRXhwLCBfTWFza2VkKTtcblxuICBmdW5jdGlvbiBNYXNrZWRSZWdFeHAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFJlZ0V4cCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZFJlZ0V4cCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkUmVnRXhwLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLm1hc2spIG9wdHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNlYXJjaChvcHRzLm1hc2spID49IDA7XG4gICAgICB9O1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSZWdFeHAucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZFJlZ0V4cDtcbn0oTWFza2VkKTtcbklNYXNrLk1hc2tlZFJlZ0V4cCA9IE1hc2tlZFJlZ0V4cDtcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkUmVnRXhwO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCwgYyBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIGggYXMgX3NldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgZm9yY2VEaXJlY3Rpb24sIERJUkVDVElPTiB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IENoYW5nZURldGFpbHMgZnJvbSAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCBNYXNrZWQgZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrIGZyb20gJy4vZmFjdG9yeS5qcyc7XG5pbXBvcnQgUGF0dGVybklucHV0RGVmaW5pdGlvbiwgeyBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIH0gZnJvbSAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0IFBhdHRlcm5GaXhlZERlZmluaXRpb24gZnJvbSAnLi9wYXR0ZXJuL2ZpeGVkLWRlZmluaXRpb24uanMnO1xuaW1wb3J0IENodW5rc1RhaWxEZXRhaWxzIGZyb20gJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5cbi8qKlxyXG4gIFBhdHRlcm4gbWFza1xyXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgQHBhcmFtIHtPYmplY3R9IG9wdHMuYmxvY2tzXHJcbiAgQHBhcmFtIHtPYmplY3R9IG9wdHMuZGVmaW5pdGlvbnNcclxuICBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbGFjZWhvbGRlckNoYXJcclxuICBAcGFyYW0ge2Jvb2xlYW59IG9wdHMubGF6eVxyXG4qL1xudmFyIE1hc2tlZFBhdHRlcm4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgX2luaGVyaXRzKE1hc2tlZFBhdHRlcm4sIF9NYXNrZWQpO1xuXG4gIC8qKiAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiBTaW5nbGUgY2hhciBmb3IgZW1wdHkgaW5wdXQgKi9cblxuICAvKiogU2hvdyBwbGFjZWhvbGRlciBvbmx5IHdoZW4gbmVlZGVkICovXG4gIGZ1bmN0aW9uIE1hc2tlZFBhdHRlcm4oKSB7XG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFBhdHRlcm4pO1xuXG4gICAgLy8gVE9ETyB0eXBlICRTaGFwZTxNYXNrZWRQYXR0ZXJuT3B0aW9ucz49e30gZG9lcyBub3Qgd29ya1xuICAgIG9wdHMuZGVmaW5pdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TLCBvcHRzLmRlZmluaXRpb25zKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4pLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkUGF0dGVybi5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICBAb3ZlcnJpZGVcclxuICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNYXNrZWRQYXR0ZXJuLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBvcHRzLmRlZmluaXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZpbml0aW9ucywgb3B0cy5kZWZpbml0aW9ucyk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgIHRoaXMuX3JlYnVpbGRNYXNrKCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYnVpbGRNYXNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWJ1aWxkTWFzaygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZzID0gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgIHRoaXMuX2Jsb2NrcyA9IFtdO1xuICAgICAgdGhpcy5fc3RvcHMgPSBbXTtcbiAgICAgIHRoaXMuX21hc2tlZEJsb2NrcyA9IHt9O1xuICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLm1hc2s7XG4gICAgICBpZiAoIXBhdHRlcm4gfHwgIWRlZnMpIHJldHVybjtcbiAgICAgIHZhciB1bm1hc2tpbmdCbG9jayA9IGZhbHNlO1xuICAgICAgdmFyIG9wdGlvbmFsQmxvY2sgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2Nrcykge1xuICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwYXR0ZXJuLnNsaWNlKGkpO1xuICAgICAgICAgICAgdmFyIGJOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzLmJsb2NrcykuZmlsdGVyKGZ1bmN0aW9uIChiTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcC5pbmRleE9mKGJOYW1lKSA9PT0gMDtcbiAgICAgICAgICAgIH0pOyAvLyBvcmRlciBieSBrZXkgbGVuZ3RoXG5cbiAgICAgICAgICAgIGJOYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7IC8vIHVzZSBibG9jayBuYW1lIHdpdGggbWF4IGxlbmd0aFxuXG4gICAgICAgICAgICB2YXIgYk5hbWUgPSBiTmFtZXNbMF07XG5cbiAgICAgICAgICAgIGlmIChiTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgbWFza2VkQmxvY2sgPSBjcmVhdGVNYXNrKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHBhcmVudDogX3RoaXMsXG4gICAgICAgICAgICAgICAgbGF6eTogX3RoaXMubGF6eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNoYXI6IF90aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGU6IF90aGlzLm92ZXJ3cml0ZVxuICAgICAgICAgICAgICB9LCBfdGhpcy5ibG9ja3NbYk5hbWVdKSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hc2tlZEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2Nrcy5wdXNoKG1hc2tlZEJsb2NrKTsgLy8gc3RvcmUgYmxvY2sgaW5kZXhcblxuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fbWFza2VkQmxvY2tzW2JOYW1lXSkgX3RoaXMuX21hc2tlZEJsb2Nrc1tiTmFtZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgIF90aGlzLl9tYXNrZWRCbG9ja3NbYk5hbWVdLnB1c2goX3RoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGkgKz0gYk5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgICB2YXIgX2lzSW5wdXQgPSBjaGFyIGluIGRlZnM7XG5cbiAgICAgICAgaWYgKGNoYXIgPT09IE1hc2tlZFBhdHRlcm4uU1RPUF9DSEFSKSB7XG4gICAgICAgICAgdGhpcy5fc3RvcHMucHVzaCh0aGlzLl9ibG9ja3MubGVuZ3RoKTtcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7JyB8fCBjaGFyID09PSAnfScpIHtcbiAgICAgICAgICB1bm1hc2tpbmdCbG9jayA9ICF1bm1hc2tpbmdCbG9jaztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyID09PSAnWycgfHwgY2hhciA9PT0gJ10nKSB7XG4gICAgICAgICAgb3B0aW9uYWxCbG9jayA9ICFvcHRpb25hbEJsb2NrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09IE1hc2tlZFBhdHRlcm4uRVNDQVBFX0NIQVIpIHtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgY2hhciA9IHBhdHRlcm5baV07XG4gICAgICAgICAgaWYgKCFjaGFyKSBicmVhaztcbiAgICAgICAgICBfaXNJbnB1dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZiA9IF9pc0lucHV0ID8gbmV3IFBhdHRlcm5JbnB1dERlZmluaXRpb24oe1xuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBsYXp5OiB0aGlzLmxhenksXG4gICAgICAgICAgcGxhY2Vob2xkZXJDaGFyOiB0aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgICAgICBtYXNrOiBkZWZzW2NoYXJdLFxuICAgICAgICAgIGlzT3B0aW9uYWw6IG9wdGlvbmFsQmxvY2tcbiAgICAgICAgfSkgOiBuZXcgUGF0dGVybkZpeGVkRGVmaW5pdGlvbih7XG4gICAgICAgICAgY2hhcjogY2hhcixcbiAgICAgICAgICBpc1VubWFza2luZzogdW5tYXNraW5nQmxvY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYmxvY2tzLnB1c2goZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJyZXNldFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLl9ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Db21taXQoKSB7XG4gICAgICB0aGlzLl9ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5kb0NvbW1pdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJkb0NvbW1pdFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVGFpbFwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVGFpbCh0YWlsKSB7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcImFwcGVuZFRhaWxcIiwgdGhpcykuY2FsbCh0aGlzLCB0YWlsKS5hZ2dyZWdhdGUodGhpcy5fYXBwZW5kUGxhY2Vob2xkZXIoKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhclJhdyhjaCkge1xuICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNoID0gdGhpcy5kb1ByZXBhcmUoY2gsIGZsYWdzKTtcblxuICAgICAgdmFyIGJsb2NrSXRlciA9IHRoaXMuX21hcFBvc1RvQmxvY2sodGhpcy52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAoIWJsb2NrSXRlcikgcmV0dXJuIGRldGFpbHM7XG5cbiAgICAgIGZvciAodmFyIGJpID0gYmxvY2tJdGVyLmluZGV4OzsgKytiaSkge1xuICAgICAgICB2YXIgX2Jsb2NrID0gdGhpcy5fYmxvY2tzW2JpXTtcbiAgICAgICAgaWYgKCFfYmxvY2spIGJyZWFrO1xuXG4gICAgICAgIHZhciBibG9ja0RldGFpbHMgPSBfYmxvY2suX2FwcGVuZENoYXIoY2gsIGZsYWdzKTtcblxuICAgICAgICB2YXIgc2tpcCA9IGJsb2NrRGV0YWlscy5za2lwO1xuICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZShibG9ja0RldGFpbHMpO1xuICAgICAgICBpZiAoc2tpcCB8fCBibG9ja0RldGFpbHMucmF3SW5zZXJ0ZWQpIGJyZWFrOyAvLyBnbyBuZXh0IGNoYXJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0VGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0VGFpbCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgY2h1bmtUYWlsID0gbmV3IENodW5rc1RhaWxEZXRhaWxzKCk7XG4gICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHJldHVybiBjaHVua1RhaWw7XG5cbiAgICAgIHRoaXMuX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MsIHRvUG9zLCBmdW5jdGlvbiAoYiwgYmksIGJGcm9tUG9zLCBiVG9Qb3MpIHtcbiAgICAgICAgdmFyIGJsb2NrQ2h1bmsgPSBiLmV4dHJhY3RUYWlsKGJGcm9tUG9zLCBiVG9Qb3MpO1xuICAgICAgICBibG9ja0NodW5rLnN0b3AgPSBfdGhpczIuX2ZpbmRTdG9wQmVmb3JlKGJpKTtcbiAgICAgICAgYmxvY2tDaHVuay5mcm9tID0gX3RoaXMyLl9ibG9ja1N0YXJ0UG9zKGJpKTtcbiAgICAgICAgaWYgKGJsb2NrQ2h1bmsgaW5zdGFuY2VvZiBDaHVua3NUYWlsRGV0YWlscykgYmxvY2tDaHVuay5ibG9ja0luZGV4ID0gYmk7XG4gICAgICAgIGNodW5rVGFpbC5leHRlbmQoYmxvY2tDaHVuayk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNodW5rVGFpbDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0SW5wdXQoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgaWYgKGZyb21Qb3MgPT09IHRvUG9zKSByZXR1cm4gJyc7XG4gICAgICB2YXIgaW5wdXQgPSAnJztcblxuICAgICAgdGhpcy5fZm9yRWFjaEJsb2Nrc0luUmFuZ2UoZnJvbVBvcywgdG9Qb3MsIGZ1bmN0aW9uIChiLCBfLCBmcm9tUG9zLCB0b1Bvcykge1xuICAgICAgICBpbnB1dCArPSBiLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcywgZmxhZ3MpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTdG9wQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kU3RvcEJlZm9yZShibG9ja0luZGV4KSB7XG4gICAgICB2YXIgc3RvcEJlZm9yZTtcblxuICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXMuX3N0b3BzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW3NpXTtcbiAgICAgICAgaWYgKHN0b3AgPD0gYmxvY2tJbmRleCkgc3RvcEJlZm9yZSA9IHN0b3A7ZWxzZSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3BCZWZvcmU7XG4gICAgfVxuICAgIC8qKiBBcHBlbmRzIHBsYWNlaG9sZGVyIGRlcGVuZGluZyBvbiBsYXppbmVzcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcih0b0Jsb2NrSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5sYXp5ICYmIHRvQmxvY2tJbmRleCA9PSBudWxsKSByZXR1cm4gZGV0YWlscztcblxuICAgICAgdmFyIHN0YXJ0QmxvY2tJdGVyID0gdGhpcy5fbWFwUG9zVG9CbG9jayh0aGlzLnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgIGlmICghc3RhcnRCbG9ja0l0ZXIpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdmFyIHN0YXJ0QmxvY2tJbmRleCA9IHN0YXJ0QmxvY2tJdGVyLmluZGV4O1xuICAgICAgdmFyIGVuZEJsb2NrSW5kZXggPSB0b0Jsb2NrSW5kZXggIT0gbnVsbCA/IHRvQmxvY2tJbmRleCA6IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX2Jsb2Nrcy5zbGljZShzdGFydEJsb2NrSW5kZXgsIGVuZEJsb2NrSW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKCFiLmxhenkgfHwgdG9CbG9ja0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIGBfYmxvY2tzYCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICB2YXIgYXJncyA9IGIuX2Jsb2NrcyAhPSBudWxsID8gW2IuX2Jsb2Nrcy5sZW5ndGhdIDogW107XG5cbiAgICAgICAgICB2YXIgYkRldGFpbHMgPSBiLl9hcHBlbmRQbGFjZWhvbGRlci5hcHBseShiLCBhcmdzKTtcblxuICAgICAgICAgIF90aGlzMy5fdmFsdWUgKz0gYkRldGFpbHMuaW5zZXJ0ZWQ7XG4gICAgICAgICAgZGV0YWlscy5hZ2dyZWdhdGUoYkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKiBGaW5kcyBibG9jayBpbiBwb3MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYXBQb3NUb0Jsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXBQb3NUb0Jsb2NrKHBvcykge1xuICAgICAgdmFyIGFjY1ZhbCA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgdGhpcy5fYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICB2YXIgX2Jsb2NrMiA9IHRoaXMuX2Jsb2Nrc1tiaV07XG4gICAgICAgIHZhciBibG9ja1N0YXJ0UG9zID0gYWNjVmFsLmxlbmd0aDtcbiAgICAgICAgYWNjVmFsICs9IF9ibG9jazIudmFsdWU7XG5cbiAgICAgICAgaWYgKHBvcyA8PSBhY2NWYWwubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBiaSxcbiAgICAgICAgICAgIG9mZnNldDogcG9zIC0gYmxvY2tTdGFydFBvc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmxvY2tTdGFydFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmxvY2tTdGFydFBvcyhibG9ja0luZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmxvY2tzLnNsaWNlKDAsIGJsb2NrSW5kZXgpLnJlZHVjZShmdW5jdGlvbiAocG9zLCBiKSB7XG4gICAgICAgIHJldHVybiBwb3MgKz0gYi52YWx1ZS5sZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZm9yRWFjaEJsb2Nrc0luUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MpIHtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGZyb21CbG9ja0l0ZXIgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKGZyb21Qb3MpO1xuXG4gICAgICBpZiAoZnJvbUJsb2NrSXRlcikge1xuICAgICAgICB2YXIgdG9CbG9ja0l0ZXIgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKHRvUG9zKTsgLy8gcHJvY2VzcyBmaXJzdCBibG9ja1xuXG5cbiAgICAgICAgdmFyIGlzU2FtZUJsb2NrID0gdG9CbG9ja0l0ZXIgJiYgZnJvbUJsb2NrSXRlci5pbmRleCA9PT0gdG9CbG9ja0l0ZXIuaW5kZXg7XG4gICAgICAgIHZhciBmcm9tQmxvY2tTdGFydFBvcyA9IGZyb21CbG9ja0l0ZXIub2Zmc2V0O1xuICAgICAgICB2YXIgZnJvbUJsb2NrRW5kUG9zID0gdG9CbG9ja0l0ZXIgJiYgaXNTYW1lQmxvY2sgPyB0b0Jsb2NrSXRlci5vZmZzZXQgOiB0aGlzLl9ibG9ja3NbZnJvbUJsb2NrSXRlci5pbmRleF0udmFsdWUubGVuZ3RoO1xuICAgICAgICBmbih0aGlzLl9ibG9ja3NbZnJvbUJsb2NrSXRlci5pbmRleF0sIGZyb21CbG9ja0l0ZXIuaW5kZXgsIGZyb21CbG9ja1N0YXJ0UG9zLCBmcm9tQmxvY2tFbmRQb3MpO1xuXG4gICAgICAgIGlmICh0b0Jsb2NrSXRlciAmJiAhaXNTYW1lQmxvY2spIHtcbiAgICAgICAgICAvLyBwcm9jZXNzIGludGVybWVkaWF0ZSBibG9ja3NcbiAgICAgICAgICBmb3IgKHZhciBiaSA9IGZyb21CbG9ja0l0ZXIuaW5kZXggKyAxOyBiaSA8IHRvQmxvY2tJdGVyLmluZGV4OyArK2JpKSB7XG4gICAgICAgICAgICBmbih0aGlzLl9ibG9ja3NbYmldLCBiaSwgMCwgdGhpcy5fYmxvY2tzW2JpXS52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gLy8gcHJvY2VzcyBsYXN0IGJsb2NrXG5cblxuICAgICAgICAgIGZuKHRoaXMuX2Jsb2Nrc1t0b0Jsb2NrSXRlci5pbmRleF0sIHRvQmxvY2tJdGVyLmluZGV4LCAwLCB0b0Jsb2NrSXRlci5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuXG4gICAgICB2YXIgcmVtb3ZlRGV0YWlscyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJyZW1vdmVcIiwgdGhpcykuY2FsbCh0aGlzLCBmcm9tUG9zLCB0b1Bvcyk7XG5cbiAgICAgIHRoaXMuX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MsIHRvUG9zLCBmdW5jdGlvbiAoYiwgXywgYkZyb21Qb3MsIGJUb1Bvcykge1xuICAgICAgICByZW1vdmVEZXRhaWxzLmFnZ3JlZ2F0ZShiLnJlbW92ZShiRnJvbVBvcywgYlRvUG9zKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlbW92ZURldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKGN1cnNvclBvcykge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRElSRUNUSU9OLk5PTkU7XG4gICAgICAvLyBUT0RPIHJlZmFjdG9yIC0gZXh0cmFjdCBhbGlnbmJsb2NrXG4gICAgICB2YXIgYmVnaW5CbG9ja0RhdGEgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKGN1cnNvclBvcykgfHwge1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGJlZ2luQmxvY2tPZmZzZXQgPSBiZWdpbkJsb2NrRGF0YS5vZmZzZXQsXG4gICAgICAgICAgYmVnaW5CbG9ja0luZGV4ID0gYmVnaW5CbG9ja0RhdGEuaW5kZXg7XG4gICAgICB2YXIgYmVnaW5CbG9jayA9IHRoaXMuX2Jsb2Nrc1tiZWdpbkJsb2NrSW5kZXhdO1xuICAgICAgaWYgKCFiZWdpbkJsb2NrKSByZXR1cm4gY3Vyc29yUG9zO1xuICAgICAgdmFyIGJlZ2luQmxvY2tDdXJzb3JQb3MgPSBiZWdpbkJsb2NrT2Zmc2V0OyAvLyBpZiBwb3NpdGlvbiBpbnNpZGUgYmxvY2sgLSB0cnkgdG8gYWRqdXN0IGl0XG5cbiAgICAgIGlmIChiZWdpbkJsb2NrQ3Vyc29yUG9zICE9PSAwICYmIGJlZ2luQmxvY2tDdXJzb3JQb3MgPCBiZWdpbkJsb2NrLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBiZWdpbkJsb2NrQ3Vyc29yUG9zID0gYmVnaW5CbG9jay5uZWFyZXN0SW5wdXRQb3MoYmVnaW5CbG9ja09mZnNldCwgZm9yY2VEaXJlY3Rpb24oZGlyZWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJzb3JBdFJpZ2h0ID0gYmVnaW5CbG9ja0N1cnNvclBvcyA9PT0gYmVnaW5CbG9jay52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgY3Vyc29yQXRMZWZ0ID0gYmVnaW5CbG9ja0N1cnNvclBvcyA9PT0gMDsgLy8gIGN1cnNvciBpcyBJTlNJREUgZmlyc3QgYmxvY2sgKG5vdCBhdCBib3VuZHMpXG5cbiAgICAgIGlmICghY3Vyc29yQXRMZWZ0ICYmICFjdXJzb3JBdFJpZ2h0KSByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhiZWdpbkJsb2NrSW5kZXgpICsgYmVnaW5CbG9ja0N1cnNvclBvcztcbiAgICAgIHZhciBzZWFyY2hCbG9ja0luZGV4ID0gY3Vyc29yQXRSaWdodCA/IGJlZ2luQmxvY2tJbmRleCArIDEgOiBiZWdpbkJsb2NrSW5kZXg7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5OT05FKSB7XG4gICAgICAgIC8vIE5PTkUgZGlyZWN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHN0YXJ0IGlucHV0IHBvc2l0aW9uIGlmIG5vIGNoYXJzIHdlcmUgcmVtb3ZlZFxuICAgICAgICAvLyBGT1IgTk9ORTpcbiAgICAgICAgLy8gLVxuICAgICAgICAvLyBpbnB1dHxhbnlcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gIGFueXxpbnB1dFxuICAgICAgICAvLyA8LVxuICAgICAgICAvLyAgZmlsbGVkLWlucHV0fGFueVxuICAgICAgICAvLyBjaGVjayBpZiBmaXJzdCBibG9jayBhdCBsZWZ0IGlzIGlucHV0XG4gICAgICAgIGlmIChzZWFyY2hCbG9ja0luZGV4ID4gMCkge1xuICAgICAgICAgIHZhciBibG9ja0luZGV4QXRMZWZ0ID0gc2VhcmNoQmxvY2tJbmRleCAtIDE7XG4gICAgICAgICAgdmFyIGJsb2NrQXRMZWZ0ID0gdGhpcy5fYmxvY2tzW2Jsb2NrSW5kZXhBdExlZnRdO1xuICAgICAgICAgIHZhciBibG9ja0lucHV0UG9zID0gYmxvY2tBdExlZnQubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTsgLy8gaXMgaW5wdXRcblxuICAgICAgICAgIGlmICghYmxvY2tBdExlZnQudmFsdWUubGVuZ3RoIHx8IGJsb2NrSW5wdXRQb3MgIT09IGJsb2NrQXRMZWZ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3Moc2VhcmNoQmxvY2tJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIC0+XG5cblxuICAgICAgICB2YXIgZmlyc3RJbnB1dEF0UmlnaHQgPSBzZWFyY2hCbG9ja0luZGV4O1xuXG4gICAgICAgIGZvciAodmFyIGJpID0gZmlyc3RJbnB1dEF0UmlnaHQ7IGJpIDwgdGhpcy5fYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgIHZhciBibG9ja0F0UmlnaHQgPSB0aGlzLl9ibG9ja3NbYmldO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zID0gYmxvY2tBdFJpZ2h0Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSk7XG5cbiAgICAgICAgICBpZiAoIWJsb2NrQXRSaWdodC52YWx1ZS5sZW5ndGggfHwgX2Jsb2NrSW5wdXRQb3MgIT09IGJsb2NrQXRSaWdodC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja1N0YXJ0UG9zKGJpKSArIF9ibG9ja0lucHV0UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyA8LVxuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi1maXhlZCBzeW1ib2xcblxuXG4gICAgICAgIGZvciAodmFyIF9iaSA9IHNlYXJjaEJsb2NrSW5kZXggLSAxOyBfYmkgPj0gMDsgLS1fYmkpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrMyA9IHRoaXMuX2Jsb2Nrc1tfYmldO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zMiA9IF9ibG9jazMubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTsgLy8gaXMgaW5wdXRcblxuXG4gICAgICAgICAgaWYgKCFfYmxvY2szLnZhbHVlLmxlbmd0aCB8fCBfYmxvY2tJbnB1dFBvczIgIT09IF9ibG9jazMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmkpICsgX2Jsb2NrMy52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQgfHwgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfTEVGVCkge1xuICAgICAgICAvLyAtXG4gICAgICAgIC8vICBhbnl8ZmlsbGVkLWlucHV0XG4gICAgICAgIC8vIDwtXG4gICAgICAgIC8vICBhbnl8Zmlyc3Qgbm90IGVtcHR5IGlzIG5vdC1sZW4tYWxpZ25lZFxuICAgICAgICAvLyAgbm90LTAtYWxpZ25lZHxhbnlcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gIGFueXxub3QtbGVuLWFsaWduZWQgb3IgZW5kXG4gICAgICAgIC8vIGNoZWNrIGlmIGZpcnN0IGJsb2NrIGF0IHJpZ2h0IGlzIGZpbGxlZCBpbnB1dFxuICAgICAgICB2YXIgZmlyc3RGaWxsZWRCbG9ja0luZGV4QXRSaWdodDtcblxuICAgICAgICBmb3IgKHZhciBfYmkyID0gc2VhcmNoQmxvY2tJbmRleDsgX2JpMiA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpMikge1xuICAgICAgICAgIGlmICh0aGlzLl9ibG9ja3NbX2JpMl0udmFsdWUpIHtcbiAgICAgICAgICAgIGZpcnN0RmlsbGVkQmxvY2tJbmRleEF0UmlnaHQgPSBfYmkyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0RmlsbGVkQmxvY2tJbmRleEF0UmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmaWxsZWRCbG9jayA9IHRoaXMuX2Jsb2Nrc1tmaXJzdEZpbGxlZEJsb2NrSW5kZXhBdFJpZ2h0XTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczMgPSBmaWxsZWRCbG9jay5uZWFyZXN0SW5wdXRQb3MoMCwgRElSRUNUSU9OLlJJR0hUKTtcblxuICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczMgPT09IDAgJiYgZmlsbGVkQmxvY2sudW5tYXNrZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpbGxlZCBibG9jayBpcyBpbnB1dFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoZmlyc3RGaWxsZWRCbG9ja0luZGV4QXRSaWdodCkgKyBfYmxvY2tJbnB1dFBvczM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIDwtXG4gICAgICAgIC8vIGZpbmQgdGhpcyB2YXJzXG5cblxuICAgICAgICB2YXIgZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGZpcnN0RW1wdHlJbnB1dEJsb2NrSW5kZXg7IC8vIFRPRE8gY29uc2lkZXIgbmVzdGVkIGVtcHR5IGlucHV0c1xuXG4gICAgICAgIGZvciAodmFyIF9iaTMgPSBzZWFyY2hCbG9ja0luZGV4IC0gMTsgX2JpMyA+PSAwOyAtLV9iaTMpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrNCA9IHRoaXMuX2Jsb2Nrc1tfYmkzXTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczQgPSBfYmxvY2s0Lm5lYXJlc3RJbnB1dFBvcyhfYmxvY2s0LnZhbHVlLmxlbmd0aCwgRElSRUNUSU9OLkZPUkNFX0xFRlQpO1xuXG4gICAgICAgICAgaWYgKCFfYmxvY2s0LnZhbHVlIHx8IF9ibG9ja0lucHV0UG9zNCAhPT0gMCkgZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCA9IF9iaTM7XG5cbiAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M0ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M0ICE9PSBfYmxvY2s0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBhbGlnbmVkIGluc2lkZSBibG9jayAtIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmkzKSArIF9ibG9ja0lucHV0UG9zNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvdW5kIGZpbGxlZFxuICAgICAgICAgICAgICBmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleCA9IF9iaTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XG4gICAgICAgICAgLy8gdHJ5IGZpbmQgZmlyc3QgZW1wdHkgaW5wdXQgYmVmb3JlIHN0YXJ0IHNlYXJjaGluZyBwb3NpdGlvbiBvbmx5IHdoZW4gbm90IGZvcmNlZFxuICAgICAgICAgIGZvciAodmFyIF9iaTQgPSBmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleCArIDE7IF9iaTQgPD0gTWF0aC5taW4oc2VhcmNoQmxvY2tJbmRleCwgdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpOyArK19iaTQpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2s1ID0gdGhpcy5fYmxvY2tzW19iaTRdO1xuXG4gICAgICAgICAgICB2YXIgX2Jsb2NrSW5wdXRQb3M1ID0gX2Jsb2NrNS5uZWFyZXN0SW5wdXRQb3MoMCwgRElSRUNUSU9OLk5PTkUpO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tBbGlnbmVkUG9zID0gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk0KSArIF9ibG9ja0lucHV0UG9zNTtcblxuICAgICAgICAgICAgaWYgKGJsb2NrQWxpZ25lZFBvcyA+IGN1cnNvclBvcykgYnJlYWs7IC8vIGlmIGJsb2NrIGlzIG5vdCBsYXp5IGlucHV0XG5cbiAgICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczUgIT09IF9ibG9jazUudmFsdWUubGVuZ3RoKSByZXR1cm4gYmxvY2tBbGlnbmVkUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9jZXNzIG92ZXJmbG93XG5cblxuICAgICAgICBpZiAoZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja1N0YXJ0UG9zKGZpcnN0RmlsbGVkSW5wdXRCbG9ja0luZGV4KSArIHRoaXMuX2Jsb2Nrc1tmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleF0udmFsdWUubGVuZ3RoO1xuICAgICAgICB9IC8vIGZvciBsYXp5IGlmIGhhcyBhbGlnbmVkIGxlZnQgaW5zaWRlIGZpeGVkIGFuZCBoYXMgY2FtZSB0byB0aGUgc3RhcnQgLSB1c2Ugc3RhcnQgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5GT1JDRV9MRUZUIHx8IHRoaXMubGF6eSAmJiAhdGhpcy5leHRyYWN0SW5wdXQoKSAmJiAhaXNJbnB1dCh0aGlzLl9ibG9ja3Nbc2VhcmNoQmxvY2tJbmRleF0pKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCk7XG4gICAgICAgIH0gLy8gZmluZCBmaXJzdCBpbnB1dFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2JpNSA9IHNlYXJjaEJsb2NrSW5kZXg7IF9iaTUgPCB0aGlzLl9ibG9ja3MubGVuZ3RoOyArK19iaTUpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrNiA9IHRoaXMuX2Jsb2Nrc1tfYmk1XTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczYgPSBfYmxvY2s2Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSk7IC8vIGlzIGlucHV0XG5cblxuICAgICAgICAgIGlmICghX2Jsb2NrNi52YWx1ZS5sZW5ndGggfHwgX2Jsb2NrSW5wdXRQb3M2ICE9PSBfYmxvY2s2LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoX2JpNSkgKyBfYmxvY2tJbnB1dFBvczY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5SSUdIVCB8fCBkaXJlY3Rpb24gPT09IERJUkVDVElPTi5GT1JDRV9SSUdIVCkge1xuICAgICAgICAvLyAtPlxuICAgICAgICAvLyAgYW55fG5vdC1sZW4tYWxpZ25lZCBhbmQgZmlsbGVkXG4gICAgICAgIC8vICBhbnl8bm90LWxlbi1hbGlnbmVkXG4gICAgICAgIC8vIDwtXG4gICAgICAgIC8vICBub3QtMC1hbGlnbmVkIG9yIHN0YXJ0fGFueVxuICAgICAgICB2YXIgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZEluZGV4O1xuICAgICAgICB2YXIgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZFBvcztcblxuICAgICAgICBmb3IgKHZhciBfYmk2ID0gc2VhcmNoQmxvY2tJbmRleDsgX2JpNiA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpNikge1xuICAgICAgICAgIHZhciBfYmxvY2s3ID0gdGhpcy5fYmxvY2tzW19iaTZdO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zNyA9IF9ibG9jazcubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTtcblxuICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczcgIT09IF9ibG9jazcudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaXJzdElucHV0QmxvY2tBbGlnbmVkUG9zID0gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk2KSArIF9ibG9ja0lucHV0UG9zNztcbiAgICAgICAgICAgIGZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleCA9IF9iaTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RJbnB1dEJsb2NrQWxpZ25lZEluZGV4ICE9IG51bGwgJiYgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZFBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2JpNyA9IGZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleDsgX2JpNyA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpNykge1xuICAgICAgICAgICAgdmFyIF9ibG9jazggPSB0aGlzLl9ibG9ja3NbX2JpN107XG5cbiAgICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczggPSBfYmxvY2s4Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uRk9SQ0VfUklHSFQpO1xuXG4gICAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M4ICE9PSBfYmxvY2s4LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk3KSArIF9ibG9ja0lucHV0UG9zODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfUklHSFQgPyB0aGlzLnZhbHVlLmxlbmd0aCA6IGZpcnN0SW5wdXRCbG9ja0FsaWduZWRQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfYmk4ID0gTWF0aC5taW4oc2VhcmNoQmxvY2tJbmRleCwgdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpOyBfYmk4ID49IDA7IC0tX2JpOCkge1xuICAgICAgICAgIHZhciBfYmxvY2s5ID0gdGhpcy5fYmxvY2tzW19iaThdO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zOSA9IF9ibG9jazkubmVhcmVzdElucHV0UG9zKF9ibG9jazkudmFsdWUubGVuZ3RoLCBESVJFQ1RJT04uTEVGVCk7XG5cbiAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M5ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgYWxpZ25lZFBvcyA9IHRoaXMuX2Jsb2NrU3RhcnRQb3MoX2JpOCkgKyBfYmxvY2tJbnB1dFBvczk7XG5cbiAgICAgICAgICAgIGlmIChhbGlnbmVkUG9zID49IGN1cnNvclBvcykgcmV0dXJuIGFsaWduZWRQb3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICB9XG4gICAgLyoqIEdldCBibG9jayBieSBuYW1lICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXNrZWRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrZWRCbG9jayhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWRCbG9ja3MobmFtZSlbMF07XG4gICAgfVxuICAgIC8qKiBHZXQgYWxsIGJsb2NrcyBieSBuYW1lICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXNrZWRCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFza2VkQmxvY2tzKG5hbWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuX21hc2tlZEJsb2Nrc1tuYW1lXTtcbiAgICAgIGlmICghaW5kaWNlcykgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIGluZGljZXMubWFwKGZ1bmN0aW9uIChnaSkge1xuICAgICAgICByZXR1cm4gX3RoaXM0Ll9ibG9ja3NbZ2ldO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcInN0YXRlXCIsIHRoaXMpLCB7XG4gICAgICAgIF9ibG9ja3M6IHRoaXMuX2Jsb2Nrcy5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5zdGF0ZTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHZhciBfYmxvY2tzID0gc3RhdGUuX2Jsb2NrcyxcbiAgICAgICAgICBtYXNrZWRTdGF0ZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzdGF0ZSwgW1wiX2Jsb2Nrc1wiXSk7XG5cbiAgICAgIHRoaXMuX2Jsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBiaSkge1xuICAgICAgICByZXR1cm4gYi5zdGF0ZSA9IF9ibG9ja3NbYmldO1xuICAgICAgfSk7XG5cbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJzdGF0ZVwiLCBtYXNrZWRTdGF0ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ29tcGxldGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ibG9ja3MuZXZlcnkoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaXNDb21wbGV0ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bm1hc2tlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmxvY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBiKSB7XG4gICAgICAgIHJldHVybiBzdHIgKz0gYi51bm1hc2tlZFZhbHVlO1xuICAgICAgfSwgJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodW5tYXNrZWRWYWx1ZSkge1xuICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcInVubWFza2VkVmFsdWVcIiwgdW5tYXNrZWRWYWx1ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gVE9ETyByZXR1cm4gX3ZhbHVlIHdoZW4gbm90IGluIGNoYW5nZT9cbiAgICAgIHJldHVybiB0aGlzLl9ibG9ja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciArPSBiLnZhbHVlO1xuICAgICAgfSwgJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZFBhdHRlcm47XG59KE1hc2tlZCk7XG5NYXNrZWRQYXR0ZXJuLkRFRkFVTFRTID0ge1xuICBsYXp5OiB0cnVlLFxuICBwbGFjZWhvbGRlckNoYXI6ICdfJ1xufTtcbk1hc2tlZFBhdHRlcm4uU1RPUF9DSEFSID0gJ2AnO1xuTWFza2VkUGF0dGVybi5FU0NBUEVfQ0hBUiA9ICdcXFxcJztcbk1hc2tlZFBhdHRlcm4uSW5wdXREZWZpbml0aW9uID0gUGF0dGVybklucHV0RGVmaW5pdGlvbjtcbk1hc2tlZFBhdHRlcm4uRml4ZWREZWZpbml0aW9uID0gUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcblxuZnVuY3Rpb24gaXNJbnB1dChibG9jaykge1xuICBpZiAoIWJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIHZhciB2YWx1ZSA9IGJsb2NrLnZhbHVlO1xuICByZXR1cm4gIXZhbHVlIHx8IGJsb2NrLm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSkgIT09IHZhbHVlLmxlbmd0aDtcbn1cblxuSU1hc2suTWFza2VkUGF0dGVybiA9IE1hc2tlZFBhdHRlcm47XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZFBhdHRlcm47XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0LCBpIGFzIF9zbGljZWRUb0FycmF5IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0ICcuL2Jhc2UuanMnO1xuaW1wb3J0ICcuL2ZhY3RvcnkuanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vaW5wdXQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vcmVnZXhwLmpzJztcbmltcG9ydCBNYXNrZWRQYXR0ZXJuIGZyb20gJy4vcGF0dGVybi5qcyc7XG5cbi8qKiBQYXR0ZXJuIHdoaWNoIGFjY2VwdHMgcmFuZ2VzICovXG5cbnZhciBNYXNrZWRSYW5nZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hc2tlZFBhdHRlcm4pIHtcbiAgX2luaGVyaXRzKE1hc2tlZFJhbmdlLCBfTWFza2VkUGF0dGVybik7XG5cbiAgZnVuY3Rpb24gTWFza2VkUmFuZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFJhbmdlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFza2VkUmFuZ2UpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZFJhbmdlLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIC8vIFRPRE8gdHlwZVxuICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0bzogdGhpcy50byB8fCAwLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20gfHwgMFxuICAgICAgfSwgb3B0cyk7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gU3RyaW5nKG9wdHMudG8pLmxlbmd0aDtcbiAgICAgIGlmIChvcHRzLm1heExlbmd0aCAhPSBudWxsKSBtYXhMZW5ndGggPSBNYXRoLm1heChtYXhMZW5ndGgsIG9wdHMubWF4TGVuZ3RoKTtcbiAgICAgIG9wdHMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgdmFyIGZyb21TdHIgPSBTdHJpbmcob3B0cy5mcm9tKS5wYWRTdGFydChtYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdG9TdHIgPSBTdHJpbmcob3B0cy50bykucGFkU3RhcnQobWF4TGVuZ3RoLCAnMCcpO1xuICAgICAgdmFyIHNhbWVDaGFyc0NvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKHNhbWVDaGFyc0NvdW50IDwgdG9TdHIubGVuZ3RoICYmIHRvU3RyW3NhbWVDaGFyc0NvdW50XSA9PT0gZnJvbVN0cltzYW1lQ2hhcnNDb3VudF0pIHtcbiAgICAgICAgKytzYW1lQ2hhcnNDb3VudDtcbiAgICAgIH1cblxuICAgICAgb3B0cy5tYXNrID0gdG9TdHIuc2xpY2UoMCwgc2FtZUNoYXJzQ291bnQpLnJlcGxhY2UoLzAvZywgJ1xcXFwwJykgKyAnMCcucmVwZWF0KG1heExlbmd0aCAtIHNhbWVDaGFyc0NvdW50KTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUmFuZ2UucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJib3VuZGFyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvdW5kYXJpZXMoc3RyKSB7XG4gICAgICB2YXIgbWluc3RyID0gJyc7XG4gICAgICB2YXIgbWF4c3RyID0gJyc7XG5cbiAgICAgIHZhciBfcmVmID0gc3RyLm1hdGNoKC9eKFxcRCopKFxcZCopKFxcRCopLykgfHwgW10sXG4gICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAzKSxcbiAgICAgICAgICBwbGFjZWhvbGRlciA9IF9yZWYyWzFdLFxuICAgICAgICAgIG51bSA9IF9yZWYyWzJdO1xuXG4gICAgICBpZiAobnVtKSB7XG4gICAgICAgIG1pbnN0ciA9ICcwJy5yZXBlYXQocGxhY2Vob2xkZXIubGVuZ3RoKSArIG51bTtcbiAgICAgICAgbWF4c3RyID0gJzknLnJlcGVhdChwbGFjZWhvbGRlci5sZW5ndGgpICsgbnVtO1xuICAgICAgfVxuXG4gICAgICBtaW5zdHIgPSBtaW5zdHIucGFkRW5kKHRoaXMubWF4TGVuZ3RoLCAnMCcpO1xuICAgICAgbWF4c3RyID0gbWF4c3RyLnBhZEVuZCh0aGlzLm1heExlbmd0aCwgJzknKTtcbiAgICAgIHJldHVybiBbbWluc3RyLCBtYXhzdHJdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9QcmVwYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvUHJlcGFyZShzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBzdHIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSYW5nZS5wcm90b3R5cGUpLCBcImRvUHJlcGFyZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHN0ciwgZmxhZ3MpLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICBpZiAoIXRoaXMuYXV0b2ZpeCkgcmV0dXJuIHN0cjtcbiAgICAgIHZhciBmcm9tU3RyID0gU3RyaW5nKHRoaXMuZnJvbSkucGFkU3RhcnQodGhpcy5tYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdG9TdHIgPSBTdHJpbmcodGhpcy50bykucGFkU3RhcnQodGhpcy5tYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciBwcmVwU3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBzdHIubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgIHZhciBuZXh0VmFsID0gdmFsICsgcHJlcFN0ciArIHN0cltjaV07XG5cbiAgICAgICAgdmFyIF90aGlzJGJvdW5kYXJpZXMgPSB0aGlzLmJvdW5kYXJpZXMobmV4dFZhbCksXG4gICAgICAgICAgICBfdGhpcyRib3VuZGFyaWVzMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGJvdW5kYXJpZXMsIDIpLFxuICAgICAgICAgICAgbWluc3RyID0gX3RoaXMkYm91bmRhcmllczJbMF0sXG4gICAgICAgICAgICBtYXhzdHIgPSBfdGhpcyRib3VuZGFyaWVzMlsxXTtcblxuICAgICAgICBpZiAoTnVtYmVyKG1heHN0cikgPCB0aGlzLmZyb20pIHByZXBTdHIgKz0gZnJvbVN0cltuZXh0VmFsLmxlbmd0aCAtIDFdO2Vsc2UgaWYgKE51bWJlcihtaW5zdHIpID4gdGhpcy50bykgcHJlcFN0ciArPSB0b1N0cltuZXh0VmFsLmxlbmd0aCAtIDFdO2Vsc2UgcHJlcFN0ciArPSBzdHJbY2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlcFN0cjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvVmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9WYWxpZGF0ZSgpIHtcbiAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgdmFyIHN0ciA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgZmlyc3ROb25aZXJvID0gc3RyLnNlYXJjaCgvW14wXS8pO1xuICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gLTEgJiYgc3RyLmxlbmd0aCA8PSB0aGlzLl9tYXRjaEZyb20pIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgX3RoaXMkYm91bmRhcmllczMgPSB0aGlzLmJvdW5kYXJpZXMoc3RyKSxcbiAgICAgICAgICBfdGhpcyRib3VuZGFyaWVzNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJGJvdW5kYXJpZXMzLCAyKSxcbiAgICAgICAgICBtaW5zdHIgPSBfdGhpcyRib3VuZGFyaWVzNFswXSxcbiAgICAgICAgICBtYXhzdHIgPSBfdGhpcyRib3VuZGFyaWVzNFsxXTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZyb20gPD0gTnVtYmVyKG1heHN0cikgJiYgTnVtYmVyKG1pbnN0cikgPD0gdGhpcy50byAmJiAoX2dldDIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSYW5nZS5wcm90b3R5cGUpLCBcImRvVmFsaWRhdGVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWF0Y2hGcm9tXCIsXG5cbiAgICAvKipcclxuICAgICAgT3B0aW9uYWxseSBzZXRzIG1heCBsZW5ndGggb2YgcGF0dGVybi5cclxuICAgICAgVXNlZCB3aGVuIHBhdHRlcm4gbGVuZ3RoIGlzIGxvbmdlciB0aGVuIGB0b2AgcGFyYW0gbGVuZ3RoLiBQYWRzIHplcm9zIGF0IHN0YXJ0IGluIHRoaXMgY2FzZS5cclxuICAgICovXG5cbiAgICAvKiogTWluIGJvdW5kICovXG5cbiAgICAvKiogTWF4IGJvdW5kICovXG5cbiAgICAvKiogKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heExlbmd0aCAtIFN0cmluZyh0aGlzLmZyb20pLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFJhbmdlLnByb3RvdHlwZSksIFwiaXNDb21wbGV0ZVwiLCB0aGlzKSAmJiBCb29sZWFuKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWRSYW5nZTtcbn0oTWFza2VkUGF0dGVybik7XG5JTWFzay5NYXNrZWRSYW5nZSA9IE1hc2tlZFJhbmdlO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWRSYW5nZTtcbiIsImltcG9ydCB7IGQgYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgaSBhcyBfc2xpY2VkVG9BcnJheSwgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGUgYXMgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIGYgYXMgX2dldFByb3RvdHlwZU9mLCBnIGFzIF9nZXQsIGggYXMgX3NldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCAnLi9iYXNlLmpzJztcbmltcG9ydCAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5pbXBvcnQgTWFza2VkUGF0dGVybiBmcm9tICcuL3BhdHRlcm4uanMnO1xuaW1wb3J0IE1hc2tlZFJhbmdlIGZyb20gJy4vcmFuZ2UuanMnO1xuXG4vKiogRGF0ZSBtYXNrICovXG5cbnZhciBNYXNrZWREYXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkUGF0dGVybikge1xuICBfaW5oZXJpdHMoTWFza2VkRGF0ZSwgX01hc2tlZFBhdHRlcm4pO1xuXG4gIC8qKiBQYXR0ZXJuIG1hc2sgZm9yIGRhdGUgYWNjb3JkaW5nIHRvIHtAbGluayBNYXNrZWREYXRlI2Zvcm1hdH0gKi9cblxuICAvKiogU3RhcnQgZGF0ZSAqL1xuXG4gIC8qKiBFbmQgZGF0ZSAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAqL1xuICBmdW5jdGlvbiBNYXNrZWREYXRlKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza2VkRGF0ZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkRGF0ZS5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICBAb3ZlcnJpZGVcclxuICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZERhdGUsIFt7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShvcHRzKSB7XG4gICAgICBpZiAob3B0cy5tYXNrID09PSBEYXRlKSBkZWxldGUgb3B0cy5tYXNrO1xuICAgICAgaWYgKG9wdHMucGF0dGVybikgb3B0cy5tYXNrID0gb3B0cy5wYXR0ZXJuO1xuICAgICAgdmFyIGJsb2NrcyA9IG9wdHMuYmxvY2tzO1xuICAgICAgb3B0cy5ibG9ja3MgPSBPYmplY3QuYXNzaWduKHt9LCBNYXNrZWREYXRlLkdFVF9ERUZBVUxUX0JMT0NLUygpKTsgLy8gYWRqdXN0IHllYXIgYmxvY2tcblxuICAgICAgaWYgKG9wdHMubWluKSBvcHRzLmJsb2Nrcy5ZLmZyb20gPSBvcHRzLm1pbi5nZXRGdWxsWWVhcigpO1xuICAgICAgaWYgKG9wdHMubWF4KSBvcHRzLmJsb2Nrcy5ZLnRvID0gb3B0cy5tYXguZ2V0RnVsbFllYXIoKTtcblxuICAgICAgaWYgKG9wdHMubWluICYmIG9wdHMubWF4ICYmIG9wdHMuYmxvY2tzLlkuZnJvbSA9PT0gb3B0cy5ibG9ja3MuWS50bykge1xuICAgICAgICBvcHRzLmJsb2Nrcy5tLmZyb20gPSBvcHRzLm1pbi5nZXRNb250aCgpICsgMTtcbiAgICAgICAgb3B0cy5ibG9ja3MubS50byA9IG9wdHMubWF4LmdldE1vbnRoKCkgKyAxO1xuXG4gICAgICAgIGlmIChvcHRzLmJsb2Nrcy5tLmZyb20gPT09IG9wdHMuYmxvY2tzLm0udG8pIHtcbiAgICAgICAgICBvcHRzLmJsb2Nrcy5kLmZyb20gPSBvcHRzLm1pbi5nZXREYXRlKCk7XG4gICAgICAgICAgb3B0cy5ibG9ja3MuZC50byA9IG9wdHMubWF4LmdldERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKG9wdHMuYmxvY2tzLCBibG9ja3MpOyAvLyBhZGQgYXV0b2ZpeFxuXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmJsb2NrcykuZm9yRWFjaChmdW5jdGlvbiAoYmspIHtcbiAgICAgICAgdmFyIGIgPSBvcHRzLmJsb2Nrc1tia107XG4gICAgICAgIGlmICghKCdhdXRvZml4JyBpbiBiKSkgYi5hdXRvZml4ID0gb3B0cy5hdXRvZml4O1xuICAgICAgfSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoKSB7XG4gICAgICB2YXIgX2dldDI7XG5cbiAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJkb1ZhbGlkYXRlXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSAmJiAoIXRoaXMuaXNDb21wbGV0ZSB8fCB0aGlzLmlzRGF0ZUV4aXN0KHRoaXMudmFsdWUpICYmIGRhdGUgIT0gbnVsbCAmJiAodGhpcy5taW4gPT0gbnVsbCB8fCB0aGlzLm1pbiA8PSBkYXRlKSAmJiAodGhpcy5tYXggPT0gbnVsbCB8fCBkYXRlIDw9IHRoaXMubWF4KSk7XG4gICAgfVxuICAgIC8qKiBDaGVja3MgaWYgZGF0ZSBpcyBleGlzdHMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRGF0ZUV4aXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGF0ZUV4aXN0KHN0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMucGFyc2Uoc3RyLCB0aGlzKSwgdGhpcykuaW5kZXhPZihzdHIpID49IDA7XG4gICAgfVxuICAgIC8qKiBQYXJzZWQgRGF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZWRWYWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRhdGUpIHtcbiAgICAgIHRoaXMudHlwZWRWYWx1ZSA9IGRhdGU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlID8gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRGF0ZS5wcm90b3R5cGUpLCBcInR5cGVkVmFsdWVcIiwgdGhpcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJ0eXBlZFZhbHVlXCIsIHZhbHVlLCB0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFza2VkRGF0ZTtcbn0oTWFza2VkUGF0dGVybik7XG5NYXNrZWREYXRlLkRFRkFVTFRTID0ge1xuICBwYXR0ZXJuOiAnZHsufWBtey59YFknLFxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgdmFyIGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB2YXIgbW9udGggPSBTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICByZXR1cm4gW2RheSwgbW9udGgsIHllYXJdLmpvaW4oJy4nKTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBfc3RyJHNwbGl0ID0gc3RyLnNwbGl0KCcuJyksXG4gICAgICAgIF9zdHIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3N0ciRzcGxpdCwgMyksXG4gICAgICAgIGRheSA9IF9zdHIkc3BsaXQyWzBdLFxuICAgICAgICBtb250aCA9IF9zdHIkc3BsaXQyWzFdLFxuICAgICAgICB5ZWFyID0gX3N0ciRzcGxpdDJbMl07XG5cbiAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICB9XG59O1xuXG5NYXNrZWREYXRlLkdFVF9ERUZBVUxUX0JMT0NLUyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkOiB7XG4gICAgICBtYXNrOiBNYXNrZWRSYW5nZSxcbiAgICAgIGZyb206IDEsXG4gICAgICB0bzogMzEsXG4gICAgICBtYXhMZW5ndGg6IDJcbiAgICB9LFxuICAgIG06IHtcbiAgICAgIG1hc2s6IE1hc2tlZFJhbmdlLFxuICAgICAgZnJvbTogMSxcbiAgICAgIHRvOiAxMixcbiAgICAgIG1heExlbmd0aDogMlxuICAgIH0sXG4gICAgWToge1xuICAgICAgbWFzazogTWFza2VkUmFuZ2UsXG4gICAgICBmcm9tOiAxOTAwLFxuICAgICAgdG86IDk5OTlcbiAgICB9XG4gIH07XG59O1xuXG5JTWFzay5NYXNrZWREYXRlID0gTWFza2VkRGF0ZTtcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkRGF0ZTtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcblxuLyoqXHJcbiAgR2VuZXJpYyBlbGVtZW50IEFQSSB0byB1c2Ugd2l0aCBtYXNrXHJcbiAgQGludGVyZmFjZVxyXG4qL1xudmFyIE1hc2tFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFza0VsZW1lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tFbGVtZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXNrRWxlbWVudCwgW3tcbiAgICBrZXk6IFwic2VsZWN0XCIsXG5cbiAgICAvKiogU2FmZWx5IHNldHMgZWxlbWVudCBzZWxlY3Rpb24gKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIGVuZCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Vuc2FmZVNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpIHt9XG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50c1wiLFxuXG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKGhhbmRsZXJzKSB7fVxuICAgIC8qKiBTaG91bGQgYmUgb3ZlcnJpZGVuIGluIHN1YmNsYXNzZXMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRFdmVudHMoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdGlvblN0YXJ0XCIsXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiAqL1xuXG4gICAgLyoqICovXG5cbiAgICAvKiogU2FmZWx5IHJldHVybnMgc2VsZWN0aW9uIHN0YXJ0ICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3RhcnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fdW5zYWZlU2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gc3RhcnQgIT0gbnVsbCA/IHN0YXJ0IDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKiBTYWZlbHkgcmV0dXJucyBzZWxlY3Rpb24gZW5kICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25FbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbmQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IHRoaXMuX3Vuc2FmZVNlbGVjdGlvbkVuZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiBlbmQgIT0gbnVsbCA/IGVuZCA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0FjdGl2ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrRWxlbWVudDtcbn0oKTtcbklNYXNrLk1hc2tFbGVtZW50ID0gTWFza0VsZW1lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tFbGVtZW50O1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YgfSBmcm9tICcuLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgTWFza0VsZW1lbnQgZnJvbSAnLi9tYXNrLWVsZW1lbnQuanMnO1xuXG4vKiogQnJpZGdlIGJldHdlZW4gSFRNTEVsZW1lbnQgYW5kIHtAbGluayBNYXNrZWR9ICovXG5cbnZhciBIVE1MTWFza0VsZW1lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrRWxlbWVudCkge1xuICBfaW5oZXJpdHMoSFRNTE1hc2tFbGVtZW50LCBfTWFza0VsZW1lbnQpO1xuXG4gIC8qKiBNYXBwaW5nIGJldHdlZW4gSFRNTEVsZW1lbnQgZXZlbnRzIGFuZCBtYXNrIGludGVybmFsIGV2ZW50cyAqL1xuXG4gIC8qKiBIVE1MRWxlbWVudCB0byB1c2UgbWFzayBvbiAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XHJcbiAgKi9cbiAgZnVuY3Rpb24gSFRNTE1hc2tFbGVtZW50KGlucHV0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxNYXNrRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihIVE1MTWFza0VsZW1lbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgX3RoaXMuX2hhbmRsZXJzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiAqL1xuICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODM5XG5cblxuICBfY3JlYXRlQ2xhc3MoSFRNTE1hc2tFbGVtZW50LCBbe1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0XCIsXG5cbiAgICAvKipcclxuICAgICAgU2V0cyBIVE1MRWxlbWVudCBzZWxlY3Rpb25cclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBIVE1MRWxlbWVudCB2YWx1ZVxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRXZlbnRzXCIsXG5cbiAgICAvKipcclxuICAgICAgQmluZHMgSFRNTEVsZW1lbnQgZXZlbnRzIHRvIG1hc2sgaW50ZXJuYWwgZXZlbnRzXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50cyhoYW5kbGVycykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl90b2dnbGVFdmVudEhhbmRsZXIoSFRNTE1hc2tFbGVtZW50LkVWRU5UU19NQVBbZXZlbnRdLCBoYW5kbGVyc1tldmVudF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBVbmJpbmRzIEhUTUxFbGVtZW50IGV2ZW50cyB0byBtYXNrIGludGVybmFsIGV2ZW50c1xyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2hhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl90b2dnbGVFdmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RvZ2dsZUV2ZW50SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5faGFuZGxlcnNbZXZlbnRdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm9vdEVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LmdldFJvb3ROb2RlID8gdGhpcy5pbnB1dC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBJcyBlbGVtZW50IGluIGZvY3VzXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQWN0aXZlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyRGbG93Rml4TWVcbiAgICAgIHJldHVybiB0aGlzLmlucHV0ID09PSB0aGlzLnJvb3RFbGVtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZXR1cm5zIEhUTUxFbGVtZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uU3RhcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUmV0dXJucyBIVE1MRWxlbWVudCBzZWxlY3Rpb24gZW5kXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91bnNhZmVTZWxlY3Rpb25FbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSFRNTE1hc2tFbGVtZW50O1xufShNYXNrRWxlbWVudCk7XG5IVE1MTWFza0VsZW1lbnQuRVZFTlRTX01BUCA9IHtcbiAgc2VsZWN0aW9uQ2hhbmdlOiAna2V5ZG93bicsXG4gIGlucHV0OiAnaW5wdXQnLFxuICBkcm9wOiAnZHJvcCcsXG4gIGNsaWNrOiAnY2xpY2snLFxuICBmb2N1czogJ2ZvY3VzJyxcbiAgY29tbWl0OiAnYmx1cidcbn07XG5JTWFzay5IVE1MTWFza0VsZW1lbnQgPSBIVE1MTWFza0VsZW1lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhUTUxNYXNrRWxlbWVudDtcbiIsImltcG9ydCB7IGQgYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGUgYXMgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIGYgYXMgX2dldFByb3RvdHlwZU9mIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0ICcuL21hc2stZWxlbWVudC5qcyc7XG5pbXBvcnQgSFRNTE1hc2tFbGVtZW50IGZyb20gJy4vaHRtbC1tYXNrLWVsZW1lbnQuanMnO1xuXG52YXIgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSFRNTE1hc2tFbGVtZW50KSB7XG4gIF9pbmhlcml0cyhIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQsIF9IVE1MTWFza0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQsIFt7XG4gICAga2V5OiBcIl91bnNhZmVTZWxlY3RcIixcblxuICAgIC8qKlxyXG4gICAgICBTZXRzIEhUTUxFbGVtZW50IHNlbGVjdGlvblxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnNhZmVTZWxlY3Qoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLnJvb3RFbGVtZW50LmNyZWF0ZVJhbmdlKSByZXR1cm47XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJvb3RFbGVtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZXRTdGFydCh0aGlzLmlucHV0LmZpcnN0Q2hpbGQgfHwgdGhpcy5pbnB1dCwgc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHRoaXMuaW5wdXQubGFzdENoaWxkIHx8IHRoaXMuaW5wdXQsIGVuZCk7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBIVE1MRWxlbWVudCB2YWx1ZVxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uU3RhcnRcIixcblxuICAgIC8qKlxyXG4gICAgICBSZXR1cm5zIEhUTUxFbGVtZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFJldHVybnMgSFRNTEVsZW1lbnQgc2VsZWN0aW9uIGVuZFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uRW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgdGhpcy5fdW5zYWZlU2VsZWN0aW9uU3RhcnQgKyBTdHJpbmcoc2VsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gdGhpcy5pbnB1dC50ZXh0Q29udGVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmlucHV0LnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudDtcbn0oSFRNTE1hc2tFbGVtZW50KTtcbklNYXNrLkhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudCA9IEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudDtcblxuZXhwb3J0IGRlZmF1bHQgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50O1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMsIERJUkVDVElPTiB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IEFjdGlvbkRldGFpbHMgZnJvbSAnLi4vY29yZS9hY3Rpb24tZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9iYXNlLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrLCB7IG1hc2tlZENsYXNzIH0gZnJvbSAnLi4vbWFza2VkL2ZhY3RvcnkuanMnO1xuaW1wb3J0ICcuLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi4vbWFza2VkL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9yZWdleHAuanMnO1xuaW1wb3J0ICcuLi9tYXNrZWQvcGF0dGVybi5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9yYW5nZS5qcyc7XG5pbXBvcnQgTWFza2VkRGF0ZSBmcm9tICcuLi9tYXNrZWQvZGF0ZS5qcyc7XG5pbXBvcnQgTWFza0VsZW1lbnQgZnJvbSAnLi9tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0IEhUTUxNYXNrRWxlbWVudCBmcm9tICcuL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmltcG9ydCBIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQgZnJvbSAnLi9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuXG4vKiogTGlzdGVucyB0byBlbGVtZW50IGV2ZW50cyBhbmQgY29udHJvbHMgY2hhbmdlcyBiZXR3ZWVuIGVsZW1lbnQgYW5kIHtAbGluayBNYXNrZWR9ICovXG5cbnZhciBJbnB1dE1hc2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgIFZpZXcgZWxlbWVudFxyXG4gICAgQHJlYWRvbmx5XHJcbiAgKi9cblxuICAvKipcclxuICAgIEludGVybmFsIHtAbGluayBNYXNrZWR9IG1vZGVsXHJcbiAgICBAcmVhZG9ubHlcclxuICAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtNYXNrRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsXHJcbiAgICBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICovXG4gIGZ1bmN0aW9uIElucHV0TWFzayhlbCwgb3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dE1hc2spO1xuXG4gICAgdGhpcy5lbCA9IGVsIGluc3RhbmNlb2YgTWFza0VsZW1lbnQgPyBlbCA6IGVsLmlzQ29udGVudEVkaXRhYmxlICYmIGVsLnRhZ05hbWUgIT09ICdJTlBVVCcgJiYgZWwudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyA/IG5ldyBIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQoZWwpIDogbmV3IEhUTUxNYXNrRWxlbWVudChlbCk7XG4gICAgdGhpcy5tYXNrZWQgPSBjcmVhdGVNYXNrKG9wdHMpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgdGhpcy5fdW5tYXNrZWRWYWx1ZSA9ICcnO1xuICAgIHRoaXMuX3NhdmVTZWxlY3Rpb24gPSB0aGlzLl9zYXZlU2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ecm9wID0gdGhpcy5fb25Ecm9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb2N1cyA9IHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWxpZ25DdXJzb3IgPSB0aGlzLmFsaWduQ3Vyc29yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5ID0gdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7IC8vIHJlZnJlc2hcblxuXG4gICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuICAvKiogUmVhZCBvciB1cGRhdGUgbWFzayAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKElucHV0TWFzaywgW3tcbiAgICBrZXk6IFwibWFza0VxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrRXF1YWxzKG1hc2spIHtcbiAgICAgIHJldHVybiBtYXNrID09IG51bGwgfHwgbWFzayA9PT0gdGhpcy5tYXNrZWQubWFzayB8fCBtYXNrID09PSBEYXRlICYmIHRoaXMubWFza2VkIGluc3RhbmNlb2YgTWFza2VkRGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRFdmVudHNcIixcblxuICAgIC8qKlxyXG4gICAgICBTdGFydHMgbGlzdGVuaW5nIHRvIGVsZW1lbnQgZXZlbnRzXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgICAgdGhpcy5lbC5iaW5kRXZlbnRzKHtcbiAgICAgICAgc2VsZWN0aW9uQ2hhbmdlOiB0aGlzLl9zYXZlU2VsZWN0aW9uLFxuICAgICAgICBpbnB1dDogdGhpcy5fb25JbnB1dCxcbiAgICAgICAgZHJvcDogdGhpcy5fb25Ecm9wLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgICAgZm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gICAgICAgIGNvbW1pdDogdGhpcy5fb25DaGFuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgU3RvcHMgbGlzdGVuaW5nIHRvIGVsZW1lbnQgZXZlbnRzXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMuZWwpIHRoaXMuZWwudW5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBGaXJlcyBjdXN0b20gZXZlbnRcclxuICAgICAgQHByb3RlY3RlZFxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmlyZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXJlRXZlbnQoZXYpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZdO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBsLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEN1cnJlbnQgc2VsZWN0aW9uIHN0YXJ0XHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlU2VsZWN0aW9uXCIsXG5cbiAgICAvKipcclxuICAgICAgU3RvcmVzIGN1cnJlbnQgc2VsZWN0aW9uXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlU2VsZWN0aW9uKClcbiAgICAvKiBldiAqL1xuICAgIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRWxlbWVudCB2YWx1ZSB3YXMgY2hhbmdlZCBvdXRzaWRlIG9mIG1hc2suIFN5bmNyb25pemUgbWFzayB1c2luZyBgbWFzay51cGRhdGVWYWx1ZSgpYCB0byB3b3JrIHByb3Blcmx5LicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiB0aGlzLmN1cnNvclBvc1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFN5bmNyb25pemVzIG1vZGVsIHZhbHVlIGZyb20gdmlldyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVmFsdWUoKSB7XG4gICAgICB0aGlzLm1hc2tlZC52YWx1ZSA9IHRoaXMuZWwudmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMubWFza2VkLnZhbHVlO1xuICAgIH1cbiAgICAvKiogU3luY3Jvbml6ZXMgdmlldyBmcm9tIG1vZGVsIHZhbHVlLCBmaXJlcyBjaGFuZ2UgZXZlbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDb250cm9sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2woKSB7XG4gICAgICB2YXIgbmV3VW5tYXNrZWRWYWx1ZSA9IHRoaXMubWFza2VkLnVubWFza2VkVmFsdWU7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hc2tlZC52YWx1ZTtcbiAgICAgIHZhciBpc0NoYW5nZWQgPSB0aGlzLnVubWFza2VkVmFsdWUgIT09IG5ld1VubWFza2VkVmFsdWUgfHwgdGhpcy52YWx1ZSAhPT0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl91bm1hc2tlZFZhbHVlID0gbmV3VW5tYXNrZWRWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5lbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHRoaXMuZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGlmIChpc0NoYW5nZWQpIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudHMoKTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZXMgb3B0aW9ucyB3aXRoIGRlZXAgZXF1YWwgY2hlY2ssIHJlY3JlYXRlcyBAe2xpbmsgTWFza2VkfSBtb2RlbCBpZiBtYXNrIHR5cGUgY2hhbmdlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdHMpIHtcbiAgICAgIHZhciBtYXNrID0gb3B0cy5tYXNrLFxuICAgICAgICAgIHJlc3RPcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdHMsIFtcIm1hc2tcIl0pO1xuXG4gICAgICB2YXIgdXBkYXRlTWFzayA9ICF0aGlzLm1hc2tFcXVhbHMobWFzayk7XG4gICAgICB2YXIgdXBkYXRlT3B0cyA9ICFvYmplY3RJbmNsdWRlcyh0aGlzLm1hc2tlZCwgcmVzdE9wdHMpO1xuICAgICAgaWYgKHVwZGF0ZU1hc2spIHRoaXMubWFzayA9IG1hc2s7XG4gICAgICBpZiAodXBkYXRlT3B0cykgdGhpcy5tYXNrZWQudXBkYXRlT3B0aW9ucyhyZXN0T3B0cyk7XG4gICAgICBpZiAodXBkYXRlTWFzayB8fCB1cGRhdGVPcHRzKSB0aGlzLnVwZGF0ZUNvbnRyb2woKTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZXMgY3Vyc29yICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvclBvcykge1xuICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnNvclBvcyA9IGN1cnNvclBvczsgLy8gYWxzbyBxdWV1ZSBjaGFuZ2UgY3Vyc29yIGZvciBtb2JpbGUgYnJvd3NlcnNcblxuICAgICAgdGhpcy5fZGVsYXlVcGRhdGVDdXJzb3IoY3Vyc29yUG9zKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIERlbGF5cyBjdXJzb3IgdXBkYXRlIHRvIHN1cHBvcnQgbW9iaWxlIGJyb3dzZXJzXHJcbiAgICAgIEBwcml2YXRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlbGF5VXBkYXRlQ3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxheVVwZGF0ZUN1cnNvcihjdXJzb3JQb3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7XG5cbiAgICAgIHRoaXMuX2NoYW5naW5nQ3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuICAgICAgdGhpcy5fY3Vyc29yQ2hhbmdpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5lbCkgcmV0dXJuOyAvLyBpZiB3YXMgZGVzdHJveWVkXG5cbiAgICAgICAgX3RoaXMuY3Vyc29yUG9zID0gX3RoaXMuX2NoYW5naW5nQ3Vyc29yUG9zO1xuXG4gICAgICAgIF90aGlzLl9hYm9ydFVwZGF0ZUN1cnNvcigpO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgRmlyZXMgY3VzdG9tIGV2ZW50c1xyXG4gICAgICBAcHJvdGVjdGVkXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpcmVDaGFuZ2VFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpcmVDaGFuZ2VFdmVudHMoKSB7XG4gICAgICB0aGlzLl9maXJlRXZlbnQoJ2FjY2VwdCcsIHRoaXMuX2lucHV0RXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5tYXNrZWQuaXNDb21wbGV0ZSkgdGhpcy5fZmlyZUV2ZW50KCdjb21wbGV0ZScsIHRoaXMuX2lucHV0RXZlbnQpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQWJvcnRzIGRlbGF5ZWQgY3Vyc29yIHVwZGF0ZVxyXG4gICAgICBAcHJpdmF0ZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hYm9ydFVwZGF0ZUN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWJvcnRVcGRhdGVDdXJzb3IoKSB7XG4gICAgICBpZiAodGhpcy5fY3Vyc29yQ2hhbmdpbmcpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvckNoYW5naW5nKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnNvckNoYW5naW5nO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQWxpZ25zIGN1cnNvciB0byBuZWFyZXN0IGF2YWlsYWJsZSBwb3NpdGlvbiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWxpZ25DdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25DdXJzb3IoKSB7XG4gICAgICB0aGlzLmN1cnNvclBvcyA9IHRoaXMubWFza2VkLm5lYXJlc3RJbnB1dFBvcyh0aGlzLmN1cnNvclBvcywgRElSRUNUSU9OLkxFRlQpO1xuICAgIH1cbiAgICAvKiogQWxpZ25zIGN1cnNvciBvbmx5IGlmIHNlbGVjdGlvbiBpcyBlbXB0eSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWxpZ25DdXJzb3JGcmllbmRseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbkN1cnNvckZyaWVuZGx5KCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuY3Vyc29yUG9zKSByZXR1cm47IC8vIHNraXAgaWYgcmFuZ2UgaXMgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5hbGlnbkN1cnNvcigpO1xuICAgIH1cbiAgICAvKiogQWRkcyBsaXN0ZW5lciBvbiBjdXN0b20gZXZlbnQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldl0pIHRoaXMuX2xpc3RlbmVyc1tldl0gPSBbXTtcblxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2XS5wdXNoKGhhbmRsZXIpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgY3VzdG9tIGV2ZW50IGxpc3RlbmVyICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldl0pIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldl07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaEluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW2V2XS5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICBpZiAoaEluZGV4ID49IDApIHRoaXMuX2xpc3RlbmVyc1tldl0uc3BsaWNlKGhJbmRleCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEhhbmRsZXMgdmlldyBpbnB1dCBldmVudCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uSW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uSW5wdXQoZSkge1xuICAgICAgdGhpcy5faW5wdXRFdmVudCA9IGU7XG5cbiAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7IC8vIGZpeCBzdHJhbmdlIElFIGJlaGF2aW9yXG5cblxuICAgICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24pIHJldHVybiB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBBY3Rpb25EZXRhaWxzKCAvLyBuZXcgc3RhdGVcbiAgICAgIHRoaXMuZWwudmFsdWUsIHRoaXMuY3Vyc29yUG9zLCAvLyBvbGQgc3RhdGVcbiAgICAgIHRoaXMudmFsdWUsIHRoaXMuX3NlbGVjdGlvbik7XG4gICAgICB2YXIgb2xkUmF3VmFsdWUgPSB0aGlzLm1hc2tlZC5yYXdJbnB1dFZhbHVlO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMubWFza2VkLnNwbGljZShkZXRhaWxzLnN0YXJ0Q2hhbmdlUG9zLCBkZXRhaWxzLnJlbW92ZWQubGVuZ3RoLCBkZXRhaWxzLmluc2VydGVkLCBkZXRhaWxzLnJlbW92ZURpcmVjdGlvbikub2Zmc2V0OyAvLyBmb3JjZSBhbGlnbiBpbiByZW1vdmUgZGlyZWN0aW9uIG9ubHkgaWYgbm8gaW5wdXQgY2hhcnMgd2VyZSByZW1vdmVkXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugc3RpbGwgbmVlZCB0byBhbGlnbiB3aXRoIE5PTkUgKHRvIGdldCBvdXQgZnJvbSBmaXhlZCBzeW1ib2xzIGZvciBpbnN0YW5jZSlcblxuICAgICAgdmFyIHJlbW92ZURpcmVjdGlvbiA9IG9sZFJhd1ZhbHVlID09PSB0aGlzLm1hc2tlZC5yYXdJbnB1dFZhbHVlID8gZGV0YWlscy5yZW1vdmVEaXJlY3Rpb24gOiBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHZhciBjdXJzb3JQb3MgPSB0aGlzLm1hc2tlZC5uZWFyZXN0SW5wdXRQb3MoZGV0YWlscy5zdGFydENoYW5nZVBvcyArIG9mZnNldCwgcmVtb3ZlRGlyZWN0aW9uKTtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgdGhpcy51cGRhdGVDdXJzb3IoY3Vyc29yUG9zKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pbnB1dEV2ZW50O1xuICAgIH1cbiAgICAvKiogSGFuZGxlcyB2aWV3IGNoYW5nZSBldmVudCBhbmQgY29tbWl0cyBtb2RlbCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXNrZWQuZG9Db21taXQoKTtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuXG4gICAgICB0aGlzLl9zYXZlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKiBIYW5kbGVzIHZpZXcgZHJvcCBldmVudCwgcHJldmVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uRHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Ecm9wKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIC8qKiBSZXN0b3JlIGxhc3Qgc2VsZWN0aW9uIG9uIGZvY3VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25Gb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Gb2N1cyhldikge1xuICAgICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5KCk7XG4gICAgfVxuICAgIC8qKiBSZXN0b3JlIGxhc3Qgc2VsZWN0aW9uIG9uIGZvY3VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25DbGljayhldikge1xuICAgICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5KCk7XG4gICAgfVxuICAgIC8qKiBVbmJpbmQgdmlldyBldmVudHMgYW5kIHJlbW92ZXMgZWxlbWVudCByZWZlcmVuY2UgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3VuYmluZEV2ZW50cygpOyAvLyAkRmxvd0ZpeE1lIHdoeSBub3QgZG8gc28/XG5cblxuICAgICAgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCA9IDA7IC8vICRGbG93Rml4TWVcblxuICAgICAgZGVsZXRlIHRoaXMuZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hc2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hc2tlZC5tYXNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobWFzaykge1xuICAgICAgaWYgKHRoaXMubWFza0VxdWFscyhtYXNrKSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIShtYXNrIGluc3RhbmNlb2YgSU1hc2suTWFza2VkKSAmJiB0aGlzLm1hc2tlZC5jb25zdHJ1Y3RvciA9PT0gbWFza2VkQ2xhc3MobWFzaykpIHtcbiAgICAgICAgdGhpcy5tYXNrZWQudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgbWFzazogbWFza1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFza2VkID0gY3JlYXRlTWFzayh7XG4gICAgICAgIG1hc2s6IG1hc2tcbiAgICAgIH0pO1xuICAgICAgbWFza2VkLnVubWFza2VkVmFsdWUgPSB0aGlzLm1hc2tlZC51bm1hc2tlZFZhbHVlO1xuICAgICAgdGhpcy5tYXNrZWQgPSBtYXNrZWQ7XG4gICAgfVxuICAgIC8qKiBSYXcgdmFsdWUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHIpIHtcbiAgICAgIHRoaXMubWFza2VkLnZhbHVlID0gc3RyO1xuICAgICAgdGhpcy51cGRhdGVDb250cm9sKCk7XG4gICAgICB0aGlzLmFsaWduQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8qKiBVbm1hc2tlZCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VubWFza2VkVmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHIpIHtcbiAgICAgIHRoaXMubWFza2VkLnVubWFza2VkVmFsdWUgPSBzdHI7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRyb2woKTtcbiAgICAgIHRoaXMuYWxpZ25DdXJzb3IoKTtcbiAgICB9XG4gICAgLyoqIFR5cGVkIHVubWFza2VkIHZhbHVlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWQudHlwZWRWYWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdGhpcy5tYXNrZWQudHlwZWRWYWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgdGhpcy5hbGlnbkN1cnNvcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25TdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvckNoYW5naW5nID8gdGhpcy5fY2hhbmdpbmdDdXJzb3JQb3MgOiB0aGlzLmVsLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICAvKiogQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1cnNvclBvc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvckNoYW5naW5nID8gdGhpcy5fY2hhbmdpbmdDdXJzb3JQb3MgOiB0aGlzLmVsLnNlbGVjdGlvbkVuZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBvcykge1xuICAgICAgaWYgKCF0aGlzLmVsIHx8ICF0aGlzLmVsLmlzQWN0aXZlKSByZXR1cm47XG4gICAgICB0aGlzLmVsLnNlbGVjdChwb3MsIHBvcyk7XG5cbiAgICAgIHRoaXMuX3NhdmVTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5wdXRNYXNrO1xufSgpO1xuSU1hc2suSW5wdXRNYXNrID0gSW5wdXRNYXNrO1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE1hc2s7XG4iLCJpbXBvcnQgJy4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9hY3Rpb24tZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgJy4vbWFza2VkL2Jhc2UuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9yZWdleHAuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9wYXR0ZXJuLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcmFuZ2UuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9kYXRlLmpzJztcbmltcG9ydCAnLi9jb250cm9scy9tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0ICcuL2NvbnRyb2xzL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmltcG9ydCAnLi9jb250cm9scy9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0ICcuL2NvbnRyb2xzL2lucHV0LmpzJztcblxuXG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCAnLi9iYXNlLmpzJztcbmltcG9ydCAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5pbXBvcnQgTWFza2VkUGF0dGVybiBmcm9tICcuL3BhdHRlcm4uanMnO1xuXG4vKiogUGF0dGVybiB3aGljaCB2YWxpZGF0ZXMgZW51bSB2YWx1ZXMgKi9cblxudmFyIE1hc2tlZEVudW0gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWRQYXR0ZXJuKSB7XG4gIF9pbmhlcml0cyhNYXNrZWRFbnVtLCBfTWFza2VkUGF0dGVybik7XG5cbiAgZnVuY3Rpb24gTWFza2VkRW51bSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza2VkRW51bSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZEVudW0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZEVudW0sIFt7XG4gICAga2V5OiBcIl91cGRhdGVcIixcblxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgLy8gVE9ETyB0eXBlXG4gICAgICBpZiAob3B0cy5lbnVtKSBvcHRzLm1hc2sgPSAnKicucmVwZWF0KG9wdHMuZW51bVswXS5sZW5ndGgpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRFbnVtLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBfZ2V0MjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVudW0uc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5pbmRleE9mKF90aGlzLnVubWFza2VkVmFsdWUpID49IDA7XG4gICAgICB9KSAmJiAoX2dldDIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRFbnVtLnByb3RvdHlwZSksIFwiZG9WYWxpZGF0ZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZEVudW07XG59KE1hc2tlZFBhdHRlcm4pO1xuSU1hc2suTWFza2VkRW51bSA9IE1hc2tlZEVudW07XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZEVudW07XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0LCBpIGFzIF9zbGljZWRUb0FycmF5LCBoIGFzIF9zZXQgfSBmcm9tICcuLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IGVzY2FwZVJlZ0V4cCwgRElSRUNUSU9OIH0gZnJvbSAnLi4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgQ2hhbmdlRGV0YWlscyBmcm9tICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcclxuICBOdW1iZXIgbWFza1xyXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgQHBhcmFtIHtzdHJpbmd9IG9wdHMucmFkaXggLSBTaW5nbGUgY2hhclxyXG4gIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRob3VzYW5kc1NlcGFyYXRvciAtIFNpbmdsZSBjaGFyXHJcbiAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBvcHRzLm1hcFRvUmFkaXggLSBBcnJheSBvZiBzaW5nbGUgY2hhcnNcclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5taW5cclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5tYXhcclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5zY2FsZSAtIERpZ2l0cyBhZnRlciBwb2ludFxyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5zaWduZWQgLSBBbGxvdyBuZWdhdGl2ZVxyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5ub3JtYWxpemVaZXJvcyAtIEZsYWcgdG8gcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHplcm9zIGluIHRoZSBlbmQgb2YgZWRpdGluZ1xyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5wYWRGcmFjdGlvbmFsWmVyb3MgLSBGbGFnIHRvIHBhZCB0cmFpbGluZyB6ZXJvcyBhZnRlciBwb2ludCBpbiB0aGUgZW5kIG9mIGVkaXRpbmdcclxuKi9cbnZhciBNYXNrZWROdW1iZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgX2luaGVyaXRzKE1hc2tlZE51bWJlciwgX01hc2tlZCk7XG5cbiAgLyoqIFNpbmdsZSBjaGFyICovXG5cbiAgLyoqIFNpbmdsZSBjaGFyICovXG5cbiAgLyoqIEFycmF5IG9mIHNpbmdsZSBjaGFycyAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiBEaWdpdHMgYWZ0ZXIgcG9pbnQgKi9cblxuICAvKiogKi9cblxuICAvKiogRmxhZyB0byByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgLyoqIEZsYWcgdG8gcGFkIHRyYWlsaW5nIHplcm9zIGFmdGVyIHBvaW50IGluIHRoZSBlbmQgb2YgZWRpdGluZyAqL1xuICBmdW5jdGlvbiBNYXNrZWROdW1iZXIob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWROdW1iZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkTnVtYmVyLkRFRkFVTFRTLCB7fSwgb3B0cykpKTtcbiAgfVxuICAvKipcclxuICAgIEBvdmVycmlkZVxyXG4gICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkTnVtYmVyLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICB0aGlzLl91cGRhdGVSZWdFeHBzKCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVJlZ0V4cHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJlZ0V4cHMoKSB7XG4gICAgICAvLyB1c2UgZGlmZmVyZW50IHJlZ2V4cCB0byBwcm9jZXNzIHVzZXIgaW5wdXQgKG1vcmUgc3RyaWN0LCBpbnB1dCBzdWZmaXgpIGFuZCB0YWlsIHNoaWZ0aW5nXG4gICAgICB2YXIgc3RhcnQgPSAnXicgKyAodGhpcy5hbGxvd05lZ2F0aXZlID8gJ1srfFxcXFwtXT8nIDogJycpO1xuICAgICAgdmFyIG1pZElucHV0ID0gJygwfChbMS05XStcXFxcZCopKT8nO1xuICAgICAgdmFyIG1pZCA9ICdcXFxcZConO1xuICAgICAgdmFyIGVuZCA9ICh0aGlzLnNjYWxlID8gJygnICsgZXNjYXBlUmVnRXhwKHRoaXMucmFkaXgpICsgJ1xcXFxkezAsJyArIHRoaXMuc2NhbGUgKyAnfSk/JyA6ICcnKSArICckJztcbiAgICAgIHRoaXMuX251bWJlclJlZ0V4cElucHV0ID0gbmV3IFJlZ0V4cChzdGFydCArIG1pZElucHV0ICsgZW5kKTtcbiAgICAgIHRoaXMuX251bWJlclJlZ0V4cCA9IG5ldyBSZWdFeHAoc3RhcnQgKyBtaWQgKyBlbmQpO1xuICAgICAgdGhpcy5fbWFwVG9SYWRpeFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1snICsgdGhpcy5tYXBUb1JhZGl4Lm1hcChlc2NhcGVSZWdFeHApLmpvaW4oJycpICsgJ10nLCAnZycpO1xuICAgICAgdGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yUmVnRXhwID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGhpcy50aG91c2FuZHNTZXBhcmF0b3IpLCAnZycpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLl90aG91c2FuZHNTZXBhcmF0b3JSZWdFeHAsICcnKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkge1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkwMTEwMi9ob3ctdG8tcHJpbnQtYS1udW1iZXItd2l0aC1jb21tYXMtYXMtdGhvdXNhbmRzLXNlcGFyYXRvcnMtaW4tamF2YXNjcmlwdFxuICAgICAgdmFyIHBhcnRzID0gdmFsdWUuc3BsaXQodGhpcy5yYWRpeCk7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yKTtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMucmFkaXgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9QcmVwYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvUHJlcGFyZShzdHIpIHtcbiAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcImRvUHJlcGFyZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXMsIHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnMoc3RyLnJlcGxhY2UodGhpcy5fbWFwVG9SYWRpeFJlZ0V4cCwgdGhpcy5yYWRpeCkpXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXBhcmF0b3JzQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NlcGFyYXRvcnNDb3VudCh0bykge1xuICAgICAgdmFyIGV4dGVuZE9uU2VwYXJhdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCB0bzsgKytwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlLmluZGV4T2YodGhpcy50aG91c2FuZHNTZXBhcmF0b3IsIHBvcykgPT09IHBvcykge1xuICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgaWYgKGV4dGVuZE9uU2VwYXJhdG9ycykgdG8gKz0gdGhpcy50aG91c2FuZHNTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXBhcmF0b3JzQ291bnRGcm9tU2xpY2UoKSB7XG4gICAgICB2YXIgc2xpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuX3ZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcGFyYXRvcnNDb3VudCh0aGlzLl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHNsaWNlKS5sZW5ndGgsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgX3RoaXMkX2FkanVzdFJhbmdlV2l0ID0gdGhpcy5fYWRqdXN0UmFuZ2VXaXRoU2VwYXJhdG9ycyhmcm9tUG9zLCB0b1Bvcyk7XG5cbiAgICAgIHZhciBfdGhpcyRfYWRqdXN0UmFuZ2VXaXQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2FkanVzdFJhbmdlV2l0LCAyKTtcblxuICAgICAgZnJvbVBvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDJbMF07XG4gICAgICB0b1BvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDJbMV07XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyhfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgXCJleHRyYWN0SW5wdXRcIiwgdGhpcykuY2FsbCh0aGlzLCBmcm9tUG9zLCB0b1BvcywgZmxhZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRDaGFyUmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRDaGFyUmF3KGNoKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKCF0aGlzLnRob3VzYW5kc1NlcGFyYXRvcikgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcIl9hcHBlbmRDaGFyUmF3XCIsIHRoaXMpLmNhbGwodGhpcywgY2gsIGZsYWdzKTtcbiAgICAgIHZhciBwcmV2QmVmb3JlVGFpbFZhbHVlID0gZmxhZ3MudGFpbCAmJiBmbGFncy5fYmVmb3JlVGFpbFN0YXRlID8gZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZS5fdmFsdWUgOiB0aGlzLl92YWx1ZTtcblxuICAgICAgdmFyIHByZXZCZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlKHByZXZCZWZvcmVUYWlsVmFsdWUpO1xuXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnModGhpcy52YWx1ZSk7XG5cbiAgICAgIHZhciBhcHBlbmREZXRhaWxzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwiX2FwcGVuZENoYXJSYXdcIiwgdGhpcykuY2FsbCh0aGlzLCBjaCwgZmxhZ3MpO1xuXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2luc2VydFRob3VzYW5kc1NlcGFyYXRvcnModGhpcy5fdmFsdWUpO1xuICAgICAgdmFyIGJlZm9yZVRhaWxWYWx1ZSA9IGZsYWdzLnRhaWwgJiYgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSA/IGZsYWdzLl9iZWZvcmVUYWlsU3RhdGUuX3ZhbHVlIDogdGhpcy5fdmFsdWU7XG5cbiAgICAgIHZhciBiZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlKGJlZm9yZVRhaWxWYWx1ZSk7XG5cbiAgICAgIGFwcGVuZERldGFpbHMudGFpbFNoaWZ0ICs9IChiZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50IC0gcHJldkJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQpICogdGhpcy50aG91c2FuZHNTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgYXBwZW5kRGV0YWlscy5za2lwID0gIWFwcGVuZERldGFpbHMucmF3SW5zZXJ0ZWQgJiYgY2ggPT09IHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yO1xuICAgICAgcmV0dXJuIGFwcGVuZERldGFpbHM7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTZXBhcmF0b3JBcm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRTZXBhcmF0b3JBcm91bmQocG9zKSB7XG4gICAgICBpZiAodGhpcy50aG91c2FuZHNTZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHNlYXJjaEZyb20gPSBwb3MgLSB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgc2VwYXJhdG9yUG9zID0gdGhpcy52YWx1ZS5pbmRleE9mKHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLCBzZWFyY2hGcm9tKTtcbiAgICAgICAgaWYgKHNlcGFyYXRvclBvcyA8PSBwb3MpIHJldHVybiBzZXBhcmF0b3JQb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkanVzdFJhbmdlV2l0aFNlcGFyYXRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdFJhbmdlV2l0aFNlcGFyYXRvcnMoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBzZXBhcmF0b3JBcm91bmRGcm9tUG9zID0gdGhpcy5fZmluZFNlcGFyYXRvckFyb3VuZChmcm9tKTtcblxuICAgICAgaWYgKHNlcGFyYXRvckFyb3VuZEZyb21Qb3MgPj0gMCkgZnJvbSA9IHNlcGFyYXRvckFyb3VuZEZyb21Qb3M7XG5cbiAgICAgIHZhciBzZXBhcmF0b3JBcm91bmRUb1BvcyA9IHRoaXMuX2ZpbmRTZXBhcmF0b3JBcm91bmQodG8pO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yQXJvdW5kVG9Qb3MgPj0gMCkgdG8gPSBzZXBhcmF0b3JBcm91bmRUb1BvcyArIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgIHJldHVybiBbZnJvbSwgdG9dO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcblxuICAgICAgdmFyIF90aGlzJF9hZGp1c3RSYW5nZVdpdDMgPSB0aGlzLl9hZGp1c3RSYW5nZVdpdGhTZXBhcmF0b3JzKGZyb21Qb3MsIHRvUG9zKTtcblxuICAgICAgdmFyIF90aGlzJF9hZGp1c3RSYW5nZVdpdDQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfYWRqdXN0UmFuZ2VXaXQzLCAyKTtcblxuICAgICAgZnJvbVBvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDRbMF07XG4gICAgICB0b1BvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDRbMV07XG4gICAgICB2YXIgdmFsdWVCZWZvcmVQb3MgPSB0aGlzLnZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpO1xuICAgICAgdmFyIHZhbHVlQWZ0ZXJQb3MgPSB0aGlzLnZhbHVlLnNsaWNlKHRvUG9zKTtcblxuICAgICAgdmFyIHByZXZCZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50KHZhbHVlQmVmb3JlUG9zLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5faW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHZhbHVlQmVmb3JlUG9zICsgdmFsdWVBZnRlclBvcykpO1xuXG4gICAgICB2YXIgYmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCA9IHRoaXMuX3NlcGFyYXRvcnNDb3VudEZyb21TbGljZSh2YWx1ZUJlZm9yZVBvcyk7XG5cbiAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscyh7XG4gICAgICAgIHRhaWxTaGlmdDogKGJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQgLSBwcmV2QmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCkgKiB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmVhcmVzdElucHV0UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3RJbnB1dFBvcyhjdXJzb3JQb3MsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKCF0aGlzLnRob3VzYW5kc1NlcGFyYXRvcikgcmV0dXJuIGN1cnNvclBvcztcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTk9ORTpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQXRMZWZ0UG9zID0gdGhpcy5fZmluZFNlcGFyYXRvckFyb3VuZChjdXJzb3JQb3MgLSAxKTtcblxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvckF0TGVmdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JBdExlZnRFbmRQb3MgPSBzZXBhcmF0b3JBdExlZnRQb3MgKyB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnNvclBvcyA8IHNlcGFyYXRvckF0TGVmdEVuZFBvcyB8fCB0aGlzLnZhbHVlLmxlbmd0aCA8PSBzZXBhcmF0b3JBdExlZnRFbmRQb3MgfHwgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfTEVGVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXBhcmF0b3JBdExlZnRQb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9SSUdIVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQXRSaWdodFBvcyA9IHRoaXMuX2ZpbmRTZXBhcmF0b3JBcm91bmQoY3Vyc29yUG9zKTtcblxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvckF0UmlnaHRQb3MgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdG9yQXRSaWdodFBvcyArIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJzb3JQb3M7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgIHZhciByZWdleHAgPSBmbGFncy5pbnB1dCA/IHRoaXMuX251bWJlclJlZ0V4cElucHV0IDogdGhpcy5fbnVtYmVyUmVnRXhwOyAvLyB2YWxpZGF0ZSBhcyBzdHJpbmdcblxuICAgICAgdmFyIHZhbGlkID0gcmVnZXhwLnRlc3QodGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLnZhbHVlKSk7XG5cbiAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAvLyB2YWxpZGF0ZSBhcyBudW1iZXJcbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubnVtYmVyO1xuICAgICAgICB2YWxpZCA9IHZhbGlkICYmICFpc05hTihudW1iZXIpICYmICggLy8gY2hlY2sgbWluIGJvdW5kIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgdGhpcy5taW4gPT0gbnVsbCB8fCB0aGlzLm1pbiA+PSAwIHx8IHRoaXMubWluIDw9IHRoaXMubnVtYmVyKSAmJiAoIC8vIGNoZWNrIG1heCBib3VuZCBmb3IgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgIHRoaXMubWF4ID09IG51bGwgfHwgdGhpcy5tYXggPD0gMCB8fCB0aGlzLm51bWJlciA8PSB0aGlzLm1heCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWxpZCAmJiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgXCJkb1ZhbGlkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9Db21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Db21taXQoKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5udW1iZXI7XG4gICAgICAgIHZhciB2YWxpZG51bSA9IG51bWJlcjsgLy8gY2hlY2sgYm91bmRzXG5cbiAgICAgICAgaWYgKHRoaXMubWluICE9IG51bGwpIHZhbGlkbnVtID0gTWF0aC5tYXgodmFsaWRudW0sIHRoaXMubWluKTtcbiAgICAgICAgaWYgKHRoaXMubWF4ICE9IG51bGwpIHZhbGlkbnVtID0gTWF0aC5taW4odmFsaWRudW0sIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKHZhbGlkbnVtICE9PSBudW1iZXIpIHRoaXMudW5tYXNrZWRWYWx1ZSA9IFN0cmluZyh2YWxpZG51bSk7XG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemVaZXJvcykgZm9ybWF0dGVkID0gdGhpcy5fbm9ybWFsaXplWmVyb3MoZm9ybWF0dGVkKTtcbiAgICAgICAgaWYgKHRoaXMucGFkRnJhY3Rpb25hbFplcm9zKSBmb3JtYXR0ZWQgPSB0aGlzLl9wYWRGcmFjdGlvbmFsWmVyb3MoZm9ybWF0dGVkKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtYXR0ZWQ7XG4gICAgICB9XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcImRvQ29tbWl0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX25vcm1hbGl6ZVplcm9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3JtYWxpemVaZXJvcyh2YWx1ZSkge1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkuc3BsaXQodGhpcy5yYWRpeCk7IC8vIHJlbW92ZSBsZWFkaW5nIHplcm9zXG5cblxuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC9eKFxcRCopKDAqKShcXGQqKS8sIGZ1bmN0aW9uIChtYXRjaCwgc2lnbiwgemVyb3MsIG51bSkge1xuICAgICAgICByZXR1cm4gc2lnbiArIG51bTtcbiAgICAgIH0pOyAvLyBhZGQgbGVhZGluZyB6ZXJvXG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggJiYgIS9cXGQkLy50ZXN0KHBhcnRzWzBdKSkgcGFydHNbMF0gPSBwYXJ0c1swXSArICcwJztcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS5yZXBsYWNlKC8wKiQvLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvc1xuXG4gICAgICAgIGlmICghcGFydHNbMV0ubGVuZ3RoKSBwYXJ0cy5sZW5ndGggPSAxOyAvLyByZW1vdmUgZnJhY3Rpb25hbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyhwYXJ0cy5qb2luKHRoaXMucmFkaXgpKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFkRnJhY3Rpb25hbFplcm9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWRGcmFjdGlvbmFsWmVyb3ModmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLnNwbGl0KHRoaXMucmFkaXgpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHBhcnRzLnB1c2goJycpO1xuICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS5wYWRFbmQodGhpcy5zY2FsZSwgJzAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMucmFkaXgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnModGhpcy5fbm9ybWFsaXplWmVyb3ModGhpcy52YWx1ZSkpLnJlcGxhY2UodGhpcy5yYWRpeCwgJy4nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHVubWFza2VkVmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcInVubWFza2VkVmFsdWVcIiwgdW5tYXNrZWRWYWx1ZS5yZXBsYWNlKCcuJywgdGhpcy5yYWRpeCksIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnVubWFza2VkVmFsdWUpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobikge1xuICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwidW5tYXNrZWRWYWx1ZVwiLCBTdHJpbmcobiksIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKiogUGFyc2VkIE51bWJlciAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtYmVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlZFZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobnVtYmVyKSB7XG4gICAgICB0aGlzLnR5cGVkVmFsdWUgPSBudW1iZXI7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBJcyBuZWdhdGl2ZSBhbGxvd2VkXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFsbG93TmVnYXRpdmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25lZCB8fCB0aGlzLm1pbiAhPSBudWxsICYmIHRoaXMubWluIDwgMCB8fCB0aGlzLm1heCAhPSBudWxsICYmIHRoaXMubWF4IDwgMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFza2VkTnVtYmVyO1xufShNYXNrZWQpO1xuTWFza2VkTnVtYmVyLkRFRkFVTFRTID0ge1xuICByYWRpeDogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcnLFxuICBtYXBUb1JhZGl4OiBbJy4nXSxcbiAgc2NhbGU6IDIsXG4gIHNpZ25lZDogZmFsc2UsXG4gIG5vcm1hbGl6ZVplcm9zOiB0cnVlLFxuICBwYWRGcmFjdGlvbmFsWmVyb3M6IGZhbHNlXG59O1xuSU1hc2suTWFza2VkTnVtYmVyID0gTWFza2VkTnVtYmVyO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWROdW1iZXI7XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKiogTWFza2luZyBieSBjdXN0b20gRnVuY3Rpb24gKi9cblxudmFyIE1hc2tlZEZ1bmN0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkKSB7XG4gIF9pbmhlcml0cyhNYXNrZWRGdW5jdGlvbiwgX01hc2tlZCk7XG5cbiAgZnVuY3Rpb24gTWFza2VkRnVuY3Rpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZEZ1bmN0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFza2VkRnVuY3Rpb24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZEZ1bmN0aW9uLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLm1hc2spIG9wdHMudmFsaWRhdGUgPSBvcHRzLm1hc2s7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZEZ1bmN0aW9uLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWRGdW5jdGlvbjtcbn0oTWFza2VkKTtcbklNYXNrLk1hc2tlZEZ1bmN0aW9uID0gTWFza2VkRnVuY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZEZ1bmN0aW9uO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCwgaCBhcyBfc2V0LCBjIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgTWFza2VkIGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgY3JlYXRlTWFzayBmcm9tICcuL2ZhY3RvcnkuanMnO1xuXG4vKiogRHluYW1pYyBtYXNrIGZvciBjaG9vc2luZyBhcHJvcHJpYXRlIG1hc2sgaW4gcnVuLXRpbWUgKi9cbnZhciBNYXNrZWREeW5hbWljID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkKSB7XG4gIF9pbmhlcml0cyhNYXNrZWREeW5hbWljLCBfTWFza2VkKTtcblxuICAvKiogQ3VycmVudGx5IGNob3NlbiBtYXNrICovXG5cbiAgLyoqIENvbXBsaWxlZCB7QGxpbmsgTWFza2VkfSBvcHRpb25zICovXG5cbiAgLyoqIENob29zZXMge0BsaW5rIE1hc2tlZH0gZGVwZW5kaW5nIG9uIGlucHV0IHZhbHVlICovXG5cbiAgLyoqXHJcbiAgICBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICovXG4gIGZ1bmN0aW9uIE1hc2tlZER5bmFtaWMob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWREeW5hbWljKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkRHluYW1pYy5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gICAgX3RoaXMuY3VycmVudE1hc2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgIEBvdmVycmlkZVxyXG4gICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkRHluYW1pYywgW3tcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgIGlmICgnbWFzaycgaW4gb3B0cykge1xuICAgICAgICAvLyBtYXNrIGNvdWxkIGJlIHRvdGFsbHkgZHluYW1pYyB3aXRoIG9ubHkgYGRpc3BhdGNoYCBvcHRpb25cbiAgICAgICAgdGhpcy5jb21waWxlZE1hc2tzID0gQXJyYXkuaXNBcnJheShvcHRzLm1hc2spID8gb3B0cy5tYXNrLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVNYXNrKG0pO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZENoYXJSYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZENoYXJSYXcoKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuX2FwcGx5RGlzcGF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHtcbiAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRNYXNrO1xuXG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKChfdGhpcyRjdXJyZW50TWFzayA9IHRoaXMuY3VycmVudE1hc2spLl9hcHBlbmRDaGFyLmFwcGx5KF90aGlzJGN1cnJlbnRNYXNrLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseURpc3BhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseURpc3BhdGNoKCkge1xuICAgICAgdmFyIGFwcGVuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcHJldlZhbHVlQmVmb3JlVGFpbCA9IGZsYWdzLnRhaWwgJiYgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSAhPSBudWxsID8gZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZS5fdmFsdWUgOiB0aGlzLnZhbHVlO1xuICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLnJhd0lucHV0VmFsdWU7XG4gICAgICB2YXIgaW5zZXJ0VmFsdWUgPSBmbGFncy50YWlsICYmIGZsYWdzLl9iZWZvcmVUYWlsU3RhdGUgIT0gbnVsbCA/IC8vICRGbG93Rml4TWUgLSB0aXJlZCB0byBmaWdodCB3aXRoIHR5cGUgc3lzdGVtXG4gICAgICBmbGFncy5fYmVmb3JlVGFpbFN0YXRlLl9yYXdJbnB1dFZhbHVlIDogaW5wdXRWYWx1ZTtcbiAgICAgIHZhciB0YWlsVmFsdWUgPSBpbnB1dFZhbHVlLnNsaWNlKGluc2VydFZhbHVlLmxlbmd0aCk7XG4gICAgICB2YXIgcHJldk1hc2sgPSB0aGlzLmN1cnJlbnRNYXNrO1xuICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdmFyIHByZXZNYXNrU3RhdGUgPSBwcmV2TWFzayAmJiBwcmV2TWFzay5zdGF0ZTsgLy8gY2xvbmUgZmxhZ3MgdG8gcHJldmVudCBvdmVyd3JpdGluZyBgX2JlZm9yZVRhaWxTdGF0ZWBcblxuICAgICAgdGhpcy5jdXJyZW50TWFzayA9IHRoaXMuZG9EaXNwYXRjaChhcHBlbmRlZCwgT2JqZWN0LmFzc2lnbih7fSwgZmxhZ3MpKTsgLy8gcmVzdG9yZSBzdGF0ZSBhZnRlciBkaXNwYXRjaFxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWFzayAhPT0gcHJldk1hc2spIHtcbiAgICAgICAgICAvLyBpZiBtYXNrIGNoYW5nZWQgcmVhcHBseSBpbnB1dFxuICAgICAgICAgIHRoaXMuY3VycmVudE1hc2sucmVzZXQoKTsgLy8gJEZsb3dGaXhNZSAtIGl0J3Mgb2ssIHdlIGRvbid0IGNoYW5nZSBjdXJyZW50IG1hc2sgYWJvdmVcblxuICAgICAgICAgIHZhciBkID0gdGhpcy5jdXJyZW50TWFzay5hcHBlbmQoaW5zZXJ0VmFsdWUsIHtcbiAgICAgICAgICAgIHJhdzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRldGFpbHMudGFpbFNoaWZ0ID0gZC5pbnNlcnRlZC5sZW5ndGggLSBwcmV2VmFsdWVCZWZvcmVUYWlsLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0YWlsVmFsdWUpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBpdCdzIG9rLCB3ZSBkb24ndCBjaGFuZ2UgY3VycmVudCBtYXNrIGFib3ZlXG4gICAgICAgICAgICBkZXRhaWxzLnRhaWxTaGlmdCArPSB0aGlzLmN1cnJlbnRNYXNrLmFwcGVuZCh0YWlsVmFsdWUsIHtcbiAgICAgICAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICAgICAgICB0YWlsOiB0cnVlXG4gICAgICAgICAgICB9KS50YWlsU2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpc3BhdGNoIGNhbiBkbyBzb21ldGhpbmcgYmFkIHdpdGggc3RhdGUsIHNvXG4gICAgICAgICAgLy8gcmVzdG9yZSBwcmV2IG1hc2sgc3RhdGVcbiAgICAgICAgICB0aGlzLmN1cnJlbnRNYXNrLnN0YXRlID0gcHJldk1hc2tTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcigpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5fYXBwbHlEaXNwYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSh0aGlzLmN1cnJlbnRNYXNrLl9hcHBlbmRQbGFjZWhvbGRlcigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0Rpc3BhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvRGlzcGF0Y2goYXBwZW5kZWQpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChhcHBlbmRlZCwgdGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF9nZXQyLCBfdGhpcyRjdXJyZW50TWFzazI7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImRvVmFsaWRhdGVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpICYmICghdGhpcy5jdXJyZW50TWFzayB8fCAoX3RoaXMkY3VycmVudE1hc2syID0gdGhpcy5jdXJyZW50TWFzaykuZG9WYWxpZGF0ZS5hcHBseShfdGhpcyRjdXJyZW50TWFzazIsIGFyZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHRoaXMuY3VycmVudE1hc2sucmVzZXQoKTtcbiAgICAgIHRoaXMuY29tcGlsZWRNYXNrcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQ2hhbmdlRGV0YWlscygpO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICB2YXIgX3RoaXMkY3VycmVudE1hc2szO1xuXG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKChfdGhpcyRjdXJyZW50TWFzazMgPSB0aGlzLmN1cnJlbnRNYXNrKS5yZW1vdmUuYXBwbHkoX3RoaXMkY3VycmVudE1hc2szLCBhcmd1bWVudHMpKSAvLyB1cGRhdGUgd2l0aCBkaXNwYXRjaFxuICAgICAgICAuYWdncmVnYXRlKHRoaXMuX2FwcGx5RGlzcGF0Y2goKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0SW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXMkY3VycmVudE1hc2s0O1xuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IChfdGhpcyRjdXJyZW50TWFzazQgPSB0aGlzLmN1cnJlbnRNYXNrKS5leHRyYWN0SW5wdXQuYXBwbHkoX3RoaXMkY3VycmVudE1hc2s0LCBhcmd1bWVudHMpIDogJyc7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0VGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0VGFpbCgpIHtcbiAgICAgIHZhciBfdGhpcyRjdXJyZW50TWFzazUsIF9nZXQzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IChfdGhpcyRjdXJyZW50TWFzazUgPSB0aGlzLmN1cnJlbnRNYXNrKS5leHRyYWN0VGFpbC5hcHBseShfdGhpcyRjdXJyZW50TWFzazUsIGFyZ3MpIDogKF9nZXQzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImV4dHJhY3RUYWlsXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQzLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvQ29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ29tbWl0KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHRoaXMuY3VycmVudE1hc2suZG9Db21taXQoKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImRvQ29tbWl0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKCkge1xuICAgICAgdmFyIF90aGlzJGN1cnJlbnRNYXNrNiwgX2dldDQ7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNYXNrID8gKF90aGlzJGN1cnJlbnRNYXNrNiA9IHRoaXMuY3VycmVudE1hc2spLm5lYXJlc3RJbnB1dFBvcy5hcHBseShfdGhpcyRjdXJyZW50TWFzazYsIGFyZ3MpIDogKF9nZXQ0ID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcIm5lYXJlc3RJbnB1dFBvc1wiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0NCwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IHRoaXMuY3VycmVudE1hc2sudmFsdWUgOiAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBfc2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLnVubWFza2VkVmFsdWUgOiAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHVubWFza2VkVmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJ1bm1hc2tlZFZhbHVlXCIsIHVubWFza2VkVmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLnR5cGVkVmFsdWUgOiAnJztcbiAgICB9IC8vIHByb2JhYmx5IHR5cGVkVmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggZHluYW1pY1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIHVubWFza2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAvLyBkb3VibGUgY2hlY2sgaXRcblxuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWFzay50eXBlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHVubWFza2VkVmFsdWUgPSB0aGlzLmN1cnJlbnRNYXNrLnVubWFza2VkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5tYXNrZWRWYWx1ZSA9IHVubWFza2VkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0NvbXBsZXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmN1cnJlbnRNYXNrICYmIHRoaXMuY3VycmVudE1hc2suaXNDb21wbGV0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksIFwic3RhdGVcIiwgdGhpcyksIHtcbiAgICAgICAgX3Jhd0lucHV0VmFsdWU6IHRoaXMucmF3SW5wdXRWYWx1ZSxcbiAgICAgICAgY29tcGlsZWRNYXNrczogdGhpcy5jb21waWxlZE1hc2tzLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLnN0YXRlO1xuICAgICAgICB9KSxcbiAgICAgICAgY3VycmVudE1hc2tSZWY6IHRoaXMuY3VycmVudE1hc2ssXG4gICAgICAgIGN1cnJlbnRNYXNrOiB0aGlzLmN1cnJlbnRNYXNrICYmIHRoaXMuY3VycmVudE1hc2suc3RhdGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHZhciBjb21waWxlZE1hc2tzID0gc3RhdGUuY29tcGlsZWRNYXNrcyxcbiAgICAgICAgICBjdXJyZW50TWFza1JlZiA9IHN0YXRlLmN1cnJlbnRNYXNrUmVmLFxuICAgICAgICAgIGN1cnJlbnRNYXNrID0gc3RhdGUuY3VycmVudE1hc2ssXG4gICAgICAgICAgbWFza2VkU3RhdGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3RhdGUsIFtcImNvbXBpbGVkTWFza3NcIiwgXCJjdXJyZW50TWFza1JlZlwiLCBcImN1cnJlbnRNYXNrXCJdKTtcblxuICAgICAgdGhpcy5jb21waWxlZE1hc2tzLmZvckVhY2goZnVuY3Rpb24gKG0sIG1pKSB7XG4gICAgICAgIHJldHVybiBtLnN0YXRlID0gY29tcGlsZWRNYXNrc1ttaV07XG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnRNYXNrUmVmICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWFzayA9IGN1cnJlbnRNYXNrUmVmO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXNrLnN0YXRlID0gY3VycmVudE1hc2s7XG4gICAgICB9XG5cbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJzdGF0ZVwiLCBtYXNrZWRTdGF0ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJ3cml0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLm92ZXJ3cml0ZSA6IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJvdmVyd3JpdGVcIiwgdGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvdmVyd3JpdGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignXCJvdmVyd3JpdGVcIiBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiBkeW5hbWljIG1hc2ssIHVzZSB0aGlzIG9wdGlvbiBpbiBzaWJsaW5ncycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWREeW5hbWljO1xufShNYXNrZWQpO1xuTWFza2VkRHluYW1pYy5ERUZBVUxUUyA9IHtcbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFwcGVuZGVkLCBtYXNrZWQsIGZsYWdzKSB7XG4gICAgaWYgKCFtYXNrZWQuY29tcGlsZWRNYXNrcy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IG1hc2tlZC5yYXdJbnB1dFZhbHVlOyAvLyBzaW11bGF0ZSBpbnB1dFxuXG4gICAgdmFyIGlucHV0cyA9IG1hc2tlZC5jb21waWxlZE1hc2tzLm1hcChmdW5jdGlvbiAobSwgaW5kZXgpIHtcbiAgICAgIG0ucmVzZXQoKTtcbiAgICAgIG0uYXBwZW5kKGlucHV0VmFsdWUsIHtcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG0uYXBwZW5kKGFwcGVuZGVkLCBmbGFncyk7XG4gICAgICB2YXIgd2VpZ2h0ID0gbS5yYXdJbnB1dFZhbHVlLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfSk7IC8vIHBvcCBtYXNrcyB3aXRoIGxvbmdlciB2YWx1ZXMgZmlyc3RcblxuICAgIGlucHV0cy5zb3J0KGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgIHJldHVybiBpMi53ZWlnaHQgLSBpMS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hc2tlZC5jb21waWxlZE1hc2tzW2lucHV0c1swXS5pbmRleF07XG4gIH1cbn07XG5JTWFzay5NYXNrZWREeW5hbWljID0gTWFza2VkRHluYW1pYztcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkRHluYW1pYztcbiIsImltcG9ydCAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrIGZyb20gJy4vZmFjdG9yeS5qcyc7XG5cbi8qKiBNYXNrIHBpcGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyAqL1xuXG52YXIgUElQRV9UWVBFID0ge1xuICBNQVNLRUQ6ICd2YWx1ZScsXG4gIFVOTUFTS0VEOiAndW5tYXNrZWRWYWx1ZScsXG4gIFRZUEVEOiAndHlwZWRWYWx1ZSdcbn07XG4vKiogQ3JlYXRlcyBuZXcgcGlwZSBmdW5jdGlvbiBkZXBlbmRpbmcgb24gbWFzayB0eXBlLCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG9wdGlvbnMgKi9cblxuZnVuY3Rpb24gY3JlYXRlUGlwZShtYXNrKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBQSVBFX1RZUEUuTUFTS0VEO1xuICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFBJUEVfVFlQRS5NQVNLRUQ7XG4gIHZhciBtYXNrZWQgPSBjcmVhdGVNYXNrKG1hc2spO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG1hc2tlZC5ydW5Jc29sYXRlZChmdW5jdGlvbiAobSkge1xuICAgICAgbVtmcm9tXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1bdG9dO1xuICAgIH0pO1xuICB9O1xufVxuLyoqIFBpcGVzIHZhbHVlIHRocm91Z2ggbWFzayBkZXBlbmRpbmcgb24gbWFzayB0eXBlLCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG9wdGlvbnMgKi9cblxuZnVuY3Rpb24gcGlwZSh2YWx1ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGlwZUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBpcGVBcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQaXBlLmFwcGx5KHZvaWQgMCwgcGlwZUFyZ3MpKHZhbHVlKTtcbn1cbklNYXNrLlBJUEVfVFlQRSA9IFBJUEVfVFlQRTtcbklNYXNrLmNyZWF0ZVBpcGUgPSBjcmVhdGVQaXBlO1xuSU1hc2sucGlwZSA9IHBpcGU7XG5cbmV4cG9ydCB7IFBJUEVfVFlQRSwgY3JlYXRlUGlwZSwgcGlwZSB9O1xuIiwiaW1wb3J0ICcuL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvYWN0aW9uLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvaG9sZGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkIH0gZnJvbSAnLi9tYXNrZWQvYmFzZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZU1hc2sgfSBmcm9tICcuL21hc2tlZC9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRSZWdFeHAgfSBmcm9tICcuL21hc2tlZC9yZWdleHAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRQYXR0ZXJuIH0gZnJvbSAnLi9tYXNrZWQvcGF0dGVybi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hc2tlZFJhbmdlIH0gZnJvbSAnLi9tYXNrZWQvcmFuZ2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWREYXRlIH0gZnJvbSAnLi9tYXNrZWQvZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hc2tFbGVtZW50IH0gZnJvbSAnLi9jb250cm9scy9tYXNrLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIVE1MTWFza0VsZW1lbnQgfSBmcm9tICcuL2NvbnRyb2xzL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50IH0gZnJvbSAnLi9jb250cm9scy9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dE1hc2sgfSBmcm9tICcuL2NvbnRyb2xzL2lucHV0LmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuL2ltYXNrLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkRW51bSB9IGZyb20gJy4vbWFza2VkL2VudW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWROdW1iZXIgfSBmcm9tICcuL21hc2tlZC9udW1iZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRGdW5jdGlvbiB9IGZyb20gJy4vbWFza2VkL2Z1bmN0aW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkRHluYW1pYyB9IGZyb20gJy4vbWFza2VkL2R5bmFtaWMuanMnO1xuZXhwb3J0IHsgUElQRV9UWVBFLCBjcmVhdGVQaXBlLCBwaXBlIH0gZnJvbSAnLi9tYXNrZWQvcGlwZS5qcyc7XG5cbnRyeSB7XG4gIGdsb2JhbFRoaXMuSU1hc2sgPSBJTWFzaztcbn0gY2F0Y2ggKGUpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')}}]);