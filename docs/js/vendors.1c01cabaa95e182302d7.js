(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return stripTime; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return today; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return dateValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addDays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return addWeeks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return addMonths; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return addYears; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return dayOfTheWeekOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getWeek; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return startOfYearPeriod; });\nfunction stripTime(timeValue) {\n  return new Date(timeValue).setHours(0, 0, 0, 0);\n}\nfunction today() {\n  return new Date().setHours(0, 0, 0, 0);\n} // Get the time value of the start of given date or year, month and day\n\nfunction dateValue(...args) {\n  switch (args.length) {\n    case 0:\n      return today();\n\n    case 1:\n      return stripTime(args[0]);\n  } // use setFullYear() to keep 2-digit year from being mapped to 1900-1999\n\n\n  const newDate = new Date(0);\n  newDate.setFullYear(...args);\n  return newDate.setHours(0, 0, 0, 0);\n}\nfunction addDays(date, amount) {\n  const newDate = new Date(date);\n  return newDate.setDate(newDate.getDate() + amount);\n}\nfunction addWeeks(date, amount) {\n  return addDays(date, amount * 7);\n}\nfunction addMonths(date, amount) {\n  // If the day of the date is not in the new month, the last day of the new\n  // month will be returned. e.g. Jan 31 + 1 month → Feb 28 (not Mar 03)\n  const newDate = new Date(date);\n  const monthsToSet = newDate.getMonth() + amount;\n  let expectedMonth = monthsToSet % 12;\n\n  if (expectedMonth < 0) {\n    expectedMonth += 12;\n  }\n\n  const time = newDate.setMonth(monthsToSet);\n  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;\n}\nfunction addYears(date, amount) {\n  // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the\n  // new year will be returned.\n  const newDate = new Date(date);\n  const expectedMonth = newDate.getMonth();\n  const time = newDate.setFullYear(newDate.getFullYear() + amount);\n  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;\n} // Calculate the distance bettwen 2 days of the week\n\nfunction dayDiff(day, from) {\n  return (day - from + 7) % 7;\n} // Get the date of the specified day of the week of given base date\n\n\nfunction dayOfTheWeekOf(baseDate, dayOfWeek, weekStart = 0) {\n  const baseDay = new Date(baseDate).getDay();\n  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));\n} // Get the ISO week of a date\n\nfunction getWeek(date) {\n  // start of ISO week is Monday\n  const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1); // 1st week == the week where the 4th of January is in\n\n  const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);\n  return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;\n} // Get the start year of the period of years that includes given date\n// years: length of the year period\n\nfunction startOfYearPeriod(date, years) {\n  /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */\n  const year = new Date(date).getFullYear();\n  return Math.floor(year / years) * years;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvbGliL2RhdGUuanM/Y2QzZiJdLCJuYW1lcyI6WyJzdHJpcFRpbWUiLCJ0aW1lVmFsdWUiLCJEYXRlIiwic2V0SG91cnMiLCJ0b2RheSIsImRhdGVWYWx1ZSIsImFyZ3MiLCJsZW5ndGgiLCJuZXdEYXRlIiwic2V0RnVsbFllYXIiLCJhZGREYXlzIiwiZGF0ZSIsImFtb3VudCIsInNldERhdGUiLCJnZXREYXRlIiwiYWRkV2Vla3MiLCJhZGRNb250aHMiLCJtb250aHNUb1NldCIsImdldE1vbnRoIiwiZXhwZWN0ZWRNb250aCIsInRpbWUiLCJzZXRNb250aCIsImFkZFllYXJzIiwiZ2V0RnVsbFllYXIiLCJkYXlEaWZmIiwiZGF5IiwiZnJvbSIsImRheU9mVGhlV2Vla09mIiwiYmFzZURhdGUiLCJkYXlPZldlZWsiLCJ3ZWVrU3RhcnQiLCJiYXNlRGF5IiwiZ2V0RGF5IiwiZ2V0V2VlayIsInRodU9mVGhlV2VlayIsImZpcnN0VGh1IiwiTWF0aCIsInJvdW5kIiwic3RhcnRPZlllYXJQZXJpb2QiLCJ5ZWFycyIsInllYXIiLCJmbG9vciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBTyxTQUFTQSxTQUFULENBQW1CQyxTQUFuQixFQUE4QjtBQUNuQyxTQUFPLElBQUlDLElBQUosQ0FBU0QsU0FBVCxFQUFvQkUsUUFBcEIsQ0FBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsQ0FBUDtBQUNEO0FBRU0sU0FBU0MsS0FBVCxHQUFpQjtBQUN0QixTQUFPLElBQUlGLElBQUosR0FBV0MsUUFBWCxDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QixDQUFQO0FBQ0QsQyxDQUVEOztBQUNPLFNBQVNFLFNBQVQsQ0FBbUIsR0FBR0MsSUFB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QzVCO0FBQ0EsUUFBTXVCLFlBQVksR0FBR1AsY0FBYyxDQUFDaEIsSUFBRCxFQUFPLENBQVAsRUFBVSxDQUFWLENBQW5DLENBRjRCLENBRzVCOztBQUNBLFFBQU13QixRQUFRLEdBQUdSLGNBQWMsQ0FBQyxJQUFJekIsSUFBSixDQUFTZ0MsWUFBVCxFQUF1QmIsUUFBdkIsQ0FBZ0MsQ0FBaEMsRUFBbUMsQ0FBbkMsQ0FBRCxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxDQUEvQjtBQUNBLFNBQU9lLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUNILFlBQVksR0FBR0MsUUFBaEIsSUFBNEIsU0FBdkMsSUFBb0QsQ0FBM0Q7QUFDRCxDLENBRUQ7QUFDQTs7QUFDTyxTQUFTRyxpQkFBVCxDQUEyQjNCLElBQTNCLEVBQWlDNEIsS0FBakMsRUFBd0M7QUFDN0M7QUFDQSxRQUFNQyxJQUFJLEdBQUcsSUFBSXRDLElBQUosQ0FBU1MsSUFBVCxFQUFlWSxXQUFmLEVBQWI7QUFDQSxTQUFPYSxJQUFJLENBQUNLLEtBQUwsQ0FBV0QsSUFBSSxHQUFHRCxLQUFsQixJQUEyQkEsS0FBbEM7QUFDRCIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVGltZSh0aW1lVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVWYWx1ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2RheSgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59XG5cbi8vIEdldCB0aGUgdGltZSB2YWx1ZSBvZiB0aGUgc3RhcnQgb2YgZ2l2ZW4gZGF0ZSBvciB5ZWFyLCBtb250aCBhbmQgZGF5XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVZhbHVlKC4uLmFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0b2RheSgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBzdHJpcFRpbWUoYXJnc1swXSk7XG4gIH1cblxuICAvLyB1c2Ugc2V0RnVsbFllYXIoKSB0byBrZWVwIDItZGlnaXQgeWVhciBmcm9tIGJlaW5nIG1hcHBlZCB0byAxOTAwLTE5OTlcbiAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKDApO1xuICBuZXdEYXRlLnNldEZ1bGxZZWFyKC4uLmFyZ3MpO1xuICByZXR1cm4gbmV3RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgYW1vdW50KSB7XG4gIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgcmV0dXJuIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRXZWVrcyhkYXRlLCBhbW91bnQpIHtcbiAgcmV0dXJuIGFkZERheXMoZGF0ZSwgYW1vdW50ICogNyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNb250aHMoZGF0ZSwgYW1vdW50KSB7XG4gIC8vIElmIHRoZSBkYXkgb2YgdGhlIGRhdGUgaXMgbm90IGluIHRoZSBuZXcgbW9udGgsIHRoZSBsYXN0IGRheSBvZiB0aGUgbmV3XG4gIC8vIG1vbnRoIHdpbGwgYmUgcmV0dXJuZWQuIGUuZy4gSmFuIDMxICsgMSBtb250aCDihpIgRmViIDI4IChub3QgTWFyIDAzKVxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIGNvbnN0IG1vbnRoc1RvU2V0ID0gbmV3RGF0ZS5nZXRNb250aCgpICsgYW1vdW50O1xuICBsZXQgZXhwZWN0ZWRNb250aCA9IG1vbnRoc1RvU2V0ICUgMTI7XG4gIGlmIChleHBlY3RlZE1vbnRoIDwgMCkge1xuICAgIGV4cGVjdGVkTW9udGggKz0gMTI7XG4gIH1cblxuICBjb25zdCB0aW1lID0gbmV3RGF0ZS5zZXRNb250aChtb250aHNUb1NldCk7XG4gIHJldHVybiBuZXdEYXRlLmdldE1vbnRoKCkgIT09IGV4cGVjdGVkTW9udGggPyBuZXdEYXRlLnNldERhdGUoMCkgOiB0aW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkWWVhcnMoZGF0ZSwgYW1vdW50KSB7XG4gIC8vIElmIHRoZSBkYXRlIGlzIEZlYiAyOSBhbmQgdGhlIG5ldyB5ZWFyIGlzIG5vdCBhIGxlYXAgeWVhciwgRmViIDI4IG9mIHRoZVxuICAvLyBuZXcgeWVhciB3aWxsIGJlIHJldHVybmVkLlxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIGNvbnN0IGV4cGVjdGVkTW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG4gIGNvbnN0IHRpbWUgPSBuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGFtb3VudCk7XG4gIHJldHVybiBleHBlY3RlZE1vbnRoID09PSAxICYmIG5ld0RhdGUuZ2V0TW9udGgoKSA9PT0gMiA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0dHdlbiAyIGRheXMgb2YgdGhlIHdlZWtcbmZ1bmN0aW9uIGRheURpZmYoZGF5LCBmcm9tKSB7XG4gIHJldHVybiAoZGF5IC0gZnJvbSArIDcpICUgNztcbn1cblxuLy8gR2V0IHRoZSBkYXRlIG9mIHRoZSBzcGVjaWZpZWQgZGF5IG9mIHRoZSB3ZWVrIG9mIGdpdmVuIGJhc2UgZGF0ZVxuZXhwb3J0IGZ1bmN0aW9uIGRheU9mVGhlV2Vla09mKGJhc2VEYXRlLCBkYXlPZldlZWssIHdlZWtTdGFydCA9IDApIHtcbiAgY29uc3QgYmFzZURheSA9IG5ldyBEYXRlKGJhc2VEYXRlKS5nZXREYXkoKTtcbiAgcmV0dXJuIGFkZERheXMoYmFzZURhdGUsIGRheURpZmYoZGF5T2ZXZWVrLCB3ZWVrU3RhcnQpIC0gZGF5RGlmZihiYXNlRGF5LCB3ZWVrU3RhcnQpKTtcbn1cblxuLy8gR2V0IHRoZSBJU08gd2VlayBvZiBhIGRhdGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgLy8gc3RhcnQgb2YgSVNPIHdlZWsgaXMgTW9uZGF5XG4gIGNvbnN0IHRodU9mVGhlV2VlayA9IGRheU9mVGhlV2Vla09mKGRhdGUsIDQsIDEpO1xuICAvLyAxc3Qgd2VlayA9PSB0aGUgd2VlayB3aGVyZSB0aGUgNHRoIG9mIEphbnVhcnkgaXMgaW5cbiAgY29uc3QgZmlyc3RUaHUgPSBkYXlPZlRoZVdlZWtPZihuZXcgRGF0ZSh0aHVPZlRoZVdlZWspLnNldE1vbnRoKDAsIDQpLCA0LCAxKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHRodU9mVGhlV2VlayAtIGZpcnN0VGh1KSAvIDYwNDgwMDAwMCkgKyAxO1xufVxuXG4vLyBHZXQgdGhlIHN0YXJ0IHllYXIgb2YgdGhlIHBlcmlvZCBvZiB5ZWFycyB0aGF0IGluY2x1ZGVzIGdpdmVuIGRhdGVcbi8vIHllYXJzOiBsZW5ndGggb2YgdGhlIHllYXIgcGVyaW9kXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRPZlllYXJQZXJpb2QoZGF0ZSwgeWVhcnMpIHtcbiAgLyogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9ZZWFyX3plcm8jSVNPXzg2MDEgKi9cbiAgY29uc3QgeWVhciA9IG5ldyBEYXRlKGRhdGUpLmdldEZ1bGxZZWFyKCk7XG4gIHJldHVybiBNYXRoLmZsb29yKHllYXIgLyB5ZWFycykgKiB5ZWFycztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return hasProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return lastItemOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return pushUnique; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return stringToArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isInRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return limitToRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createTagRepeat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return optimizeTemplateHTML; });\nfunction hasProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction lastItemOf(arr) {\n  return arr[arr.length - 1];\n} // push only the items not included in the array\n\nfunction pushUnique(arr, ...items) {\n  items.forEach(item => {\n    if (arr.includes(item)) {\n      return;\n    }\n\n    arr.push(item);\n  });\n  return arr;\n}\nfunction stringToArray(str, separator) {\n  // convert empty string to an empty array\n  return str ? str.split(separator) : [];\n}\nfunction isInRange(testVal, min, max) {\n  const minOK = min === undefined || testVal >= min;\n  const maxOK = max === undefined || testVal <= max;\n  return minOK && maxOK;\n}\nfunction limitToRange(val, min, max) {\n  if (val < min) {\n    return min;\n  }\n\n  if (val > max) {\n    return max;\n  }\n\n  return val;\n}\nfunction createTagRepeat(tagName, repeat, attributes = {}, index = 0, html = \'\') {\n  const openTagSrc = Object.keys(attributes).reduce((src, attr) => {\n    let val = attributes[attr];\n\n    if (typeof val === \'function\') {\n      val = val(index);\n    }\n\n    return `${src} ${attr}="${val}"`;\n  }, tagName);\n  html += `<${openTagSrc}></${tagName}>`;\n  const next = index + 1;\n  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;\n} // Remove the spacing surrounding tags for HTML parser not to create text nodes\n// before/after elements\n\nfunction optimizeTemplateHTML(html) {\n  return html.replace(/>\\s+/g, \'>\').replace(/\\s+</, \'<\');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvbGliL3V0aWxzLmpzP2M4MzMiXSwibmFtZXMiOlsiaGFzUHJvcGVydHkiLCJvYmoiLCJwcm9wIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibGFzdEl0ZW1PZiIsImFyciIsImxlbmd0aCIsInB1c2hVbmlxdWUiLCJpdGVtcyIsImZvckVhY2giLCJpdGVtIiwiaW5jbHVkZXMiLCJwdXNoIiwic3RyaW5nVG9BcnJheSIsInN0ciIsInNlcGFyYXRvciIsInNwbGl0IiwiaXNJblJhbmdlIiwidGVzdFZhbCIsIm1pbiIsIm1heCIsIm1pbk9LIiwidW5kZWZpbmVkIiwibWF4T0siLCJsaW1pdFRvUmFuZ2UiLCJ2YWwiLCJjcmVhdGVUYWdSZXBlYXQiLCJ0YWdOYW1lIiwicmVwZWF0IiwiYXR0cmlidXRlcyIsImluZGV4IiwiaHRtbCIsIm9wZW5UYWdTcmMiLCJrZXlzIiwicmVkdWNlIiwic3JjIiwiYXR0ciIsIm5leHQiLCJvcHRpbWl6ZVRlbXBsYXRlSFRNTCIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBTyxTQUFTQSxXQUFULENBQXFCQyxHQUFyQixFQUEwQkMsSUFBMUIsRUFBZ0M7QUFDckMsU0FBT0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNMLEdBQXJDLEVBQTBDQyxJQUExQyxDQUFQO0FBQ0Q7QUFFTSxTQUFTSyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUM5QixTQUFPQSxHQUFHLENBQUNBLEdBQUcsQ0FBQ0MsTUFBSixHQUFhLENBQWQsQ0FBVjtBQUNELEMsQ0FFRDs7QUFDTyxTQUFTQyxVQUFULENBQW9CRixHQUFwQixFQUF5QixHQUFHRyxLQUE1QixFQUFtQztBQUN4Q0EsT0FBSyxDQUFDQyxPQUFOLENBQWVDLElBQUQsSUFBVTtBQUN0QixRQUFJTCxHQUFHLENBQUNNLFFBQUosQ0FBYUQsSUFBYixDQUFKLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBQ0RMLE9BQUcsQ0FBQ08sSUFBSixDQUFTRixJQUFUO0FBQ0QsR0FMRDtBQU1BLFNBQU9MLEdBQVA7QUFDRDtBQUVNLFNBQVNRLGFBQVQsQ0FBdUJDLEdBQXZCLEVBQTRCQyxTQUE1QixFQUF1QztBQUM1QztBQUNBLFNBQU9ELEdBQUcsR0FBR0EsR0FBRyxDQUFDRSxLQUFKLENBQVVELFNBQVYsQ0FBSCxHQUEwQixFQUFwQztBQUNEO0FBRU0sU0FBU0UsU0FBVCxDQUFtQkMsT0FBbkIsRUFBNEJDLEdBQTVCLEVBQWlDQyxHQUFqQyxFQUFzQztBQUMzQyxRQUFNQyxLQUFLLEdBQUdGLEdBQUcsS0FBS0csU0FBUixJQUFxQkosT0FBTyxJQUFJQyxHQUE5QztBQUNBLFFBQU1JLEtBQUssR0FBR0gsR0FBRyxLQUFLRSxTQUFSLElBQXFCSixPQUFPLElBQUlFLEdBQTlDO0FBQ0EsU0FBT0MsS0FBSyxJQUFJRSxLQUFoQjtBQUNEO0FBRU0sU0FBU0MsWUFBVCxDQUFzQkMsR0FBdEIsRUFBMkJOLEdBQTNCLEVBQWdDQyxHQUFoQyxFQUFxQztBQUMxQyxNQUFJSyxHQUFHLEdBQUdOLEdBQVYsRUFBZTtBQUNiLFdBQU9BLEdBQVA7QUFDRDs7QUFDRCxNQUFJTSxHQUFHLEdBQUdMLEdBQVYsRUFBZTtBQUNiLFdBQU9BLEdBQVA7QUFDRDs7QUFDRCxTQUFPSyxHQUFQO0FBQ0Q7QUFFTSxTQUFTQyxlQUFULENBQXlCQyxPQUF6QixFQUFrQ0MsTUFBbEMsRUFBMENDLFVBQVUsR0FBRyxFQUF2RCxFQUEyREMsS0FBSyxHQUFHLENBQW5FLEVBQXNFQyxJQUFJLEdBQUcsRUFBN0UsRUFBaUY7QUFDdEYsUUFBTUMsVUFBVSxHQUFHaEMsTUFBTSxDQUFDaUMsSUFBUCxDQUFZSixVQUFaLEVBQXdCSyxNQUF4QixDQUErQixDQUFDQyxHQUFELEVBQU1DLElBQU4sS0FBZTtBQUMvRCxRQUFJWCxHQUFHLEdBQUdJLFVBQVUsQ0FBQ08sSUFBRCxDQUFwQjs7QUFDQSxRQUFJLE9BQU9YLEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUM3QkEsU0FBRyxHQUFHQSxHQUFHLENBQUNLLEtBQUQsQ0FBVDtBQUNEOztBQUNELFdBQVEsR0FBRUssR0FBSSxJQUFHQyxJQUFLLEtBQUlYLEdBQUksR0FBOUI7QUFDRCxHQU5rQixFQU1oQkUsT0FOZ0IsQ0FBbkI7QUFPQUksTUFBSSxJQUFLLElBQUdDLFVBQVcsTUFBS0wsT0FBUSxHQUFwQztBQUVBLFFBQU1VLElBQUksR0FBR1AsS0FBSyxHQUFHLENBQXJCO0FBQ0EsU0FBT08sSUFBSSxHQUFHVCxNQUFQLEdBQ0hGLGVBQWUsQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQWtCQyxVQUFsQixFQUE4QlEsSUFBOUIsRUFBb0NOLElBQXBDLENBRFosR0FFSEEsSUFGSjtBQUdELEMsQ0FFRDtBQUNBOztBQUNPLFNBQVNPLG9CQUFULENBQThCUCxJQUE5QixFQUFvQztBQUN6QyxTQUFPQSxJQUFJLENBQUNRLE9BQUwsQ0FBYSxPQUFiLEVBQXNCLEdBQXRCLEVBQTJCQSxPQUEzQixDQUFtQyxNQUFuQyxFQUEyQyxHQUEzQyxDQUFQO0FBQ0QiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFzdEl0ZW1PZihhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbi8vIHB1c2ggb25seSB0aGUgaXRlbXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheVxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hVbmlxdWUoYXJyLCAuLi5pdGVtcykge1xuICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKGFyci5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcnIucHVzaChpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0ciwgc2VwYXJhdG9yKSB7XG4gIC8vIGNvbnZlcnQgZW1wdHkgc3RyaW5nIHRvIGFuIGVtcHR5IGFycmF5XG4gIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoc2VwYXJhdG9yKSA6IFtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJblJhbmdlKHRlc3RWYWwsIG1pbiwgbWF4KSB7XG4gIGNvbnN0IG1pbk9LID0gbWluID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA+PSBtaW47XG4gIGNvbnN0IG1heE9LID0gbWF4ID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA8PSBtYXg7XG4gIHJldHVybiBtaW5PSyAmJiBtYXhPSztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbWl0VG9SYW5nZSh2YWwsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWwgPCBtaW4pIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGlmICh2YWwgPiBtYXgpIHtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWdSZXBlYXQodGFnTmFtZSwgcmVwZWF0LCBhdHRyaWJ1dGVzID0ge30sIGluZGV4ID0gMCwgaHRtbCA9ICcnKSB7XG4gIGNvbnN0IG9wZW5UYWdTcmMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKHNyYywgYXR0cikgPT4ge1xuICAgIGxldCB2YWwgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWwgPSB2YWwoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c3JjfSAke2F0dHJ9PVwiJHt2YWx9XCJgO1xuICB9LCB0YWdOYW1lKTtcbiAgaHRtbCArPSBgPCR7b3BlblRhZ1NyY30+PC8ke3RhZ05hbWV9PmA7XG5cbiAgY29uc3QgbmV4dCA9IGluZGV4ICsgMTtcbiAgcmV0dXJuIG5leHQgPCByZXBlYXRcbiAgICA/IGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQsIGF0dHJpYnV0ZXMsIG5leHQsIGh0bWwpXG4gICAgOiBodG1sO1xufVxuXG4vLyBSZW1vdmUgdGhlIHNwYWNpbmcgc3Vycm91bmRpbmcgdGFncyBmb3IgSFRNTCBwYXJzZXIgbm90IHRvIGNyZWF0ZSB0ZXh0IG5vZGVzXG4vLyBiZWZvcmUvYWZ0ZXIgZWxlbWVudHNcbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZVRlbXBsYXRlSFRNTChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLz5cXHMrL2csICc+JykucmVwbGFjZSgvXFxzKzwvLCAnPCcpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return reFormatTokens; });\n/* unused harmony export reNonDateParts */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return parseDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return formatDate; });\n/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n\n // pattern for format parts\n\nconst reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/; // pattern for non date parts\n\nconst reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/; // cache for persed formats\n\nlet knownFormats = {}; // parse funtions for date parts\n\nconst parseFns = {\n  y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n\n  M: undefined,\n\n  // placeholder to maintain the key order\n  m(date, month, locale) {\n    const newDate = new Date(date);\n    let monthIndex = parseInt(month, 10) - 1;\n\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n\n      const monthName = month.toLowerCase();\n\n      const compareNames = name => name.toLowerCase().startsWith(monthName); // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n\n\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n\n      return monthIndex < 0 ? NaN : newDate.setMonth(monthIndex);\n    }\n\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n  },\n\n  d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  }\n\n};\nparseFns.M = parseFns.m; // make "M" an alias of "m"\n// format functions for date parts\n\nconst formatFns = {\n  d(date) {\n    return date.getDate();\n  },\n\n  dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n\n  D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n\n  DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n\n  m(date) {\n    return date.getMonth() + 1;\n  },\n\n  mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n\n  M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n\n  MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n\n  y(date) {\n    return date.getFullYear();\n  },\n\n  yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n\n  yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  }\n\n}; // get month index in normal range (0 - 11) from any number\n\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\n\nfunction padZero(num, length) {\n  return num.toString().padStart(length, \'0\');\n}\n\nfunction parseFormatString(format) {\n  if (typeof format !== \'string\') {\n    throw new Error("Invalid date format.");\n  }\n\n  if (format in knownFormats) {\n    return knownFormats[format];\n  } // sprit the format string into parts and seprators\n\n\n  const separators = format.split(reFormatTokens);\n  const parts = format.match(new RegExp(reFormatTokens, \'g\'));\n\n  if (separators.length === 0 || !parts) {\n    throw new Error("Invalid date format.");\n  } // collect format functions used in the format\n\n\n  const partFormatters = parts.map(token => formatFns[token]); // collect parse functions used in the format\n  // iterate over parseFns\' keys in order to keep the order of the keys.\n\n  const partParsers = Object.keys(parseFns).reduce((parsers, key) => {\n    const token = parts.find(part => part[0] === key);\n\n    if (!token) {\n      return parsers;\n    }\n\n    parsers[key] = parseFns[key];\n    return parsers;\n  }, {});\n  const partParserKeys = Object.keys(partParsers);\n  return knownFormats[format] = {\n    parser(dateStr, locale) {\n      const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n        if (part.length > 0 && parts[index]) {\n          const token = parts[index][0];\n\n          if (parseFns[token] !== undefined) {\n            dtParts[token] = part;\n          }\n        }\n\n        return dtParts;\n      }, {}); // iterate over partParsers\' keys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n\n      return partParserKeys.reduce((origDate, key) => {\n        const newDate = partParsers[key](origDate, dateParts[key], locale); // ingnore the part failed to parse\n\n        return isNaN(newDate) ? origDate : newDate;\n      }, Object(_date_js__WEBPACK_IMPORTED_MODULE_0__[/* today */ "j"])());\n    },\n\n    formatter(date, locale) {\n      let dateStr = partFormatters.reduce((str, fn, index) => {\n        return str += `${separators[index]}${fn(date, locale)}`;\n      }, \'\'); // separators\' length is always parts\' length + 1,\n\n      return dateStr += Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[/* lastItemOf */ "d"])(separators);\n    }\n\n  };\n}\n\nfunction parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === \'number\') {\n    const date = Object(_date_js__WEBPACK_IMPORTED_MODULE_0__[/* stripTime */ "i"])(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n\n  if (!dateStr) {\n    return undefined;\n  }\n\n  if (dateStr === \'today\') {\n    return Object(_date_js__WEBPACK_IMPORTED_MODULE_0__[/* today */ "j"])();\n  }\n\n  if (format && format.toValue) {\n    const date = format.toValue(dateStr, format, locale);\n    return isNaN(date) ? undefined : Object(_date_js__WEBPACK_IMPORTED_MODULE_0__[/* stripTime */ "i"])(date);\n  }\n\n  return parseFormatString(format).parser(dateStr, locale);\n}\nfunction formatDate(date, format, locale) {\n  if (isNaN(date) || !date && date !== 0) {\n    return \'\';\n  }\n\n  const dateObj = typeof date === \'number\' ? new Date(date) : date;\n\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n\n  return parseFormatString(format).formatter(dateObj, locale);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvbGliL2RhdGUtZm9ybWF0LmpzPzJlMDEiXSwibmFtZXMiOlsicmVGb3JtYXRUb2tlbnMiLCJyZU5vbkRhdGVQYXJ0cyIsImtub3duRm9ybWF0cyIsInBhcnNlRm5zIiwieSIsImRhdGUiLCJ5ZWFyIiwiRGF0ZSIsInNldEZ1bGxZZWFyIiwicGFyc2VJbnQiLCJNIiwidW5kZWZpbmVkIiwibSIsIm1vbnRoIiwibG9jYWxlIiwibmV3RGF0ZSIsIm1vbnRoSW5kZXgiLCJpc05hTiIsIk5hTiIsIm1vbnRoTmFtZSIsInRvTG93ZXJDYXNlIiwiY29tcGFyZU5hbWVzIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJtb250aHNTaG9ydCIsImZpbmRJbmRleCIsIm1vbnRocyIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJub3JtYWxpemVNb250aCIsInNldERhdGUiLCJnZXRUaW1lIiwiZCIsImRheSIsImZvcm1hdEZucyIsImdldERhdGUiLCJkZCIsInBhZFplcm8iLCJEIiwiZGF5c1Nob3J0IiwiZ2V0RGF5IiwiREQiLCJkYXlzIiwibW0iLCJNTSIsImdldEZ1bGxZZWFyIiwieXkiLCJzbGljZSIsInl5eXkiLCJudW0iLCJsZW5ndGgiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicGFyc2VGb3JtYXRTdHJpbmciLCJmb3JtYXQiLCJFcnJvciIsInNlcGFyYXRvcnMiLCJzcGxpdCIsInBhcnRzIiwibWF0Y2giLCJSZWdFeHAiLCJwYXJ0Rm9ybWF0dGVycyIsIm1hcCIsInRva2VuIiwicGFydFBhcnNlcnMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwicGFyc2VycyIsImtleSIsImZpbmQiLCJwYXJ0IiwicGFydFBhcnNlcktleXMiLCJwYXJzZXIiLCJkYXRlU3RyIiwiZGF0ZVBhcnRzIiwiZHRQYXJ0cyIsImluZGV4Iiwib3JpZ0RhdGUiLCJ0b2RheSIsImZvcm1hdHRlciIsInN0ciIsImZuIiwibGFzdEl0ZW1PZiIsInBhcnNlRGF0ZSIsInN0cmlwVGltZSIsInRvVmFsdWUiLCJmb3JtYXREYXRlIiwiZGF0ZU9iaiIsInRvRGlzcGxheSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Q0FHQTs7QUFDTyxNQUFNQSxjQUFjLEdBQUcsNEJBQXZCLEMsQ0FDUDs7QUFDTyxNQUFNQyxjQUFjLEdBQUcsc0JBQXZCLEMsQ0FDUDs7QUFDQSxJQUFJQyxZQUFZLEdBQUcsRUFBbkIsQyxDQUNBOztBQUNBLE1BQU1DLFFBQVEsR0FBRztBQUNmQyxHQUFDLENBQUNDLElBQUQsRUFBT0MsSUFBUCxFQUFhO0FBQ1osV0FBTyxJQUFJQyxJQUFKLENBQVNGLElBQVQsRUFBZUcsV0FBZixDQUEyQkMsUUFBUSxDQUFDSCxJQUFELEVBQU8sRUFBUCxDQUFuQyxDQUFQO0FBQ0QsR0FIYzs7QUFJZkksR0FBQyxFQUFFQyxTQUpZOztBQUlBO0FBQ2ZDLEdBQUMsQ0FBQ1AsSUFBRCxFQUFPUSxLQUFQLEVBQWNDLE1BQWQsRUFBc0I7QUFDckIsVUFBTUMsT0FBTyxHQUFHLElBQUlSLElBQUosQ0FBU0YsSUFBVCxDQUFoQjtBQUNBLFFBQUlXLFVBQVUsR0FBR1AsUUFBUSxDQUFDSSxLQUFELEVBQVEsRUFBUixDQUFSLEdBQXNCLENBQXZDOztBQUVBLFFBQUlJLEtBQUssQ0FBQ0QsVUFBRCxDQUFULEVBQXVCO0FBQ3JCLFVBQUksQ0FBQ0gsS0FBTCxFQUFZO0FBQ1YsZUFBT0ssR0FBUDtBQUNEOztBQUVELFlBQU1DLFNBQVMsR0FBR04sS0FBSyxDQUFDTyxXQUFOLEVBQWxCOztBQUNBLFlBQU1DLFlBQVksR0FBR0MsSUFBSSxJQUFJQSxJQUFJLENBQUNGLFdBQUwsR0FBbUJHLFVBQW5CLENBQThCSixTQUE5QixDQUE3QixDQU5xQixDQU9yQjtBQUNBOzs7QUFDQUgsZ0JBQVUsR0FBR0YsTUFBTSxDQUFDVSxXQUFQLENBQW1CQyxTQUFuQixDQUE2QkosWUFBN0IsQ0FBYjs7QUFD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LENBQUNnQyxPQUFyQixFQUE4QjtBQUM1QixVQUFNakYsSUFBSSxHQUFHaUQsTUFBTSxDQUFDZ0MsT0FBUCxDQUFlWixPQUFmLEVBQXdCcEIsTUFBeEIsRUFBZ0N4QyxNQUFoQyxDQUFiO0FBQ0EsV0FBT0csS0FBSyxDQUFDWixJQUFELENBQUwsR0FBY00sU0FBZCxHQUEwQjBFLGtFQUFTLENBQUNoRixJQUFELENBQTFDO0FBQ0Q7O0FBRUQsU0FBT2dELGlCQUFpQixDQUFDQyxNQUFELENBQWpCLENBQTBCbUIsTUFBMUIsQ0FBaUNDLE9BQWpDLEVBQTBDNUQsTUFBMUMsQ0FBUDtBQUNEO0FBRU0sU0FBU3lFLFVBQVQsQ0FBb0JsRixJQUFwQixFQUEwQmlELE1BQTFCLEVBQWtDeEMsTUFBbEMsRUFBMEM7QUFDL0MsTUFBSUcsS0FBSyxDQUFDWixJQUFELENBQUwsSUFBZ0IsQ0FBQ0EsSUFBRCxJQUFTQSxJQUFJLEtBQUssQ0FBdEMsRUFBMEM7QUFDeEMsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsUUFBTW1GLE9BQU8sR0FBRyxPQUFPbkYsSUFBUCxLQUFnQixRQUFoQixHQUEyQixJQUFJRSxJQUFKLENBQVNGLElBQVQsQ0FBM0IsR0FBNENBLElBQTVEOztBQUVBLE1BQUlpRCxNQUFNLENBQUNtQyxTQUFYLEVBQXNCO0FBQ3BCLFdBQU9uQyxNQUFNLENBQUNtQyxTQUFQLENBQWlCRCxPQUFqQixFQUEwQmxDLE1BQTFCLEVBQWtDeEMsTUFBbEMsQ0FBUDtBQUNEOztBQUVELFNBQU91QyxpQkFBaUIsQ0FBQ0MsTUFBRCxDQUFqQixDQUEwQjBCLFNBQTFCLENBQW9DUSxPQUFwQyxFQUE2QzFFLE1BQTdDLENBQVA7QUFDRCIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzdHJpcFRpbWUsIHRvZGF5fSBmcm9tICcuL2RhdGUuanMnO1xuaW1wb3J0IHtsYXN0SXRlbU9mfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gcGF0dGVybiBmb3IgZm9ybWF0IHBhcnRzXG5leHBvcnQgY29uc3QgcmVGb3JtYXRUb2tlbnMgPSAvZGQ/fEREP3xtbT98TU0/fHl5Pyg/Onl5KT8vO1xuLy8gcGF0dGVybiBmb3Igbm9uIGRhdGUgcGFydHNcbmV4cG9ydCBjb25zdCByZU5vbkRhdGVQYXJ0cyA9IC9bXFxzIS0vOi1AWy1gey1+5bm05pyI5pelXSsvO1xuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXG5sZXQga25vd25Gb3JtYXRzID0ge307XG4vLyBwYXJzZSBmdW50aW9ucyBmb3IgZGF0ZSBwYXJ0c1xuY29uc3QgcGFyc2VGbnMgPSB7XG4gIHkoZGF0ZSwgeWVhcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS5zZXRGdWxsWWVhcihwYXJzZUludCh5ZWFyLCAxMCkpO1xuICB9LFxuICBNOiB1bmRlZmluZWQsICAvLyBwbGFjZWhvbGRlciB0byBtYWludGFpbiB0aGUga2V5IG9yZGVyXG4gIG0oZGF0ZSwgbW9udGgsIGxvY2FsZSkge1xuICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBsZXQgbW9udGhJbmRleCA9IHBhcnNlSW50KG1vbnRoLCAxMCkgLSAxO1xuXG4gICAgaWYgKGlzTmFOKG1vbnRoSW5kZXgpKSB7XG4gICAgICBpZiAoIW1vbnRoKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vbnRoTmFtZSA9IG1vbnRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBjb21wYXJlTmFtZXMgPSBuYW1lID0+IG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG1vbnRoTmFtZSk7XG4gICAgICAvLyBjb21wYXJlIHdpdGggYm90aCBzaG9ydCBhbmQgZnVsbCBuYW1lcyBiZWNhdXNlIHNvbWUgbG9jYWxlcyBoYXZlIHBlcmlvZHNcbiAgICAgIC8vIGluIHRoZSBzaG9ydCBuYW1lcyAobm90IGVxdWFsIHRvIHRoZSBmaXJzdCBYIGxldHRlcnMgb2YgdGhlIGZ1bGwgbmFtZXMpXG4gICAgICBtb250aEluZGV4ID0gbG9jYWxlLm1vbnRoc1Nob3J0LmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xuICAgICAgaWYgKG1vbnRoSW5kZXggPCAwKSB7XG4gICAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzLmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vbnRoSW5kZXggPCAwID8gTmFOIDogbmV3RGF0ZS5zZXRNb250aChtb250aEluZGV4KTtcbiAgICB9XG5cbiAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoSW5kZXgpO1xuICAgIHJldHVybiBuZXdEYXRlLmdldE1vbnRoKCkgIT09IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpXG4gICAgICA/IG5ld0RhdGUuc2V0RGF0ZSgwKVxuICAgICAgOiBuZXdEYXRlLmdldFRpbWUoKTtcbiAgfSxcbiAgZChkYXRlLCBkYXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RGF0ZShwYXJzZUludChkYXksIDEwKSk7XG4gIH0sXG59O1xucGFyc2VGbnMuTSA9IHBhcnNlRm5zLm07ICAvLyBtYWtlIFwiTVwiIGFuIGFsaWFzIG9mIFwibVwiXG4vLyBmb3JtYXQgZnVuY3Rpb25zIGZvciBkYXRlIHBhcnRzXG5jb25zdCBmb3JtYXRGbnMgPSB7XG4gIGQoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgfSxcbiAgZGQoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgfSxcbiAgRChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmRheXNTaG9ydFtkYXRlLmdldERheSgpXTtcbiAgfSxcbiAgREQoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzW2RhdGUuZ2V0RGF5KCldO1xuICB9LFxuICBtKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgfSxcbiAgbW0oZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuICB9LFxuICBNKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgTU0oZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgeShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcbiAgeXkoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RnVsbFllYXIoKSwgMikuc2xpY2UoLTIpO1xuICB9LFxuICB5eXl5KGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICB9LFxufTtcblxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpIHtcbiAgcmV0dXJuIG1vbnRoSW5kZXggPiAtMSA/IG1vbnRoSW5kZXggJSAxMiA6IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXggKyAxMik7XG59XG5cbmZ1bmN0aW9uIHBhZFplcm8obnVtLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG4gIGlmIChmb3JtYXQgaW4ga25vd25Gb3JtYXRzKSB7XG4gICAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdO1xuICB9XG5cbiAgLy8gc3ByaXQgdGhlIGZvcm1hdCBzdHJpbmcgaW50byBwYXJ0cyBhbmQgc2VwcmF0b3JzXG4gIGNvbnN0IHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xuICBjb25zdCBwYXJ0cyA9IGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKHJlRm9ybWF0VG9rZW5zLCAnZycpKTtcbiAgaWYgKHNlcGFyYXRvcnMubGVuZ3RoID09PSAwIHx8ICFwYXJ0cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxuICBjb25zdCBwYXJ0Rm9ybWF0dGVycyA9IHBhcnRzLm1hcCh0b2tlbiA9PiBmb3JtYXRGbnNbdG9rZW5dKTtcblxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBmb3JtYXRcbiAgLy8gaXRlcmF0ZSBvdmVyIHBhcnNlRm5zJyBrZXlzIGluIG9yZGVyIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBrZXlzLlxuICBjb25zdCBwYXJ0UGFyc2VycyA9IE9iamVjdC5rZXlzKHBhcnNlRm5zKS5yZWR1Y2UoKHBhcnNlcnMsIGtleSkgPT4ge1xuICAgIGNvbnN0IHRva2VuID0gcGFydHMuZmluZChwYXJ0ID0+IHBhcnRbMF0gPT09IGtleSk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmV0dXJuIHBhcnNlcnM7XG4gICAgfVxuICAgIHBhcnNlcnNba2V5XSA9IHBhcnNlRm5zW2tleV07XG4gICAgcmV0dXJuIHBhcnNlcnM7XG4gIH0sIHt9KTtcbiAgY29uc3QgcGFydFBhcnNlcktleXMgPSBPYmplY3Qua2V5cyhwYXJ0UGFyc2Vycyk7XG5cbiAgcmV0dXJuIGtub3duRm9ybWF0c1tmb3JtYXRdID0ge1xuICAgIHBhcnNlcihkYXRlU3RyLCBsb2NhbGUpIHtcbiAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IGRhdGVTdHIuc3BsaXQocmVOb25EYXRlUGFydHMpLnJlZHVjZSgoZHRQYXJ0cywgcGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCAmJiBwYXJ0c1tpbmRleF0pIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnRzW2luZGV4XVswXTtcbiAgICAgICAgICBpZiAocGFyc2VGbnNbdG9rZW5dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vycycga2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcbiAgICAgIC8vIG9mIHllYXIsIG1vbnRoIGFuZCBkYXkgdG8gcHJldmVudCB0aGUgZGF5IHBhcnNlciBmcm9tIGNvcnJlY3RpbmcgbGFzdFxuICAgICAgLy8gZGF5IG9mIG1vbnRoIHdyb25nbHlcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoKG9yaWdEYXRlLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGF0ZSA9IHBhcnRQYXJzZXJzW2tleV0ob3JpZ0RhdGUsIGRhdGVQYXJ0c1trZXldLCBsb2NhbGUpO1xuICAgICAgICAvLyBpbmdub3JlIHRoZSBwYXJ0IGZhaWxlZCB0byBwYXJzZVxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XG4gICAgICB9LCB0b2RheSgpKTtcbiAgICB9LFxuICAgIGZvcm1hdHRlcihkYXRlLCBsb2NhbGUpIHtcbiAgICAgIGxldCBkYXRlU3RyID0gcGFydEZvcm1hdHRlcnMucmVkdWNlKChzdHIsIGZuLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RyICs9IGAke3NlcGFyYXRvcnNbaW5kZXhdfSR7Zm4oZGF0ZSwgbG9jYWxlKX1gO1xuICAgICAgfSwgJycpO1xuICAgICAgLy8gc2VwYXJhdG9ycycgbGVuZ3RoIGlzIGFsd2F5cyBwYXJ0cycgbGVuZ3RoICsgMSxcbiAgICAgIHJldHVybiBkYXRlU3RyICs9IGxhc3RJdGVtT2Yoc2VwYXJhdG9ycyk7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyLCBmb3JtYXQsIGxvY2FsZSkge1xuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XG4gICAgY29uc3QgZGF0ZSA9IHN0cmlwVGltZShkYXRlU3RyKTtcbiAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyB1bmRlZmluZWQgOiBkYXRlO1xuICB9XG4gIGlmICghZGF0ZVN0cikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGRhdGVTdHIgPT09ICd0b2RheScpIHtcbiAgICByZXR1cm4gdG9kYXkoKTtcbiAgfVxuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnRvVmFsdWUpIHtcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0LnRvVmFsdWUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IHN0cmlwVGltZShkYXRlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpLnBhcnNlcihkYXRlU3RyLCBsb2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxvY2FsZSkge1xuICBpZiAoaXNOYU4oZGF0ZSkgfHwgKCFkYXRlICYmIGRhdGUgIT09IDApKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZGF0ZU9iaiA9IHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJyA/IG5ldyBEYXRlKGRhdGUpIDogZGF0ZTtcblxuICBpZiAoZm9ybWF0LnRvRGlzcGxheSkge1xuICAgIHJldHVybiBmb3JtYXQudG9EaXNwbGF5KGRhdGVPYmosIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpLmZvcm1hdHRlcihkYXRlT2JqLCBsb2NhbGUpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return registerListeners; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return unregisterListeners; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findElementInEventPath; });\nconst listenerRegistry = new WeakMap();\nconst {\n  addEventListener,\n  removeEventListener\n} = EventTarget.prototype; // Register event listeners to a key object\n// listeners: array of listener definitions;\n//   - each definition must be a flat array of event target and the arguments\n//     used to call addEventListener() on the target\n\nfunction registerListeners(keyObj, listeners) {\n  let registered = listenerRegistry.get(keyObj);\n\n  if (!registered) {\n    registered = [];\n    listenerRegistry.set(keyObj, registered);\n  }\n\n  listeners.forEach(listener => {\n    addEventListener.call(...listener);\n    registered.push(listener);\n  });\n}\nfunction unregisterListeners(keyObj) {\n  let listeners = listenerRegistry.get(keyObj);\n\n  if (!listeners) {\n    return;\n  }\n\n  listeners.forEach(listener => {\n    removeEventListener.call(...listener);\n  });\n  listenerRegistry.delete(keyObj);\n} // Event.composedPath() polyfill for Edge\n// based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec\n\nif (!Event.prototype.composedPath) {\n  const getComposedPath = (node, path = []) => {\n    path.push(node);\n    let parent;\n\n    if (node.parentNode) {\n      parent = node.parentNode;\n    } else if (node.host) {\n      // ShadowRoot\n      parent = node.host;\n    } else if (node.defaultView) {\n      // Document\n      parent = node.defaultView;\n    }\n\n    return parent ? getComposedPath(parent, path) : path;\n  };\n\n  Event.prototype.composedPath = function () {\n    return getComposedPath(this.target);\n  };\n}\n\nfunction findFromPath(path, criteria, currentTarget, index = 0) {\n  const el = path[index];\n\n  if (criteria(el)) {\n    return el;\n  } else if (el === currentTarget || !el.parentElement) {\n    // stop when reaching currentTarget or <html>\n    return;\n  }\n\n  return findFromPath(path, criteria, currentTarget, index + 1);\n} // Search for the actual target of a delegated event\n\n\nfunction findElementInEventPath(ev, selector) {\n  const criteria = typeof selector === \'function\' ? selector : el => el.matches(selector);\n  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvbGliL2V2ZW50LmpzPzI2YzYiXSwibmFtZXMiOlsibGlzdGVuZXJSZWdpc3RyeSIsIldlYWtNYXAiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkV2ZW50VGFyZ2V0IiwicHJvdG90eXBlIiwicmVnaXN0ZXJMaXN0ZW5lcnMiLCJrZXlPYmoiLCJsaXN0ZW5lcnMiLCJyZWdpc3RlcmVkIiwiZ2V0Iiwic2V0IiwiZm9yRWFjaCIsImxpc3RlbmVyIiwiY2FsbCIsInB1c2giLCJ1bnJlZ2lzdGVyTGlzdGVuZXJzIiwiZGVsZXRlIiwiRXZlbnQiLCJjb21wb3NlZFBhdGgiLCJnZXRDb21wb3NlZFBhdGgiLCJub2RlIiwicGF0aCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJob3N0IiwiZGVmYXVsdFZpZXciLCJ0YXJnZXQiLCJmaW5kRnJvbVBhdGgiLCJjcml0ZXJpYSIsImN1cnJlbnRUYXJnZXQiLCJpbmRleCIsImVsIiwicGFyZW50RWxlbWVudCIsImZpbmRFbGVtZW50SW5FdmVudFBhdGgiLCJldiIsInNlbGVjdG9yIiwibWF0Y2hlcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEsTUFBTUEsZ0JBQWdCLEdBQUcsSUFBSUMsT0FBSixFQUF6QjtBQUNBLE1BQU07QUFBQ0Msa0JBQUQ7QUFBbUJDO0FBQW5CLElBQTBDQyxXQUFXLENBQUNDLFNBQTVELEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLFNBQW5DLEVBQThDO0FBQ25ELE1BQUlDLFVBQVUsR0FBR1QsZ0JBQWdCLENBQUNVLEdBQWpCLENBQXFCSCxNQUFyQixDQUFqQjs7QUFDQSxNQUFJLENBQUNFLFVBQUwsRUFBaUI7QUFDZkEsY0FBVSxHQUFHLEVBQWI7QUFDQVQsb0JBQWdCLENBQUNXLEdBQWpCLENBQXFCSixNQUFyQixFQUE2QkUsVUFBN0I7QUFDRDs7QUFDREQsV0FBUyxDQUFDSSxPQUFWLENBQW1CQyxRQUFELElBQWM7QUFDOUJYLG9CQUFnQixDQUFDWSxJQUFqQixDQUFzQixHQUFHRCxRQUF6QjtBQUNBSixjQUFVLENBQUNNLElBQVgsQ0FBZ0JGLFFBQWhCO0FBQ0QsR0FIRDtBQUlEO0FBRU0sU0FBU0csbUJBQVQsQ0FBNkJULE1BQTdCLEVBQXFDO0FBQzFDLE1BQUlDLFNBQVMsR0FBR1IsZ0JBQWdCLENBQUNVLEdBQWpCLENBQXFCSCxNQUFyQixDQUFoQjs7QUFDQSxNQUFJLENBQUNDLFNBQUwsRUFBZ0I7QUFDZDtBQUNEOztBQUNEQSxXQUFTLENBQUNJLE9BQVYsQ0FBbUJDLFFBQUQsSUFBYztBQUM5QlYsdUJBQW1CLENBQUNXLElBQXBCLENBQXlCLEdBQUdELFFBQTVCO0FBQ0QsR0FGRDtBQUdBYixrQkFBZ0IsQ0FBQ2lCLE1BQWpCLENBQXdCVixNQUF4QjtBQUNELEMsQ0FFRDtBQUNBOztBQUNBLElBQUksQ0FBQ1csS0FBSyxDQUFDYixTQUFOLENBQWdCYyxZQUFyQixFQUFtQztBQUNqQyxRQUFNQyxlQUFlLEdBQUcsQ0FBQ0MsSUFBRCxFQUFPQyxJQUFJLEdBQUcsRUFBZCxLQUFxQjtBQUMzQ0EsUUFBSSxDQUFDUCxJQUFMLENBQVVNLElBQVY7QUFFQSxRQUFJRSxNQUFKOztBQUNBLFFBQUlGLElBQUksQ0FBQ0csVUFBVCxFQUFxQjtBQUNuQkQsWUFBTSxHQUFHRixJQUFJLENBQUNHLFVBQWQ7QUFDRCxLQUZELE1BRU8sSUFBSUgsSUFBSSxDQUFDSSxJQUFULEVBQWU7QUFBRTtBQUN0QkYsWUFBTSxHQUFHRixJQUFJLENBQUNJLElBQWQ7QUFDRCxLQUZNLE1BRUEsSUFBSUosSUFBSSxDQUFDSyxXQUFULEVBQXNCO0FBQUc7QUFDOUJILFlBQU0sR0FBR0YsSUFBSSxDQUFDSyxXQUFkO0FBQ0Q7O0FBQ0QsV0FBT0gsTUFBTSxHQUFHSCxlQUFlLENBQUNHLE1BQUQsRUFBU0QsSUFBVCxDQUFsQixHQUFtQ0EsSUFBaEQ7QUFDRCxHQVpEOztBQWNBSixPQUFLLENBQUNiLFNBQU4sQ0FBZ0JjLFlBQWhCLEdBQStCLFlBQVk7QUFDekMsV0FBT0MsZUFBZSxDQUFDLEtBQUtPLE1BQU4sQ0FBdEI7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsU0FBU0MsWUFBVCxDQUFzQk4sSUFBdEIsRUFBNEJPLFFBQTVCLEVBQXNDQyxhQUF0QyxFQUFxREMsS0FBSyxHQUFHLENBQTdELEVBQWdFO0FBQzlELFFBQU1DLEVBQUUsR0FBR1YsSUFBSSxDQUFDUyxLQUFELENBQWY7O0FBQ0EsTUFBSUYsUUFBUSxDQUFDRyxFQUFELENBQVosRUFBa0I7QUFDaEIsV0FBT0EsRUFBUDtBQUNELEdBRkQsTUFFTyxJQUFJQSxFQUFFLEtBQUtGLGFBQVAsSUFBd0IsQ0FBQ0UsRUFBRSxDQUFDQyxhQUFoQyxFQUErQztBQUNwRDtBQUNBO0FBQ0Q7O0FBQ0QsU0FBT0wsWUFBWSxDQUFDTixJQUFELEVBQU9PLFFBQVAsRUFBaUJDLGFBQWpCLEVBQWdDQyxLQUFLLEdBQUcsQ0FBeEMsQ0FBbkI7QUFDRCxDLENBRUQ7OztBQUNPLFNBQVNHLHNCQUFULENBQWdDQyxFQUFoQyxFQUFvQ0MsUUFBcEMsRUFBOEM7QUFDbkQsUUFBTVAsUUFBUSxHQUFHLE9BQU9PLFFBQVAsS0FBb0IsVUFBcEIsR0FBaUNBLFFBQWpDLEdBQTRDSixFQUFFLElBQUlBLEVBQUUsQ0FBQ0ssT0FBSCxDQUFXRCxRQUFYLENBQW5FO0FBQ0EsU0FBT1IsWUFBWSxDQUFDTyxFQUFFLENBQUNoQixZQUFILEVBQUQsRUFBb0JVLFFBQXBCLEVBQThCTSxFQUFFLENBQUNMLGFBQWpDLENBQW5CO0FBQ0QiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGxpc3RlbmVyUmVnaXN0cnkgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9ID0gRXZlbnRUYXJnZXQucHJvdG90eXBlO1xuXG4vLyBSZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgdG8gYSBrZXkgb2JqZWN0XG4vLyBsaXN0ZW5lcnM6IGFycmF5IG9mIGxpc3RlbmVyIGRlZmluaXRpb25zO1xuLy8gICAtIGVhY2ggZGVmaW5pdGlvbiBtdXN0IGJlIGEgZmxhdCBhcnJheSBvZiBldmVudCB0YXJnZXQgYW5kIHRoZSBhcmd1bWVudHNcbi8vICAgICB1c2VkIHRvIGNhbGwgYWRkRXZlbnRMaXN0ZW5lcigpIG9uIHRoZSB0YXJnZXRcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycyhrZXlPYmosIGxpc3RlbmVycykge1xuICBsZXQgcmVnaXN0ZXJlZCA9IGxpc3RlbmVyUmVnaXN0cnkuZ2V0KGtleU9iaik7XG4gIGlmICghcmVnaXN0ZXJlZCkge1xuICAgIHJlZ2lzdGVyZWQgPSBbXTtcbiAgICBsaXN0ZW5lclJlZ2lzdHJ5LnNldChrZXlPYmosIHJlZ2lzdGVyZWQpO1xuICB9XG4gIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCguLi5saXN0ZW5lcik7XG4gICAgcmVnaXN0ZXJlZC5wdXNoKGxpc3RlbmVyKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKGtleU9iaikge1xuICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJSZWdpc3RyeS5nZXQoa2V5T2JqKTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKC4uLmxpc3RlbmVyKTtcbiAgfSk7XG4gIGxpc3RlbmVyUmVnaXN0cnkuZGVsZXRlKGtleU9iaik7XG59XG5cbi8vIEV2ZW50LmNvbXBvc2VkUGF0aCgpIHBvbHlmaWxsIGZvciBFZGdlXG4vLyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rbGVpbmZyZXVuZC9lOTc4N2Q3Mzc3NmMwZTM3NTBkY2ZjZGM4OWYxMDBlY1xuaWYgKCFFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoKSB7XG4gIGNvbnN0IGdldENvbXBvc2VkUGF0aCA9IChub2RlLCBwYXRoID0gW10pID0+IHtcbiAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICBsZXQgcGFyZW50O1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuaG9zdCkgeyAvLyBTaGFkb3dSb290XG4gICAgICBwYXJlbnQgPSBub2RlLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7ICAvLyBEb2N1bWVudFxuICAgICAgcGFyZW50ID0gbm9kZS5kZWZhdWx0VmlldztcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudCA/IGdldENvbXBvc2VkUGF0aChwYXJlbnQsIHBhdGgpIDogcGF0aDtcbiAgfTtcblxuICBFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRDb21wb3NlZFBhdGgodGhpcy50YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRnJvbVBhdGgocGF0aCwgY3JpdGVyaWEsIGN1cnJlbnRUYXJnZXQsIGluZGV4ID0gMCkge1xuICBjb25zdCBlbCA9IHBhdGhbaW5kZXhdO1xuICBpZiAoY3JpdGVyaWEoZWwpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9IGVsc2UgaWYgKGVsID09PSBjdXJyZW50VGFyZ2V0IHx8ICFlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgLy8gc3RvcCB3aGVuIHJlYWNoaW5nIGN1cnJlbnRUYXJnZXQgb3IgPGh0bWw+XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBmaW5kRnJvbVBhdGgocGF0aCwgY3JpdGVyaWEsIGN1cnJlbnRUYXJnZXQsIGluZGV4ICsgMSk7XG59XG5cbi8vIFNlYXJjaCBmb3IgdGhlIGFjdHVhbCB0YXJnZXQgb2YgYSBkZWxlZ2F0ZWQgZXZlbnRcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCBzZWxlY3Rvcikge1xuICBjb25zdCBjcml0ZXJpYSA9IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yIDogZWwgPT4gZWwubWF0Y2hlcyhzZWxlY3Rvcik7XG4gIHJldHVybiBmaW5kRnJvbVBhdGgoZXYuY29tcG9zZWRQYXRoKCksIGNyaXRlcmlhLCBldi5jdXJyZW50VGFyZ2V0KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ Datepicker_Datepicker; });\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/utils.js\nvar utils = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/date.js\nvar lib_date = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/date-format.js\nvar date_format = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/event.js\nvar lib_event = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/i18n/base-locales.js\n// default locales\nconst base_locales_locales = {\n  en: {\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    today: \"Today\",\n    clear: \"Clear\",\n    titleFormat: \"MM y\"\n  }\n};\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/options/defaultOptions.js\n// config options updatable by setOptions() and their default values\nconst defaultOptions = {\n  autohide: false,\n  beforeShowDay: null,\n  beforeShowDecade: null,\n  beforeShowMonth: null,\n  beforeShowYear: null,\n  calendarWeeks: false,\n  clearBtn: false,\n  dateDelimiter: ',',\n  datesDisabled: [],\n  daysOfWeekDisabled: [],\n  daysOfWeekHighlighted: [],\n  defaultViewDate: undefined,\n  // placeholder, defaults to today() by the program\n  disableTouchKeyboard: false,\n  format: 'mm/dd/yyyy',\n  language: 'en',\n  maxDate: null,\n  maxNumberOfDates: 1,\n  maxView: 3,\n  minDate: null,\n  nextArrow: '»',\n  orientation: 'auto',\n  prevArrow: '«',\n  showDaysOfWeek: true,\n  showOnFocus: true,\n  startView: 0,\n  title: '',\n  todayBtn: false,\n  todayBtnMode: 0,\n  todayHighlight: false,\n  weekStart: 0\n};\n/* harmony default export */ var options_defaultOptions = (defaultOptions);\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/lib/dom.js\nconst range = document.createRange();\nfunction parseHTML(html) {\n  return range.createContextualFragment(html);\n} // equivalent to jQuery's :visble\n\nfunction isVisible(el) {\n  return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n}\nfunction hideElement(el) {\n  if (el.style.display === 'none') {\n    return;\n  } // back up the existing display setting in data-style-display\n\n\n  if (el.style.display) {\n    el.dataset.styleDisplay = el.style.display;\n  }\n\n  el.style.display = 'none';\n}\nfunction showElement(el) {\n  if (el.style.display !== 'none') {\n    return;\n  }\n\n  if (el.dataset.styleDisplay) {\n    // restore backed-up dispay property\n    el.style.display = el.dataset.styleDisplay;\n    delete el.dataset.styleDisplay;\n  } else {\n    el.style.display = '';\n  }\n}\nfunction emptyChildNodes(el) {\n  if (el.firstChild) {\n    el.removeChild(el.firstChild);\n    emptyChildNodes(el);\n  }\n}\nfunction replaceChildNodes(el, newChildNodes) {\n  emptyChildNodes(el);\n\n  if (newChildNodes instanceof DocumentFragment) {\n    el.appendChild(newChildNodes);\n  } else if (typeof newChildNodes === 'string') {\n    el.appendChild(parseHTML(newChildNodes));\n  } else if (typeof newChildNodes.forEach === 'function') {\n    newChildNodes.forEach(node => {\n      el.appendChild(node);\n    });\n  }\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/options/processOptions.js\n\n\n\n\n\nconst {\n  language: defaultLang,\n  format: defaultFormat,\n  weekStart: defaultWeekStart\n} = options_defaultOptions; // Reducer function to filter out invalid day-of-week from the input\n\nfunction sanitizeDOW(dow, day) {\n  return dow.length < 6 && day >= 0 && day < 7 ? Object(utils[\"g\" /* pushUnique */])(dow, day) : dow;\n}\n\nfunction calcEndOfWeek(startOfWeek) {\n  return (startOfWeek + 6) % 7;\n} // validate input date. if invalid, fallback to the original value\n\n\nfunction validateDate(value, format, locale, origValue) {\n  const date = Object(date_format[\"b\" /* parseDate */])(value, format, locale);\n  return date !== undefined ? date : origValue;\n} // Validate viewId. if invalid, fallback to the original value\n\n\nfunction validateViewId(value, origValue) {\n  const viewId = parseInt(value, 10);\n  return viewId >= 0 && viewId < 4 ? viewId : origValue;\n} // Create Datepicker configuration to set\n\n\nfunction processOptions(options, datepicker) {\n  const inOpts = Object.assign({}, options);\n  const config = {};\n  const locales = datepicker.constructor.locales;\n  let {\n    format,\n    language,\n    locale,\n    maxDate,\n    maxView,\n    minDate,\n    startView,\n    weekStart\n  } = datepicker.config || {};\n\n  if (inOpts.language) {\n    let lang;\n\n    if (inOpts.language !== language) {\n      if (locales[inOpts.language]) {\n        lang = inOpts.language;\n      } else {\n        // Check if langauge + region tag can fallback to the one without\n        // region (e.g. fr-CA → fr)\n        lang = inOpts.language.split('-')[0];\n\n        if (locales[lang] === undefined) {\n          lang = false;\n        }\n      }\n    }\n\n    delete inOpts.language;\n\n    if (lang) {\n      language = config.language = lang; // update locale as well when updating language\n\n      const origLocale = locale || locales[defaultLang]; // use default language's properties for the fallback\n\n      locale = Object.assign({\n        format: defaultFormat,\n        weekStart: defaultWeekStart\n      }, locales[defaultLang]);\n\n      if (language !== defaultLang) {\n        Object.assign(locale, locales[language]);\n      }\n\n      config.locale = locale; // if format and/or weekStart are the same as old locale's defaults,\n      // update them to new locale's defaults\n\n      if (format === origLocale.format) {\n        format = config.format = locale.format;\n      }\n\n      if (weekStart === origLocale.weekStart) {\n        weekStart = config.weekStart = locale.weekStart;\n        config.weekEnd = calcEndOfWeek(locale.weekStart);\n      }\n    }\n  }\n\n  if (inOpts.format) {\n    const hasToDisplay = typeof inOpts.format.toDisplay === 'function';\n    const hasToValue = typeof inOpts.format.toValue === 'function';\n    const validFormatString = date_format[\"c\" /* reFormatTokens */].test(inOpts.format);\n\n    if (hasToDisplay && hasToValue || validFormatString) {\n      format = config.format = inOpts.format;\n    }\n\n    delete inOpts.format;\n  } //*** dates ***//\n  // while min and maxDate for \"no limit\" in the options are better to be null\n  // (especially when updating), the ones in the config have to be undefined\n  // because null is treated as 0 (= unix epoch) when comparing with time value\n\n\n  let minDt = minDate;\n  let maxDt = maxDate;\n\n  if (inOpts.minDate !== undefined) {\n    minDt = inOpts.minDate === null ? Object(lib_date[\"e\" /* dateValue */])(0, 0, 1) // set 0000-01-01 to prevent negative values for year\n    : validateDate(inOpts.minDate, format, locale, minDt);\n    delete inOpts.minDate;\n  }\n\n  if (inOpts.maxDate !== undefined) {\n    maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);\n    delete inOpts.maxDate;\n  }\n\n  if (maxDt < minDt) {\n    minDate = config.minDate = maxDt;\n    maxDate = config.maxDate = minDt;\n  } else {\n    if (minDate !== minDt) {\n      minDate = config.minDate = minDt;\n    }\n\n    if (maxDate !== maxDt) {\n      maxDate = config.maxDate = maxDt;\n    }\n  }\n\n  if (inOpts.datesDisabled) {\n    config.datesDisabled = inOpts.datesDisabled.reduce((dates, dt) => {\n      const date = Object(date_format[\"b\" /* parseDate */])(dt, format, locale);\n      return date !== undefined ? Object(utils[\"g\" /* pushUnique */])(dates, date) : dates;\n    }, []);\n    delete inOpts.datesDisabled;\n  }\n\n  if (inOpts.defaultViewDate !== undefined) {\n    const viewDate = Object(date_format[\"b\" /* parseDate */])(inOpts.defaultViewDate, format, locale);\n\n    if (viewDate !== undefined) {\n      config.defaultViewDate = viewDate;\n    }\n\n    delete inOpts.defaultViewDate;\n  } //*** days of week ***//\n\n\n  if (inOpts.weekStart !== undefined) {\n    const wkStart = Number(inOpts.weekStart) % 7;\n\n    if (!isNaN(wkStart)) {\n      weekStart = config.weekStart = wkStart;\n      config.weekEnd = calcEndOfWeek(wkStart);\n    }\n\n    delete inOpts.weekStart;\n  }\n\n  if (inOpts.daysOfWeekDisabled) {\n    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);\n    delete inOpts.daysOfWeekDisabled;\n  }\n\n  if (inOpts.daysOfWeekHighlighted) {\n    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);\n    delete inOpts.daysOfWeekHighlighted;\n  } //*** multi date ***//\n\n\n  if (inOpts.maxNumberOfDates !== undefined) {\n    const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);\n\n    if (maxNumberOfDates >= 0) {\n      config.maxNumberOfDates = maxNumberOfDates;\n      config.multidate = maxNumberOfDates !== 1;\n    }\n\n    delete inOpts.maxNumberOfDates;\n  }\n\n  if (inOpts.dateDelimiter) {\n    config.dateDelimiter = String(inOpts.dateDelimiter);\n    delete inOpts.dateDelimiter;\n  } //*** view mode ***//\n\n\n  let newMaxView = maxView;\n\n  if (inOpts.maxView !== undefined) {\n    newMaxView = validateViewId(inOpts.maxView, maxView);\n    delete inOpts.maxView;\n  }\n\n  if (newMaxView !== maxView) {\n    maxView = config.maxView = newMaxView;\n  }\n\n  let newStartView = startView;\n\n  if (inOpts.startView !== undefined) {\n    newStartView = validateViewId(inOpts.startView, newStartView);\n    delete inOpts.startView;\n  } // ensure start view < max\n\n\n  newStartView = maxView < newStartView ? maxView : newStartView;\n\n  if (newStartView !== startView) {\n    config.startView = newStartView;\n  } //*** template ***//\n\n\n  if (inOpts.prevArrow) {\n    const prevArrow = parseHTML(inOpts.prevArrow);\n\n    if (prevArrow.childNodes.length > 0) {\n      config.prevArrow = prevArrow.childNodes;\n    }\n\n    delete inOpts.prevArrow;\n  }\n\n  if (inOpts.nextArrow) {\n    const nextArrow = parseHTML(inOpts.nextArrow);\n\n    if (nextArrow.childNodes.length > 0) {\n      config.nextArrow = nextArrow.childNodes;\n    }\n\n    delete inOpts.nextArrow;\n  } //*** misc ***//\n\n\n  if (inOpts.disableTouchKeyboard !== undefined) {\n    config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;\n    delete inOpts.disableTouchKeyboard;\n  }\n\n  if (inOpts.orientation) {\n    const orientation = inOpts.orientation.toLowerCase().split(/\\s+/g);\n    config.orientation = {\n      x: orientation.find(x => x === 'left' || x === 'right') || 'auto',\n      y: orientation.find(y => y === 'top' || y === 'bottom') || 'auto'\n    };\n    delete inOpts.orientation;\n  }\n\n  if (inOpts.todayBtnMode !== undefined) {\n    switch (inOpts.todayBtnMode) {\n      case 0:\n      case 1:\n        config.todayBtnMode = inOpts.todayBtnMode;\n    }\n\n    delete inOpts.todayBtnMode;\n  } //*** copy the rest ***//\n\n\n  Object.keys(inOpts).forEach(key => {\n    if (inOpts[key] !== undefined && Object(utils[\"b\" /* hasProperty */])(options_defaultOptions, key)) {\n      config[key] = inOpts[key];\n    }\n  });\n  return config;\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/templates/pickerTemplate.js\n\nconst pickerTemplate = Object(utils[\"f\" /* optimizeTemplateHTML */])(`<div class=\"datepicker\">\n  <div class=\"datepicker-picker\">\n    <div class=\"datepicker-header\">\n      <div class=\"datepicker-title\"></div>\n      <div class=\"datepicker-controls\">\n        <button class=\"%buttonClass% prev-btn\"></button>\n        <button class=\"%buttonClass% view-switch\"></button>\n        <button class=\"%buttonClass% next-btn\"></button>\n      </div>\n    </div>\n    <div class=\"datepicker-main\"></div>\n    <div class=\"datepicker-footer\">\n      <div class=\"datepicker-controls\">\n        <button class=\"%buttonClass% today-btn\"></button>\n        <button class=\"%buttonClass% clear-btn\"></button>\n      </div>\n    </div>\n  </div>\n</div>`);\n/* harmony default export */ var templates_pickerTemplate = (pickerTemplate);\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/templates/daysTemplate.js\n\nconst daysTemplate = Object(utils[\"f\" /* optimizeTemplateHTML */])(`<div class=\"days\">\n  <div class=\"days-of-week\">${Object(utils[\"a\" /* createTagRepeat */])('span', 7, {\n  class: 'dow'\n})}</div>\n  <div class=\"datepicker-grid\">${Object(utils[\"a\" /* createTagRepeat */])('span', 42)}</div>\n</div>`);\n/* harmony default export */ var templates_daysTemplate = (daysTemplate);\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/templates/calendarWeeksTemplate.js\n\nconst calendarWeeksTemplate = Object(utils[\"f\" /* optimizeTemplateHTML */])(`<div class=\"calendar-weeks\">\n  <div class=\"days-of-week\"><span class=\"dow\"></span></div>\n  <div class=\"weeks\">${Object(utils[\"a\" /* createTagRepeat */])('span', 6, {\n  class: 'week'\n})}</div>\n</div>`);\n/* harmony default export */ var templates_calendarWeeksTemplate = (calendarWeeksTemplate);\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/views/View.js\n\n // Base class of the view classes\n\nclass View_View {\n  constructor(picker, config) {\n    Object.assign(this, config, {\n      picker,\n      element: parseHTML(`<div class=\"datepicker-view\"></div>`).firstChild,\n      selected: []\n    });\n    this.init(this.picker.datepicker.config);\n  }\n\n  init(options) {\n    this.setOptions(options);\n    this.updateFocus();\n    this.updateSelection();\n  } // Execute beforeShow() callback and apply the result to the element\n  // args:\n  // - current - current value on the iteration on view rendering\n  // - timeValue - time value of the date to pass to beforeShow()\n\n\n  performBeforeHook(el, current, timeValue) {\n    let result = this.beforeShow(new Date(timeValue));\n\n    switch (typeof result) {\n      case 'boolean':\n        result = {\n          enabled: result\n        };\n        break;\n\n      case 'string':\n        result = {\n          classes: result\n        };\n    }\n\n    if (result) {\n      if (result.enabled === false) {\n        el.classList.add('disabled');\n        Object(utils[\"g\" /* pushUnique */])(this.disabled, current);\n      }\n\n      if (result.classes) {\n        const extraClasses = result.classes.split(/\\s+/);\n        el.classList.add(...extraClasses);\n\n        if (extraClasses.includes('disabled')) {\n          Object(utils[\"g\" /* pushUnique */])(this.disabled, current);\n        }\n      }\n\n      if (result.content) {\n        replaceChildNodes(el, result.content);\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/views/DaysView.js\n\n\n\n\n\n\n\nclass DaysView_DaysView extends View_View {\n  constructor(picker) {\n    super(picker, {\n      id: 0,\n      name: 'days',\n      cellClass: 'day'\n    });\n  }\n\n  init(options, onConstruction = true) {\n    if (onConstruction) {\n      const inner = parseHTML(templates_daysTemplate).firstChild;\n      this.dow = inner.firstChild;\n      this.grid = inner.lastChild;\n      this.element.appendChild(inner);\n    }\n\n    super.init(options);\n  }\n\n  setOptions(options) {\n    let updateDOW;\n\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'minDate')) {\n      this.minDate = options.minDate;\n    }\n\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'maxDate')) {\n      this.maxDate = options.maxDate;\n    }\n\n    if (options.datesDisabled) {\n      this.datesDisabled = options.datesDisabled;\n    }\n\n    if (options.daysOfWeekDisabled) {\n      this.daysOfWeekDisabled = options.daysOfWeekDisabled;\n      updateDOW = true;\n    }\n\n    if (options.daysOfWeekHighlighted) {\n      this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;\n    }\n\n    if (options.todayHighlight !== undefined) {\n      this.todayHighlight = options.todayHighlight;\n    }\n\n    if (options.weekStart !== undefined) {\n      this.weekStart = options.weekStart;\n      this.weekEnd = options.weekEnd;\n      updateDOW = true;\n    }\n\n    if (options.locale) {\n      const locale = this.locale = options.locale;\n      this.dayNames = locale.daysMin;\n      this.switchLabelFormat = locale.titleFormat;\n      this.switchLabel = Object(date_format[\"a\" /* formatDate */])(this.picker.viewDate, locale.titleFormat, locale);\n      updateDOW = true;\n    }\n\n    if (options.beforeShowDay !== undefined) {\n      this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;\n    }\n\n    if (options.calendarWeeks !== undefined) {\n      if (options.calendarWeeks && !this.calendarWeeks) {\n        const weeksElem = parseHTML(templates_calendarWeeksTemplate).firstChild;\n        this.calendarWeeks = {\n          element: weeksElem,\n          dow: weeksElem.firstChild,\n          weeks: weeksElem.lastChild\n        };\n        this.element.insertBefore(weeksElem, this.element.firstChild);\n      } else if (this.calendarWeeks && !options.calendarWeeks) {\n        this.element.removeChild(this.calendarWeeks.element);\n        this.calendarWeeks = null;\n      }\n    }\n\n    if (options.showDaysOfWeek !== undefined) {\n      if (options.showDaysOfWeek) {\n        showElement(this.dow);\n\n        if (this.calendarWeeks) {\n          showElement(this.calendarWeeks.dow);\n        }\n      } else {\n        hideElement(this.dow);\n\n        if (this.calendarWeeks) {\n          hideElement(this.calendarWeeks.dow);\n        }\n      }\n    } // update days-of-week when locale, daysOfweekDisabled or weekStart is changed\n\n\n    if (updateDOW) {\n      Array.from(this.dow.children).forEach((el, index) => {\n        const dow = (this.weekStart + index) % 7;\n        el.textContent = this.dayNames[dow];\n        el.className = this.daysOfWeekDisabled.includes(dow) ? 'dow disabled' : 'dow';\n      });\n    }\n  } // Apply update on the focused date to view's settings\n\n\n  updateFocus() {\n    const viewDate = new Date(this.picker.viewDate);\n    const viewYear = viewDate.getFullYear();\n    const viewMonth = viewDate.getMonth();\n    const firstOfMonth = Object(lib_date[\"e\" /* dateValue */])(viewYear, viewMonth, 1);\n    const start = Object(lib_date[\"f\" /* dayOfTheWeekOf */])(firstOfMonth, this.weekStart, this.weekStart);\n    this.first = firstOfMonth;\n    this.last = Object(lib_date[\"e\" /* dateValue */])(viewYear, viewMonth + 1, 0);\n    this.start = start;\n    this.switchLabel = Object(date_format[\"a\" /* formatDate */])(viewDate, this.switchLabelFormat, this.locale);\n    this.focused = this.picker.viewDate;\n  } // Apply update on the selected dates to view's settings\n\n\n  updateSelection() {\n    const {\n      dates,\n      range\n    } = this.picker.datepicker;\n    this.selected = dates;\n    this.range = range;\n  } // Update the entire view UI\n\n\n  render() {\n    // update today marker on ever render\n    this.today = this.todayHighlight ? Object(lib_date[\"j\" /* today */])() : undefined; // refresh disabled dates on every render in order to clear the ones added\n    // by beforeShow hook at previous render\n\n    this.disabled = [...this.datesDisabled];\n    this.picker.setViewSwitchLabel(this.switchLabel);\n    this.picker.setPrevBtnDisabled(this.first <= this.minDate);\n    this.picker.setNextBtnDisabled(this.last >= this.maxDate);\n\n    if (this.calendarWeeks) {\n      // start of the UTC week (Monday) of the 1st of the month\n      const startOfWeek = Object(lib_date[\"f\" /* dayOfTheWeekOf */])(this.first, 1, 1);\n      Array.from(this.calendarWeeks.weeks.children).forEach((el, index) => {\n        el.textContent = Object(lib_date[\"g\" /* getWeek */])(Object(lib_date[\"c\" /* addWeeks */])(startOfWeek, index));\n      });\n    }\n\n    Array.from(this.grid.children).forEach((el, index) => {\n      const classList = el.classList;\n      const current = Object(lib_date[\"a\" /* addDays */])(this.start, index);\n      const date = new Date(current);\n      const day = date.getDay();\n      el.className = `datepicker-cell ${this.cellClass}`;\n      el.dataset.date = current;\n      el.textContent = date.getDate();\n\n      if (current < this.first) {\n        classList.add('prev');\n      } else if (current > this.last) {\n        classList.add('next');\n      }\n\n      if (this.today === current) {\n        classList.add('today');\n      }\n\n      if (current < this.minDate || current > this.maxDate || this.disabled.includes(current)) {\n        classList.add('disabled');\n      }\n\n      if (this.daysOfWeekDisabled.includes(day)) {\n        classList.add('disabled');\n        Object(utils[\"g\" /* pushUnique */])(this.disabled, current);\n      }\n\n      if (this.daysOfWeekHighlighted.includes(day)) {\n        classList.add('highlighted');\n      }\n\n      if (this.range) {\n        const [rangeStart, rangeEnd] = this.range;\n\n        if (current > rangeStart && current < rangeEnd) {\n          classList.add('range');\n        }\n\n        if (current === rangeStart) {\n          classList.add('range-start');\n        }\n\n        if (current === rangeEnd) {\n          classList.add('range-end');\n        }\n      }\n\n      if (this.selected.includes(current)) {\n        classList.add('selected');\n      }\n\n      if (current === this.focused) {\n        classList.add('focused');\n      }\n\n      if (this.beforeShow) {\n        this.performBeforeHook(el, current, current);\n      }\n    });\n  } // Update the view UI by applying the changes of selected and focused items\n\n\n  refresh() {\n    const [rangeStart, rangeEnd] = this.range || [];\n    this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(el => {\n      el.classList.remove('range', 'range-start', 'range-end', 'selected', 'focused');\n    });\n    Array.from(this.grid.children).forEach(el => {\n      const current = Number(el.dataset.date);\n      const classList = el.classList;\n\n      if (current > rangeStart && current < rangeEnd) {\n        classList.add('range');\n      }\n\n      if (current === rangeStart) {\n        classList.add('range-start');\n      }\n\n      if (current === rangeEnd) {\n        classList.add('range-end');\n      }\n\n      if (this.selected.includes(current)) {\n        classList.add('selected');\n      }\n\n      if (current === this.focused) {\n        classList.add('focused');\n      }\n    });\n  } // Update the view UI by applying the change of focused item\n\n\n  refreshFocus() {\n    const index = Math.round((this.focused - this.start) / 86400000);\n    this.grid.querySelectorAll('.focused').forEach(el => {\n      el.classList.remove('focused');\n    });\n    this.grid.children[index].classList.add('focused');\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/views/MonthsView.js\n\n\n\n\nclass MonthsView_MonthsView extends View_View {\n  constructor(picker) {\n    super(picker, {\n      id: 1,\n      name: 'months',\n      cellClass: 'month'\n    });\n  }\n\n  init(options, onConstruction = true) {\n    if (onConstruction) {\n      this.grid = this.element;\n      this.element.classList.add('months', 'datepicker-grid');\n      this.grid.appendChild(parseHTML(Object(utils[\"a\" /* createTagRepeat */])('span', 12, {\n        'data-month': ix => ix\n      })));\n    }\n\n    super.init(options);\n  }\n\n  setOptions(options) {\n    if (options.locale) {\n      this.monthNames = options.locale.monthsShort;\n    }\n\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'minDate')) {\n      if (options.minDate === undefined) {\n        this.minYear = this.minMonth = this.minDate = undefined;\n      } else {\n        const minDateObj = new Date(options.minDate);\n        this.minYear = minDateObj.getFullYear();\n        this.minMonth = minDateObj.getMonth();\n        this.minDate = minDateObj.setDate(1);\n      }\n    }\n\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'maxDate')) {\n      if (options.maxDate === undefined) {\n        this.maxYear = this.maxMonth = this.maxDate = undefined;\n      } else {\n        const maxDateObj = new Date(options.maxDate);\n        this.maxYear = maxDateObj.getFullYear();\n        this.maxMonth = maxDateObj.getMonth();\n        this.maxDate = Object(lib_date[\"e\" /* dateValue */])(this.maxYear, this.maxMonth + 1, 0);\n      }\n    }\n\n    if (options.beforeShowMonth !== undefined) {\n      this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;\n    }\n  } // Update view's settings to reflect the viewDate set on the picker\n\n\n  updateFocus() {\n    const viewDate = new Date(this.picker.viewDate);\n    this.year = viewDate.getFullYear();\n    this.switchLabel = this.year;\n    this.focused = viewDate.getMonth();\n  } // Update view's settings to reflect the selected dates\n\n\n  updateSelection() {\n    this.selected = this.picker.datepicker.dates.reduce((selected, timeValue) => {\n      const date = new Date(timeValue);\n      const year = date.getFullYear();\n      const month = date.getMonth();\n\n      if (selected[year] === undefined) {\n        selected[year] = [month];\n      } else {\n        Object(utils[\"g\" /* pushUnique */])(selected[year], month);\n      }\n\n      return selected;\n    }, {});\n  } // Update the entire view UI\n\n\n  render() {\n    // refresh disabled months on every render in order to clear the ones added\n    // by beforeShow hook at previous render\n    this.disabled = [];\n    this.picker.setViewSwitchLabel(this.switchLabel);\n    this.picker.setPrevBtnDisabled(this.year <= this.minYear);\n    this.picker.setNextBtnDisabled(this.year >= this.maxYear);\n    const selected = this.selected[this.year] || [];\n    const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;\n    const isMinYear = this.year === this.minYear;\n    const isMaxYear = this.year === this.maxYear;\n    Array.from(this.grid.children).forEach((el, index) => {\n      const classList = el.classList;\n      el.className = `datepicker-cell ${this.cellClass}`; // reset text on every render to clear the custom content set\n      // by beforeShow hook at previous render\n\n      el.textContent = this.monthNames[index];\n\n      if (yrOutOfRange || isMinYear && index < this.minMonth || isMaxYear && index > this.maxMonth) {\n        classList.add('disabled');\n      }\n\n      if (selected.includes(index)) {\n        classList.add('selected');\n      }\n\n      if (index === this.focused) {\n        classList.add('focused');\n      }\n\n      if (this.beforeShow) {\n        this.performBeforeHook(el, index, Object(lib_date[\"e\" /* dateValue */])(this.year, index, 1));\n      }\n    });\n  } // Update the view UI by applying the changes of selected and focused items\n\n\n  refresh() {\n    const selected = this.selected[this.year] || [];\n    this.grid.querySelectorAll('.selected, .focused').forEach(el => {\n      el.classList.remove('selected', 'focused');\n    });\n    Array.from(this.grid.children).forEach((el, index) => {\n      const classList = el.classList;\n\n      if (selected.includes(index)) {\n        classList.add('selected');\n      }\n\n      if (index === this.focused) {\n        classList.add('focused');\n      }\n    });\n  } // Update the view UI by applying the change of focused item\n\n\n  refreshFocus() {\n    this.grid.querySelectorAll('.focused').forEach(el => {\n      el.classList.remove('focused');\n    });\n    this.grid.children[this.focused].classList.add('focused');\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/views/YearsView.js\n\n\n\n\n\nfunction toTitleCase(word) {\n  return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), '');\n} // Class representing the years and decades view elements\n\n\nclass YearsView_YearsView extends View_View {\n  constructor(picker, config) {\n    super(picker, config);\n  }\n\n  init(options, onConstruction = true) {\n    if (onConstruction) {\n      this.navStep = this.step * 10;\n      this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;\n      this.grid = this.element;\n      this.element.classList.add(this.name, 'datepicker-grid');\n      this.grid.appendChild(parseHTML(Object(utils[\"a\" /* createTagRepeat */])('span', 12)));\n    }\n\n    super.init(options);\n  }\n\n  setOptions(options) {\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'minDate')) {\n      if (options.minDate === undefined) {\n        this.minYear = this.minDate = undefined;\n      } else {\n        this.minYear = Object(lib_date[\"h\" /* startOfYearPeriod */])(options.minDate, this.step);\n        this.minDate = Object(lib_date[\"e\" /* dateValue */])(this.minYear, 0, 1);\n      }\n    }\n\n    if (Object(utils[\"b\" /* hasProperty */])(options, 'maxDate')) {\n      if (options.maxDate === undefined) {\n        this.maxYear = this.maxDate = undefined;\n      } else {\n        this.maxYear = Object(lib_date[\"h\" /* startOfYearPeriod */])(options.maxDate, this.step);\n        this.maxDate = Object(lib_date[\"e\" /* dateValue */])(this.maxYear, 11, 31);\n      }\n    }\n\n    if (options[this.beforeShowOption] !== undefined) {\n      const beforeShow = options[this.beforeShowOption];\n      this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;\n    }\n  } // Update view's settings to reflect the viewDate set on the picker\n\n\n  updateFocus() {\n    const viewDate = new Date(this.picker.viewDate);\n    const first = Object(lib_date[\"h\" /* startOfYearPeriod */])(viewDate, this.navStep);\n    const last = first + 9 * this.step;\n    this.first = first;\n    this.last = last;\n    this.start = first - this.step;\n    this.switchLabel = `${first}-${last}`;\n    this.focused = Object(lib_date[\"h\" /* startOfYearPeriod */])(viewDate, this.step);\n  } // Update view's settings to reflect the selected dates\n\n\n  updateSelection() {\n    this.selected = this.picker.datepicker.dates.reduce((years, timeValue) => {\n      return Object(utils[\"g\" /* pushUnique */])(years, Object(lib_date[\"h\" /* startOfYearPeriod */])(timeValue, this.step));\n    }, []);\n  } // Update the entire view UI\n\n\n  render() {\n    // refresh disabled years on every render in order to clear the ones added\n    // by beforeShow hook at previous render\n    this.disabled = [];\n    this.picker.setViewSwitchLabel(this.switchLabel);\n    this.picker.setPrevBtnDisabled(this.first <= this.minYear);\n    this.picker.setNextBtnDisabled(this.last >= this.maxYear);\n    Array.from(this.grid.children).forEach((el, index) => {\n      const classList = el.classList;\n      const current = this.start + index * this.step;\n      el.className = `datepicker-cell ${this.cellClass}`;\n      el.textContent = el.dataset.year = current;\n\n      if (index === 0) {\n        classList.add('prev');\n      } else if (index === 11) {\n        classList.add('next');\n      }\n\n      if (current < this.minYear || current > this.maxYear) {\n        classList.add('disabled');\n      }\n\n      if (this.selected.includes(current)) {\n        classList.add('selected');\n      }\n\n      if (current === this.focused) {\n        classList.add('focused');\n      }\n\n      if (this.beforeShow) {\n        this.performBeforeHook(el, current, Object(lib_date[\"e\" /* dateValue */])(current, 0, 1));\n      }\n    });\n  } // Update the view UI by applying the changes of selected and focused items\n\n\n  refresh() {\n    this.grid.querySelectorAll('.selected, .focused').forEach(el => {\n      el.classList.remove('selected', 'focused');\n    });\n    Array.from(this.grid.children).forEach(el => {\n      const current = Number(el.textContent);\n      const classList = el.classList;\n\n      if (this.selected.includes(current)) {\n        classList.add('selected');\n      }\n\n      if (current === this.focused) {\n        classList.add('focused');\n      }\n    });\n  } // Update the view UI by applying the change of focused item\n\n\n  refreshFocus() {\n    const index = Math.round((this.focused - this.start) / this.step);\n    this.grid.querySelectorAll('.focused').forEach(el => {\n      el.classList.remove('focused');\n    });\n    this.grid.children[index].classList.add('focused');\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/events/functions.js\n\n\nfunction triggerDatepickerEvent(datepicker, type) {\n  const detail = {\n    date: datepicker.getDate(),\n    viewDate: new Date(datepicker.picker.viewDate),\n    viewId: datepicker.picker.currentView.id,\n    datepicker\n  };\n  datepicker.element.dispatchEvent(new CustomEvent(type, {\n    detail\n  }));\n} // direction: -1 (to previous), 1 (to next)\n\nfunction goToPrevOrNext(datepicker, direction) {\n  const {\n    minDate,\n    maxDate\n  } = datepicker.config;\n  const {\n    currentView,\n    viewDate\n  } = datepicker.picker;\n  let newViewDate;\n\n  switch (currentView.id) {\n    case 0:\n      newViewDate = Object(lib_date[\"b\" /* addMonths */])(viewDate, direction);\n      break;\n\n    case 1:\n      newViewDate = Object(lib_date[\"d\" /* addYears */])(viewDate, direction);\n      break;\n\n    default:\n      newViewDate = Object(lib_date[\"d\" /* addYears */])(viewDate, direction * currentView.navStep);\n  }\n\n  newViewDate = Object(utils[\"e\" /* limitToRange */])(newViewDate, minDate, maxDate);\n  datepicker.picker.changeFocus(newViewDate).render();\n}\nfunction switchView(datepicker) {\n  const viewId = datepicker.picker.currentView.id;\n\n  if (viewId === datepicker.config.maxView) {\n    return;\n  }\n\n  datepicker.picker.changeView(viewId + 1).render();\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/events/pickerListeners.js\n\n\n\n\nfunction goToSelectedMonthOrYear(datepicker, selection) {\n  const picker = datepicker.picker;\n  const viewDate = new Date(picker.viewDate);\n  const viewId = picker.currentView.id;\n  const newDate = viewId === 1 ? Object(lib_date[\"b\" /* addMonths */])(viewDate, selection - viewDate.getMonth()) : Object(lib_date[\"d\" /* addYears */])(viewDate, selection - viewDate.getFullYear());\n  picker.changeFocus(newDate).changeView(viewId - 1).render();\n}\n\nfunction onClickTodayBtn(datepicker) {\n  const picker = datepicker.picker;\n  const currentDate = Object(lib_date[\"j\" /* today */])();\n\n  if (datepicker.config.todayBtnMode === 1) {\n    if (datepicker.config.autohide) {\n      datepicker.setDate(currentDate);\n      return;\n    }\n\n    datepicker.setDate(currentDate, {\n      render: false\n    });\n    picker.update();\n  }\n\n  if (picker.viewDate !== currentDate) {\n    picker.changeFocus(currentDate);\n  }\n\n  picker.changeView(0).render();\n}\nfunction onClickClearBtn(datepicker) {\n  datepicker.setDate({\n    clear: true\n  });\n}\nfunction onClickViewSwitch(datepicker) {\n  switchView(datepicker);\n}\nfunction onClickPrevBtn(datepicker) {\n  goToPrevOrNext(datepicker, -1);\n}\nfunction onClickNextBtn(datepicker) {\n  goToPrevOrNext(datepicker, 1);\n} // For the picker's main block to delegete the events from `datepicker-cell`s\n\nfunction onClickView(datepicker, ev) {\n  const target = Object(lib_event[\"a\" /* findElementInEventPath */])(ev, '.datepicker-cell');\n\n  if (!target || target.classList.contains('disabled')) {\n    return;\n  }\n\n  switch (datepicker.picker.currentView.id) {\n    case 0:\n      datepicker.setDate(Number(target.dataset.date));\n      break;\n\n    case 1:\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));\n      break;\n\n    default:\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));\n  }\n}\nfunction onClickPicker(datepicker, ev) {\n  ev.preventDefault();\n  ev.stopPropagation(); // check if the picker is active in order to prevent the picker from being\n  // re-shown after auto-hide when showOnFocus: true\n  // it's caused by bubbled event from cells/buttons, but the bubbling cannot\n  // be disabled because it's needed to keep the focus on the input element\n\n  if (!datepicker.inline && datepicker.picker.active && !datepicker.config.disableTouchKeyboard) {\n    datepicker.inputField.focus();\n  }\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/picker/Picker.js\n\n\n\n\n\n\n\n\n\n\n\nfunction processPickerOptions(picker, options) {\n  if (options.title !== undefined) {\n    if (options.title) {\n      picker.controls.title.textContent = options.title;\n      showElement(picker.controls.title);\n    } else {\n      picker.controls.title.textContent = '';\n      hideElement(picker.controls.title);\n    }\n  }\n\n  if (options.prevArrow) {\n    const prevBtn = picker.controls.prevBtn;\n    emptyChildNodes(prevBtn);\n    options.prevArrow.forEach(node => {\n      prevBtn.appendChild(node.cloneNode(true));\n    });\n  }\n\n  if (options.nextArrow) {\n    const nextBtn = picker.controls.nextBtn;\n    emptyChildNodes(nextBtn);\n    options.nextArrow.forEach(node => {\n      nextBtn.appendChild(node.cloneNode(true));\n    });\n  }\n\n  if (options.locale) {\n    picker.controls.todayBtn.textContent = options.locale.today;\n    picker.controls.clearBtn.textContent = options.locale.clear;\n  }\n\n  if (options.todayBtn !== undefined) {\n    if (options.todayBtn) {\n      showElement(picker.controls.todayBtn);\n    } else {\n      hideElement(picker.controls.todayBtn);\n    }\n  }\n\n  if (Object(utils[\"b\" /* hasProperty */])(options, 'minDate') || Object(utils[\"b\" /* hasProperty */])(options, 'maxDate')) {\n    const {\n      minDate,\n      maxDate\n    } = picker.datepicker.config;\n    picker.controls.todayBtn.disabled = !Object(utils[\"c\" /* isInRange */])(Object(lib_date[\"j\" /* today */])(), minDate, maxDate);\n  }\n\n  if (options.clearBtn !== undefined) {\n    if (options.clearBtn) {\n      showElement(picker.controls.clearBtn);\n    } else {\n      hideElement(picker.controls.clearBtn);\n    }\n  }\n} // Compute view date to reset, which will be...\n// - the last item of the selected dates or defaultViewDate if no selection\n// - limitted to minDate or maxDate if it exceeds the range\n\n\nfunction computeResetViewDate(datepicker) {\n  const {\n    dates,\n    config\n  } = datepicker;\n  const viewDate = dates.length > 0 ? Object(utils[\"d\" /* lastItemOf */])(dates) : config.defaultViewDate;\n  return Object(utils[\"e\" /* limitToRange */])(viewDate, config.minDate, config.maxDate);\n} // Change current view's view date\n\n\nfunction setViewDate(picker, newDate) {\n  const oldViewDate = new Date(picker.viewDate);\n  const newViewDate = new Date(newDate);\n  const {\n    id,\n    year,\n    first,\n    last\n  } = picker.currentView;\n  const viewYear = newViewDate.getFullYear();\n  picker.viewDate = newDate;\n\n  if (viewYear !== oldViewDate.getFullYear()) {\n    triggerDatepickerEvent(picker.datepicker, 'changeYear');\n  }\n\n  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {\n    triggerDatepickerEvent(picker.datepicker, 'changeMonth');\n  } // return whether the new date is in different period on time from the one\n  // displayed in the current view\n  // when true, the view needs to be re-rendered on the next UI refresh.\n\n\n  switch (id) {\n    case 0:\n      return newDate < first || newDate > last;\n\n    case 1:\n      return viewYear !== year;\n\n    default:\n      return viewYear < first || viewYear > last;\n  }\n}\n\nfunction getTextDirection(el) {\n  return window.getComputedStyle(el).direction;\n} // Class representing the picker UI\n\n\nclass Picker_Picker {\n  constructor(datepicker) {\n    this.datepicker = datepicker;\n    const template = templates_pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);\n    const element = this.element = parseHTML(template).firstChild;\n    const [header, main, footer] = element.firstChild.children;\n    const title = header.firstElementChild;\n    const [prevBtn, viewSwitch, nextBtn] = header.lastElementChild.children;\n    const [todayBtn, clearBtn] = footer.firstChild.children;\n    const controls = {\n      title,\n      prevBtn,\n      viewSwitch,\n      nextBtn,\n      todayBtn,\n      clearBtn\n    };\n    this.main = main;\n    this.controls = controls;\n    const elementClass = datepicker.inline ? 'inline' : 'dropdown';\n    element.classList.add(`datepicker-${elementClass}`);\n    processPickerOptions(this, datepicker.config);\n    this.viewDate = computeResetViewDate(datepicker); // set up event listeners\n\n    Object(lib_event[\"b\" /* registerListeners */])(datepicker, [[element, 'click', onClickPicker.bind(null, datepicker)], [main, 'click', onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, 'click', onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, 'click', onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, 'click', onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, 'click', onClickClearBtn.bind(null, datepicker)]]); // set up views\n\n    this.views = [new DaysView_DaysView(this), new MonthsView_MonthsView(this), new YearsView_YearsView(this, {\n      id: 2,\n      name: 'years',\n      cellClass: 'year',\n      step: 1\n    }), new YearsView_YearsView(this, {\n      id: 3,\n      name: 'decades',\n      cellClass: 'decade',\n      step: 10\n    })];\n    this.currentView = this.views[datepicker.config.startView];\n    this.currentView.render();\n    this.main.appendChild(this.currentView.element);\n    datepicker.config.container.appendChild(this.element);\n  }\n\n  setOptions(options) {\n    processPickerOptions(this, options);\n    this.views.forEach(view => {\n      view.init(options, false);\n    });\n    this.currentView.render();\n  }\n\n  detach() {\n    this.datepicker.config.container.removeChild(this.element);\n  }\n\n  show() {\n    if (this.active) {\n      return;\n    }\n\n    this.element.classList.add('active');\n    this.active = true;\n    const datepicker = this.datepicker;\n\n    if (!datepicker.inline) {\n      // ensure picker's direction matches input's\n      const inputDirection = getTextDirection(datepicker.inputField);\n\n      if (inputDirection !== getTextDirection(datepicker.config.container)) {\n        this.element.dir = inputDirection;\n      } else if (this.element.dir) {\n        this.element.removeAttribute('dir');\n      }\n\n      this.place();\n\n      if (datepicker.config.disableTouchKeyboard) {\n        datepicker.inputField.blur();\n      }\n    }\n\n    triggerDatepickerEvent(datepicker, 'show');\n  }\n\n  hide() {\n    if (!this.active) {\n      return;\n    }\n\n    this.datepicker.exitEditMode();\n    this.element.classList.remove('active');\n    this.active = false;\n    triggerDatepickerEvent(this.datepicker, 'hide');\n  }\n\n  place() {\n    const {\n      classList,\n      style\n    } = this.element;\n    const {\n      config,\n      inputField\n    } = this.datepicker;\n    const container = config.container;\n    const {\n      width: calendarWidth,\n      height: calendarHeight\n    } = this.element.getBoundingClientRect();\n    const {\n      left: containerLeft,\n      top: containerTop,\n      width: containerWidth\n    } = container.getBoundingClientRect();\n    const {\n      left: inputLeft,\n      top: inputTop,\n      width: inputWidth,\n      height: inputHeight\n    } = inputField.getBoundingClientRect();\n    let {\n      x: orientX,\n      y: orientY\n    } = config.orientation;\n    let scrollTop;\n    let left;\n    let top;\n\n    if (container === document.body) {\n      scrollTop = window.scrollY;\n      left = inputLeft + window.scrollX;\n      top = inputTop + scrollTop;\n    } else {\n      scrollTop = container.scrollTop;\n      left = inputLeft - containerLeft;\n      top = inputTop - containerTop + scrollTop;\n    }\n\n    if (orientX === 'auto') {\n      if (left < 0) {\n        // align to the left and move into visible area if input's left edge < window's\n        orientX = 'left';\n        left = 10;\n      } else if (left + calendarWidth > containerWidth) {\n        // align to the right if canlendar's right edge > container's\n        orientX = 'right';\n      } else {\n        orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';\n      }\n    }\n\n    if (orientX === 'right') {\n      left -= calendarWidth - inputWidth;\n    }\n\n    if (orientY === 'auto') {\n      orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';\n    }\n\n    if (orientY === 'top') {\n      top -= calendarHeight;\n    } else {\n      top += inputHeight;\n    }\n\n    classList.remove('datepicker-orient-top', 'datepicker-orient-bottom', 'datepicker-orient-right', 'datepicker-orient-left');\n    classList.add(`datepicker-orient-${orientY}`, `datepicker-orient-${orientX}`);\n    style.top = top ? `${top}px` : top;\n    style.left = left ? `${left}px` : left;\n  }\n\n  setViewSwitchLabel(labelText) {\n    this.controls.viewSwitch.textContent = labelText;\n  }\n\n  setPrevBtnDisabled(disabled) {\n    this.controls.prevBtn.disabled = disabled;\n  }\n\n  setNextBtnDisabled(disabled) {\n    this.controls.nextBtn.disabled = disabled;\n  }\n\n  changeView(viewId) {\n    const oldView = this.currentView;\n    const newView = this.views[viewId];\n\n    if (newView.id !== oldView.id) {\n      this.currentView = newView;\n      this._renderMethod = 'render';\n      triggerDatepickerEvent(this.datepicker, 'changeView');\n      this.main.replaceChild(newView.element, oldView.element);\n    }\n\n    return this;\n  } // Change the focused date (view date)\n\n\n  changeFocus(newViewDate) {\n    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';\n    this.views.forEach(view => {\n      view.updateFocus();\n    });\n    return this;\n  } // Apply the change of the selected dates\n\n\n  update() {\n    const newViewDate = computeResetViewDate(this.datepicker);\n    this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';\n    this.views.forEach(view => {\n      view.updateFocus();\n      view.updateSelection();\n    });\n    return this;\n  } // Refresh the picker UI\n\n\n  render() {\n    const renderMethod = this._renderMethod || 'render';\n    delete this._renderMethod;\n    this.currentView[renderMethod]();\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/events/inputFieldListeners.js\n\n\n // Find the closest date that doesn't meet the condition for unavailable date\n// Returns undefined if no available date is found\n// addFn: function to calculate the next date\n//   - args: time value, amount\n// increase: amount to pass to addFn\n// testFn: function to test the unavailablity of the date\n//   - args: time value; retun: true if unavailable\n\nfunction findNextAvailableOne(date, addFn, increase, testFn, min, max) {\n  if (!Object(utils[\"c\" /* isInRange */])(date, min, max)) {\n    return;\n  }\n\n  if (testFn(date)) {\n    const newDate = addFn(date, increase);\n    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);\n  }\n\n  return date;\n} // direction: -1 (left/up), 1 (right/down)\n// vertical: true for up/down, false for left/right\n\n\nfunction moveByArrowKey(datepicker, ev, direction, vertical) {\n  const currentView = datepicker.picker.currentView;\n  const step = currentView.step || 1;\n  let viewDate = datepicker.picker.viewDate;\n  let addFn;\n  let testFn;\n\n  switch (currentView.id) {\n    case 0:\n      if (vertical) {\n        viewDate = Object(lib_date[\"a\" /* addDays */])(viewDate, direction * 7);\n      } else if (ev.ctrlKey || ev.metaKey) {\n        viewDate = Object(lib_date[\"d\" /* addYears */])(viewDate, direction);\n      } else {\n        viewDate = Object(lib_date[\"a\" /* addDays */])(viewDate, direction);\n      }\n\n      addFn = lib_date[\"a\" /* addDays */];\n\n      testFn = date => currentView.disabled.includes(date);\n\n      break;\n\n    case 1:\n      viewDate = Object(lib_date[\"b\" /* addMonths */])(viewDate, vertical ? direction * 4 : direction);\n      addFn = lib_date[\"b\" /* addMonths */];\n\n      testFn = date => {\n        const dt = new Date(date);\n        const {\n          year,\n          disabled\n        } = currentView;\n        return dt.getFullYear() === year && disabled.includes(dt.getMonth());\n      };\n\n      break;\n\n    default:\n      viewDate = Object(lib_date[\"d\" /* addYears */])(viewDate, direction * (vertical ? 4 : 1) * step);\n      addFn = lib_date[\"d\" /* addYears */];\n\n      testFn = date => currentView.disabled.includes(Object(lib_date[\"h\" /* startOfYearPeriod */])(date, step));\n\n  }\n\n  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);\n\n  if (viewDate !== undefined) {\n    datepicker.picker.changeFocus(viewDate).render();\n  }\n}\n\nfunction onKeydown(datepicker, ev) {\n  if (ev.key === 'Tab') {\n    datepicker.refresh('input');\n    datepicker.hide();\n    return;\n  }\n\n  const viewId = datepicker.picker.currentView.id;\n\n  if (!datepicker.picker.active) {\n    switch (ev.key) {\n      case 'ArrowDown':\n      case 'Escape':\n        datepicker.picker.show();\n        break;\n\n      case 'Enter':\n        datepicker.update();\n        break;\n\n      default:\n        return;\n    }\n  } else if (datepicker.editMode) {\n    switch (ev.key) {\n      case 'Escape':\n        datepicker.exitEditMode();\n        break;\n\n      case 'Enter':\n        datepicker.exitEditMode({\n          update: true,\n          autohide: datepicker.config.autohide\n        });\n        break;\n\n      default:\n        return;\n    }\n  } else {\n    switch (ev.key) {\n      case 'Escape':\n        if (ev.shiftKey) {\n          datepicker.enterEditMode();\n        } else {\n          datepicker.picker.hide();\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (ev.ctrlKey || ev.metaKey) {\n          goToPrevOrNext(datepicker, -1);\n        } else {\n          moveByArrowKey(datepicker, ev, -1, false);\n        }\n\n        break;\n\n      case 'ArrowRight':\n        if (ev.ctrlKey || ev.metaKey) {\n          goToPrevOrNext(datepicker, 1);\n        } else {\n          moveByArrowKey(datepicker, ev, 1, false);\n        }\n\n        break;\n\n      case 'ArrowUp':\n        if (ev.ctrlKey || ev.metaKey) {\n          switchView(datepicker);\n        } else {\n          moveByArrowKey(datepicker, ev, -1, true);\n        }\n\n        break;\n\n      case 'ArrowDown':\n        moveByArrowKey(datepicker, ev, 1, true);\n        break;\n\n      case 'Enter':\n        if (viewId === 0) {\n          datepicker.setDate(datepicker.picker.viewDate);\n        } else {\n          datepicker.picker.changeView(viewId - 1).render();\n        }\n\n        break;\n\n      case 'Backspace':\n      case 'Delete':\n        datepicker.enterEditMode();\n        return;\n\n      default:\n        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {\n          datepicker.enterEditMode();\n        }\n\n        return;\n    }\n  }\n\n  ev.preventDefault();\n  ev.stopPropagation();\n}\nfunction onFocus(datepicker) {\n  if (datepicker.config.showOnFocus) {\n    datepicker.show();\n  }\n} // for the prevention for entering edit mode while getting focus on click\n\nfunction onMousedown(datepicker, ev) {\n  const el = ev.target;\n\n  if (datepicker.picker.active) {\n    el._clicking = setTimeout(() => {\n      delete el._clicking;\n    }, 2000);\n  }\n}\nfunction onClickInput(datepicker, ev) {\n  const el = ev.target;\n\n  if (!el._clicking) {\n    return;\n  }\n\n  clearTimeout(el._clicking);\n  delete el._clicking;\n  datepicker.enterEditMode();\n}\nfunction onPaste(datepicker, ev) {\n  if (ev.clipboardData.types.includes('text/plain')) {\n    datepicker.enterEditMode();\n  }\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/events/otherListeners.js\n // for the `document` to delegate the events from outside the picker/input field\n\nfunction onClickOutside(datepicker, ev) {\n  const element = datepicker.element;\n  const pickerElem = datepicker.picker.element;\n\n  if (Object(lib_event[\"a\" /* findElementInEventPath */])(ev, el => el === element || el === pickerElem)) {\n    return;\n  }\n\n  datepicker.refresh('input');\n  datepicker.hide();\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/Datepicker.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction stringifyDates(dates, config) {\n  return dates.map(dt => Object(date_format[\"a\" /* formatDate */])(dt, config.format, config.locale)).join(config.dateDelimiter);\n} // parse input dates and create an array of time values for selection\n// returns undefined if there are no valid dates in inputDates\n// when origDates (current selection) is passed, the function works to mix\n// the input dates into the current selection\n\n\nfunction processInputDates(inputDates, config, origDates = undefined) {\n  if (inputDates.length === 0) {\n    // empty input is considered valid unless origiDates is passed\n    return origDates ? undefined : [];\n  }\n\n  let newDates = inputDates.reduce((dates, dt) => {\n    const date = Object(date_format[\"b\" /* parseDate */])(dt, config.format, config.locale);\n\n    if (date !== undefined && Object(utils[\"c\" /* isInRange */])(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {\n      dates.push(date);\n    }\n\n    return dates;\n  }, []);\n\n  if (newDates.length === 0) {\n    return;\n  }\n\n  if (origDates && config.multidate) {\n    // get the synmetric difference between origDates and newDates\n    newDates = newDates.reduce((dates, date) => {\n      if (!origDates.includes(date)) {\n        dates.push(date);\n      }\n\n      return dates;\n    }, origDates.filter(date => !newDates.includes(date)));\n  } // do length check always because user can input multiple dates regardless of the mode\n\n\n  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;\n}\n/**\n * Class representing a date picker\n */\n\n\nclass Datepicker_Datepicker {\n  /**\n   * Create a date picker\n   * @param  {Element} element - element to bind a date picker\n   * @param  {Object} [options] - config options\n   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\n   * date picker belongs to. Use this only when creating date picker as a part\n   * of date range picker\n   */\n  constructor(element, options = {}, rangepicker = undefined) {\n    element.datepicker = this;\n    this.element = element; // set up config\n\n    const config = this.config = Object.assign({\n      buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n      container: document.body,\n      defaultViewDate: Object(lib_date[\"j\" /* today */])(),\n      maxDate: undefined,\n      minDate: undefined\n    }, processOptions(options_defaultOptions, this));\n    this._options = options;\n    Object.assign(config, processOptions(options, this)); // configure by type\n\n    const inline = this.inline = element.tagName !== 'INPUT';\n    let inputField;\n    let initialDates;\n\n    if (inline) {\n      config.container = element;\n      initialDates = Object(utils[\"h\" /* stringToArray */])(element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n    } else {\n      const container = options.container ? document.querySelector(options.container) : null;\n\n      if (container) {\n        config.container = container;\n      }\n\n      inputField = this.inputField = element;\n      inputField.classList.add('datepicker-input');\n      initialDates = Object(utils[\"h\" /* stringToArray */])(inputField.value, config.dateDelimiter);\n    } // set initial value\n\n\n    this.dates = processInputDates(initialDates, config) || [];\n\n    if (rangepicker && rangepicker.constructor.name === 'DateRangePicker') {\n      this.rangepicker = rangepicker; // add getter for range\n\n      Object.defineProperty(this, 'range', {\n        get() {\n          return this.rangepicker.dates;\n        }\n\n      });\n    }\n\n    const picker = this.picker = new Picker_Picker(this);\n\n    if (inline) {\n      this.show();\n    } else {\n      // set up event listeners in other modes\n      const onMousedownDocument = onClickOutside.bind(null, this);\n      const listeners = [[inputField, 'keydown', onKeydown.bind(null, this)], [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)], [document, 'mousedown', onMousedownDocument], [document, 'touchstart', onMousedownDocument], [window, 'resize', picker.place.bind(picker)]];\n      Object(lib_event[\"b\" /* registerListeners */])(this, listeners);\n    }\n  }\n  /**\n   * Format Date object or time value in given format and language\n   * @param  {Date|Number} date - date or time value to format\n   * @param  {String|Object} format - format string or object that contains\n   * toDisplay() custom formatter, whose signature is\n   * - args:\n   *   - date: {Date} - Date instance of the date passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {String} formatted date\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {String} formatted date\n   */\n\n\n  static formatDate(date, format, lang) {\n    return Object(date_format[\"a\" /* formatDate */])(date, format, lang && base_locales_locales[lang] || base_locales_locales.en);\n  }\n  /**\n   * Pasre date string\n   * @param  {String|Date|Number} dateStr - date string, Date object or time\n   * value to parse\n   * @param  {String|Object} format - format string or object that contains\n   * toValue() custom parser, whose signature is\n   * - args:\n   *   - dateStr: {String|Date|Number} - the dateStr passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {Date|Number} parsed date or its time value\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {Number} time value of parsed date\n   */\n\n\n  static parseDate(dateStr, format, lang) {\n    return Object(date_format[\"b\" /* parseDate */])(dateStr, format, lang && base_locales_locales[lang] || base_locales_locales.en);\n  }\n  /**\n   * @type {Object} - Installed locales in `[languageCode]: localeObject` format\n   * en`:_English (US)_ is pre-installed.\n   */\n\n\n  static get locales() {\n    return base_locales_locales;\n  }\n  /**\n   * @type {Boolean} - Whether the picker element is shown. `true` whne shown\n   */\n\n\n  get active() {\n    return !!(this.picker && this.picker.active);\n  }\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n\n\n  setOptions(options) {\n    const picker = this.picker;\n    const newOptions = processOptions(options, this);\n    Object.assign(this._options, options);\n    Object.assign(this.config, newOptions);\n    picker.setOptions(newOptions);\n    const currentViewId = picker.currentView.id;\n\n    if (newOptions.maxView < currentViewId) {\n      picker.changeView(newOptions.maxView);\n    } else if (newOptions.startView !== undefined && !picker.active && newOptions.startView !== currentViewId) {\n      picker.changeView(newOptions.startView);\n    }\n\n    this.refresh();\n  }\n  /**\n   * Show the picker element\n   */\n\n\n  show() {\n    if (this.inputField && this.inputField.disabled) {\n      return;\n    }\n\n    this.picker.show();\n  }\n  /**\n   * Hide the picker element\n   * Not avilable on inline picker\n   */\n\n\n  hide() {\n    if (this.inline) {\n      return;\n    }\n\n    this.picker.hide();\n    this.picker.update().changeView(this.config.startView).render();\n  }\n  /**\n   * Destroy the Datepicker instance\n   * @return {Detepicker} - the instance destroyed\n   */\n\n\n  destroy() {\n    this.hide();\n    Object(lib_event[\"c\" /* unregisterListeners */])(this);\n    this.picker.detach();\n\n    if (!this.inline) {\n      this.inputField.classList.remove('datepicker-input');\n    }\n\n    delete this.element.datepicker;\n    return this;\n  }\n  /**\n   * Get the selected date(s)\n   *\n   * The method returns a Date object of selected date by default, and returns\n   * an array of selected dates in multidate mode. If format string is passed,\n   * it returns date string(s) formatted in given format.\n   *\n   * @param  {String} [format] - Format string to stringify the date(s)\n   * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\n   * selected, empty array in multidate mode and untitled in sigledate mode\n   */\n\n\n  getDate(format = undefined) {\n    const callback = format ? date => Object(date_format[\"a\" /* formatDate */])(date, format, this.config.locale) : date => new Date(date);\n\n    if (this.config.multidate) {\n      return this.dates.map(callback);\n    }\n\n    if (this.dates.length > 0) {\n      return callback(this.dates[0]);\n    }\n  }\n  /**\n   * Set selected date(s)\n   *\n   * In multidate mode, you can pass multiple dates as a series of arguments\n   * or an array. (Since each date is parsed individually, the type of the\n   * dates doesn't have to be the same.)\n   * The given dates are used to toggle the select status of each date. The\n   * number of selected dates is kept from exceeding the length set to\n   * maxNumberOfDates.\n   *\n   * With clear: true option, the method can be used to clear the selection\n   * and to replace the selection instead of toggling in multidate mode.\n   * If the option is passed with no date arguments or an empty dates array,\n   * it works as \"clear\" (clear the selection then set nothing), and if the\n   * option is passed with new dates to select, it works as \"replace\" (clear\n   * the selection then set the given dates)\n   *\n   * When render: false option is used, the method omits re-rendering the\n   * picker element. In this case, you need to call refresh() method later in\n   * order for the picker element to reflect the changes. The input field is\n   * refreshed always regardless of this option.\n   *\n   * When invalid (unparsable, repeated, disabled or out-of-range) dates are\n   * passed, the method ignores them and applies only valid ones. In the case\n   * that all the given dates are invalid, which is distiguished from passing\n   * no dates, the method considers it as an error and leaves the selection\n   * untouched.\n   *\n   * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\n   * objects, time values or mix of those for new selection\n   * @param {Object} [options] - function options\n   * - clear: {boolean} - Whether to clear the existing selection\n   *     defualt: false\n   * - render: {boolean} - Whether to re-render the picker element\n   *     default: true\n   * - autohide: {boolean} - Whether to hide the picker element after re-render\n   *     Ignored when used with render: false\n   *     default: config.autohide\n   */\n\n\n  setDate(...args) {\n    const dates = [...args];\n    const opts = {\n      clear: false,\n      render: true,\n      autohide: this.config.autohide\n    };\n    const lastArg = Object(utils[\"d\" /* lastItemOf */])(args);\n\n    if (typeof lastArg === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date)) {\n      Object.assign(opts, dates.pop());\n    }\n\n    const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n    const origDates = opts.clear ? undefined : this.dates;\n    const newDates = processInputDates(inputDates, this.config, origDates);\n\n    if (!newDates) {\n      return;\n    }\n\n    if (newDates.toString() !== this.dates.toString()) {\n      this.dates = newDates;\n\n      if (opts.render) {\n        this.picker.update();\n        this.refresh();\n      } else {\n        this.refresh('input');\n      }\n\n      triggerDatepickerEvent(this, 'changeDate');\n    } else {\n      this.refresh('input');\n    }\n\n    if (opts.render && opts.autohide) {\n      this.hide();\n    }\n  }\n  /**\n   * Update the selected date(s) with input field's value\n   * Not avilable on inline picker\n   *\n   * The input field will be refreshed with properly formatted date string.\n   *\n   * @param  {Object} [options] - function options\n   * - autohide: {boolean} - whether to hide the picker element after refresh\n   *     default: false\n   */\n\n\n  update(options = undefined) {\n    if (this.inline) {\n      return;\n    }\n\n    const opts = Object.assign({\n      autohide: false\n    }, options);\n    const inputDates = Object(utils[\"h\" /* stringToArray */])(this.inputField.value, this.config.dateDelimiter);\n    const newDates = processInputDates(inputDates, this.config);\n\n    if (!newDates) {\n      return;\n    }\n\n    if (newDates.toString() !== this.dates.toString()) {\n      this.dates = newDates;\n      this.picker.update();\n      this.refresh();\n      triggerDatepickerEvent(this, 'changeDate');\n    } else {\n      this.refresh('input');\n    }\n\n    if (opts.autohide) {\n      this.hide();\n    }\n  }\n  /**\n   * Refresh the picker element and the associated input field\n   * @param {String} [target] - target item when refreshing one item only\n   * 'picker' or 'input'\n   */\n\n\n  refresh(target = undefined) {\n    if (target !== 'input') {\n      this.picker.render();\n    }\n\n    if (!this.inline && target !== 'picker') {\n      this.inputField.value = stringifyDates(this.dates, this.config);\n    }\n  }\n  /**\n   * Enter edit mode\n   * Not avilable on inline picker or when the picker element is hidden\n   */\n\n\n  enterEditMode() {\n    if (this.inline || !this.picker.active || this.editMode) {\n      return;\n    }\n\n    this.editMode = true;\n    this.inputField.classList.add('in-edit');\n  }\n  /**\n   * Exit from edit mode\n   * Not avilable on inline picker\n   * @param  {Object} [options] - function options\n   * - update: {boolean} - whether to call update() after exiting\n   *     If false, input field is revert to the existing selection\n   *     default: false\n   */\n\n\n  exitEditMode(options = undefined) {\n    if (this.inline || !this.editMode) {\n      return;\n    }\n\n    const opts = Object.assign({\n      update: false\n    }, options);\n    delete this.editMode;\n    this.inputField.classList.remove('in-edit');\n\n    if (opts.update) {\n      this.update(opts);\n    } else {\n      this.inputField.value = stringifyDates(this.dates, this.config);\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvaTE4bi9iYXNlLWxvY2FsZXMuanM/YjE0YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvb3B0aW9ucy9kZWZhdWx0T3B0aW9ucy5qcz9lMzEyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9saWIvZG9tLmpzPzkyMmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbmlsbGFqcy1kYXRlcGlja2VyL2pzL29wdGlvbnMvcHJvY2Vzc09wdGlvbnMuanM/MjRjNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvcGlja2VyL3RlbXBsYXRlcy9waWNrZXJUZW1wbGF0ZS5qcz8wYWNiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2RheXNUZW1wbGF0ZS5qcz80N2JjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qcz8yNGQyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvVmlldy5qcz83YzlmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvRGF5c1ZpZXcuanM/NDg0ZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvcGlja2VyL3ZpZXdzL01vbnRoc1ZpZXcuanM/ODgxNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvcGlja2VyL3ZpZXdzL1llYXJzVmlldy5qcz9iOWU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9ldmVudHMvZnVuY3Rpb25zLmpzPzQ4NDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbmlsbGFqcy1kYXRlcGlja2VyL2pzL2V2ZW50cy9waWNrZXJMaXN0ZW5lcnMuanM/MDc2NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvcGlja2VyL1BpY2tlci5qcz85YjgzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9ldmVudHMvaW5wdXRGaWVsZExpc3RlbmVycy5qcz9kMzNmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92YW5pbGxhanMtZGF0ZXBpY2tlci9qcy9ldmVudHMvb3RoZXJMaXN0ZW5lcnMuanM/MzJkMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvRGF0ZXBpY2tlci5qcz82MWVlIl0sIm5hbWVzIjpbImxvY2FsZXMiLCJlbiIsImRheXMiLCJkYXlzU2hvcnQiLCJkYXlzTWluIiwibW9udGhzIiwibW9udGhzU2hvcnQiLCJ0b2RheSIsImNsZWFyIiwidGl0bGVGb3JtYXQiLCJkZWZhdWx0T3B0aW9ucyIsImF1dG9oaWRlIiwiYmVmb3JlU2hvd0RheSIsImJlZm9yZVNob3dEZWNhZGUiLCJiZWZvcmVTaG93TW9udGgiLCJiZWZvcmVTaG93WWVhciIsImNhbGVuZGFyV2Vla3MiLCJjbGVhckJ0biIsImRhdGVEZWxpbWl0ZXIiLCJkYXRlc0Rpc2FibGVkIiwiZGF5c09mV2Vla0Rpc2FibGVkIiwiZGF5c09mV2Vla0hpZ2hsaWdodGVkIiwiZGVmYXVsdFZpZXdEYXRlIiwidW5kZWZpbmVkIiwiZGlzYWJsZVRvdWNoS2V5Ym9hcmQiLCJmb3JtYXQiLCJsYW5ndWFnZSIsIm1heERhdGUiLCJtYXhOdW1iZXJPZkRhdGVzIiwibWF4VmlldyIsIm1pbkRhdGUiLCJuZXh0QXJyb3ciLCJvcmllbnRhdGlvbiIsInByZXZBcnJvdyIsInNob3dEYXlzT2ZXZWVrIiwic2hvd09uRm9jdXMiLCJzdGFydFZpZXciLCJ0aXRsZSIsInRvZGF5QnRuIiwidG9kYXlCdG5Nb2RlIiwidG9kYXlIaWdobGlnaHQiLCJ3ZWVrU3RhcnQiLCJyYW5nZSIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJwYXJzZUhUTUwiLCJodG1sIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaXNWaXNpYmxlIiwiZWwiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImdldENsaWVudFJlY3RzIiwibGVuZ3RoIiwiaGlkZUVsZW1lbnQiLCJzdHlsZSIsImRpc3BsYXkiLCJkYXRhc2V0Iiwic3R5bGVEaXNwbGF5Iiwic2hvd0VsZW1lbnQiLCJlbXB0eUNoaWxkTm9kZXMiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJyZXBsYWNlQ2hpbGROb2RlcyIsIm5ld0NoaWxkTm9kZXMiLCJEb2N1bWVudEZyYWdtZW50IiwiYXBwZW5kQ2hpbGQiLCJmb3JFYWNoIiwibm9kZSIsImRlZmF1bHRMYW5nIiwiZGVmYXVsdEZvcm1hdCIsImRlZmF1bHRXZWVrU3RhcnQiLCJzYW5pdGl6ZURPVyIsImRvdyIsImRheSIsInB1c2hVbmlxdWUiLCJjYWxjRW5kT2ZXZWVrIiwic3RhcnRPZldlZWsiLCJ2YWxpZGF0ZURhdGUiLCJ2YWx1ZSIsImxvY2FsZSIsIm9yaWdWYWx1ZSIsImRhdGUiLCJwYXJzZURhdGUiLCJ2YWxpZGF0ZVZpZXdJZCIsInZpZXdJZCIsInBhcnNlSW50IiwicHJvY2Vzc09wdGlvbnMiLCJvcHRpb25zIiwiZGF0ZXBpY2tlciIsImluT3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImNvbmZpZyIsImNvbnN0cnVjdG9yIiwibGFuZyIsInNwbGl0Iiwib3JpZ0xvY2FsZSIsIndlZWtFbmQiLCJoYXNUb0Rpc3BsYXkiLCJ0b0Rpc3BsYXkiLCJoYXNUb1ZhbHVlIiwidG9WYWx1ZSIsInZhbGlkRm9ybWF0U3RyaW5nIiwicmVGb3JtYXRUb2tlbnMiLCJ0ZXN0IiwibWluRHQiLCJtYXhEdCIsImRhdGVWYWx1ZSIsInJlZHVjZSIsImRhdGVzIiwiZHQiLCJ2aWV3RGF0ZSIsIndrU3RhcnQiLCJOdW1iZXIiLCJpc05hTiIsIm11bHRpZGF0ZSIsIlN0cmluZyIsIm5ld01heFZpZXciLCJuZXdTdGFydFZpZXciLCJjaGlsZE5vZGVzIiwidG9Mb3dlckNhc2UiLCJ4IiwiZmluZCIsInkiLCJrZXlzIiwia2V5IiwiaGFzUHJvcGVydHkiLCJwaWNrZXJUZW1wbGF0ZSIsIm9wdGltaXplVGVtcGxhdGVIVE1MIiwiZGF5c1RlbXBsYXRlIiwiY3JlYXRlVGFnUmVwZWF0IiwiY2xhc3MiLCJjYWxlbmRhcldlZWtzVGVtcGxhdGUiLCJWaWV3IiwicGlja2VyIiwiZWxlbWVudCIsInNlbGVjdGVkIiwiaW5pdCIsInNldE9wdGlvbnMiLCJ1cGRhdGVGb2N1cyIsInVwZGF0ZVNlbGVjdGlvbiIsInBlcmZvcm1CZWZvcmVIb29rIiwiY3VycmVudCIsInRpbWVWYWx1ZSIsInJlc3VsdCIsImJlZm9yZVNob3ciLCJEYXRlIiwiZW5hYmxlZCIsImNsYXNzZXMiLCJjbGFzc0xpc3QiLCJhZGQiLCJkaXNhYmxlZCIsImV4dHJhQ2xhc3NlcyIsImluY2x1ZGVzIiwiY29udGVudCIsIkRheXNWaWV3IiwiaWQiLCJuYW1lIiwiY2VsbENsYXNzIiwib25Db25zdHJ1Y3Rpb24iLCJpbm5lciIsImdyaWQiLCJsYXN0Q2hpbGQiLCJ1cGRhdGVET1ciLCJkYXlOYW1lcyIsInN3aXRjaExhYmVsRm9ybWF0Iiwic3dpdGNoTGFiZWwiLCJmb3JtYXREYXRlIiwid2Vla3NFbGVtIiwid2Vla3MiLCJpbnNlcnRCZWZvcmUiLCJBcnJheSIsImZyb20iLCJjaGlsZHJlbiIsImluZGV4IiwidGV4dENvbnRlbnQiLCJjbGFzc05hbWUiLCJ2aWV3WWVhciIsImdldEZ1bGxZZWFyIiwidmlld01vbnRoIiwiZ2V0TW9udGgiLCJmaXJzdE9mTW9udGgiLCJzdGFydCIsImRheU9mVGhlV2Vla09mIiwiZmlyc3QiLCJsYXN0IiwiZm9jdXNlZCIsInJlbmRlciIsInNldFZpZXdTd2l0Y2hMYWJlbCIsInNldFByZXZCdG5EaXNhYmxlZCIsInNldE5leHRCdG5EaXNhYmxlZCIsImdldFdlZWsiLCJhZGRXZWVrcyIsImFkZERheXMiLCJnZXREYXkiLCJnZXREYXRlIiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwicmVmcmVzaCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmUiLCJyZWZyZXNoRm9jdXMiLCJNYXRoIiwicm91bmQiLCJNb250aHNWaWV3IiwiaXgiLCJtb250aE5hbWVzIiwibWluWWVhciIsIm1pbk1vbnRoIiwibWluRGF0ZU9iaiIsInNldERhdGUiLCJtYXhZZWFyIiwibWF4TW9udGgiLCJtYXhEYXRlT2JqIiwieWVhciIsIm1vbnRoIiwieXJPdXRPZlJhbmdlIiwiaXNNaW5ZZWFyIiwiaXNNYXhZZWFyIiwidG9UaXRsZUNhc2UiLCJ3b3JkIiwic3RyIiwiY2giLCJ0b1VwcGVyQ2FzZSIsIlllYXJzVmlldyIsIm5hdlN0ZXAiLCJzdGVwIiwiYmVmb3JlU2hvd09wdGlvbiIsInN0YXJ0T2ZZZWFyUGVyaW9kIiwieWVhcnMiLCJ0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50IiwidHlwZSIsImRldGFpbCIsImN1cnJlbnRWaWV3IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZ29Ub1ByZXZPck5leHQiLCJkaXJlY3Rpb24iLCJuZXdWaWV3RGF0ZSIsImFkZE1vbnRocyIsImFkZFllYXJzIiwibGltaXRUb1JhbmdlIiwiY2hhbmdlRm9jdXMiLCJzd2l0Y2hWaWV3IiwiY2hhbmdlVmlldyIsImdvVG9TZWxlY3RlZE1vbnRoT3JZZWFyIiwic2VsZWN0aW9uIiwibmV3RGF0ZSIsIm9uQ2xpY2tUb2RheUJ0biIsImN1cnJlbnREYXRlIiwidXBkYXRlIiwib25DbGlja0NsZWFyQnRuIiwib25DbGlja1ZpZXdTd2l0Y2giLCJvbkNsaWNrUHJldkJ0biIsIm9uQ2xpY2tOZXh0QnRuIiwib25DbGlja1ZpZXciLCJldiIsInRhcmdldCIsImZpbmRFbGVtZW50SW5FdmVudFBhdGgiLCJjb250YWlucyIsIm9uQ2xpY2tQaWNrZXIiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImlubGluZSIsImFjdGl2ZSIsImlucHV0RmllbGQiLCJmb2N1cyIsInByb2Nlc3NQaWNrZXJPcHRpb25zIiwiY29udHJvbHMiLCJwcmV2QnRuIiwiY2xvbmVOb2RlIiwibmV4dEJ0biIsImlzSW5SYW5nZSIsImNvbXB1dGVSZXNldFZpZXdEYXRlIiwibGFzdEl0ZW1PZiIsInNldFZpZXdEYXRlIiwib2xkVmlld0RhdGUiLCJnZXRUZXh0RGlyZWN0aW9uIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIlBpY2tlciIsInRlbXBsYXRlIiwicmVwbGFjZSIsImJ1dHRvbkNsYXNzIiwiaGVhZGVyIiwibWFpbiIsImZvb3RlciIsImZpcnN0RWxlbWVudENoaWxkIiwidmlld1N3aXRjaCIsImxhc3RFbGVtZW50Q2hpbGQiLCJlbGVtZW50Q2xhc3MiLCJyZWdpc3Rlckxpc3RlbmVycyIsImJpbmQiLCJ2aWV3cyIsImNvbnRhaW5lciIsInZpZXciLCJkZXRhY2giLCJzaG93IiwiaW5wdXREaXJlY3Rpb24iLCJkaXIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwbGFjZSIsImJsdXIiLCJoaWRlIiwiZXhpdEVkaXRNb2RlIiwid2lkdGgiLCJjYWxlbmRhcldpZHRoIiwiaGVpZ2h0IiwiY2FsZW5kYXJIZWlnaHQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwiY29udGFpbmVyTGVmdCIsInRvcCIsImNvbnRhaW5lclRvcCIsImNvbnRhaW5lcldpZHRoIiwiaW5wdXRMZWZ0IiwiaW5wdXRUb3AiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJvcmllbnRYIiwib3JpZW50WSIsInNjcm9sbFRvcCIsImJvZHkiLCJzY3JvbGxZIiwic2Nyb2xsWCIsImxhYmVsVGV4dCIsIm9sZFZpZXciLCJuZXdWaWV3IiwiX3JlbmRlck1ldGhvZCIsInJlcGxhY2VDaGlsZCIsInJlbmRlck1ldGhvZCIsImZpbmROZXh0QXZhaWxhYmxlT25lIiwiYWRkRm4iLCJpbmNyZWFzZSIsInRlc3RGbiIsIm1pbiIsIm1heCIsIm1vdmVCeUFycm93S2V5IiwidmVydGljYWwiLCJjdHJsS2V5IiwibWV0YUtleSIsIm9uS2V5ZG93biIsImVkaXRNb2RlIiwic2hpZnRLZXkiLCJlbnRlckVkaXRNb2RlIiwib25Gb2N1cyIsIm9uTW91c2Vkb3duIiwiX2NsaWNraW5nIiwic2V0VGltZW91dCIsIm9uQ2xpY2tJbnB1dCIsImNsZWFyVGltZW91dCIsIm9uUGFzdGUiLCJjbGlwYm9hcmREYXRhIiwidHlwZXMiLCJvbkNsaWNrT3V0c2lkZSIsInBpY2tlckVsZW0iLCJzdHJpbmdpZnlEYXRlcyIsIm1hcCIsImpvaW4iLCJwcm9jZXNzSW5wdXREYXRlcyIsImlucHV0RGF0ZXMiLCJvcmlnRGF0ZXMiLCJuZXdEYXRlcyIsInB1c2giLCJmaWx0ZXIiLCJzbGljZSIsIkRhdGVwaWNrZXIiLCJyYW5nZXBpY2tlciIsIl9vcHRpb25zIiwidGFnTmFtZSIsImluaXRpYWxEYXRlcyIsInN0cmluZ1RvQXJyYXkiLCJxdWVyeVNlbGVjdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJvbk1vdXNlZG93bkRvY3VtZW50IiwibGlzdGVuZXJzIiwiZGF0ZVN0ciIsIm5ld09wdGlvbnMiLCJjdXJyZW50Vmlld0lkIiwiZGVzdHJveSIsInVucmVnaXN0ZXJMaXN0ZW5lcnMiLCJjYWxsYmFjayIsImFyZ3MiLCJvcHRzIiwibGFzdEFyZyIsImlzQXJyYXkiLCJwb3AiLCJ0b1N0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPLE1BQU1BLG9CQUFPLEdBQUc7QUFDckJDLElBQUUsRUFBRTtBQUNGQyxRQUFJLEVB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QUFDRDtBQUNGO0FBRUQ7Ozs7OztBQUlBNFAsZUFBYSxHQUFHO0FBQ2QsUUFBSSxLQUFLakYsTUFBTCxJQUFlLENBQUMsS0FBS2pJLE1BQUwsQ0FBWWtJLE1BQTVCLElBQXNDLEtBQUs4RSxRQUEvQyxFQUF5RDtBQUN2RDtBQUNEOztBQUNELFNBQUtBLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLN0UsVUFBTCxDQUFnQnBILFNBQWhCLENBQTBCQyxHQUExQixDQUE4QixTQUE5QjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7QUFRQTBKLGNBQVksQ0FBQ3pOLE9BQU8sR0FBR2pFLFNBQVgsRUFBc0I7QUFDaEMsUUFBSSxLQUFLaVAsTUFBTCxJQUFlLENBQUMsS0FBSytFLFFBQXpCLEVBQW1DO0FBQ2pDO0FBQ0Q7O0FBQ0QsVUFBTTBDLElBQUksR0FBR3RTLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjO0FBQUMrSixZQUFNLEVBQUU7QUFBVCxLQUFkLEVBQStCbkssT0FBL0IsQ0FBYjtBQUNBLFdBQU8sS0FBSytQLFFBQVo7QUFDQSxTQUFLN0UsVUFBTCxDQUFnQnBILFNBQWhCLENBQTBCbUQsTUFBMUIsQ0FBaUMsU0FBakM7O0FBQ0EsUUFBSXdMLElBQUksQ0FBQ3RJLE1BQVQsRUFBaUI7QUFDZixXQUFLQSxNQUFMLENBQVlzSSxJQUFaO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBS3ZILFVBQUwsQ0FBZ0IzTCxLQUFoQixHQUF3QnNSLGNBQWMsQ0FBQyxLQUFLdlAsS0FBTixFQUFhLEtBQUtqQixNQUFsQixDQUF0QztBQUNEO0FBQ0Y7O0FBaFg2QiIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZGVmYXVsdCBsb2NhbGVzXG5leHBvcnQgY29uc3QgbG9jYWxlcyA9IHtcbiAgZW46IHtcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG4gICAgdG9kYXk6IFwiVG9kYXlcIixcbiAgICBjbGVhcjogXCJDbGVhclwiLFxuICAgIHRpdGxlRm9ybWF0OiBcIk1NIHlcIlxuICB9XG59O1xuIiwiLy8gY29uZmlnIG9wdGlvbnMgdXBkYXRhYmxlIGJ5IHNldE9wdGlvbnMoKSBhbmQgdGhlaXIgZGVmYXVsdCB2YWx1ZXNcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhdXRvaGlkZTogZmFsc2UsXG4gIGJlZm9yZVNob3dEYXk6IG51bGwsXG4gIGJlZm9yZVNob3dEZWNhZGU6IG51bGwsXG4gIGJlZm9yZVNob3dNb250aDogbnVsbCxcbiAgYmVmb3JlU2hvd1llYXI6IG51bGwsXG4gIGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuICBjbGVhckJ0bjogZmFsc2UsXG4gIGRhdGVEZWxpbWl0ZXI6ICcsJyxcbiAgZGF0ZXNEaXNhYmxlZDogW10sXG4gIGRheXNPZldlZWtEaXNhYmxlZDogW10sXG4gIGRheXNPZldlZWtIaWdobGlnaHRlZDogW10sXG4gIGRlZmF1bHRWaWV3RGF0ZTogdW5kZWZpbmVkLCAvLyBwbGFjZWhvbGRlciwgZGVmYXVsdHMgdG8gdG9kYXkoKSBieSB0aGUgcHJvZ3JhbVxuICBkaXNhYmxlVG91Y2hLZXlib2FyZDogZmFsc2UsXG4gIGZvcm1hdDogJ21tL2RkL3l5eXknLFxuICBsYW5ndWFnZTogJ2VuJyxcbiAgbWF4RGF0ZTogbnVsbCxcbiAgbWF4TnVtYmVyT2ZEYXRlczogMSxcbiAgbWF4VmlldzogMyxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbmV4dEFycm93OiAnwrsnLFxuICBvcmllbnRhdGlvbjogJ2F1dG8nLFxuICBwcmV2QXJyb3c6ICfCqycsXG4gIHNob3dEYXlzT2ZXZWVrOiB0cnVlLFxuICBzaG93T25Gb2N1czogdHJ1ZSxcbiAgc3RhcnRWaWV3OiAwLFxuICB0aXRsZTogJycsXG4gIHRvZGF5QnRuOiBmYWxzZSxcbiAgdG9kYXlCdG5Nb2RlOiAwLFxuICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gIHdlZWtTdGFydDogMCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRPcHRpb25zO1xuIiwiY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwpIHtcbiAgcmV0dXJuIHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbn1cblxuLy8gZXF1aXZhbGVudCB0byBqUXVlcnkncyA6dmlzYmxlXG5leHBvcnQgZnVuY3Rpb24gaXNWaXNpYmxlKGVsKSB7XG4gIHJldHVybiAhIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUVsZW1lbnQoZWwpIHtcbiAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBiYWNrIHVwIHRoZSBleGlzdGluZyBkaXNwbGF5IHNldHRpbmcgaW4gZGF0YS1zdHlsZS1kaXNwbGF5XG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5KSB7XG4gICAgZWwuZGF0YXNldC5zdHlsZURpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5O1xuICB9XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93RWxlbWVudChlbCkge1xuICBpZiAoZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbC5kYXRhc2V0LnN0eWxlRGlzcGxheSkge1xuICAgIC8vIHJlc3RvcmUgYmFja2VkLXVwIGRpc3BheSBwcm9wZXJ0eVxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcbiAgICBkZWxldGUgZWwuZGF0YXNldC5zdHlsZURpc3BsYXk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUNoaWxkTm9kZXMoZWwpIHtcbiAgaWYgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICBlbXB0eUNoaWxkTm9kZXMoZWwpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ2hpbGROb2RlcyhlbCwgbmV3Q2hpbGROb2Rlcykge1xuICBlbXB0eUNoaWxkTm9kZXMoZWwpO1xuICBpZiAobmV3Q2hpbGROb2RlcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBlbC5hcHBlbmRDaGlsZChuZXdDaGlsZE5vZGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q2hpbGROb2RlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBlbC5hcHBlbmRDaGlsZChwYXJzZUhUTUwobmV3Q2hpbGROb2RlcykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZE5vZGVzLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBuZXdDaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge2hhc1Byb3BlcnR5LCBwdXNoVW5pcXVlfSBmcm9tICcuLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWV9IGZyb20gJy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7cmVGb3JtYXRUb2tlbnMsIHBhcnNlRGF0ZX0gZnJvbSAnLi4vbGliL2RhdGUtZm9ybWF0LmpzJztcbmltcG9ydCB7cGFyc2VIVE1MfSBmcm9tICcuLi9saWIvZG9tLmpzJztcbmltcG9ydCBkZWZhdWx0T3B0aW9ucyBmcm9tICcuL2RlZmF1bHRPcHRpb25zLmpzJztcblxuY29uc3Qge1xuICBsYW5ndWFnZTogZGVmYXVsdExhbmcsXG4gIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcbiAgd2Vla1N0YXJ0OiBkZWZhdWx0V2Vla1N0YXJ0LFxufSA9IGRlZmF1bHRPcHRpb25zO1xuXG4vLyBSZWR1Y2VyIGZ1bmN0aW9uIHRvIGZpbHRlciBvdXQgaW52YWxpZCBkYXktb2Ytd2VlayBmcm9tIHRoZSBpbnB1dFxuZnVuY3Rpb24gc2FuaXRpemVET1coZG93LCBkYXkpIHtcbiAgcmV0dXJuIGRvdy5sZW5ndGggPCA2ICYmIGRheSA+PSAwICYmIGRheSA8IDdcbiAgICA/IHB1c2hVbmlxdWUoZG93LCBkYXkpXG4gICAgOiBkb3c7XG59XG5cbmZ1bmN0aW9uIGNhbGNFbmRPZldlZWsoc3RhcnRPZldlZWspIHtcbiAgcmV0dXJuIChzdGFydE9mV2VlayArIDYpICUgNztcbn1cblxuLy8gdmFsaWRhdGUgaW5wdXQgZGF0ZS4gaWYgaW52YWxpZCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUodmFsdWUsIGZvcm1hdCwgbG9jYWxlLCBvcmlnVmFsdWUpIHtcbiAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICByZXR1cm4gZGF0ZSAhPT0gdW5kZWZpbmVkID8gZGF0ZSA6IG9yaWdWYWx1ZTtcbn1cblxuLy8gVmFsaWRhdGUgdmlld0lkLiBpZiBpbnZhbGlkLCBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVcbmZ1bmN0aW9uIHZhbGlkYXRlVmlld0lkKHZhbHVlLCBvcmlnVmFsdWUpIHtcbiAgY29uc3Qgdmlld0lkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHZpZXdJZCA+PSAwICYmIHZpZXdJZCA8IDQgPyB2aWV3SWQgOiBvcmlnVmFsdWU7XG59XG5cbi8vIENyZWF0ZSBEYXRlcGlja2VyIGNvbmZpZ3VyYXRpb24gdG8gc2V0XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCBkYXRlcGlja2VyKSB7XG4gIGNvbnN0IGluT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICBjb25zdCBjb25maWcgPSB7fTtcbiAgY29uc3QgbG9jYWxlcyA9IGRhdGVwaWNrZXIuY29uc3RydWN0b3IubG9jYWxlcztcbiAgbGV0IHtcbiAgICBmb3JtYXQsXG4gICAgbGFuZ3VhZ2UsXG4gICAgbG9jYWxlLFxuICAgIG1heERhdGUsXG4gICAgbWF4VmlldyxcbiAgICBtaW5EYXRlLFxuICAgIHN0YXJ0VmlldyxcbiAgICB3ZWVrU3RhcnQsXG4gIH0gPSBkYXRlcGlja2VyLmNvbmZpZyB8fCB7fTtcblxuICBpZiAoaW5PcHRzLmxhbmd1YWdlKSB7XG4gICAgbGV0IGxhbmc7XG4gICAgaWYgKGluT3B0cy5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgIGlmIChsb2NhbGVzW2luT3B0cy5sYW5ndWFnZV0pIHtcbiAgICAgICAgbGFuZyA9IGluT3B0cy5sYW5ndWFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGxhbmdhdWdlICsgcmVnaW9uIHRhZyBjYW4gZmFsbGJhY2sgdG8gdGhlIG9uZSB3aXRob3V0XG4gICAgICAgIC8vIHJlZ2lvbiAoZS5nLiBmci1DQSDihpIgZnIpXG4gICAgICAgIGxhbmcgPSBpbk9wdHMubGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmxhbmd1YWdlO1xuICAgIGlmIChsYW5nKSB7XG4gICAgICBsYW5ndWFnZSA9IGNvbmZpZy5sYW5ndWFnZSA9IGxhbmc7XG5cbiAgICAgIC8vIHVwZGF0ZSBsb2NhbGUgYXMgd2VsbCB3aGVuIHVwZGF0aW5nIGxhbmd1YWdlXG4gICAgICBjb25zdCBvcmlnTG9jYWxlID0gbG9jYWxlIHx8IGxvY2FsZXNbZGVmYXVsdExhbmddO1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbGFuZ3VhZ2UncyBwcm9wZXJ0aWVzIGZvciB0aGUgZmFsbGJhY2tcbiAgICAgIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgICAgIHdlZWtTdGFydDogZGVmYXVsdFdlZWtTdGFydFxuICAgICAgfSwgbG9jYWxlc1tkZWZhdWx0TGFuZ10pO1xuICAgICAgaWYgKGxhbmd1YWdlICE9PSBkZWZhdWx0TGFuZykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGxvY2FsZSwgbG9jYWxlc1tsYW5ndWFnZV0pO1xuICAgICAgfVxuICAgICAgY29uZmlnLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgIC8vIGlmIGZvcm1hdCBhbmQvb3Igd2Vla1N0YXJ0IGFyZSB0aGUgc2FtZSBhcyBvbGQgbG9jYWxlJ3MgZGVmYXVsdHMsXG4gICAgICAvLyB1cGRhdGUgdGhlbSB0byBuZXcgbG9jYWxlJ3MgZGVmYXVsdHNcbiAgICAgIGlmIChmb3JtYXQgPT09IG9yaWdMb2NhbGUuZm9ybWF0KSB7XG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICAgICAgfVxuICAgICAgaWYgKHdlZWtTdGFydCA9PT0gb3JpZ0xvY2FsZS53ZWVrU3RhcnQpIHtcbiAgICAgICAgd2Vla1N0YXJ0ID0gY29uZmlnLndlZWtTdGFydCA9IGxvY2FsZS53ZWVrU3RhcnQ7XG4gICAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayhsb2NhbGUud2Vla1N0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5PcHRzLmZvcm1hdCkge1xuICAgIGNvbnN0IGhhc1RvRGlzcGxheSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvRGlzcGxheSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCBoYXNUb1ZhbHVlID0gdHlwZW9mIGluT3B0cy5mb3JtYXQudG9WYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCB2YWxpZEZvcm1hdFN0cmluZyA9IHJlRm9ybWF0VG9rZW5zLnRlc3QoaW5PcHRzLmZvcm1hdCk7XG4gICAgaWYgKChoYXNUb0Rpc3BsYXkgJiYgaGFzVG9WYWx1ZSkgfHwgdmFsaWRGb3JtYXRTdHJpbmcpIHtcbiAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQgPSBpbk9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmZvcm1hdDtcbiAgfVxuXG4gIC8vKioqIGRhdGVzICoqKi8vXG4gIC8vIHdoaWxlIG1pbiBhbmQgbWF4RGF0ZSBmb3IgXCJubyBsaW1pdFwiIGluIHRoZSBvcHRpb25zIGFyZSBiZXR0ZXIgdG8gYmUgbnVsbFxuICAvLyAoZXNwZWNpYWxseSB3aGVuIHVwZGF0aW5nKSwgdGhlIG9uZXMgaW4gdGhlIGNvbmZpZyBoYXZlIHRvIGJlIHVuZGVmaW5lZFxuICAvLyBiZWNhdXNlIG51bGwgaXMgdHJlYXRlZCBhcyAwICg9IHVuaXggZXBvY2gpIHdoZW4gY29tcGFyaW5nIHdpdGggdGltZSB2YWx1ZVxuICBsZXQgbWluRHQgPSBtaW5EYXRlO1xuICBsZXQgbWF4RHQgPSBtYXhEYXRlO1xuICBpZiAoaW5PcHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1pbkR0ID0gaW5PcHRzLm1pbkRhdGUgPT09IG51bGxcbiAgICAgID8gZGF0ZVZhbHVlKDAsIDAsIDEpICAvLyBzZXQgMDAwMC0wMS0wMSB0byBwcmV2ZW50IG5lZ2F0aXZlIHZhbHVlcyBmb3IgeWVhclxuICAgICAgOiB2YWxpZGF0ZURhdGUoaW5PcHRzLm1pbkRhdGUsIGZvcm1hdCwgbG9jYWxlLCBtaW5EdCk7XG4gICAgZGVsZXRlIGluT3B0cy5taW5EYXRlO1xuICB9XG4gIGlmIChpbk9wdHMubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4RHQgPSBpbk9wdHMubWF4RGF0ZSA9PT0gbnVsbFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5tYXhEYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWF4RHQpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWF4RGF0ZTtcbiAgfVxuICBpZiAobWF4RHQgPCBtaW5EdCkge1xuICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1heER0O1xuICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1pbkR0O1xuICB9IGVsc2Uge1xuICAgIGlmIChtaW5EYXRlICE9PSBtaW5EdCkge1xuICAgICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWluRHQ7XG4gICAgfVxuICAgIGlmIChtYXhEYXRlICE9PSBtYXhEdCkge1xuICAgICAgbWF4RGF0ZSA9IGNvbmZpZy5tYXhEYXRlID0gbWF4RHQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluT3B0cy5kYXRlc0Rpc2FibGVkKSB7XG4gICAgY29uZmlnLmRhdGVzRGlzYWJsZWQgPSBpbk9wdHMuZGF0ZXNEaXNhYmxlZC5yZWR1Y2UoKGRhdGVzLCBkdCkgPT4ge1xuICAgICAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZShkdCwgZm9ybWF0LCBsb2NhbGUpO1xuICAgICAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IHB1c2hVbmlxdWUoZGF0ZXMsIGRhdGUpIDogZGF0ZXM7XG4gICAgfSwgW10pO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF0ZXNEaXNhYmxlZDtcbiAgfVxuICBpZiAoaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgdmlld0RhdGUgPSBwYXJzZURhdGUoaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICAgIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuZGVmYXVsdFZpZXdEYXRlID0gdmlld0RhdGU7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMuZGVmYXVsdFZpZXdEYXRlO1xuICB9XG5cbiAgLy8qKiogZGF5cyBvZiB3ZWVrICoqKi8vXG4gIGlmIChpbk9wdHMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB3a1N0YXJ0ID0gTnVtYmVyKGluT3B0cy53ZWVrU3RhcnQpICUgNztcbiAgICBpZiAoIWlzTmFOKHdrU3RhcnQpKSB7XG4gICAgICB3ZWVrU3RhcnQgPSBjb25maWcud2Vla1N0YXJ0ID0gd2tTdGFydDtcbiAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayh3a1N0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIGluT3B0cy53ZWVrU3RhcnQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcbiAgICBjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkID0gaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgfVxuICBpZiAoaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgIGNvbmZpZy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkLnJlZHVjZShzYW5pdGl6ZURPVywgW10pO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xuICB9XG5cbiAgLy8qKiogbXVsdGkgZGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1heE51bWJlck9mRGF0ZXMgPSBwYXJzZUludChpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcywgMTApO1xuICAgIGlmIChtYXhOdW1iZXJPZkRhdGVzID49IDApIHtcbiAgICAgIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzID0gbWF4TnVtYmVyT2ZEYXRlcztcbiAgICAgIGNvbmZpZy5tdWx0aWRhdGUgPSBtYXhOdW1iZXJPZkRhdGVzICE9PSAxO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLm1heE51bWJlck9mRGF0ZXM7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXRlRGVsaW1pdGVyKSB7XG4gICAgY29uZmlnLmRhdGVEZWxpbWl0ZXIgPSBTdHJpbmcoaW5PcHRzLmRhdGVEZWxpbWl0ZXIpO1xuICAgIGRlbGV0ZSBpbk9wdHMuZGF0ZURlbGltaXRlcjtcbiAgfVxuXG4gIC8vKioqIHZpZXcgbW9kZSAqKiovL1xuICBsZXQgbmV3TWF4VmlldyA9IG1heFZpZXc7XG4gIGlmIChpbk9wdHMubWF4VmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmV3TWF4VmlldyA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5tYXhWaWV3LCBtYXhWaWV3KTtcbiAgICBkZWxldGUgaW5PcHRzLm1heFZpZXc7XG4gIH1cbiAgaWYgKG5ld01heFZpZXcgIT09IG1heFZpZXcpIHtcbiAgICBtYXhWaWV3ID0gY29uZmlnLm1heFZpZXcgPSBuZXdNYXhWaWV3O1xuICB9XG5cbiAgbGV0IG5ld1N0YXJ0VmlldyA9IHN0YXJ0VmlldztcbiAgaWYgKGluT3B0cy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1N0YXJ0VmlldyA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5zdGFydFZpZXcsIG5ld1N0YXJ0Vmlldyk7XG4gICAgZGVsZXRlIGluT3B0cy5zdGFydFZpZXc7XG4gIH1cbiAgLy8gZW5zdXJlIHN0YXJ0IHZpZXcgPCBtYXhcbiAgbmV3U3RhcnRWaWV3ID0gbWF4VmlldyA8IG5ld1N0YXJ0VmlldyA/IG1heFZpZXcgOiBuZXdTdGFydFZpZXc7XG4gIGlmIChuZXdTdGFydFZpZXcgIT09IHN0YXJ0Vmlldykge1xuICAgIGNvbmZpZy5zdGFydFZpZXcgPSBuZXdTdGFydFZpZXc7XG4gIH1cblxuICAvLyoqKiB0ZW1wbGF0ZSAqKiovL1xuICBpZiAoaW5PcHRzLnByZXZBcnJvdykge1xuICAgIGNvbnN0IHByZXZBcnJvdyA9IHBhcnNlSFRNTChpbk9wdHMucHJldkFycm93KTtcbiAgICBpZiAocHJldkFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmlnLnByZXZBcnJvdyA9IHByZXZBcnJvdy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLnByZXZBcnJvdztcbiAgfVxuICBpZiAoaW5PcHRzLm5leHRBcnJvdykge1xuICAgIGNvbnN0IG5leHRBcnJvdyA9IHBhcnNlSFRNTChpbk9wdHMubmV4dEFycm93KTtcbiAgICBpZiAobmV4dEFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmlnLm5leHRBcnJvdyA9IG5leHRBcnJvdy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLm5leHRBcnJvdztcbiAgfVxuXG4gIC8vKioqIG1pc2MgKioqLy9cbiAgaWYgKGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQgJiYgISFpbk9wdHMuZGlzYWJsZVRvdWNoS2V5Ym9hcmQ7XG4gICAgZGVsZXRlIGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcbiAgfVxuICBpZiAoaW5PcHRzLm9yaWVudGF0aW9uKSB7XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBpbk9wdHMub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICBjb25maWcub3JpZW50YXRpb24gPSB7XG4gICAgICB4OiBvcmllbnRhdGlvbi5maW5kKHggPT4gKHggPT09ICdsZWZ0JyB8fCB4ID09PSAncmlnaHQnKSkgfHwgJ2F1dG8nLFxuICAgICAgeTogb3JpZW50YXRpb24uZmluZCh5ID0+ICh5ID09PSAndG9wJyB8fCB5ID09PSAnYm90dG9tJykpIHx8ICdhdXRvJyxcbiAgICB9O1xuICAgIGRlbGV0ZSBpbk9wdHMub3JpZW50YXRpb247XG4gIH1cbiAgaWYgKGluT3B0cy50b2RheUJ0bk1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHN3aXRjaChpbk9wdHMudG9kYXlCdG5Nb2RlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvbmZpZy50b2RheUJ0bk1vZGUgPSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLnRvZGF5QnRuTW9kZTtcbiAgfVxuXG4gIC8vKioqIGNvcHkgdGhlIHJlc3QgKioqLy9cbiAgT2JqZWN0LmtleXMoaW5PcHRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoaW5PcHRzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBoYXNQcm9wZXJ0eShkZWZhdWx0T3B0aW9ucywga2V5KSkge1xuICAgICAgY29uZmlnW2tleV0gPSBpbk9wdHNba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59XG4iLCJpbXBvcnQge29wdGltaXplVGVtcGxhdGVIVE1MfSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuXG5jb25zdCBwaWNrZXJUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPlxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1waWNrZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1oZWFkZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXRpdGxlXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1jb250cm9sc1wiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJWJ1dHRvbkNsYXNzJSBwcmV2LWJ0blwiPjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJWJ1dHRvbkNsYXNzJSB2aWV3LXN3aXRjaFwiPjwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJWJ1dHRvbkNsYXNzJSBuZXh0LWJ0blwiPjwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbWFpblwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWZvb3RlclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHNcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiVidXR0b25DbGFzcyUgdG9kYXktYnRuXCI+PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCIlYnV0dG9uQ2xhc3MlIGNsZWFyLWJ0blwiPjwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+YCk7XG5cbmV4cG9ydCBkZWZhdWx0IHBpY2tlclRlbXBsYXRlO1xuIiwiaW1wb3J0IHtjcmVhdGVUYWdSZXBlYXQsIG9wdGltaXplVGVtcGxhdGVIVE1MfSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuXG5jb25zdCBkYXlzVGVtcGxhdGUgPSBvcHRpbWl6ZVRlbXBsYXRlSFRNTChgPGRpdiBjbGFzcz1cImRheXNcIj5cbiAgPGRpdiBjbGFzcz1cImRheXMtb2Ytd2Vla1wiPiR7Y3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgNywge2NsYXNzOiAnZG93J30pfTwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1ncmlkXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA0Mil9PC9kaXY+XG48L2Rpdj5gKTtcblxuZXhwb3J0IGRlZmF1bHQgZGF5c1RlbXBsYXRlO1xuIiwiaW1wb3J0IHtjcmVhdGVUYWdSZXBlYXQsIG9wdGltaXplVGVtcGxhdGVIVE1MfSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuXG5jb25zdCBjYWxlbmRhcldlZWtzVGVtcGxhdGUgPSBvcHRpbWl6ZVRlbXBsYXRlSFRNTChgPGRpdiBjbGFzcz1cImNhbGVuZGFyLXdlZWtzXCI+XG4gIDxkaXYgY2xhc3M9XCJkYXlzLW9mLXdlZWtcIj48c3BhbiBjbGFzcz1cImRvd1wiPjwvc3Bhbj48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIndlZWtzXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA2LCB7Y2xhc3M6ICd3ZWVrJ30pfTwvZGl2PlxuPC9kaXY+YCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZTtcbiIsImltcG9ydCB7cHVzaFVuaXF1ZX0gZnJvbSAnLi4vLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7cGFyc2VIVE1MLCByZXBsYWNlQ2hpbGROb2Rlc30gZnJvbSAnLi4vLi4vbGliL2RvbS5qcyc7XG5cbi8vIEJhc2UgY2xhc3Mgb2YgdGhlIHZpZXcgY2xhc3Nlc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlciwgY29uZmlnKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcbiAgICAgIHBpY2tlcixcbiAgICAgIGVsZW1lbnQ6IHBhcnNlSFRNTChgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdmlld1wiPjwvZGl2PmApLmZpcnN0Q2hpbGQsXG4gICAgICBzZWxlY3RlZDogW10sXG4gICAgfSk7XG4gICAgdGhpcy5pbml0KHRoaXMucGlja2VyLmRhdGVwaWNrZXIuY29uZmlnKTtcbiAgfVxuXG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZUZvY3VzKCk7XG4gICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgYmVmb3JlU2hvdygpIGNhbGxiYWNrIGFuZCBhcHBseSB0aGUgcmVzdWx0IHRvIHRoZSBlbGVtZW50XG4gIC8vIGFyZ3M6XG4gIC8vIC0gY3VycmVudCAtIGN1cnJlbnQgdmFsdWUgb24gdGhlIGl0ZXJhdGlvbiBvbiB2aWV3IHJlbmRlcmluZ1xuICAvLyAtIHRpbWVWYWx1ZSAtIHRpbWUgdmFsdWUgb2YgdGhlIGRhdGUgdG8gcGFzcyB0byBiZWZvcmVTaG93KClcbiAgcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmJlZm9yZVNob3cobmV3IERhdGUodGltZVZhbHVlKSk7XG4gICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmVzdWx0ID0ge2VuYWJsZWQ6IHJlc3VsdH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmVzdWx0ID0ge2NsYXNzZXM6IHJlc3VsdH07XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdC5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IGV4dHJhQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uZXh0cmFDbGFzc2VzKTtcbiAgICAgICAgaWYgKGV4dHJhQ2xhc3Nlcy5pbmNsdWRlcygnZGlzYWJsZWQnKSkge1xuICAgICAgICAgIHB1c2hVbmlxdWUodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuY29udGVudCkge1xuICAgICAgICByZXBsYWNlQ2hpbGROb2RlcyhlbCwgcmVzdWx0LmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgcHVzaFVuaXF1ZX0gZnJvbSAnLi4vLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7dG9kYXksIGRhdGVWYWx1ZSwgYWRkRGF5cywgYWRkV2Vla3MsIGRheU9mVGhlV2Vla09mLCBnZXRXZWVrfSBmcm9tICcuLi8uLi9saWIvZGF0ZS5qcyc7XG5pbXBvcnQge2Zvcm1hdERhdGV9IGZyb20gJy4uLy4uL2xpYi9kYXRlLWZvcm1hdC5qcyc7XG5pbXBvcnQge3BhcnNlSFRNTCwgc2hvd0VsZW1lbnQsIGhpZGVFbGVtZW50fSBmcm9tICcuLi8uLi9saWIvZG9tLmpzJztcbmltcG9ydCBkYXlzVGVtcGxhdGUgZnJvbSAnLi4vdGVtcGxhdGVzL2RheXNUZW1wbGF0ZS5qcyc7XG5pbXBvcnQgY2FsZW5kYXJXZWVrc1RlbXBsYXRlIGZyb20gJy4uL3RlbXBsYXRlcy9jYWxlbmRhcldlZWtzVGVtcGxhdGUuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi9WaWV3LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF5c1ZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgY29uc3RydWN0b3IocGlja2VyKSB7XG4gICAgc3VwZXIocGlja2VyLCB7XG4gICAgICBpZDogMCxcbiAgICAgIG5hbWU6ICdkYXlzJyxcbiAgICAgIGNlbGxDbGFzczogJ2RheScsXG4gICAgfSk7XG4gIH1cblxuICBpbml0KG9wdGlvbnMsIG9uQ29uc3RydWN0aW9uID0gdHJ1ZSkge1xuICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xuICAgICAgY29uc3QgaW5uZXIgPSBwYXJzZUhUTUwoZGF5c1RlbXBsYXRlKS5maXJzdENoaWxkO1xuICAgICAgdGhpcy5kb3cgPSBpbm5lci5maXJzdENoaWxkO1xuICAgICAgdGhpcy5ncmlkID0gaW5uZXIubGFzdENoaWxkO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCB1cGRhdGVET1c7XG5cbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgdGhpcy5taW5EYXRlID0gb3B0aW9ucy5taW5EYXRlO1xuICAgIH1cbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgICAgdGhpcy5tYXhEYXRlID0gb3B0aW9ucy5tYXhEYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRlc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRhdGVzRGlzYWJsZWQgPSBvcHRpb25zLmRhdGVzRGlzYWJsZWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZDtcbiAgICAgIHVwZGF0ZURPVyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZCkge1xuICAgICAgdGhpcy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9kYXlIaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50b2RheUhpZ2hsaWdodCA9IG9wdGlvbnMudG9kYXlIaWdobGlnaHQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndlZWtTdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0O1xuICAgICAgdGhpcy53ZWVrRW5kID0gb3B0aW9ucy53ZWVrRW5kO1xuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XG4gICAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICAgICAgdGhpcy5kYXlOYW1lcyA9IGxvY2FsZS5kYXlzTWluO1xuICAgICAgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCA9IGxvY2FsZS50aXRsZUZvcm1hdDtcbiAgICAgIHRoaXMuc3dpdGNoTGFiZWwgPSBmb3JtYXREYXRlKHRoaXMucGlja2VyLnZpZXdEYXRlLCBsb2NhbGUudGl0bGVGb3JtYXQsIGxvY2FsZSk7XG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iZWZvcmVTaG93RGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBvcHRpb25zLmJlZm9yZVNob3dEYXkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLmJlZm9yZVNob3dEYXlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzICYmICF0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgY29uc3Qgd2Vla3NFbGVtID0gcGFyc2VIVE1MKGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSkuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IHdlZWtzRWxlbSxcbiAgICAgICAgICBkb3c6IHdlZWtzRWxlbS5maXJzdENoaWxkLFxuICAgICAgICAgIHdlZWtzOiB3ZWVrc0VsZW0ubGFzdENoaWxkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdlZWtzRWxlbSwgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MgJiYgIW9wdGlvbnMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jYWxlbmRhcldlZWtzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyV2Vla3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2VlayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2Vlaykge1xuICAgICAgICBzaG93RWxlbWVudCh0aGlzLmRvdyk7XG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmNhbGVuZGFyV2Vla3MuZG93KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5kb3cpO1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5jYWxlbmRhcldlZWtzLmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF5cy1vZi13ZWVrIHdoZW4gbG9jYWxlLCBkYXlzT2Z3ZWVrRGlzYWJsZWQgb3Igd2Vla1N0YXJ0IGlzIGNoYW5nZWRcbiAgICBpZiAodXBkYXRlRE9XKSB7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZG93LmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZG93ID0gKHRoaXMud2Vla1N0YXJ0ICsgaW5kZXgpICUgNztcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0aGlzLmRheU5hbWVzW2Rvd107XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRvdykgPyAnZG93IGRpc2FibGVkJyA6ICdkb3cnO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBmb2N1c2VkIGRhdGUgdG8gdmlldydzIHNldHRpbmdzXG4gIHVwZGF0ZUZvY3VzKCkge1xuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgIGNvbnN0IHZpZXdZZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCB2aWV3TW9udGggPSB2aWV3RGF0ZS5nZXRNb250aCgpO1xuICAgIGNvbnN0IGZpcnN0T2ZNb250aCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoLCAxKTtcbiAgICBjb25zdCBzdGFydCA9IGRheU9mVGhlV2Vla09mKGZpcnN0T2ZNb250aCwgdGhpcy53ZWVrU3RhcnQsIHRoaXMud2Vla1N0YXJ0KTtcblxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdE9mTW9udGg7XG4gICAgdGhpcy5sYXN0ID0gZGF0ZVZhbHVlKHZpZXdZZWFyLCB2aWV3TW9udGggKyAxLCAwKTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cbiAgICB0aGlzLnN3aXRjaExhYmVsID0gZm9ybWF0RGF0ZSh2aWV3RGF0ZSwgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCwgdGhpcy5sb2NhbGUpO1xuICAgIHRoaXMuZm9jdXNlZCA9IHRoaXMucGlja2VyLnZpZXdEYXRlO1xuICB9XG5cbiAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBzZWxlY3RlZCBkYXRlcyB0byB2aWV3J3Mgc2V0dGluZ3NcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2V9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcbiAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXM7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICB9XG5cbiAgIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHVwZGF0ZSB0b2RheSBtYXJrZXIgb24gZXZlciByZW5kZXJcbiAgICB0aGlzLnRvZGF5ID0gdGhpcy50b2RheUhpZ2hsaWdodCA/IHRvZGF5KCkgOiB1bmRlZmluZWQ7XG4gICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBkYXRlcyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcbiAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXG4gICAgdGhpcy5kaXNhYmxlZCA9IFsuLi50aGlzLmRhdGVzRGlzYWJsZWRdO1xuXG4gICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKHRoaXMuc3dpdGNoTGFiZWwpO1xuICAgIHRoaXMucGlja2VyLnNldFByZXZCdG5EaXNhYmxlZCh0aGlzLmZpcnN0IDw9IHRoaXMubWluRGF0ZSk7XG4gICAgdGhpcy5waWNrZXIuc2V0TmV4dEJ0bkRpc2FibGVkKHRoaXMubGFzdCA+PSB0aGlzLm1heERhdGUpO1xuXG4gICAgaWYgKHRoaXMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgLy8gc3RhcnQgb2YgdGhlIFVUQyB3ZWVrIChNb25kYXkpIG9mIHRoZSAxc3Qgb2YgdGhlIG1vbnRoXG4gICAgICBjb25zdCBzdGFydE9mV2VlayA9IGRheU9mVGhlV2Vla09mKHRoaXMuZmlyc3QsIDEsIDEpO1xuICAgICAgQXJyYXkuZnJvbSh0aGlzLmNhbGVuZGFyV2Vla3Mud2Vla3MuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IGdldFdlZWsoYWRkV2Vla3Moc3RhcnRPZldlZWssIGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgY29uc3QgY3VycmVudCA9IGFkZERheXModGhpcy5zdGFydCwgaW5kZXgpO1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xuICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcblxuICAgICAgZWwuY2xhc3NOYW1lID0gYGRhdGVwaWNrZXItY2VsbCAke3RoaXMuY2VsbENsYXNzfWA7XG4gICAgICBlbC5kYXRhc2V0LmRhdGUgPSBjdXJyZW50O1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBkYXRlLmdldERhdGUoKTtcblxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLmZpcnN0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA+IHRoaXMubGFzdCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0Jyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2RheSA9PT0gY3VycmVudCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCd0b2RheScpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pbkRhdGUgfHwgY3VycmVudCA+IHRoaXMubWF4RGF0ZSB8fCB0aGlzLmRpc2FibGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQuaW5jbHVkZXMoZGF5KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF5c09mV2Vla0hpZ2hsaWdodGVkLmluY2x1ZGVzKGRheSkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJhbmdlKXtcbiAgICAgICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2U7XG4gICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iZWZvcmVTaG93KSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2UgfHwgW107XG4gICAgdGhpcy5ncmlkXG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKVxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3JhbmdlJywgJ3JhbmdlLXN0YXJ0JywgJ3JhbmdlLWVuZCcsICdzZWxlY3RlZCcsICdmb2N1c2VkJyk7XG4gICAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBOdW1iZXIoZWwuZGF0YXNldC5kYXRlKTtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyA4NjQwMDAwMCk7XG4gICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbiAgICB0aGlzLmdyaWQuY2hpbGRyZW5baW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgcHVzaFVuaXF1ZSwgY3JlYXRlVGFnUmVwZWF0fSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWV9IGZyb20gJy4uLy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7cGFyc2VIVE1MfSBmcm9tICcuLi8uLi9saWIvZG9tLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4vVmlldy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vbnRoc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgY29uc3RydWN0b3IocGlja2VyKSB7XG4gICAgc3VwZXIocGlja2VyLCB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdtb250aHMnLFxuICAgICAgY2VsbENsYXNzOiAnbW9udGgnLFxuICAgIH0pO1xuICB9XG5cbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtb250aHMnLCAnZGF0ZXBpY2tlci1ncmlkJyk7XG4gICAgICB0aGlzLmdyaWQuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDEyLCB7J2RhdGEtbW9udGgnOiBpeCA9PiBpeH0pKSk7XG4gICAgfVxuICAgIHN1cGVyLmluaXQob3B0aW9ucyk7XG4gIH1cblxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcbiAgICAgIHRoaXMubW9udGhOYW1lcyA9IG9wdGlvbnMubG9jYWxlLm1vbnRoc1Nob3J0O1xuICAgIH1cbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgaWYgKG9wdGlvbnMubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWluWWVhciA9IHRoaXMubWluTW9udGggPSB0aGlzLm1pbkRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtaW5EYXRlT2JqID0gbmV3IERhdGUob3B0aW9ucy5taW5EYXRlKTtcbiAgICAgICAgdGhpcy5taW5ZZWFyID0gbWluRGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLm1pbk1vbnRoID0gbWluRGF0ZU9iai5nZXRNb250aCgpO1xuICAgICAgICB0aGlzLm1pbkRhdGUgPSBtaW5EYXRlT2JqLnNldERhdGUoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXhEYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhNb250aCA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heERhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1heERhdGUpO1xuICAgICAgICB0aGlzLm1heFllYXIgPSBtYXhEYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHRoaXMubWF4TW9udGggPSBtYXhEYXRlT2JqLmdldE1vbnRoKCk7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1heFllYXIsIHRoaXMubWF4TW9udGggKyAxLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlU2hvd01vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBvcHRpb25zLmJlZm9yZVNob3dNb250aCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuYmVmb3JlU2hvd01vbnRoXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcbiAgdXBkYXRlRm9jdXMoKSB7XG4gICAgY29uc3Qgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgdGhpcy55ZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB0aGlzLnN3aXRjaExhYmVsID0gdGhpcy55ZWFyO1xuICAgIHRoaXMuZm9jdXNlZCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlci5kYXRlcy5yZWR1Y2UoKHNlbGVjdGVkLCB0aW1lVmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lVmFsdWUpO1xuICAgICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgaWYgKHNlbGVjdGVkW3llYXJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZWN0ZWRbeWVhcl0gPSBbbW9udGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaFVuaXF1ZShzZWxlY3RlZFt5ZWFyXSwgbW9udGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgbW9udGhzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICB0aGlzLmRpc2FibGVkID0gW107XG5cbiAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwodGhpcy5zd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMueWVhciA8PSB0aGlzLm1pblllYXIpO1xuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLnllYXIgPj0gdGhpcy5tYXhZZWFyKTtcblxuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xuICAgIGNvbnN0IHlyT3V0T2ZSYW5nZSA9IHRoaXMueWVhciA8IHRoaXMubWluWWVhciB8fCB0aGlzLnllYXIgPiB0aGlzLm1heFllYXI7XG4gICAgY29uc3QgaXNNaW5ZZWFyID0gdGhpcy55ZWFyID09PSB0aGlzLm1pblllYXI7XG4gICAgY29uc3QgaXNNYXhZZWFyID0gdGhpcy55ZWFyID09PSB0aGlzLm1heFllYXI7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsICR7dGhpcy5jZWxsQ2xhc3N9YDtcbiAgICAgIC8vIHJlc2V0IHRleHQgb24gZXZlcnkgcmVuZGVyIHRvIGNsZWFyIHRoZSBjdXN0b20gY29udGVudCBzZXRcbiAgICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5tb250aE5hbWVzW2luZGV4XTtcblxuICAgICAgaWYgKFxuICAgICAgICB5ck91dE9mUmFuZ2VcbiAgICAgICAgfHwgaXNNaW5ZZWFyICYmIGluZGV4IDwgdGhpcy5taW5Nb250aFxuICAgICAgICB8fCBpc01heFllYXIgJiYgaW5kZXggPiB0aGlzLm1heE1vbnRoXG4gICAgICApIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2hvdykge1xuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBpbmRleCwgZGF0ZVZhbHVlKHRoaXMueWVhciwgaW5kZXgsIDEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xuICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuc2VsZWN0ZWQsIC5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJywgJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICBpZiAoc2VsZWN0ZWQuaW5jbHVkZXMoaW5kZXgpKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJyk7XG4gICAgfSk7XG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW3RoaXMuZm9jdXNlZF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICB9XG59IiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgcHVzaFVuaXF1ZSwgY3JlYXRlVGFnUmVwZWF0fSBmcm9tICcuLi8uLi9saWIvdXRpbHMuanMnO1xuaW1wb3J0IHtkYXRlVmFsdWUsIHN0YXJ0T2ZZZWFyUGVyaW9kfSBmcm9tICcuLi8uLi9saWIvZGF0ZS5qcyc7XG5pbXBvcnQge3BhcnNlSFRNTH0gZnJvbSAnLi4vLi4vbGliL2RvbS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuXG5mdW5jdGlvbiB0b1RpdGxlQ2FzZSh3b3JkKSB7XG4gIHJldHVybiBbLi4ud29yZF0ucmVkdWNlKChzdHIsIGNoLCBpeCkgPT4gc3RyICs9IGl4ID8gY2ggOiBjaC50b1VwcGVyQ2FzZSgpLCAnJyk7XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgeWVhcnMgYW5kIGRlY2FkZXMgdmlldyBlbGVtZW50c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWWVhcnNWaWV3IGV4dGVuZHMgVmlldyB7XG4gIGNvbnN0cnVjdG9yKHBpY2tlciwgY29uZmlnKSB7XG4gICAgc3VwZXIocGlja2VyLCBjb25maWcpO1xuICB9XG5cbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAob25Db25zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMubmF2U3RlcCA9IHRoaXMuc3RlcCAqIDEwO1xuICAgICAgdGhpcy5iZWZvcmVTaG93T3B0aW9uID0gYGJlZm9yZVNob3cke3RvVGl0bGVDYXNlKHRoaXMuY2VsbENsYXNzKX1gO1xuICAgICAgdGhpcy5ncmlkID0gdGhpcy5lbGVtZW50O1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5uYW1lLCAnZGF0ZXBpY2tlci1ncmlkJyk7XG4gICAgICB0aGlzLmdyaWQuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDEyKSkpO1xuICAgIH1cbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtaW5EYXRlJykpIHtcbiAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbkRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1pblllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1pbkRhdGUsIHRoaXMuc3RlcCk7XG4gICAgICAgIHRoaXMubWluRGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1pblllYXIsIDAsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWF4WWVhciA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF4WWVhciA9IHN0YXJ0T2ZZZWFyUGVyaW9kKG9wdGlvbnMubWF4RGF0ZSwgdGhpcy5zdGVwKTtcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZVZhbHVlKHRoaXMubWF4WWVhciwgMTEsIDMxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbdGhpcy5iZWZvcmVTaG93T3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBiZWZvcmVTaG93ID0gb3B0aW9uc1t0aGlzLmJlZm9yZVNob3dPcHRpb25dO1xuICAgICAgdGhpcy5iZWZvcmVTaG93ID0gdHlwZW9mIGJlZm9yZVNob3cgPT09ICdmdW5jdGlvbicgPyBiZWZvcmVTaG93IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcbiAgdXBkYXRlRm9jdXMoKSB7XG4gICAgY29uc3Qgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgY29uc3QgZmlyc3QgPSBzdGFydE9mWWVhclBlcmlvZCh2aWV3RGF0ZSwgdGhpcy5uYXZTdGVwKTtcbiAgICBjb25zdCBsYXN0ID0gZmlyc3QgKyA5ICogdGhpcy5zdGVwO1xuXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgIHRoaXMubGFzdCA9IGxhc3Q7XG4gICAgdGhpcy5zdGFydCA9IGZpcnN0IC0gdGhpcy5zdGVwO1xuICAgIHRoaXMuc3dpdGNoTGFiZWwgPSBgJHtmaXJzdH0tJHtsYXN0fWA7XG4gICAgdGhpcy5mb2N1c2VkID0gc3RhcnRPZlllYXJQZXJpb2Qodmlld0RhdGUsIHRoaXMuc3RlcCk7XG4gIH1cblxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlci5kYXRlcy5yZWR1Y2UoKHllYXJzLCB0aW1lVmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBwdXNoVW5pcXVlKHllYXJzLCBzdGFydE9mWWVhclBlcmlvZCh0aW1lVmFsdWUsIHRoaXMuc3RlcCkpO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgcmVuZGVyKCkge1xuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgeWVhcnMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcblxuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbCh0aGlzLnN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnBpY2tlci5zZXRQcmV2QnRuRGlzYWJsZWQodGhpcy5maXJzdCA8PSB0aGlzLm1pblllYXIpO1xuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhZZWFyKTtcblxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnN0YXJ0ICsgKGluZGV4ICogdGhpcy5zdGVwKTtcblxuICAgICAgZWwuY2xhc3NOYW1lID0gYGRhdGVwaWNrZXItY2VsbCAke3RoaXMuY2VsbENsYXNzfWA7XG4gICAgICBlbC50ZXh0Q29udGVudCA9IGVsLmRhdGFzZXQueWVhciA9IGN1cnJlbnQ7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdwcmV2Jyk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAxMSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA8IHRoaXMubWluWWVhciB8fCBjdXJyZW50ID4gdGhpcy5tYXhZZWFyKSB7XG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgZGF0ZVZhbHVlKGN1cnJlbnQsIDAsIDEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuc2VsZWN0ZWQsIC5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJywgJ2ZvY3VzZWQnKTtcbiAgICB9KTtcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBOdW1iZXIoZWwudGV4dENvbnRlbnQpO1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXG4gIHJlZnJlc2hGb2N1cygpIHtcbiAgICBjb25zdCBpbmRleCA9IE1hdGgucm91bmQoKHRoaXMuZm9jdXNlZCAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwKTtcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3JpZC5jaGlsZHJlbltpbmRleF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICB9XG59XG4iLCJpbXBvcnQge2xpbWl0VG9SYW5nZX0gZnJvbSAnLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7YWRkTW9udGhzLCBhZGRZZWFyc30gZnJvbSAnLi4vbGliL2RhdGUuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCB0eXBlKSB7XG4gIGNvbnN0IGRldGFpbCA9IHtcbiAgICBkYXRlOiBkYXRlcGlja2VyLmdldERhdGUoKSxcbiAgICB2aWV3RGF0ZTogbmV3IERhdGUoZGF0ZXBpY2tlci5waWNrZXIudmlld0RhdGUpLFxuICAgIHZpZXdJZDogZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQsXG4gICAgZGF0ZXBpY2tlcixcbiAgfTtcbiAgZGF0ZXBpY2tlci5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtkZXRhaWx9KSk7XG59XG5cbi8vIGRpcmVjdGlvbjogLTEgKHRvIHByZXZpb3VzKSwgMSAodG8gbmV4dClcbmV4cG9ydCBmdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qge21pbkRhdGUsIG1heERhdGV9ID0gZGF0ZXBpY2tlci5jb25maWc7XG4gIGNvbnN0IHtjdXJyZW50Vmlldywgdmlld0RhdGV9ID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIGxldCBuZXdWaWV3RGF0ZTtcbiAgc3dpdGNoIChjdXJyZW50Vmlldy5pZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcbiAgfVxuICBuZXdWaWV3RGF0ZSA9IGxpbWl0VG9SYW5nZShuZXdWaWV3RGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSk7XG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcikge1xuICBjb25zdCB2aWV3SWQgPSBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgaWYgKHZpZXdJZCA9PT0gZGF0ZXBpY2tlci5jb25maWcubWF4Vmlldykge1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRlcGlja2VyLnBpY2tlci5jaGFuZ2VWaWV3KHZpZXdJZCArIDEpLnJlbmRlcigpO1xufVxuIiwiaW1wb3J0IHt0b2RheSwgYWRkTW9udGhzLCBhZGRZZWFyc30gZnJvbSAnLi4vbGliL2RhdGUuanMnO1xuaW1wb3J0IHtmaW5kRWxlbWVudEluRXZlbnRQYXRofSBmcm9tICcuLi9saWIvZXZlbnQuanMnO1xuaW1wb3J0IHtnb1RvUHJldk9yTmV4dCwgc3dpdGNoVmlld30gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuXG5mdW5jdGlvbiBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUocGlja2VyLnZpZXdEYXRlKTtcbiAgY29uc3Qgdmlld0lkID0gcGlja2VyLmN1cnJlbnRWaWV3LmlkO1xuICBjb25zdCBuZXdEYXRlID0gdmlld0lkID09PSAxXG4gICAgPyBhZGRNb250aHModmlld0RhdGUsIHNlbGVjdGlvbiAtIHZpZXdEYXRlLmdldE1vbnRoKCkpXG4gICAgOiBhZGRZZWFycyh2aWV3RGF0ZSwgc2VsZWN0aW9uIC0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgcGlja2VyLmNoYW5nZUZvY3VzKG5ld0RhdGUpLmNoYW5nZVZpZXcodmlld0lkIC0gMSkucmVuZGVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrVG9kYXlCdG4oZGF0ZXBpY2tlcikge1xuICBjb25zdCBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgY29uc3QgY3VycmVudERhdGUgPSB0b2RheSgpO1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudG9kYXlCdG5Nb2RlID09PSAxKSB7XG4gICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRlcGlja2VyLnNldERhdGUoY3VycmVudERhdGUsIHtyZW5kZXI6IGZhbHNlfSk7XG4gICAgcGlja2VyLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChwaWNrZXIudmlld0RhdGUgIT09IGN1cnJlbnREYXRlKSB7XG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKGN1cnJlbnREYXRlKTtcbiAgfVxuICBwaWNrZXIuY2hhbmdlVmlldygwKS5yZW5kZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2xpY2tDbGVhckJ0bihkYXRlcGlja2VyKSB7XG4gIGRhdGVwaWNrZXIuc2V0RGF0ZSh7Y2xlYXI6IHRydWV9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2xpY2tWaWV3U3dpdGNoKGRhdGVwaWNrZXIpIHtcbiAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2xpY2tQcmV2QnRuKGRhdGVwaWNrZXIpIHtcbiAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgLTEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja05leHRCdG4oZGF0ZXBpY2tlcikge1xuICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAxKTtcbn1cblxuLy8gRm9yIHRoZSBwaWNrZXIncyBtYWluIGJsb2NrIHRvIGRlbGVnZXRlIHRoZSBldmVudHMgZnJvbSBgZGF0ZXBpY2tlci1jZWxsYHNcbmV4cG9ydCBmdW5jdGlvbiBvbkNsaWNrVmlldyhkYXRlcGlja2VyLCBldikge1xuICBjb25zdCB0YXJnZXQgPSBmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCAnLmRhdGVwaWNrZXItY2VsbCcpO1xuICBpZiAoIXRhcmdldCB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGRhdGVwaWNrZXIuc2V0RGF0ZShOdW1iZXIodGFyZ2V0LmRhdGFzZXQuZGF0ZSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0Lm1vbnRoKSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0LnllYXIpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja1BpY2tlcihkYXRlcGlja2VyLCBldikge1xuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAvLyBjaGVjayBpZiB0aGUgcGlja2VyIGlzIGFjdGl2ZSBpbiBvcmRlciB0byBwcmV2ZW50IHRoZSBwaWNrZXIgZnJvbSBiZWluZ1xuICAvLyByZS1zaG93biBhZnRlciBhdXRvLWhpZGUgd2hlbiBzaG93T25Gb2N1czogdHJ1ZVxuICAvLyBpdCdzIGNhdXNlZCBieSBidWJibGVkIGV2ZW50IGZyb20gY2VsbHMvYnV0dG9ucywgYnV0IHRoZSBidWJibGluZyBjYW5ub3RcbiAgLy8gYmUgZGlzYWJsZWQgYmVjYXVzZSBpdCdzIG5lZWRlZCB0byBrZWVwIHRoZSBmb2N1cyBvbiB0aGUgaW5wdXQgZWxlbWVudFxuICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lICYmIGRhdGVwaWNrZXIucGlja2VyLmFjdGl2ZSAmJiAhZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtoYXNQcm9wZXJ0eSwgbGFzdEl0ZW1PZiwgaXNJblJhbmdlLCBsaW1pdFRvUmFuZ2V9IGZyb20gJy4uL2xpYi91dGlscy5qcyc7XG5pbXBvcnQge3RvZGF5fSBmcm9tICcuLi9saWIvZGF0ZS5qcyc7XG5pbXBvcnQge3BhcnNlSFRNTCwgc2hvd0VsZW1lbnQsIGhpZGVFbGVtZW50LCBlbXB0eUNoaWxkTm9kZXN9IGZyb20gJy4uL2xpYi9kb20uanMnO1xuaW1wb3J0IHtyZWdpc3Rlckxpc3RlbmVyc30gZnJvbSAnLi4vbGliL2V2ZW50LmpzJztcbmltcG9ydCBwaWNrZXJUZW1wbGF0ZSBmcm9tICcuL3RlbXBsYXRlcy9waWNrZXJUZW1wbGF0ZS5qcyc7XG5pbXBvcnQgRGF5c1ZpZXcgZnJvbSAnLi92aWV3cy9EYXlzVmlldy5qcyc7XG5pbXBvcnQgTW9udGhzVmlldyBmcm9tICcuL3ZpZXdzL01vbnRoc1ZpZXcuanMnO1xuaW1wb3J0IFllYXJzVmlldyBmcm9tICcuL3ZpZXdzL1llYXJzVmlldy5qcyc7XG5pbXBvcnQge3RyaWdnZXJEYXRlcGlja2VyRXZlbnR9IGZyb20gJy4uL2V2ZW50cy9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtcbiAgb25DbGlja1RvZGF5QnRuLFxuICBvbkNsaWNrQ2xlYXJCdG4sXG4gIG9uQ2xpY2tWaWV3U3dpdGNoLFxuICBvbkNsaWNrUHJldkJ0bixcbiAgb25DbGlja05leHRCdG4sXG4gIG9uQ2xpY2tWaWV3LFxuICBvbkNsaWNrUGlja2VyLFxufSBmcm9tICcuLi9ldmVudHMvcGlja2VyTGlzdGVuZXJzLmpzJztcblxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJldkFycm93KSB7XG4gICAgY29uc3QgcHJldkJ0biA9IHBpY2tlci5jb250cm9scy5wcmV2QnRuO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcbiAgICBvcHRpb25zLnByZXZBcnJvdy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBwcmV2QnRuLmFwcGVuZENoaWxkKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5uZXh0QXJyb3cpIHtcbiAgICBjb25zdCBuZXh0QnRuID0gcGlja2VyLmNvbnRyb2xzLm5leHRCdG47XG4gICAgZW1wdHlDaGlsZE5vZGVzKG5leHRCdG4pO1xuICAgIG9wdGlvbnMubmV4dEFycm93LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5leHRCdG4uYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLnRvZGF5O1xuICAgIHBpY2tlci5jb250cm9scy5jbGVhckJ0bi50ZXh0Q29udGVudCA9IG9wdGlvbnMubG9jYWxlLmNsZWFyO1xuICB9XG4gIGlmIChvcHRpb25zLnRvZGF5QnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50b2RheUJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtaW5EYXRlJykgfHwgaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xuICAgIGNvbnN0IHttaW5EYXRlLCBtYXhEYXRlfSA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZztcbiAgICBwaWNrZXIuY29udHJvbHMudG9kYXlCdG4uZGlzYWJsZWQgPSAhaXNJblJhbmdlKHRvZGF5KCksIG1pbkRhdGUsIG1heERhdGUpO1xuICB9XG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5jbGVhckJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cbi8vIC0gdGhlIGxhc3QgaXRlbSBvZiB0aGUgc2VsZWN0ZWQgZGF0ZXMgb3IgZGVmYXVsdFZpZXdEYXRlIGlmIG5vIHNlbGVjdGlvblxuLy8gLSBsaW1pdHRlZCB0byBtaW5EYXRlIG9yIG1heERhdGUgaWYgaXQgZXhjZWVkcyB0aGUgcmFuZ2VcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcbiAgY29uc3Qge2RhdGVzLCBjb25maWd9ID0gZGF0ZXBpY2tlcjtcbiAgY29uc3Qgdmlld0RhdGUgPSBkYXRlcy5sZW5ndGggPiAwID8gbGFzdEl0ZW1PZihkYXRlcykgOiBjb25maWcuZGVmYXVsdFZpZXdEYXRlO1xuICByZXR1cm4gbGltaXRUb1JhbmdlKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xufVxuXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXG5mdW5jdGlvbiBzZXRWaWV3RGF0ZShwaWNrZXIsIG5ld0RhdGUpIHtcbiAgY29uc3Qgb2xkVmlld0RhdGUgPSBuZXcgRGF0ZShwaWNrZXIudmlld0RhdGUpO1xuICBjb25zdCBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xuICBjb25zdCB7aWQsIHllYXIsIGZpcnN0LCBsYXN0fSA9IHBpY2tlci5jdXJyZW50VmlldztcbiAgY29uc3Qgdmlld1llYXIgPSBuZXdWaWV3RGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gIHBpY2tlci52aWV3RGF0ZSA9IG5ld0RhdGU7XG4gIGlmICh2aWV3WWVhciAhPT0gb2xkVmlld0RhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VZZWFyJyk7XG4gIH1cbiAgaWYgKG5ld1ZpZXdEYXRlLmdldE1vbnRoKCkgIT09IG9sZFZpZXdEYXRlLmdldE1vbnRoKCkpIHtcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlTW9udGgnKTtcbiAgfVxuXG4gIC8vIHJldHVybiB3aGV0aGVyIHRoZSBuZXcgZGF0ZSBpcyBpbiBkaWZmZXJlbnQgcGVyaW9kIG9uIHRpbWUgZnJvbSB0aGUgb25lXG4gIC8vIGRpc3BsYXllZCBpbiB0aGUgY3VycmVudCB2aWV3XG4gIC8vIHdoZW4gdHJ1ZSwgdGhlIHZpZXcgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQgb24gdGhlIG5leHQgVUkgcmVmcmVzaC5cbiAgc3dpdGNoIChpZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBuZXdEYXRlIDwgZmlyc3QgfHwgbmV3RGF0ZSA+IGxhc3Q7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHZpZXdZZWFyICE9PSB5ZWFyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmlld1llYXIgPCBmaXJzdCB8fCB2aWV3WWVhciA+IGxhc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbihlbCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbjtcbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBwaWNrZXIgVUlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGVwaWNrZXIpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIgPSBkYXRlcGlja2VyO1xuXG4gICAgY29uc3QgdGVtcGxhdGUgPSBwaWNrZXJUZW1wbGF0ZS5yZXBsYWNlKC8lYnV0dG9uQ2xhc3MlL2csIGRhdGVwaWNrZXIuY29uZmlnLmJ1dHRvbkNsYXNzKTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50ID0gcGFyc2VIVE1MKHRlbXBsYXRlKS5maXJzdENoaWxkO1xuICAgIGNvbnN0IFtoZWFkZXIsIG1haW4sIGZvb3Rlcl0gPSBlbGVtZW50LmZpcnN0Q2hpbGQuY2hpbGRyZW47XG4gICAgY29uc3QgdGl0bGUgPSBoZWFkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgY29uc3QgW3ByZXZCdG4sIHZpZXdTd2l0Y2gsIG5leHRCdG5dID0gaGVhZGVyLmxhc3RFbGVtZW50Q2hpbGQuY2hpbGRyZW47XG4gICAgY29uc3QgW3RvZGF5QnRuLCBjbGVhckJ0bl0gPSBmb290ZXIuZmlyc3RDaGlsZC5jaGlsZHJlbjtcbiAgICBjb25zdCBjb250cm9scyA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgcHJldkJ0bixcbiAgICAgIHZpZXdTd2l0Y2gsXG4gICAgICBuZXh0QnRuLFxuICAgICAgdG9kYXlCdG4sXG4gICAgICBjbGVhckJ0bixcbiAgICB9O1xuICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuXG4gICAgY29uc3QgZWxlbWVudENsYXNzID0gZGF0ZXBpY2tlci5pbmxpbmUgPyAnaW5saW5lJyA6ICdkcm9wZG93bic7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLSR7ZWxlbWVudENsYXNzfWApO1xuXG4gICAgcHJvY2Vzc1BpY2tlck9wdGlvbnModGhpcywgZGF0ZXBpY2tlci5jb25maWcpO1xuICAgIHRoaXMudmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZShkYXRlcGlja2VyKTtcblxuICAgIC8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICByZWdpc3Rlckxpc3RlbmVycyhkYXRlcGlja2VyLCBbXG4gICAgICBbZWxlbWVudCwgJ2NsaWNrJywgb25DbGlja1BpY2tlci5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFttYWluLCAnY2xpY2snLCBvbkNsaWNrVmlldy5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy52aWV3U3dpdGNoLCAnY2xpY2snLCBvbkNsaWNrVmlld1N3aXRjaC5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy5wcmV2QnRuLCAnY2xpY2snLCBvbkNsaWNrUHJldkJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy5uZXh0QnRuLCAnY2xpY2snLCBvbkNsaWNrTmV4dEJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcbiAgICAgIFtjb250cm9scy50b2RheUJ0biwgJ2NsaWNrJywgb25DbGlja1RvZGF5QnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxuICAgICAgW2NvbnRyb2xzLmNsZWFyQnRuLCAnY2xpY2snLCBvbkNsaWNrQ2xlYXJCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXG4gICAgXSk7XG5cbiAgICAvLyBzZXQgdXAgdmlld3NcbiAgICB0aGlzLnZpZXdzID0gW1xuICAgICAgbmV3IERheXNWaWV3KHRoaXMpLFxuICAgICAgbmV3IE1vbnRoc1ZpZXcodGhpcyksXG4gICAgICBuZXcgWWVhcnNWaWV3KHRoaXMsIHtpZDogMiwgbmFtZTogJ3llYXJzJywgY2VsbENsYXNzOiAneWVhcicsIHN0ZXA6IDF9KSxcbiAgICAgIG5ldyBZZWFyc1ZpZXcodGhpcywge2lkOiAzLCBuYW1lOiAnZGVjYWRlcycsIGNlbGxDbGFzczogJ2RlY2FkZScsIHN0ZXA6IDEwfSksXG4gICAgXTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy52aWV3c1tkYXRlcGlja2VyLmNvbmZpZy5zdGFydFZpZXddO1xuXG4gICAgdGhpcy5jdXJyZW50Vmlldy5yZW5kZXIoKTtcbiAgICB0aGlzLm1haW4uYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50Vmlldy5lbGVtZW50KTtcbiAgICBkYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMudmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgdmlldy5pbml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICB9XG5cbiAgZGV0YWNoKCl7XG4gICAgdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG5cbiAgICBjb25zdCBkYXRlcGlja2VyID0gdGhpcy5kYXRlcGlja2VyO1xuICAgIGlmICghZGF0ZXBpY2tlci5pbmxpbmUpIHtcbiAgICAgIC8vIGVuc3VyZSBwaWNrZXIncyBkaXJlY3Rpb24gbWF0Y2hlcyBpbnB1dCdzXG4gICAgICBjb25zdCBpbnB1dERpcmVjdGlvbiA9IGdldFRleHREaXJlY3Rpb24oZGF0ZXBpY2tlci5pbnB1dEZpZWxkKTtcbiAgICAgIGlmIChpbnB1dERpcmVjdGlvbiAhPT0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIpKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXIgPSBpbnB1dERpcmVjdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmRpcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGFjZSgpO1xuICAgICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkKSB7XG4gICAgICAgIGRhdGVwaWNrZXIuaW5wdXRGaWVsZC5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ3Nob3cnKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRhdGVwaWNrZXIuZXhpdEVkaXRNb2RlKCk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudCh0aGlzLmRhdGVwaWNrZXIsICdoaWRlJyk7XG4gIH1cblxuICBwbGFjZSgpIHtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3Qge2NvbmZpZywgaW5wdXRGaWVsZH0gPSB0aGlzLmRhdGVwaWNrZXI7XG4gICAgY29uc3QgY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lcjtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogY2FsZW5kYXJXaWR0aCxcbiAgICAgIGhlaWdodDogY2FsZW5kYXJIZWlnaHQsXG4gICAgfSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBjb250YWluZXJMZWZ0LFxuICAgICAgdG9wOiBjb250YWluZXJUb3AsXG4gICAgICB3aWR0aDogY29udGFpbmVyV2lkdGgsXG4gICAgfSA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBpbnB1dExlZnQsXG4gICAgICB0b3A6IGlucHV0VG9wLFxuICAgICAgd2lkdGg6IGlucHV0V2lkdGgsXG4gICAgICBoZWlnaHQ6IGlucHV0SGVpZ2h0XG4gICAgfSA9IGlucHV0RmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHt4OiBvcmllbnRYLCB5OiBvcmllbnRZfSA9IGNvbmZpZy5vcmllbnRhdGlvbjtcbiAgICBsZXQgc2Nyb2xsVG9wO1xuICAgIGxldCBsZWZ0O1xuICAgIGxldCB0b3A7XG5cbiAgICBpZiAoY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBzY3JvbGxUb3AgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIGxlZnQgPSBpbnB1dExlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgIHRvcCA9IGlucHV0VG9wICsgc2Nyb2xsVG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgbGVmdCA9IGlucHV0TGVmdCAtIGNvbnRhaW5lckxlZnQ7XG4gICAgICB0b3AgPSBpbnB1dFRvcCAtIGNvbnRhaW5lclRvcCArIHNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICBpZiAob3JpZW50WCA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgLy8gYWxpZ24gdG8gdGhlIGxlZnQgYW5kIG1vdmUgaW50byB2aXNpYmxlIGFyZWEgaWYgaW5wdXQncyBsZWZ0IGVkZ2UgPCB3aW5kb3cnc1xuICAgICAgICBvcmllbnRYID0gJ2xlZnQnO1xuICAgICAgICBsZWZ0ID0gMTA7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQgKyBjYWxlbmRhcldpZHRoID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgLy8gYWxpZ24gdG8gdGhlIHJpZ2h0IGlmIGNhbmxlbmRhcidzIHJpZ2h0IGVkZ2UgPiBjb250YWluZXInc1xuICAgICAgICBvcmllbnRYID0gJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWVudFggPSBnZXRUZXh0RGlyZWN0aW9uKGlucHV0RmllbGQpID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmllbnRYID09PSAncmlnaHQnKSB7XG4gICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dFdpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcmllbnRZID09PSAnYXV0bycpIHtcbiAgICAgIG9yaWVudFkgPSB0b3AgLSBjYWxlbmRhckhlaWdodCA8IHNjcm9sbFRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfVxuICAgIGlmIChvcmllbnRZID09PSAndG9wJykge1xuICAgICAgdG9wIC09IGNhbGVuZGFySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgKz0gaW5wdXRIZWlnaHQ7XG4gICAgfVxuXG4gICAgY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC10b3AnLFxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LWJvdHRvbScsXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnLFxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnXG4gICAgKTtcbiAgICBjbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLW9yaWVudC0ke29yaWVudFl9YCwgYGRhdGVwaWNrZXItb3JpZW50LSR7b3JpZW50WH1gKTtcblxuICAgIHN0eWxlLnRvcCA9IHRvcCA/IGAke3RvcH1weGAgOiB0b3A7XG4gICAgc3R5bGUubGVmdCA9IGxlZnQgPyBgJHtsZWZ0fXB4YCA6IGxlZnQ7XG4gIH1cblxuICBzZXRWaWV3U3dpdGNoTGFiZWwobGFiZWxUZXh0KSB7XG4gICAgdGhpcy5jb250cm9scy52aWV3U3dpdGNoLnRleHRDb250ZW50ID0gbGFiZWxUZXh0O1xuICB9XG5cbiAgc2V0UHJldkJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5jb250cm9scy5wcmV2QnRuLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH1cblxuICBzZXROZXh0QnRuRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmNvbnRyb2xzLm5leHRCdG4uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfVxuXG4gIGNoYW5nZVZpZXcodmlld0lkKSB7XG4gICAgY29uc3Qgb2xkVmlldyA9IHRoaXMuY3VycmVudFZpZXc7XG4gICAgY29uc3QgbmV3VmlldyA9ICB0aGlzLnZpZXdzW3ZpZXdJZF07XG4gICAgaWYgKG5ld1ZpZXcuaWQgIT09IG9sZFZpZXcuaWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBuZXdWaWV3O1xuICAgICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gJ3JlbmRlcic7XG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2NoYW5nZVZpZXcnKTtcbiAgICAgIHRoaXMubWFpbi5yZXBsYWNlQ2hpbGQobmV3Vmlldy5lbGVtZW50LCBvbGRWaWV3LmVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIENoYW5nZSB0aGUgZm9jdXNlZCBkYXRlICh2aWV3IGRhdGUpXG4gIGNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKSB7XG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaEZvY3VzJztcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcbiAgICAgIHZpZXcudXBkYXRlRm9jdXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBuZXdWaWV3RGF0ZSA9IGNvbXB1dGVSZXNldFZpZXdEYXRlKHRoaXMuZGF0ZXBpY2tlcik7XG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaCc7XG4gICAgdGhpcy52aWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICB2aWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgICB2aWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUmVmcmVzaCB0aGUgcGlja2VyIFVJXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCByZW5kZXJNZXRob2QgPSB0aGlzLl9yZW5kZXJNZXRob2QgfHwgJ3JlbmRlcic7XG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlck1ldGhvZDtcblxuICAgIHRoaXMuY3VycmVudFZpZXdbcmVuZGVyTWV0aG9kXSgpO1xuICB9XG59XG4iLCJpbXBvcnQge2lzSW5SYW5nZX0gZnJvbSAnLi4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7YWRkRGF5cywgYWRkTW9udGhzLCBhZGRZZWFycywgc3RhcnRPZlllYXJQZXJpb2R9IGZyb20gJy4uL2xpYi9kYXRlLmpzJztcbmltcG9ydCB7Z29Ub1ByZXZPck5leHQsIHN3aXRjaFZpZXd9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuLy8gRmluZCB0aGUgY2xvc2VzdCBkYXRlIHRoYXQgZG9lc24ndCBtZWV0IHRoZSBjb25kaXRpb24gZm9yIHVuYXZhaWxhYmxlIGRhdGVcbi8vIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIGF2YWlsYWJsZSBkYXRlIGlzIGZvdW5kXG4vLyBhZGRGbjogZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBuZXh0IGRhdGVcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlLCBhbW91bnRcbi8vIGluY3JlYXNlOiBhbW91bnQgdG8gcGFzcyB0byBhZGRGblxuLy8gdGVzdEZuOiBmdW5jdGlvbiB0byB0ZXN0IHRoZSB1bmF2YWlsYWJsaXR5IG9mIHRoZSBkYXRlXG4vLyAgIC0gYXJnczogdGltZSB2YWx1ZTsgcmV0dW46IHRydWUgaWYgdW5hdmFpbGFibGVcbmZ1bmN0aW9uIGZpbmROZXh0QXZhaWxhYmxlT25lKGRhdGUsIGFkZEZuLCBpbmNyZWFzZSwgdGVzdEZuLCBtaW4sIG1heCkge1xuICBpZiAoIWlzSW5SYW5nZShkYXRlLCBtaW4sIG1heCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRlc3RGbihkYXRlKSkge1xuICAgIGNvbnN0IG5ld0RhdGUgPSBhZGRGbihkYXRlLCBpbmNyZWFzZSk7XG4gICAgcmV0dXJuIGZpbmROZXh0QXZhaWxhYmxlT25lKG5ld0RhdGUsIGFkZEZuLCBpbmNyZWFzZSwgdGVzdEZuLCBtaW4sIG1heCk7XG4gIH1cbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIGRpcmVjdGlvbjogLTEgKGxlZnQvdXApLCAxIChyaWdodC9kb3duKVxuLy8gdmVydGljYWw6IHRydWUgZm9yIHVwL2Rvd24sIGZhbHNlIGZvciBsZWZ0L3JpZ2h0XG5mdW5jdGlvbiBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgZGlyZWN0aW9uLCB2ZXJ0aWNhbCkge1xuICBjb25zdCBjdXJyZW50VmlldyA9IGRhdGVwaWNrZXIucGlja2VyLmN1cnJlbnRWaWV3O1xuICBjb25zdCBzdGVwID0gY3VycmVudFZpZXcuc3RlcCB8fCAxO1xuICBsZXQgdmlld0RhdGUgPSBkYXRlcGlja2VyLnBpY2tlci52aWV3RGF0ZTtcbiAgbGV0IGFkZEZuO1xuICBsZXQgdGVzdEZuO1xuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIHZpZXdEYXRlID0gYWRkRGF5cyh2aWV3RGF0ZSwgZGlyZWN0aW9uICogNyk7XG4gICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgYWRkRm4gPSBhZGREYXlzO1xuICAgICAgdGVzdEZuID0gKGRhdGUpID0+IGN1cnJlbnRWaWV3LmRpc2FibGVkLmluY2x1ZGVzKGRhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgdmlld0RhdGUgPSBhZGRNb250aHModmlld0RhdGUsIHZlcnRpY2FsID8gZGlyZWN0aW9uICogNCA6IGRpcmVjdGlvbik7XG4gICAgICBhZGRGbiA9IGFkZE1vbnRocztcbiAgICAgIHRlc3RGbiA9IChkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGR0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgIGNvbnN0IHt5ZWFyLCBkaXNhYmxlZH0gPSBjdXJyZW50VmlldztcbiAgICAgICAgcmV0dXJuIGR0LmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgZGlzYWJsZWQuaW5jbHVkZXMoZHQuZ2V0TW9udGgoKSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZpZXdEYXRlID0gYWRkWWVhcnModmlld0RhdGUsIGRpcmVjdGlvbiAqICh2ZXJ0aWNhbCA/IDQgOiAxKSAqIHN0ZXApO1xuICAgICAgYWRkRm4gPSBhZGRZZWFycztcbiAgICAgIHRlc3RGbiA9IGRhdGUgPT4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoc3RhcnRPZlllYXJQZXJpb2QoZGF0ZSwgc3RlcCkpO1xuICB9XG4gIHZpZXdEYXRlID0gZmluZE5leHRBdmFpbGFibGVPbmUoXG4gICAgdmlld0RhdGUsXG4gICAgYWRkRm4sXG4gICAgZGlyZWN0aW9uIDwgMCA/IC1zdGVwIDogc3RlcCxcbiAgICB0ZXN0Rm4sXG4gICAgY3VycmVudFZpZXcubWluRGF0ZSxcbiAgICBjdXJyZW50Vmlldy5tYXhEYXRlXG4gICk7XG4gIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0ZXBpY2tlci5waWNrZXIuY2hhbmdlRm9jdXModmlld0RhdGUpLnJlbmRlcigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbktleWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmtleSA9PT0gJ1RhYicpIHtcbiAgICBkYXRlcGlja2VyLnJlZnJlc2goJ2lucHV0Jyk7XG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgdmlld0lkID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQ7XG4gIGlmICghZGF0ZXBpY2tlci5waWNrZXIuYWN0aXZlKSB7XG4gICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBkYXRlcGlja2VyLnBpY2tlci5zaG93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICBkYXRlcGlja2VyLnVwZGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0ZXBpY2tlci5lZGl0TW9kZSkge1xuICAgIHN3aXRjaCAoZXYua2V5KSB7XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBkYXRlcGlja2VyLmV4aXRFZGl0TW9kZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgZGF0ZXBpY2tlci5leGl0RWRpdE1vZGUoe3VwZGF0ZTogdHJ1ZSwgYXV0b2hpZGU6IGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5waWNrZXIuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIDEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIDEsIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgaWYgKHZpZXdJZCA9PT0gMCkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuc2V0RGF0ZShkYXRlcGlja2VyLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5waWNrZXIuY2hhbmdlVmlldyh2aWV3SWQgLSAxKS5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICBjYXNlICdEZWxldGUnOlxuICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGV2LmtleS5sZW5ndGggPT09IDEgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25Gb2N1cyhkYXRlcGlja2VyKSB7XG4gIGlmIChkYXRlcGlja2VyLmNvbmZpZy5zaG93T25Gb2N1cykge1xuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xuICB9XG59XG5cbi8vIGZvciB0aGUgcHJldmVudGlvbiBmb3IgZW50ZXJpbmcgZWRpdCBtb2RlIHdoaWxlIGdldHRpbmcgZm9jdXMgb24gY2xpY2tcbmV4cG9ydCBmdW5jdGlvbiBvbk1vdXNlZG93bihkYXRlcGlja2VyLCBldikge1xuICBjb25zdCBlbCA9IGV2LnRhcmdldDtcbiAgaWYgKGRhdGVwaWNrZXIucGlja2VyLmFjdGl2ZSkge1xuICAgIGVsLl9jbGlja2luZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVsZXRlIGVsLl9jbGlja2luZztcbiAgICB9LCAyMDAwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja0lucHV0KGRhdGVwaWNrZXIsIGV2KSB7XG4gIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xuICBpZiAoIWVsLl9jbGlja2luZykge1xuICAgIHJldHVybjtcbiAgfVxuICBjbGVhclRpbWVvdXQoZWwuX2NsaWNraW5nKTtcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcblxuICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uUGFzdGUoZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG59XG4iLCJpbXBvcnQge2ZpbmRFbGVtZW50SW5FdmVudFBhdGh9IGZyb20gJy4uL2xpYi9ldmVudC5qcyc7XG5cbi8vIGZvciB0aGUgYGRvY3VtZW50YCB0byBkZWxlZ2F0ZSB0aGUgZXZlbnRzIGZyb20gb3V0c2lkZSB0aGUgcGlja2VyL2lucHV0IGZpZWxkXG5leHBvcnQgZnVuY3Rpb24gb25DbGlja091dHNpZGUoZGF0ZXBpY2tlciwgZXYpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRhdGVwaWNrZXIuZWxlbWVudDtcbiAgY29uc3QgcGlja2VyRWxlbSA9IGRhdGVwaWNrZXIucGlja2VyLmVsZW1lbnQ7XG5cbiAgaWYgKGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsIGVsID0+IGVsID09PSBlbGVtZW50IHx8IGVsID09PSBwaWNrZXJFbGVtKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRlcGlja2VyLnJlZnJlc2goJ2lucHV0Jyk7XG4gIGRhdGVwaWNrZXIuaGlkZSgpO1xufVxuIiwiaW1wb3J0IHtsYXN0SXRlbU9mLCBzdHJpbmdUb0FycmF5LCBpc0luUmFuZ2V9IGZyb20gJy4vbGliL3V0aWxzLmpzJztcbmltcG9ydCB7dG9kYXl9IGZyb20gJy4vbGliL2RhdGUuanMnO1xuaW1wb3J0IHtwYXJzZURhdGUsIGZvcm1hdERhdGV9IGZyb20gJy4vbGliL2RhdGUtZm9ybWF0LmpzJztcbmltcG9ydCB7cmVnaXN0ZXJMaXN0ZW5lcnMsIHVucmVnaXN0ZXJMaXN0ZW5lcnN9IGZyb20gJy4vbGliL2V2ZW50LmpzJztcbmltcG9ydCB7bG9jYWxlc30gZnJvbSAnLi9pMThuL2Jhc2UtbG9jYWxlcy5qcyc7XG5pbXBvcnQgZGVmYXVsdE9wdGlvbnMgZnJvbSAnLi9vcHRpb25zL2RlZmF1bHRPcHRpb25zLmpzJztcbmltcG9ydCBwcm9jZXNzT3B0aW9ucyBmcm9tICcuL29wdGlvbnMvcHJvY2Vzc09wdGlvbnMuanMnO1xuaW1wb3J0IFBpY2tlciBmcm9tICcuL3BpY2tlci9QaWNrZXIuanMnO1xuaW1wb3J0IHt0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50fSBmcm9tICcuL2V2ZW50cy9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtvbktleWRvd24sIG9uRm9jdXMsIG9uTW91c2Vkb3duLCBvbkNsaWNrSW5wdXQsIG9uUGFzdGV9IGZyb20gJy4vZXZlbnRzL2lucHV0RmllbGRMaXN0ZW5lcnMuanMnO1xuaW1wb3J0IHtvbkNsaWNrT3V0c2lkZX0gZnJvbSAnLi9ldmVudHMvb3RoZXJMaXN0ZW5lcnMuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlEYXRlcyhkYXRlcywgY29uZmlnKSB7XG4gIHJldHVybiBkYXRlc1xuICAgIC5tYXAoZHQgPT4gZm9ybWF0RGF0ZShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSkpXG4gICAgLmpvaW4oY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xufVxuXG4vLyBwYXJzZSBpbnB1dCBkYXRlcyBhbmQgY3JlYXRlIGFuIGFycmF5IG9mIHRpbWUgdmFsdWVzIGZvciBzZWxlY3Rpb25cbi8vIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBkYXRlcyBpbiBpbnB1dERhdGVzXG4vLyB3aGVuIG9yaWdEYXRlcyAoY3VycmVudCBzZWxlY3Rpb24pIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHdvcmtzIHRvIG1peFxuLy8gdGhlIGlucHV0IGRhdGVzIGludG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5mdW5jdGlvbiBwcm9jZXNzSW5wdXREYXRlcyhpbnB1dERhdGVzLCBjb25maWcsIG9yaWdEYXRlcyA9IHVuZGVmaW5lZCkge1xuICBpZiAoaW5wdXREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBlbXB0eSBpbnB1dCBpcyBjb25zaWRlcmVkIHZhbGlkIHVubGVzcyBvcmlnaURhdGVzIGlzIHBhc3NlZFxuICAgIHJldHVybiBvcmlnRGF0ZXMgPyB1bmRlZmluZWQgOiBbXTtcbiAgfVxuXG4gIGxldCBuZXdEYXRlcyA9IGlucHV0RGF0ZXMucmVkdWNlKChkYXRlcywgZHQpID0+IHtcbiAgICBjb25zdCBkYXRlID0gcGFyc2VEYXRlKGR0LCBjb25maWcuZm9ybWF0LCBjb25maWcubG9jYWxlKTtcbiAgICBpZiAoXG4gICAgICBkYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICYmIGlzSW5SYW5nZShkYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpXG4gICAgICAmJiAhZGF0ZXMuaW5jbHVkZXMoZGF0ZSlcbiAgICAgICYmICFjb25maWcuZGF0ZXNEaXNhYmxlZC5pbmNsdWRlcyhkYXRlKVxuICAgICAgJiYgIWNvbmZpZy5kYXlzT2ZXZWVrRGlzYWJsZWQuaW5jbHVkZXMobmV3IERhdGUoZGF0ZSkuZ2V0RGF5KCkpXG4gICAgKSB7XG4gICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXM7XG4gIH0sIFtdKTtcbiAgaWYgKG5ld0RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3JpZ0RhdGVzICYmIGNvbmZpZy5tdWx0aWRhdGUpIHtcbiAgICAvLyBnZXQgdGhlIHN5bm1ldHJpYyBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ0RhdGVzIGFuZCBuZXdEYXRlc1xuICAgIG5ld0RhdGVzID0gbmV3RGF0ZXMucmVkdWNlKChkYXRlcywgZGF0ZSkgPT4ge1xuICAgICAgaWYgKCFvcmlnRGF0ZXMuaW5jbHVkZXMoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlcztcbiAgICB9LCBvcmlnRGF0ZXMuZmlsdGVyKGRhdGUgPT4gIW5ld0RhdGVzLmluY2x1ZGVzKGRhdGUpKSk7XG4gIH1cbiAgLy8gZG8gbGVuZ3RoIGNoZWNrIGFsd2F5cyBiZWNhdXNlIHVzZXIgY2FuIGlucHV0IG11bHRpcGxlIGRhdGVzIHJlZ2FyZGxlc3Mgb2YgdGhlIG1vZGVcbiAgcmV0dXJuIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICYmIG5ld0RhdGVzLmxlbmd0aCA+IGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzXG4gICAgPyBuZXdEYXRlcy5zbGljZShjb25maWcubWF4TnVtYmVyT2ZEYXRlcyAqIC0xKVxuICAgIDogbmV3RGF0ZXM7XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZGF0ZSBwaWNrZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZXBpY2tlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkYXRlIHBpY2tlclxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGEgZGF0ZSBwaWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBjb25maWcgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtEYXRlUmFuZ2VQaWNrZXJ9IFtyYW5nZXBpY2tlcl0gLSBEYXRlUmFuZ2VQaWNrZXIgaW5zdGFuY2UgdGhlXG4gICAqIGRhdGUgcGlja2VyIGJlbG9uZ3MgdG8uIFVzZSB0aGlzIG9ubHkgd2hlbiBjcmVhdGluZyBkYXRlIHBpY2tlciBhcyBhIHBhcnRcbiAgICogb2YgZGF0ZSByYW5nZSBwaWNrZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSwgcmFuZ2VwaWNrZXIgPSB1bmRlZmluZWQpIHtcbiAgICBlbGVtZW50LmRhdGVwaWNrZXIgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvLyBzZXQgdXAgY29uZmlnXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGJ1dHRvbkNsYXNzOiAob3B0aW9ucy5idXR0b25DbGFzcyAmJiBTdHJpbmcob3B0aW9ucy5idXR0b25DbGFzcykpIHx8ICdidXR0b24nLFxuICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgZGVmYXVsdFZpZXdEYXRlOiB0b2RheSgpLFxuICAgICAgbWF4RGF0ZTogdW5kZWZpbmVkLFxuICAgICAgbWluRGF0ZTogdW5kZWZpbmVkLFxuICAgIH0sIHByb2Nlc3NPcHRpb25zKGRlZmF1bHRPcHRpb25zLCB0aGlzKSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBieSB0eXBlXG4gICAgY29uc3QgaW5saW5lID0gdGhpcy5pbmxpbmUgPSBlbGVtZW50LnRhZ05hbWUgIT09ICdJTlBVVCc7XG4gICAgbGV0IGlucHV0RmllbGQ7XG4gICAgbGV0IGluaXRpYWxEYXRlcztcblxuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBlbGVtZW50O1xuICAgICAgaW5pdGlhbERhdGVzID0gc3RyaW5nVG9BcnJheShlbGVtZW50LmRhdGFzZXQuZGF0ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpIDogbnVsbDtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIGlucHV0RmllbGQgPSB0aGlzLmlucHV0RmllbGQgPSBlbGVtZW50O1xuICAgICAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKCdkYXRlcGlja2VyLWlucHV0Jyk7XG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGlucHV0RmllbGQudmFsdWUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWVcbiAgICB0aGlzLmRhdGVzID0gcHJvY2Vzc0lucHV0RGF0ZXMoaW5pdGlhbERhdGVzLCBjb25maWcpIHx8IFtdO1xuXG4gICAgaWYgKHJhbmdlcGlja2VyICYmIHJhbmdlcGlja2VyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlUmFuZ2VQaWNrZXInKSB7XG4gICAgICB0aGlzLnJhbmdlcGlja2VyID0gcmFuZ2VwaWNrZXI7XG4gICAgICAvLyBhZGQgZ2V0dGVyIGZvciByYW5nZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyYW5nZScsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlcGlja2VyLmRhdGVzO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5waWNrZXIgPSBuZXcgUGlja2VyKHRoaXMpO1xuXG4gICAgaWYgKGlubGluZSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgaW4gb3RoZXIgbW9kZXNcbiAgICAgIGNvbnN0IG9uTW91c2Vkb3duRG9jdW1lbnQgPSBvbkNsaWNrT3V0c2lkZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW1xuICAgICAgICBbaW5wdXRGaWVsZCwgJ2tleWRvd24nLCBvbktleWRvd24uYmluZChudWxsLCB0aGlzKV0sXG4gICAgICAgIFtpbnB1dEZpZWxkLCAnZm9jdXMnLCBvbkZvY3VzLmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duLmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2NsaWNrJywgb25DbGlja0lucHV0LmJpbmQobnVsbCwgdGhpcyldLFxuICAgICAgICBbaW5wdXRGaWVsZCwgJ3Bhc3RlJywgb25QYXN0ZS5iaW5kKG51bGwsIHRoaXMpXSxcbiAgICAgICAgW2RvY3VtZW50LCAnbW91c2Vkb3duJywgb25Nb3VzZWRvd25Eb2N1bWVudF0sXG4gICAgICAgIFtkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbk1vdXNlZG93bkRvY3VtZW50XSxcbiAgICAgICAgW3dpbmRvdywgJ3Jlc2l6ZScsIHBpY2tlci5wbGFjZS5iaW5kKHBpY2tlcildXG4gICAgICBdO1xuICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IERhdGUgb2JqZWN0IG9yIHRpbWUgdmFsdWUgaW4gZ2l2ZW4gZm9ybWF0IGFuZCBsYW5ndWFnZVxuICAgKiBAcGFyYW0gIHtEYXRlfE51bWJlcn0gZGF0ZSAtIGRhdGUgb3IgdGltZSB2YWx1ZSB0byBmb3JtYXRcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gZm9ybWF0IHN0cmluZyBvciBvYmplY3QgdGhhdCBjb250YWluc1xuICAgKiB0b0Rpc3BsYXkoKSBjdXN0b20gZm9ybWF0dGVyLCB3aG9zZSBzaWduYXR1cmUgaXNcbiAgICogLSBhcmdzOlxuICAgKiAgIC0gZGF0ZToge0RhdGV9IC0gRGF0ZSBpbnN0YW5jZSBvZiB0aGUgZGF0ZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gZm9ybWF0OiB7T2JqZWN0fSAtIHRoZSBmb3JtYXQgb2JqZWN0IHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxuICAgKiAtIHJldHVybjpcbiAgICogICAgIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nICYmIGxvY2FsZXNbbGFuZ10gfHwgbG9jYWxlcy5lbik7XG4gIH1cblxuICAvKipcbiAgICogUGFzcmUgZGF0ZSBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfERhdGV8TnVtYmVyfSBkYXRlU3RyIC0gZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IG9yIHRpbWVcbiAgICogdmFsdWUgdG8gcGFyc2VcbiAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZm9ybWF0IC0gZm9ybWF0IHN0cmluZyBvciBvYmplY3QgdGhhdCBjb250YWluc1xuICAgKiB0b1ZhbHVlKCkgY3VzdG9tIHBhcnNlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXG4gICAqIC0gYXJnczpcbiAgICogICAtIGRhdGVTdHI6IHtTdHJpbmd8RGF0ZXxOdW1iZXJ9IC0gdGhlIGRhdGVTdHIgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcbiAgICogLSByZXR1cm46XG4gICAqICAgICB7RGF0ZXxOdW1iZXJ9IHBhcnNlZCBkYXRlIG9yIGl0cyB0aW1lIHZhbHVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aW1lIHZhbHVlIG9mIHBhcnNlZCBkYXRlXG4gICAqL1xuICBzdGF0aWMgcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbGFuZykge1xuICAgIHJldHVybiBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nICYmIGxvY2FsZXNbbGFuZ10gfHwgbG9jYWxlcy5lbik7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdH0gLSBJbnN0YWxsZWQgbG9jYWxlcyBpbiBgW2xhbmd1YWdlQ29kZV06IGxvY2FsZU9iamVjdGAgZm9ybWF0XG4gICAqIGVuYDpfRW5nbGlzaCAoVVMpXyBpcyBwcmUtaW5zdGFsbGVkLlxuICAgKi9cbiAgc3RhdGljIGdldCBsb2NhbGVzKCkge1xuICAgIHJldHVybiBsb2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufSAtIFdoZXRoZXIgdGhlIHBpY2tlciBlbGVtZW50IGlzIHNob3duLiBgdHJ1ZWAgd2huZSBzaG93blxuICAgKi9cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gISEodGhpcy5waWNrZXIgJiYgdGhpcy5waWNrZXIuYWN0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IHZhbHVlcyB0byB0aGUgY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHBpY2tlciA9IHRoaXMucGlja2VyO1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIG5ld09wdGlvbnMpO1xuICAgIHBpY2tlci5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuXG4gICAgY29uc3QgY3VycmVudFZpZXdJZCA9IHBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgICBpZiAobmV3T3B0aW9ucy5tYXhWaWV3IDwgY3VycmVudFZpZXdJZCkge1xuICAgICAgcGlja2VyLmNoYW5nZVZpZXcobmV3T3B0aW9ucy5tYXhWaWV3KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbmV3T3B0aW9ucy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZFxuICAgICAgJiYgIXBpY2tlci5hY3RpdmVcbiAgICAgICYmIG5ld09wdGlvbnMuc3RhcnRWaWV3ICE9PSBjdXJyZW50Vmlld0lkXG4gICAgKSB7XG4gICAgICBwaWNrZXIuY2hhbmdlVmlldyhuZXdPcHRpb25zLnN0YXJ0Vmlldyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICovXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRGaWVsZCAmJiB0aGlzLmlucHV0RmllbGQuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waWNrZXIuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHBpY2tlciBlbGVtZW50XG4gICAqIE5vdCBhdmlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXG4gICAqL1xuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpY2tlci5oaWRlKCk7XG4gICAgdGhpcy5waWNrZXIudXBkYXRlKCkuY2hhbmdlVmlldyh0aGlzLmNvbmZpZy5zdGFydFZpZXcpLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIERhdGVwaWNrZXIgaW5zdGFuY2VcbiAgICogQHJldHVybiB7RGV0ZXBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHVucmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5waWNrZXIuZGV0YWNoKCk7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRlcGlja2VyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKVxuICAgKlxuICAgKiBUaGUgbWV0aG9kIHJldHVybnMgYSBEYXRlIG9iamVjdCBvZiBzZWxlY3RlZCBkYXRlIGJ5IGRlZmF1bHQsIGFuZCByZXR1cm5zXG4gICAqIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRhdGVzIGluIG11bHRpZGF0ZSBtb2RlLiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZyhzKSBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmb3JtYXRdIC0gRm9ybWF0IHN0cmluZyB0byBzdHJpbmdpZnkgdGhlIGRhdGUocylcbiAgICogQHJldHVybiB7RGF0ZXxTdHJpbmd8RGF0ZVtdfFN0cmluZ1tdfSAtIHNlbGVjdGVkIGRhdGUocyksIG9yIGlmIG5vbmUgaXNcbiAgICogc2VsZWN0ZWQsIGVtcHR5IGFycmF5IGluIG11bHRpZGF0ZSBtb2RlIGFuZCB1bnRpdGxlZCBpbiBzaWdsZWRhdGUgbW9kZVxuICAgKi9cbiAgZ2V0RGF0ZShmb3JtYXQgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxuICAgICAgPyBkYXRlID0+IGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLmNvbmZpZy5sb2NhbGUpXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5jb25maWcubXVsdGlkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RlZCBkYXRlKHMpXG4gICAqXG4gICAqIEluIG11bHRpZGF0ZSBtb2RlLCB5b3UgY2FuIHBhc3MgbXVsdGlwbGUgZGF0ZXMgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzXG4gICAqIG9yIGFuIGFycmF5LiAoU2luY2UgZWFjaCBkYXRlIGlzIHBhcnNlZCBpbmRpdmlkdWFsbHksIHRoZSB0eXBlIG9mIHRoZVxuICAgKiBkYXRlcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUuKVxuICAgKiBUaGUgZ2l2ZW4gZGF0ZXMgYXJlIHVzZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Qgc3RhdHVzIG9mIGVhY2ggZGF0ZS4gVGhlXG4gICAqIG51bWJlciBvZiBzZWxlY3RlZCBkYXRlcyBpcyBrZXB0IGZyb20gZXhjZWVkaW5nIHRoZSBsZW5ndGggc2V0IHRvXG4gICAqIG1heE51bWJlck9mRGF0ZXMuXG4gICAqXG4gICAqIFdpdGggY2xlYXI6IHRydWUgb3B0aW9uLCB0aGUgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICogYW5kIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiBpbnN0ZWFkIG9mIHRvZ2dsaW5nIGluIG11bHRpZGF0ZSBtb2RlLlxuICAgKiBJZiB0aGUgb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5vIGRhdGUgYXJndW1lbnRzIG9yIGFuIGVtcHR5IGRhdGVzIGFycmF5LFxuICAgKiBpdCB3b3JrcyBhcyBcImNsZWFyXCIgKGNsZWFyIHRoZSBzZWxlY3Rpb24gdGhlbiBzZXQgbm90aGluZyksIGFuZCBpZiB0aGVcbiAgICogb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5ldyBkYXRlcyB0byBzZWxlY3QsIGl0IHdvcmtzIGFzIFwicmVwbGFjZVwiIChjbGVhclxuICAgKiB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IHRoZSBnaXZlbiBkYXRlcylcbiAgICpcbiAgICogV2hlbiByZW5kZXI6IGZhbHNlIG9wdGlvbiBpcyB1c2VkLCB0aGUgbWV0aG9kIG9taXRzIHJlLXJlbmRlcmluZyB0aGVcbiAgICogcGlja2VyIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgeW91IG5lZWQgdG8gY2FsbCByZWZyZXNoKCkgbWV0aG9kIGxhdGVyIGluXG4gICAqIG9yZGVyIGZvciB0aGUgcGlja2VyIGVsZW1lbnQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcy4gVGhlIGlucHV0IGZpZWxkIGlzXG4gICAqIHJlZnJlc2hlZCBhbHdheXMgcmVnYXJkbGVzcyBvZiB0aGlzIG9wdGlvbi5cbiAgICpcbiAgICogV2hlbiBpbnZhbGlkICh1bnBhcnNhYmxlLCByZXBlYXRlZCwgZGlzYWJsZWQgb3Igb3V0LW9mLXJhbmdlKSBkYXRlcyBhcmVcbiAgICogcGFzc2VkLCB0aGUgbWV0aG9kIGlnbm9yZXMgdGhlbSBhbmQgYXBwbGllcyBvbmx5IHZhbGlkIG9uZXMuIEluIHRoZSBjYXNlXG4gICAqIHRoYXQgYWxsIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW52YWxpZCwgd2hpY2ggaXMgZGlzdGlndWlzaGVkIGZyb20gcGFzc2luZ1xuICAgKiBubyBkYXRlcywgdGhlIG1ldGhvZCBjb25zaWRlcnMgaXQgYXMgYW4gZXJyb3IgYW5kIGxlYXZlcyB0aGUgc2VsZWN0aW9uXG4gICAqIHVudG91Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oRGF0ZXxOdW1iZXJ8U3RyaW5nKXxBcnJheX0gW2RhdGVzXSAtIERhdGUgc3RyaW5ncywgRGF0ZVxuICAgKiBvYmplY3RzLCB0aW1lIHZhbHVlcyBvciBtaXggb2YgdGhvc2UgZm9yIG5ldyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICogLSBjbGVhcjoge2Jvb2xlYW59IC0gV2hldGhlciB0byBjbGVhciB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAqICAgICBkZWZ1YWx0OiBmYWxzZVxuICAgKiAtIHJlbmRlcjoge2Jvb2xlYW59IC0gV2hldGhlciB0byByZS1yZW5kZXIgdGhlIHBpY2tlciBlbGVtZW50XG4gICAqICAgICBkZWZhdWx0OiB0cnVlXG4gICAqIC0gYXV0b2hpZGU6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gaGlkZSB0aGUgcGlja2VyIGVsZW1lbnQgYWZ0ZXIgcmUtcmVuZGVyXG4gICAqICAgICBJZ25vcmVkIHdoZW4gdXNlZCB3aXRoIHJlbmRlcjogZmFsc2VcbiAgICogICAgIGRlZmF1bHQ6IGNvbmZpZy5hdXRvaGlkZVxuICAgKi9cbiAgc2V0RGF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgZGF0ZXMgPSBbLi4uYXJnc107XG4gICAgY29uc3Qgb3B0cyA9IHtjbGVhcjogZmFsc2UsIHJlbmRlcjogdHJ1ZSwgYXV0b2hpZGU6IHRoaXMuY29uZmlnLmF1dG9oaWRlfTtcbiAgICBjb25zdCBsYXN0QXJnID0gbGFzdEl0ZW1PZihhcmdzKTtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcbiAgICAgICYmICFBcnJheS5pc0FycmF5KGxhc3RBcmcpXG4gICAgICAmJiAhKGxhc3RBcmcgaW5zdGFuY2VvZiBEYXRlKVxuICAgICkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBkYXRlcy5wb3AoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXREYXRlcyA9IEFycmF5LmlzQXJyYXkoZGF0ZXNbMF0pID8gZGF0ZXNbMF0gOiBkYXRlcztcbiAgICBjb25zdCBvcmlnRGF0ZXMgPSBvcHRzLmNsZWFyID8gdW5kZWZpbmVkIDogdGhpcy5kYXRlcztcbiAgICBjb25zdCBuZXdEYXRlcyA9IHByb2Nlc3NJbnB1dERhdGVzKGlucHV0RGF0ZXMsIHRoaXMuY29uZmlnLCBvcmlnRGF0ZXMpO1xuICAgIGlmICghbmV3RGF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld0RhdGVzLnRvU3RyaW5nKCkgIT09IHRoaXMuZGF0ZXMudG9TdHJpbmcoKSkge1xuICAgICAgdGhpcy5kYXRlcyA9IG5ld0RhdGVzO1xuICAgICAgaWYgKG9wdHMucmVuZGVyKSB7XG4gICAgICAgIHRoaXMucGlja2VyLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgnaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQodGhpcywgJ2NoYW5nZURhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKCdpbnB1dCcpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZW5kZXIgJiYgb3B0cy5hdXRvaGlkZSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgZGF0ZShzKSB3aXRoIGlucHV0IGZpZWxkJ3MgdmFsdWVcbiAgICogTm90IGF2aWxhYmxlIG9uIGlubGluZSBwaWNrZXJcbiAgICpcbiAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVmcmVzaGVkIHdpdGggcHJvcGVybHkgZm9ybWF0dGVkIGRhdGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICogLSBhdXRvaGlkZToge2Jvb2xlYW59IC0gd2hldGhlciB0byBoaWRlIHRoZSBwaWNrZXIgZWxlbWVudCBhZnRlciByZWZyZXNoXG4gICAqICAgICBkZWZhdWx0OiBmYWxzZVxuICAgKi9cbiAgdXBkYXRlKG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7YXV0b2hpZGU6IGZhbHNlfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgaW5wdXREYXRlcyA9IHN0cmluZ1RvQXJyYXkodGhpcy5pbnB1dEZpZWxkLnZhbHVlLCB0aGlzLmNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbiAgICBjb25zdCBuZXdEYXRlcyA9IHByb2Nlc3NJbnB1dERhdGVzKGlucHV0RGF0ZXMsIHRoaXMuY29uZmlnKTtcbiAgICBpZiAoIW5ld0RhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXdEYXRlcy50b1N0cmluZygpICE9PSB0aGlzLmRhdGVzLnRvU3RyaW5nKCkpIHtcbiAgICAgIHRoaXMuZGF0ZXMgPSBuZXdEYXRlcztcbiAgICAgIHRoaXMucGlja2VyLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMsICdjaGFuZ2VEYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCgnaW5wdXQnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYXV0b2hpZGUpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRdIC0gdGFyZ2V0IGl0ZW0gd2hlbiByZWZyZXNoaW5nIG9uZSBpdGVtIG9ubHlcbiAgICogJ3BpY2tlcicgb3IgJ2lucHV0J1xuICAgKi9cbiAgcmVmcmVzaCh0YXJnZXQgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGFyZ2V0ICE9PSAnaW5wdXQnKSB7XG4gICAgICB0aGlzLnBpY2tlci5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlubGluZSAmJiB0YXJnZXQgIT09ICdwaWNrZXInKSB7XG4gICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSBzdHJpbmdpZnlEYXRlcyh0aGlzLmRhdGVzLCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVudGVyIGVkaXQgbW9kZVxuICAgKiBOb3QgYXZpbGFibGUgb24gaW5saW5lIHBpY2tlciBvciB3aGVuIHRoZSBwaWNrZXIgZWxlbWVudCBpcyBoaWRkZW5cbiAgICovXG4gIGVudGVyRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5saW5lIHx8ICF0aGlzLnBpY2tlci5hY3RpdmUgfHwgdGhpcy5lZGl0TW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnaW4tZWRpdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4aXQgZnJvbSBlZGl0IG1vZGVcbiAgICogTm90IGF2aWxhYmxlIG9uIGlubGluZSBwaWNrZXJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAqIC0gdXBkYXRlOiB7Ym9vbGVhbn0gLSB3aGV0aGVyIHRvIGNhbGwgdXBkYXRlKCkgYWZ0ZXIgZXhpdGluZ1xuICAgKiAgICAgSWYgZmFsc2UsIGlucHV0IGZpZWxkIGlzIHJldmVydCB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAqICAgICBkZWZhdWx0OiBmYWxzZVxuICAgKi9cbiAgZXhpdEVkaXRNb2RlKG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMuZWRpdE1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe3VwZGF0ZTogZmFsc2V9LCBvcHRpb25zKTtcbiAgICBkZWxldGUgdGhpcy5lZGl0TW9kZTtcbiAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LnJlbW92ZSgnaW4tZWRpdCcpO1xuICAgIGlmIChvcHRzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUob3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9IHN0cmluZ2lmeURhdGVzKHRoaXMuZGF0ZXMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// UNUSED EXPORTS: Masked, createMask, MaskedRegExp, MaskedPattern, MaskedRange, MaskedDate, MaskElement, HTMLMaskElement, HTMLContenteditableMaskElement, InputMask, MaskedEnum, MaskedNumber, MaskedFunction, MaskedDynamic, PIPE_TYPE, createPipe, pipe\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/_rollupPluginBabelHelpers-3c58f0e3.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.set) {\n    _rollupPluginBabelHelpers_3c58f0e3_set = Reflect.set;\n  } else {\n    _rollupPluginBabelHelpers_3c58f0e3_set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = _rollupPluginBabelHelpers_3c58f0e3_set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error(\'failed to set property\');\n  }\n\n  return value;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance");\n}\n\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/utils.js\n\n/** Checks if value is string */\n\nfunction isString(str) {\n  return typeof str === \'string\' || str instanceof String;\n}\n/**\r\n  Direction\r\n  @prop {string} NONE\r\n  @prop {string} LEFT\r\n  @prop {string} FORCE_LEFT\r\n  @prop {string} RIGHT\r\n  @prop {string} FORCE_RIGHT\r\n*/\n\n\nvar DIRECTION = {\n  NONE: \'NONE\',\n  LEFT: \'LEFT\',\n  FORCE_LEFT: \'FORCE_LEFT\',\n  RIGHT: \'RIGHT\',\n  FORCE_RIGHT: \'FORCE_RIGHT\'\n};\n/**\r\n  Direction\r\n  @enum {string}\r\n*/\n\n/** Returns next char index in direction */\n\nfunction indexInDirection(pos, direction) {\n  if (direction === DIRECTION.LEFT) --pos;\n  return pos;\n}\n/** Returns next char position in direction */\n\n\nfunction posInDirection(pos, direction) {\n  switch (direction) {\n    case DIRECTION.LEFT:\n    case DIRECTION.FORCE_LEFT:\n      return --pos;\n\n    case DIRECTION.RIGHT:\n    case DIRECTION.FORCE_RIGHT:\n      return ++pos;\n\n    default:\n      return pos;\n  }\n}\n/** */\n\n\nfunction forceDirection(direction) {\n  switch (direction) {\n    case DIRECTION.LEFT:\n      return DIRECTION.FORCE_LEFT;\n\n    case DIRECTION.RIGHT:\n      return DIRECTION.FORCE_RIGHT;\n\n    default:\n      return direction;\n  }\n}\n/** Escapes regular expression control chars */\n\n\nfunction escapeRegExp(str) {\n  return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, \'\\\\$1\');\n} // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes\n\n\nfunction objectIncludes(b, a) {\n  if (a === b) return true;\n  var arrA = Array.isArray(a),\n      arrB = Array.isArray(b),\n      i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n\n    for (i = 0; i < a.length; i++) {\n      if (!objectIncludes(a[i], b[i])) return false;\n    }\n\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && _typeof(a) === \'object\' && _typeof(b) === \'object\') {\n    var dateA = a instanceof Date,\n        dateB = b instanceof Date;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    if (dateA != dateB) return false;\n    var regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    if (regexpA != regexpB) return false;\n    var keys = Object.keys(a); // if (keys.length !== Object.keys(b).length) return false;\n\n    for (i = 0; i < keys.length; i++) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = 0; i < keys.length; i++) {\n      if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;\n    }\n\n    return true;\n  } else if (a && b && typeof a === \'function\' && typeof b === \'function\') {\n    return a.toString() === b.toString();\n  }\n\n  return false;\n}\n/** Selection range */\n\n\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/action-details.js\n\n\n/** Provides details of changing input */\n\nvar action_details_ActionDetails = /*#__PURE__*/function () {\n  /** Current input value */\n\n  /** Current cursor position */\n\n  /** Old input value */\n\n  /** Old selection */\n  function ActionDetails(value, cursorPos, oldValue, oldSelection) {\n    _classCallCheck(this, ActionDetails);\n\n    this.value = value;\n    this.cursorPos = cursorPos;\n    this.oldValue = oldValue;\n    this.oldSelection = oldSelection; // double check if left part was changed (autofilling, other non-standard input triggers)\n\n    while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {\n      --this.oldSelection.start;\n    }\n  }\n  /**\r\n    Start changing position\r\n    @readonly\r\n  */\n\n\n  _createClass(ActionDetails, [{\n    key: "startChangePos",\n    get: function get() {\n      return Math.min(this.cursorPos, this.oldSelection.start);\n    }\n    /**\r\n      Inserted symbols count\r\n      @readonly\r\n    */\n\n  }, {\n    key: "insertedCount",\n    get: function get() {\n      return this.cursorPos - this.startChangePos;\n    }\n    /**\r\n      Inserted symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "inserted",\n    get: function get() {\n      return this.value.substr(this.startChangePos, this.insertedCount);\n    }\n    /**\r\n      Removed symbols count\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removedCount",\n    get: function get() {\n      // Math.max for opposite operation\n      return Math.max(this.oldSelection.end - this.startChangePos || // for Delete\n      this.oldValue.length - this.value.length, 0);\n    }\n    /**\r\n      Removed symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removed",\n    get: function get() {\n      return this.oldValue.substr(this.startChangePos, this.removedCount);\n    }\n    /**\r\n      Unchanged head symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "head",\n    get: function get() {\n      return this.value.substring(0, this.startChangePos);\n    }\n    /**\r\n      Unchanged tail symbols\r\n      @readonly\r\n    */\n\n  }, {\n    key: "tail",\n    get: function get() {\n      return this.value.substring(this.startChangePos + this.insertedCount);\n    }\n    /**\r\n      Remove direction\r\n      @readonly\r\n    */\n\n  }, {\n    key: "removeDirection",\n    get: function get() {\n      if (!this.removedCount || this.insertedCount) return DIRECTION.NONE; // align right if delete at right or if range removed (event with backspace)\n\n      return this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? DIRECTION.RIGHT : DIRECTION.LEFT;\n    }\n  }]);\n\n  return ActionDetails;\n}();\n\n/* harmony default export */ var action_details = (action_details_ActionDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/change-details.js\n\n/**\r\n  Provides details of changing model value\r\n  @param {Object} [details]\r\n  @param {string} [details.inserted] - Inserted symbols\r\n  @param {boolean} [details.skip] - Can skip chars\r\n  @param {number} [details.removeCount] - Removed symbols count\r\n  @param {number} [details.tailShift] - Additional offset if any changes occurred before tail\r\n*/\n\nvar change_details_ChangeDetails = /*#__PURE__*/function () {\n  /** Inserted symbols */\n\n  /** Can skip chars */\n\n  /** Additional offset if any changes occurred before tail */\n\n  /** Raw inserted is used by dynamic mask */\n  function ChangeDetails(details) {\n    _classCallCheck(this, ChangeDetails);\n\n    Object.assign(this, {\n      inserted: \'\',\n      rawInserted: \'\',\n      skip: false,\n      tailShift: 0\n    }, details);\n  }\n  /**\r\n    Aggregate changes\r\n    @returns {ChangeDetails} `this`\r\n  */\n\n\n  _createClass(ChangeDetails, [{\n    key: "aggregate",\n    value: function aggregate(details) {\n      this.rawInserted += details.rawInserted;\n      this.skip = this.skip || details.skip;\n      this.inserted += details.inserted;\n      this.tailShift += details.tailShift;\n      return this;\n    }\n    /** Total offset considering all changes */\n\n  }, {\n    key: "offset",\n    get: function get() {\n      return this.tailShift + this.inserted.length;\n    }\n  }]);\n\n  return ChangeDetails;\n}();\n\n/* harmony default export */ var change_details = (change_details_ChangeDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/continuous-tail-details.js\n\n/** Provides details of continuous extracted tail */\n\nvar continuous_tail_details_ContinuousTailDetails = /*#__PURE__*/function () {\n  /** Tail value as string */\n\n  /** Tail start position */\n\n  /** Start position */\n  function ContinuousTailDetails() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var stop = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ContinuousTailDetails);\n\n    this.value = value;\n    this.from = from;\n    this.stop = stop;\n  }\n\n  _createClass(ContinuousTailDetails, [{\n    key: "toString",\n    value: function toString() {\n      return this.value;\n    }\n  }, {\n    key: "extend",\n    value: function extend(tail) {\n      this.value += String(tail);\n    }\n  }, {\n    key: "appendTo",\n    value: function appendTo(masked) {\n      return masked.append(this.toString(), {\n        tail: true\n      }).aggregate(masked._appendPlaceholder());\n    }\n  }, {\n    key: "shiftBefore",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.value.length) return \'\';\n      var shiftChar = this.value[0];\n      this.value = this.value.slice(1);\n      return shiftChar;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        value: this.value,\n        from: this.from,\n        stop: this.stop\n      };\n    },\n    set: function set(state) {\n      Object.assign(this, state);\n    }\n  }]);\n\n  return ContinuousTailDetails;\n}();\n\n/* harmony default export */ var continuous_tail_details = (continuous_tail_details_ContinuousTailDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/core/holder.js\n/**\r\n * Applies mask on element.\r\n * @constructor\r\n * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask\r\n * @param {Object} opts - Custom mask options\r\n * @return {InputMask}\r\n */\nfunction IMask(el) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // currently available only for input-like elements\n\n  return new IMask.InputMask(el, opts);\n}\n\n/* harmony default export */ var holder = (IMask);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/base.js\n\n\n\n\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar base_Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = \'\';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, {}, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: "updateOptions",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: "_update",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: "reset",\n\n    /** Resets value */\n    value: function reset() {\n      this._value = \'\';\n    }\n    /** */\n\n  }, {\n    key: "resolve",\n\n    /** Resolve new value */\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, \'\');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: "nearestInputPos",\n\n    /** Finds nearest input position in direction */\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new continuous_tail_details(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: "appendTail",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new continuous_tail_details(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n      if (!ch) return new change_details();\n      this._value += ch;\n      return new change_details({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(ch, flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new change_details();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      return new change_details();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: "append",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error(\'value should be string\');\n      var details = new change_details();\n      var checkTail = isString(tail) ? new continuous_tail_details(String(tail)) : tail;\n      if (flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it\'s a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new change_details();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: "withValueRefresh",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, \'\');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: "runIsolated",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: "doFormat",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: "doParse",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: "splice",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new change_details({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, \'\');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: "rawInputValue",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, \'\');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return Masked;\n}();\n\nbase_Masked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nholder.Masked = base_Masked;\n/* harmony default export */ var base = (base_Masked);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/factory.js\n\n\n\n/** Get Masked class by mask type */\n\nfunction maskedClass(mask) {\n  if (mask == null) {\n    throw new Error(\'mask property should be defined\');\n  } // $FlowFixMe\n\n\n  if (mask instanceof RegExp) return holder.MaskedRegExp; // $FlowFixMe\n\n  if (isString(mask)) return holder.MaskedPattern; // $FlowFixMe\n\n  if (mask instanceof Date || mask === Date) return holder.MaskedDate; // $FlowFixMe\n\n  if (mask instanceof Number || typeof mask === \'number\' || mask === Number) return holder.MaskedNumber; // $FlowFixMe\n\n  if (Array.isArray(mask) || mask === Array) return holder.MaskedDynamic; // $FlowFixMe\n\n  if (holder.Masked && mask.prototype instanceof holder.Masked) return mask; // $FlowFixMe\n\n  if (mask instanceof Function) return holder.MaskedFunction; // $FlowFixMe\n\n  if (mask instanceof holder.Masked) return mask.constructor;\n  console.warn(\'Mask not found for mask\', mask); // eslint-disable-line no-console\n  // $FlowFixMe\n\n  return holder.Masked;\n}\n/** Creates new {@link Masked} depending on mask type */\n\n\nfunction createMask(opts) {\n  // $FlowFixMe\n  if (holder.Masked && opts instanceof holder.Masked) return opts;\n  opts = Object.assign({}, opts);\n  var mask = opts.mask; // $FlowFixMe\n\n  if (holder.Masked && mask instanceof holder.Masked) return mask;\n  var MaskedClass = maskedClass(mask);\n  if (!MaskedClass) throw new Error(\'Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.\');\n  return new MaskedClass(opts);\n}\n\nholder.createMask = createMask;\n/* harmony default export */ var factory = (createMask);\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/input-definition.js\n\n\n\n\n\nvar DEFAULT_INPUT_DEFINITIONS = {\n  \'0\': /\\d/,\n  \'a\': /[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n  // http://stackoverflow.com/a/22075070\n  \'*\': /./\n};\n/** */\n\nvar input_definition_PatternInputDefinition = /*#__PURE__*/function () {\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n  function PatternInputDefinition(opts) {\n    _classCallCheck(this, PatternInputDefinition);\n\n    var mask = opts.mask,\n        blockOpts = _objectWithoutProperties(opts, ["mask"]);\n\n    this.masked = factory({\n      mask: mask\n    });\n    Object.assign(this, blockOpts);\n  }\n\n  _createClass(PatternInputDefinition, [{\n    key: "reset",\n    value: function reset() {\n      this._isFilled = false;\n      this.masked.reset();\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      if (fromPos === 0 && toPos >= 1) {\n        this._isFilled = false;\n        return this.masked.remove(fromPos, toPos);\n      }\n\n      return new change_details();\n    }\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this._isFilled) return new change_details();\n      var state = this.masked.state; // simulate input\n\n      var details = this.masked._appendChar(str, flags);\n\n      if (details.inserted && this.doValidate(flags) === false) {\n        details.inserted = details.rawInserted = \'\';\n        this.masked.state = state;\n      }\n\n      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {\n        details.inserted = this.placeholderChar;\n      }\n\n      details.skip = !details.inserted && !this.isOptional;\n      this._isFilled = Boolean(details.inserted);\n      return details;\n    }\n  }, {\n    key: "append",\n    value: function append() {\n      var _this$masked;\n\n      return (_this$masked = this.masked).append.apply(_this$masked, arguments);\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = new change_details();\n      if (this._isFilled || this.isOptional) return details;\n      this._isFilled = true;\n      details.inserted = this.placeholderChar;\n      return details;\n    }\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this$masked2;\n\n      return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);\n    }\n  }, {\n    key: "appendTail",\n    value: function appendTail() {\n      var _this$masked3;\n\n      return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);\n    }\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 ? arguments[2] : undefined;\n      return this.masked.extractInput(fromPos, toPos, flags);\n    }\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      var minPos = 0;\n      var maxPos = this.value.length;\n      var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);\n\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return this.isComplete ? boundPos : minPos;\n\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          return this.isComplete ? boundPos : maxPos;\n\n        case DIRECTION.NONE:\n        default:\n          return boundPos;\n      }\n    }\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _this$masked4, _this$parent;\n\n      return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));\n    }\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      this.masked.doCommit();\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : \'\');\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.masked.unmaskedValue;\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return Boolean(this.masked.value) || this.isOptional;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        masked: this.masked.state,\n        _isFilled: this._isFilled\n      };\n    },\n    set: function set(state) {\n      this.masked.state = state.masked;\n      this._isFilled = state._isFilled;\n    }\n  }]);\n\n  return PatternInputDefinition;\n}();\n\n/* harmony default export */ var input_definition = (input_definition_PatternInputDefinition);\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/fixed-definition.js\n\n\n\n\n\nvar fixed_definition_PatternFixedDefinition = /*#__PURE__*/function () {\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n  function PatternFixedDefinition(opts) {\n    _classCallCheck(this, PatternFixedDefinition);\n\n    Object.assign(this, opts);\n    this._value = \'\';\n  }\n\n  _createClass(PatternFixedDefinition, [{\n    key: "reset",\n    value: function reset() {\n      this._isRawInput = false;\n      this._value = \'\';\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;\n      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);\n      if (!this._value) this._isRawInput = false;\n      return new change_details();\n    }\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      var minPos = 0;\n      var maxPos = this._value.length;\n\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return minPos;\n\n        case DIRECTION.NONE:\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n        default:\n          return maxPos;\n      }\n    }\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || \'\';\n    }\n  }, {\n    key: "_appendChar",\n    value: function _appendChar(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var details = new change_details();\n      if (this._value) return details;\n      var appended = this.char === str[0];\n      var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !flags.tail;\n      if (isResolved) details.rawInserted = this.char;\n      this._value = details.inserted = this.char;\n      this._isRawInput = isResolved && (flags.raw || flags.input);\n      return details;\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = new change_details();\n      if (this._value) return details;\n      this._value = details.inserted = this.char;\n      return details;\n    }\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new continuous_tail_details(\'\');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: "appendTail",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new continuous_tail_details(String(tail));\n      return tail.appendTo(this);\n    }\n  }, {\n    key: "append",\n    value: function append(str, flags, tail) {\n      var details = this._appendChar(str, flags);\n\n      if (tail != null) {\n        details.tailShift += this.appendTail(tail).tailShift;\n      }\n\n      return details;\n    }\n  }, {\n    key: "doCommit",\n    value: function doCommit() {}\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.isUnmasking ? this.value : \'\';\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        _value: this._value,\n        _isRawInput: this._isRawInput\n      };\n    },\n    set: function set(state) {\n      Object.assign(this, state);\n    }\n  }]);\n\n  return PatternFixedDefinition;\n}();\n\n/* harmony default export */ var fixed_definition = (fixed_definition_PatternFixedDefinition);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern/chunk-tail-details.js\n\n\n\n\n\n\nvar chunk_tail_details_ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: "toString",\n    value: function toString() {\n      return this.chunks.map(String).join(\'\');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: "extend",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new continuous_tail_details(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof continuous_tail_details) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: "appendTo",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof holder.MaskedPattern)) {\n        var tail = new continuous_tail_details(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new change_details();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: "shiftBefore",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.chunks.length) return \'\';\n      var chunkShiftPos = pos - this.from;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shiftBefore(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return \'\';\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, ["chunks"]);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = "chunks" in cstate ? new ChunksTailDetails() : new continuous_tail_details(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\n/* harmony default export */ var chunk_tail_details = (chunk_tail_details_ChunksTailDetails);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/regexp.js\n\n\n\n\n\n\n/** Masking by RegExp */\n\nvar regexp_MaskedRegExp = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedRegExp, _Masked);\n\n  function MaskedRegExp() {\n    _classCallCheck(this, MaskedRegExp);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedRegExp).apply(this, arguments));\n  }\n\n  _createClass(MaskedRegExp, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      if (opts.mask) opts.validate = function (value) {\n        return value.search(opts.mask) >= 0;\n      };\n\n      _get(_getPrototypeOf(MaskedRegExp.prototype), "_update", this).call(this, opts);\n    }\n  }]);\n\n  return MaskedRegExp;\n}(base);\n\nholder.MaskedRegExp = regexp_MaskedRegExp;\n/* harmony default export */ var masked_regexp = (regexp_MaskedRegExp);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pattern.js\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\n\nvar pattern_MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedPattern).call(this, Object.assign({}, MaskedPattern.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: "_update",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), "_update", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: "_rebuildMask",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              var maskedBlock = factory(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return "continue";\n            }\n          }();\n\n          if (_ret === "continue") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === \'{\' || char === \'}\') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === \'[\' || char === \']\') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new input_definition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new fixed_definition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "reset",\n\n    /**\r\n      @override\r\n    */\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), "reset", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n\n    /**\r\n      @override\r\n    */\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), "doCommit", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "appendTail",\n\n    /**\r\n      @override\r\n    */\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new change_details();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new chunk_tail_details();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof chunk_tail_details) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return \'\';\n      var input = \'\';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: "_findStopBefore",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new change_details();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: "_mapPosToBlock",\n    value: function _mapPosToBlock(pos) {\n      var accVal = \'\';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: "_blockStartPos",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: "_forEachBlocksInRange",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), "remove", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE; // TODO refactor - extract alignblock\n\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: "maskedBlock",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: "maskedBlocks",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), "state", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, ["_blocks"]);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), "state", maskedState, this, true);\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, \'\');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), "unmaskedValue", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "value",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, \'\');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), "value", value, this, true);\n    }\n  }]);\n\n  return MaskedPattern;\n}(base);\n\npattern_MaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: \'_\'\n};\npattern_MaskedPattern.STOP_CHAR = \'`\';\npattern_MaskedPattern.ESCAPE_CHAR = \'\\\\\';\npattern_MaskedPattern.InputDefinition = input_definition;\npattern_MaskedPattern.FixedDefinition = fixed_definition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nholder.MaskedPattern = pattern_MaskedPattern;\n/* harmony default export */ var masked_pattern = (pattern_MaskedPattern);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/range.js\n\n\n\n\n\n\n\n\n\n\n\n\n/** Pattern which accepts ranges */\n\nvar range_MaskedRange = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedRange, _MaskedPattern);\n\n  function MaskedRange() {\n    _classCallCheck(this, MaskedRange);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedRange).apply(this, arguments));\n  }\n\n  _createClass(MaskedRange, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n    */\n    value: function _update(opts) {\n      // TODO type\n      opts = Object.assign({\n        to: this.to || 0,\n        from: this.from || 0\n      }, opts);\n      var maxLength = String(opts.to).length;\n      if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n      opts.maxLength = maxLength;\n      var fromStr = String(opts.from).padStart(maxLength, \'0\');\n      var toStr = String(opts.to).padStart(maxLength, \'0\');\n      var sameCharsCount = 0;\n\n      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {\n        ++sameCharsCount;\n      }\n\n      opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, \'\\\\0\') + \'0\'.repeat(maxLength - sameCharsCount);\n\n      _get(_getPrototypeOf(MaskedRange.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "boundaries",\n    value: function boundaries(str) {\n      var minstr = \'\';\n      var maxstr = \'\';\n\n      var _ref = str.match(/^(\\D*)(\\d*)(\\D*)/) || [],\n          _ref2 = _slicedToArray(_ref, 3),\n          placeholder = _ref2[1],\n          num = _ref2[2];\n\n      if (num) {\n        minstr = \'0\'.repeat(placeholder.length) + num;\n        maxstr = \'9\'.repeat(placeholder.length) + num;\n      }\n\n      minstr = minstr.padEnd(this.maxLength, \'0\');\n      maxstr = maxstr.padEnd(this.maxLength, \'9\');\n      return [minstr, maxstr];\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      str = _get(_getPrototypeOf(MaskedRange.prototype), "doPrepare", this).call(this, str, flags).replace(/\\D/g, \'\');\n      if (!this.autofix) return str;\n      var fromStr = String(this.from).padStart(this.maxLength, \'0\');\n      var toStr = String(this.to).padStart(this.maxLength, \'0\');\n      var val = this.value;\n      var prepStr = \'\';\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        var nextVal = val + prepStr + str[ci];\n\n        var _this$boundaries = this.boundaries(nextVal),\n            _this$boundaries2 = _slicedToArray(_this$boundaries, 2),\n            minstr = _this$boundaries2[0],\n            maxstr = _this$boundaries2[1];\n\n        if (Number(maxstr) < this.from) prepStr += fromStr[nextVal.length - 1];else if (Number(minstr) > this.to) prepStr += toStr[nextVal.length - 1];else prepStr += str[ci];\n      }\n\n      return prepStr;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2;\n\n      var str = this.value;\n      var firstNonZero = str.search(/[^0]/);\n      if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n\n      var _this$boundaries3 = this.boundaries(str),\n          _this$boundaries4 = _slicedToArray(_this$boundaries3, 2),\n          minstr = _this$boundaries4[0],\n          maxstr = _this$boundaries4[1];\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf(MaskedRange.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: "_matchFrom",\n\n    /**\r\n      Optionally sets max length of pattern.\r\n      Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\r\n    */\n\n    /** Min bound */\n\n    /** Max bound */\n\n    /** */\n    get: function get() {\n      return this.maxLength - String(this.from).length;\n    }\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return _get(_getPrototypeOf(MaskedRange.prototype), "isComplete", this) && Boolean(this.value);\n    }\n  }]);\n\n  return MaskedRange;\n}(masked_pattern);\n\nholder.MaskedRange = range_MaskedRange;\n/* harmony default export */ var range = (range_MaskedRange);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/date.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Date mask */\n\nvar date_MaskedDate = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedDate, _MaskedPattern);\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\r\n    @param {Object} opts\r\n  */\n\n\n  function MaskedDate(opts) {\n    _classCallCheck(this, MaskedDate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedDate).call(this, Object.assign({}, MaskedDate.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDate, [{\n    key: "_update",\n    value: function _update(opts) {\n      if (opts.mask === Date) delete opts.mask;\n      if (opts.pattern) opts.mask = opts.pattern;\n      var blocks = opts.blocks;\n      opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block\n\n      if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n      if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n\n      if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n        opts.blocks.m.from = opts.min.getMonth() + 1;\n        opts.blocks.m.to = opts.max.getMonth() + 1;\n\n        if (opts.blocks.m.from === opts.blocks.m.to) {\n          opts.blocks.d.from = opts.min.getDate();\n          opts.blocks.d.to = opts.max.getDate();\n        }\n      }\n\n      Object.assign(opts.blocks, blocks); // add autofix\n\n      Object.keys(opts.blocks).forEach(function (bk) {\n        var b = opts.blocks[bk];\n        if (!(\'autofix\' in b)) b.autofix = opts.autofix;\n      });\n\n      _get(_getPrototypeOf(MaskedDate.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2;\n\n      var date = this.date;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDate.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n    }\n    /** Checks if date is exists */\n\n  }, {\n    key: "isDateExist",\n    value: function isDateExist(str) {\n      return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n    }\n    /** Parsed Date */\n\n  }, {\n    key: "date",\n    get: function get() {\n      return this.typedValue;\n    },\n    set: function set(date) {\n      this.typedValue = date;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.isComplete ? _get(_getPrototypeOf(MaskedDate.prototype), "typedValue", this) : null;\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDate.prototype), "typedValue", value, this, true);\n    }\n  }]);\n\n  return MaskedDate;\n}(masked_pattern);\n\ndate_MaskedDate.DEFAULTS = {\n  pattern: \'d{.}`m{.}`Y\',\n  format: function format(date) {\n    var day = String(date.getDate()).padStart(2, \'0\');\n    var month = String(date.getMonth() + 1).padStart(2, \'0\');\n    var year = date.getFullYear();\n    return [day, month, year].join(\'.\');\n  },\n  parse: function parse(str) {\n    var _str$split = str.split(\'.\'),\n        _str$split2 = _slicedToArray(_str$split, 3),\n        day = _str$split2[0],\n        month = _str$split2[1],\n        year = _str$split2[2];\n\n    return new Date(year, month - 1, day);\n  }\n};\n\ndate_MaskedDate.GET_DEFAULT_BLOCKS = function () {\n  return {\n    d: {\n      mask: range,\n      from: 1,\n      to: 31,\n      maxLength: 2\n    },\n    m: {\n      mask: range,\n      from: 1,\n      to: 12,\n      maxLength: 2\n    },\n    Y: {\n      mask: range,\n      from: 1900,\n      to: 9999\n    }\n  };\n};\n\nholder.MaskedDate = date_MaskedDate;\n/* harmony default export */ var masked_date = (date_MaskedDate);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/mask-element.js\n\n\n/**\r\n  Generic element API to use with mask\r\n  @interface\r\n*/\n\nvar mask_element_MaskElement = /*#__PURE__*/function () {\n  function MaskElement() {\n    _classCallCheck(this, MaskElement);\n  }\n\n  _createClass(MaskElement, [{\n    key: "select",\n\n    /** Safely sets element selection */\n    value: function select(start, end) {\n      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;\n\n      try {\n        this._unsafeSelect(start, end);\n      } catch (e) {}\n    }\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "_unsafeSelect",\n    value: function _unsafeSelect(start, end) {}\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "bindEvents",\n\n    /** Should be overriden in subclasses */\n    value: function bindEvents(handlers) {}\n    /** Should be overriden in subclasses */\n\n  }, {\n    key: "unbindEvents",\n    value: function unbindEvents() {}\n  }, {\n    key: "selectionStart",\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** Safely returns selection start */\n    get: function get() {\n      var start;\n\n      try {\n        start = this._unsafeSelectionStart;\n      } catch (e) {}\n\n      return start != null ? start : this.value.length;\n    }\n    /** Safely returns selection end */\n\n  }, {\n    key: "selectionEnd",\n    get: function get() {\n      var end;\n\n      try {\n        end = this._unsafeSelectionEnd;\n      } catch (e) {}\n\n      return end != null ? end : this.value.length;\n    }\n  }, {\n    key: "isActive",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return MaskElement;\n}();\n\nholder.MaskElement = mask_element_MaskElement;\n/* harmony default export */ var mask_element = (mask_element_MaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/html-mask-element.js\n\n\n\n/** Bridge between HTMLElement and {@link Masked} */\n\nvar html_mask_element_HTMLMaskElement = /*#__PURE__*/function (_MaskElement) {\n  _inherits(HTMLMaskElement, _MaskElement);\n  /** Mapping between HTMLElement events and mask internal events */\n\n  /** HTMLElement to use mask on */\n\n  /**\r\n    @param {HTMLInputElement|HTMLTextAreaElement} input\r\n  */\n\n\n  function HTMLMaskElement(input) {\n    var _this;\n\n    _classCallCheck(this, HTMLMaskElement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLMaskElement).call(this));\n    _this.input = input;\n    _this._handlers = {};\n    return _this;\n  }\n  /** */\n  // $FlowFixMe https://github.com/facebook/flow/issues/2839\n\n\n  _createClass(HTMLMaskElement, [{\n    key: "_unsafeSelect",\n\n    /**\r\n      Sets HTMLElement selection\r\n      @override\r\n    */\n    value: function _unsafeSelect(start, end) {\n      this.input.setSelectionRange(start, end);\n    }\n    /**\r\n      HTMLElement value\r\n      @override\r\n    */\n\n  }, {\n    key: "bindEvents",\n\n    /**\r\n      Binds HTMLElement events to mask internal events\r\n      @override\r\n    */\n    value: function bindEvents(handlers) {\n      var _this2 = this;\n\n      Object.keys(handlers).forEach(function (event) {\n        return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);\n      });\n    }\n    /**\r\n      Unbinds HTMLElement events to mask internal events\r\n      @override\r\n    */\n\n  }, {\n    key: "unbindEvents",\n    value: function unbindEvents() {\n      var _this3 = this;\n\n      Object.keys(this._handlers).forEach(function (event) {\n        return _this3._toggleEventHandler(event);\n      });\n    }\n    /** */\n\n  }, {\n    key: "_toggleEventHandler",\n    value: function _toggleEventHandler(event, handler) {\n      if (this._handlers[event]) {\n        this.input.removeEventListener(event, this._handlers[event]);\n        delete this._handlers[event];\n      }\n\n      if (handler) {\n        this.input.addEventListener(event, handler);\n        this._handlers[event] = handler;\n      }\n    }\n  }, {\n    key: "rootElement",\n    get: function get() {\n      return this.input.getRootNode ? this.input.getRootNode() : document;\n    }\n    /**\r\n      Is element in focus\r\n      @readonly\r\n    */\n\n  }, {\n    key: "isActive",\n    get: function get() {\n      //$FlowFixMe\n      return this.input === this.rootElement.activeElement;\n    }\n    /**\r\n      Returns HTMLElement selection start\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionStart",\n    get: function get() {\n      return this.input.selectionStart;\n    }\n    /**\r\n      Returns HTMLElement selection end\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionEnd",\n    get: function get() {\n      return this.input.selectionEnd;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.input.value;\n    },\n    set: function set(value) {\n      this.input.value = value;\n    }\n  }]);\n\n  return HTMLMaskElement;\n}(mask_element);\n\nhtml_mask_element_HTMLMaskElement.EVENTS_MAP = {\n  selectionChange: \'keydown\',\n  input: \'input\',\n  drop: \'drop\',\n  click: \'click\',\n  focus: \'focus\',\n  commit: \'blur\'\n};\nholder.HTMLMaskElement = html_mask_element_HTMLMaskElement;\n/* harmony default export */ var html_mask_element = (html_mask_element_HTMLMaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/html-contenteditable-mask-element.js\n\n\n\n\n\nvar html_contenteditable_mask_element_HTMLContenteditableMaskElement = /*#__PURE__*/function (_HTMLMaskElement) {\n  _inherits(HTMLContenteditableMaskElement, _HTMLMaskElement);\n\n  function HTMLContenteditableMaskElement() {\n    _classCallCheck(this, HTMLContenteditableMaskElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HTMLContenteditableMaskElement).apply(this, arguments));\n  }\n\n  _createClass(HTMLContenteditableMaskElement, [{\n    key: "_unsafeSelect",\n\n    /**\r\n      Sets HTMLElement selection\r\n      @override\r\n    */\n    value: function _unsafeSelect(start, end) {\n      if (!this.rootElement.createRange) return;\n      var range = this.rootElement.createRange();\n      range.setStart(this.input.firstChild || this.input, start);\n      range.setEnd(this.input.lastChild || this.input, end);\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n\n      if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    }\n    /**\r\n      HTMLElement value\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionStart",\n\n    /**\r\n      Returns HTMLElement selection start\r\n      @override\r\n    */\n    get: function get() {\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n      return selection && selection.anchorOffset;\n    }\n    /**\r\n      Returns HTMLElement selection end\r\n      @override\r\n    */\n\n  }, {\n    key: "_unsafeSelectionEnd",\n    get: function get() {\n      var root = this.rootElement;\n      var selection = root.getSelection && root.getSelection();\n      return selection && this._unsafeSelectionStart + String(selection).length;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      // $FlowFixMe\n      return this.input.textContent;\n    },\n    set: function set(value) {\n      this.input.textContent = value;\n    }\n  }]);\n\n  return HTMLContenteditableMaskElement;\n}(html_mask_element);\n\nholder.HTMLContenteditableMaskElement = html_contenteditable_mask_element_HTMLContenteditableMaskElement;\n/* harmony default export */ var html_contenteditable_mask_element = (html_contenteditable_mask_element_HTMLContenteditableMaskElement);\n// CONCATENATED MODULE: ./node_modules/imask/esm/controls/input.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** Listens to element events and controls changes between element and {@link Masked} */\n\nvar input_InputMask = /*#__PURE__*/function () {\n  /**\r\n    View element\r\n    @readonly\r\n  */\n\n  /**\r\n    Internal {@link Masked} model\r\n    @readonly\r\n  */\n\n  /**\r\n    @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el\r\n    @param {Object} opts\r\n  */\n  function InputMask(el, opts) {\n    _classCallCheck(this, InputMask);\n\n    this.el = el instanceof mask_element ? el : el.isContentEditable && el.tagName !== \'INPUT\' && el.tagName !== \'TEXTAREA\' ? new html_contenteditable_mask_element(el) : new html_mask_element(el);\n    this.masked = factory(opts);\n    this._listeners = {};\n    this._value = \'\';\n    this._unmaskedValue = \'\';\n    this._saveSelection = this._saveSelection.bind(this);\n    this._onInput = this._onInput.bind(this);\n    this._onChange = this._onChange.bind(this);\n    this._onDrop = this._onDrop.bind(this);\n    this._onFocus = this._onFocus.bind(this);\n    this._onClick = this._onClick.bind(this);\n    this.alignCursor = this.alignCursor.bind(this);\n    this.alignCursorFriendly = this.alignCursorFriendly.bind(this);\n\n    this._bindEvents(); // refresh\n\n\n    this.updateValue();\n\n    this._onChange();\n  }\n  /** Read or update mask */\n\n\n  _createClass(InputMask, [{\n    key: "maskEquals",\n    value: function maskEquals(mask) {\n      return mask == null || mask === this.masked.mask || mask === Date && this.masked instanceof masked_date;\n    }\n  }, {\n    key: "_bindEvents",\n\n    /**\r\n      Starts listening to element events\r\n      @protected\r\n    */\n    value: function _bindEvents() {\n      this.el.bindEvents({\n        selectionChange: this._saveSelection,\n        input: this._onInput,\n        drop: this._onDrop,\n        click: this._onClick,\n        focus: this._onFocus,\n        commit: this._onChange\n      });\n    }\n    /**\r\n      Stops listening to element events\r\n      @protected\r\n     */\n\n  }, {\n    key: "_unbindEvents",\n    value: function _unbindEvents() {\n      if (this.el) this.el.unbindEvents();\n    }\n    /**\r\n      Fires custom event\r\n      @protected\r\n     */\n\n  }, {\n    key: "_fireEvent",\n    value: function _fireEvent(ev) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var listeners = this._listeners[ev];\n      if (!listeners) return;\n      listeners.forEach(function (l) {\n        return l.apply(void 0, args);\n      });\n    }\n    /**\r\n      Current selection start\r\n      @readonly\r\n    */\n\n  }, {\n    key: "_saveSelection",\n\n    /**\r\n      Stores current selection\r\n      @protected\r\n    */\n    value: function _saveSelection()\n    /* ev */\n    {\n      if (this.value !== this.el.value) {\n        console.warn(\'Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.\'); // eslint-disable-line no-console\n      }\n\n      this._selection = {\n        start: this.selectionStart,\n        end: this.cursorPos\n      };\n    }\n    /** Syncronizes model value from view */\n\n  }, {\n    key: "updateValue",\n    value: function updateValue() {\n      this.masked.value = this.el.value;\n      this._value = this.masked.value;\n    }\n    /** Syncronizes view from model value, fires change events */\n\n  }, {\n    key: "updateControl",\n    value: function updateControl() {\n      var newUnmaskedValue = this.masked.unmaskedValue;\n      var newValue = this.masked.value;\n      var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;\n      this._unmaskedValue = newUnmaskedValue;\n      this._value = newValue;\n      if (this.el.value !== newValue) this.el.value = newValue;\n      if (isChanged) this._fireChangeEvents();\n    }\n    /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */\n\n  }, {\n    key: "updateOptions",\n    value: function updateOptions(opts) {\n      var mask = opts.mask,\n          restOpts = _objectWithoutProperties(opts, ["mask"]);\n\n      var updateMask = !this.maskEquals(mask);\n      var updateOpts = !objectIncludes(this.masked, restOpts);\n      if (updateMask) this.mask = mask;\n      if (updateOpts) this.masked.updateOptions(restOpts);\n      if (updateMask || updateOpts) this.updateControl();\n    }\n    /** Updates cursor */\n\n  }, {\n    key: "updateCursor",\n    value: function updateCursor(cursorPos) {\n      if (cursorPos == null) return;\n      this.cursorPos = cursorPos; // also queue change cursor for mobile browsers\n\n      this._delayUpdateCursor(cursorPos);\n    }\n    /**\r\n      Delays cursor update to support mobile browsers\r\n      @private\r\n    */\n\n  }, {\n    key: "_delayUpdateCursor",\n    value: function _delayUpdateCursor(cursorPos) {\n      var _this = this;\n\n      this._abortUpdateCursor();\n\n      this._changingCursorPos = cursorPos;\n      this._cursorChanging = setTimeout(function () {\n        if (!_this.el) return; // if was destroyed\n\n        _this.cursorPos = _this._changingCursorPos;\n\n        _this._abortUpdateCursor();\n      }, 10);\n    }\n    /**\r\n      Fires custom events\r\n      @protected\r\n    */\n\n  }, {\n    key: "_fireChangeEvents",\n    value: function _fireChangeEvents() {\n      this._fireEvent(\'accept\', this._inputEvent);\n\n      if (this.masked.isComplete) this._fireEvent(\'complete\', this._inputEvent);\n    }\n    /**\r\n      Aborts delayed cursor update\r\n      @private\r\n    */\n\n  }, {\n    key: "_abortUpdateCursor",\n    value: function _abortUpdateCursor() {\n      if (this._cursorChanging) {\n        clearTimeout(this._cursorChanging);\n        delete this._cursorChanging;\n      }\n    }\n    /** Aligns cursor to nearest available position */\n\n  }, {\n    key: "alignCursor",\n    value: function alignCursor() {\n      this.cursorPos = this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT);\n    }\n    /** Aligns cursor only if selection is empty */\n\n  }, {\n    key: "alignCursorFriendly",\n    value: function alignCursorFriendly() {\n      if (this.selectionStart !== this.cursorPos) return; // skip if range is selected\n\n      this.alignCursor();\n    }\n    /** Adds listener on custom event */\n\n  }, {\n    key: "on",\n    value: function on(ev, handler) {\n      if (!this._listeners[ev]) this._listeners[ev] = [];\n\n      this._listeners[ev].push(handler);\n\n      return this;\n    }\n    /** Removes custom event listener */\n\n  }, {\n    key: "off",\n    value: function off(ev, handler) {\n      if (!this._listeners[ev]) return this;\n\n      if (!handler) {\n        delete this._listeners[ev];\n        return this;\n      }\n\n      var hIndex = this._listeners[ev].indexOf(handler);\n\n      if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);\n      return this;\n    }\n    /** Handles view input event */\n\n  }, {\n    key: "_onInput",\n    value: function _onInput(e) {\n      this._inputEvent = e;\n\n      this._abortUpdateCursor(); // fix strange IE behavior\n\n\n      if (!this._selection) return this.updateValue();\n      var details = new action_details( // new state\n      this.el.value, this.cursorPos, // old state\n      this.value, this._selection);\n      var oldRawValue = this.masked.rawInputValue;\n      var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset; // force align in remove direction only if no input chars were removed\n      // otherwise we still need to align with NONE (to get out from fixed symbols for instance)\n\n      var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;\n      var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);\n      this.updateControl();\n      this.updateCursor(cursorPos);\n      delete this._inputEvent;\n    }\n    /** Handles view change event and commits model value */\n\n  }, {\n    key: "_onChange",\n    value: function _onChange() {\n      if (this.value !== this.el.value) {\n        this.updateValue();\n      }\n\n      this.masked.doCommit();\n      this.updateControl();\n\n      this._saveSelection();\n    }\n    /** Handles view drop event, prevents by default */\n\n  }, {\n    key: "_onDrop",\n    value: function _onDrop(ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    /** Restore last selection on focus */\n\n  }, {\n    key: "_onFocus",\n    value: function _onFocus(ev) {\n      this.alignCursorFriendly();\n    }\n    /** Restore last selection on focus */\n\n  }, {\n    key: "_onClick",\n    value: function _onClick(ev) {\n      this.alignCursorFriendly();\n    }\n    /** Unbind view events and removes element reference */\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._unbindEvents(); // $FlowFixMe why not do so?\n\n\n      this._listeners.length = 0; // $FlowFixMe\n\n      delete this.el;\n    }\n  }, {\n    key: "mask",\n    get: function get() {\n      return this.masked.mask;\n    },\n    set: function set(mask) {\n      if (this.maskEquals(mask)) return;\n\n      if (!(mask instanceof holder.Masked) && this.masked.constructor === maskedClass(mask)) {\n        this.masked.updateOptions({\n          mask: mask\n        });\n        return;\n      }\n\n      var masked = factory({\n        mask: mask\n      });\n      masked.unmaskedValue = this.masked.unmaskedValue;\n      this.masked = masked;\n    }\n    /** Raw value */\n\n  }, {\n    key: "value",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(str) {\n      this.masked.value = str;\n      this.updateControl();\n      this.alignCursor();\n    }\n    /** Unmasked value */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._unmaskedValue;\n    },\n    set: function set(str) {\n      this.masked.unmaskedValue = str;\n      this.updateControl();\n      this.alignCursor();\n    }\n    /** Typed unmasked value */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.masked.typedValue;\n    },\n    set: function set(val) {\n      this.masked.typedValue = val;\n      this.updateControl();\n      this.alignCursor();\n    }\n  }, {\n    key: "selectionStart",\n    get: function get() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;\n    }\n    /** Current cursor position */\n\n  }, {\n    key: "cursorPos",\n    get: function get() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;\n    },\n    set: function set(pos) {\n      if (!this.el || !this.el.isActive) return;\n      this.el.select(pos, pos);\n\n      this._saveSelection();\n    }\n  }]);\n\n  return InputMask;\n}();\n\nholder.InputMask = input_InputMask;\n/* harmony default export */ var controls_input = (input_InputMask);\n// CONCATENATED MODULE: ./node_modules/imask/esm/imask.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var imask = (holder);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/enum.js\n\n\n\n\n\n\n\n\n\n\n\n\n/** Pattern which validates enum values */\n\nvar enum_MaskedEnum = /*#__PURE__*/function (_MaskedPattern) {\n  _inherits(MaskedEnum, _MaskedPattern);\n\n  function MaskedEnum() {\n    _classCallCheck(this, MaskedEnum);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedEnum).apply(this, arguments));\n  }\n\n  _createClass(MaskedEnum, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      // TODO type\n      if (opts.enum) opts.mask = \'*\'.repeat(opts.enum[0].length);\n\n      _get(_getPrototypeOf(MaskedEnum.prototype), "_update", this).call(this, opts);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _this = this,\n          _get2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.enum.some(function (e) {\n        return e.indexOf(_this.unmaskedValue) >= 0;\n      }) && (_get2 = _get(_getPrototypeOf(MaskedEnum.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));\n    }\n  }]);\n\n  return MaskedEnum;\n}(masked_pattern);\n\nholder.MaskedEnum = enum_MaskedEnum;\n/* harmony default export */ var masked_enum = (enum_MaskedEnum);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/number.js\n\n\n\n\n\n\n/**\r\n  Number mask\r\n  @param {Object} opts\r\n  @param {string} opts.radix - Single char\r\n  @param {string} opts.thousandsSeparator - Single char\r\n  @param {Array<string>} opts.mapToRadix - Array of single chars\r\n  @param {number} opts.min\r\n  @param {number} opts.max\r\n  @param {number} opts.scale - Digits after point\r\n  @param {boolean} opts.signed - Allow negative\r\n  @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing\r\n  @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing\r\n*/\n\nvar number_MaskedNumber = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedNumber, _Masked);\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n\n  function MaskedNumber(opts) {\n    _classCallCheck(this, MaskedNumber);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedNumber).call(this, Object.assign({}, MaskedNumber.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedNumber, [{\n    key: "_update",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedNumber.prototype), "_update", this).call(this, opts);\n\n      this._updateRegExps();\n    }\n    /** */\n\n  }, {\n    key: "_updateRegExps",\n    value: function _updateRegExps() {\n      // use different regexp to process user input (more strict, input suffix) and tail shifting\n      var start = \'^\' + (this.allowNegative ? \'[+|\\\\-]?\' : \'\');\n      var midInput = \'(0|([1-9]+\\\\d*))?\';\n      var mid = \'\\\\d*\';\n      var end = (this.scale ? \'(\' + escapeRegExp(this.radix) + \'\\\\d{0,\' + this.scale + \'})?\' : \'\') + \'$\';\n      this._numberRegExpInput = new RegExp(start + midInput + end);\n      this._numberRegExp = new RegExp(start + mid + end);\n      this._mapToRadixRegExp = new RegExp(\'[\' + this.mapToRadix.map(escapeRegExp).join(\'\') + \']\', \'g\');\n      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), \'g\');\n    }\n    /** */\n\n  }, {\n    key: "_removeThousandsSeparators",\n    value: function _removeThousandsSeparators(value) {\n      return value.replace(this._thousandsSeparatorRegExp, \'\');\n    }\n    /** */\n\n  }, {\n    key: "_insertThousandsSeparators",\n    value: function _insertThousandsSeparators(value) {\n      // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n      var parts = value.split(this.radix);\n      parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n      return parts.join(this.radix);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doPrepare",\n    value: function doPrepare(str) {\n      var _get2;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedNumber.prototype), "doPrepare", this)).call.apply(_get2, [this, this._removeThousandsSeparators(str.replace(this._mapToRadixRegExp, this.radix))].concat(args));\n    }\n    /** */\n\n  }, {\n    key: "_separatorsCount",\n    value: function _separatorsCount(to) {\n      var extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var count = 0;\n\n      for (var pos = 0; pos < to; ++pos) {\n        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n          ++count;\n          if (extendOnSeparators) to += this.thousandsSeparator.length;\n        }\n      }\n\n      return count;\n    }\n    /** */\n\n  }, {\n    key: "_separatorsCountFromSlice",\n    value: function _separatorsCountFromSlice() {\n      var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;\n      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 ? arguments[2] : undefined;\n\n      var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);\n\n      var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);\n\n      fromPos = _this$_adjustRangeWit2[0];\n      toPos = _this$_adjustRangeWit2[1];\n      return this._removeThousandsSeparators(_get(_getPrototypeOf(MaskedNumber.prototype), "extractInput", this).call(this, fromPos, toPos, flags));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!this.thousandsSeparator) return _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);\n      var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n      var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n\n      this._value = this._removeThousandsSeparators(this.value);\n\n      var appendDetails = _get(_getPrototypeOf(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);\n\n      this._value = this._insertThousandsSeparators(this._value);\n      var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n\n      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n      appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n      return appendDetails;\n    }\n    /** */\n\n  }, {\n    key: "_findSeparatorAround",\n    value: function _findSeparatorAround(pos) {\n      if (this.thousandsSeparator) {\n        var searchFrom = pos - this.thousandsSeparator.length + 1;\n        var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n        if (separatorPos <= pos) return separatorPos;\n      }\n\n      return -1;\n    }\n  }, {\n    key: "_adjustRangeWithSeparators",\n    value: function _adjustRangeWithSeparators(from, to) {\n      var separatorAroundFromPos = this._findSeparatorAround(from);\n\n      if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n\n      var separatorAroundToPos = this._findSeparatorAround(to);\n\n      if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n      return [from, to];\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);\n\n      var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);\n\n      fromPos = _this$_adjustRangeWit4[0];\n      toPos = _this$_adjustRangeWit4[1];\n      var valueBeforePos = this.value.slice(0, fromPos);\n      var valueAfterPos = this.value.slice(toPos);\n\n      var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n\n      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n\n      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n\n      return new change_details({\n        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos(cursorPos, direction) {\n      if (!this.thousandsSeparator) return cursorPos;\n\n      switch (direction) {\n        case DIRECTION.NONE:\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          {\n            var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n\n            if (separatorAtLeftPos >= 0) {\n              var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n\n              if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n                return separatorAtLeftPos;\n              }\n            }\n\n            break;\n          }\n\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          {\n            var separatorAtRightPos = this._findSeparatorAround(cursorPos);\n\n            if (separatorAtRightPos >= 0) {\n              return separatorAtRightPos + this.thousandsSeparator.length;\n            }\n          }\n      }\n\n      return cursorPos;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate(flags) {\n      var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp; // validate as string\n\n      var valid = regexp.test(this._removeThousandsSeparators(this.value));\n\n      if (valid) {\n        // validate as number\n        var number = this.number;\n        valid = valid && !isNaN(number) && ( // check min bound for negative values\n        this.min == null || this.min >= 0 || this.min <= this.number) && ( // check max bound for positive values\n        this.max == null || this.max <= 0 || this.number <= this.max);\n      }\n\n      return valid && _get(_getPrototypeOf(MaskedNumber.prototype), "doValidate", this).call(this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.value) {\n        var number = this.number;\n        var validnum = number; // check bounds\n\n        if (this.min != null) validnum = Math.max(validnum, this.min);\n        if (this.max != null) validnum = Math.min(validnum, this.max);\n        if (validnum !== number) this.unmaskedValue = String(validnum);\n        var formatted = this.value;\n        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n        if (this.padFractionalZeros) formatted = this._padFractionalZeros(formatted);\n        this._value = formatted;\n      }\n\n      _get(_getPrototypeOf(MaskedNumber.prototype), "doCommit", this).call(this);\n    }\n    /** */\n\n  }, {\n    key: "_normalizeZeros",\n    value: function _normalizeZeros(value) {\n      var parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros\n\n\n      parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, function (match, sign, zeros, num) {\n        return sign + num;\n      }); // add leading zero\n\n      if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + \'0\';\n\n      if (parts.length > 1) {\n        parts[1] = parts[1].replace(/0*$/, \'\'); // remove trailing zeros\n\n        if (!parts[1].length) parts.length = 1; // remove fractional\n      }\n\n      return this._insertThousandsSeparators(parts.join(this.radix));\n    }\n    /** */\n\n  }, {\n    key: "_padFractionalZeros",\n    value: function _padFractionalZeros(value) {\n      if (!value) return value;\n      var parts = value.split(this.radix);\n      if (parts.length < 2) parts.push(\'\');\n      parts[1] = parts[1].padEnd(this.scale, \'0\');\n      return parts.join(this.radix);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, \'.\');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", unmaskedValue.replace(\'.\', this.radix), this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return Number(this.unmaskedValue);\n    },\n    set: function set(n) {\n      _set(_getPrototypeOf(MaskedNumber.prototype), "unmaskedValue", String(n), this, true);\n    }\n    /** Parsed Number */\n\n  }, {\n    key: "number",\n    get: function get() {\n      return this.typedValue;\n    },\n    set: function set(number) {\n      this.typedValue = number;\n    }\n    /**\r\n      Is negative allowed\r\n      @readonly\r\n    */\n\n  }, {\n    key: "allowNegative",\n    get: function get() {\n      return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;\n    }\n  }]);\n\n  return MaskedNumber;\n}(base);\n\nnumber_MaskedNumber.DEFAULTS = {\n  radix: \',\',\n  thousandsSeparator: \'\',\n  mapToRadix: [\'.\'],\n  scale: 2,\n  signed: false,\n  normalizeZeros: true,\n  padFractionalZeros: false\n};\nholder.MaskedNumber = number_MaskedNumber;\n/* harmony default export */ var masked_number = (number_MaskedNumber);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/function.js\n\n\n\n\n\n\n/** Masking by custom Function */\n\nvar function_MaskedFunction = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedFunction, _Masked);\n\n  function MaskedFunction() {\n    _classCallCheck(this, MaskedFunction);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedFunction).apply(this, arguments));\n  }\n\n  _createClass(MaskedFunction, [{\n    key: "_update",\n\n    /**\r\n      @override\r\n      @param {Object} opts\r\n    */\n    value: function _update(opts) {\n      if (opts.mask) opts.validate = opts.mask;\n\n      _get(_getPrototypeOf(MaskedFunction.prototype), "_update", this).call(this, opts);\n    }\n  }]);\n\n  return MaskedFunction;\n}(base);\n\nholder.MaskedFunction = function_MaskedFunction;\n/* harmony default export */ var masked_function = (function_MaskedFunction);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/dynamic.js\n\n\n\n\n\n\n\n/** Dynamic mask for choosing apropriate mask in run-time */\n\nvar dynamic_MaskedDynamic = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedDynamic, _Masked);\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\r\n    @param {Object} opts\r\n  */\n\n\n  function MaskedDynamic(opts) {\n    var _this;\n\n    _classCallCheck(this, MaskedDynamic);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MaskedDynamic).call(this, Object.assign({}, MaskedDynamic.DEFAULTS, {}, opts)));\n    _this.currentMask = null;\n    return _this;\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDynamic, [{\n    key: "_update",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedDynamic.prototype), "_update", this).call(this, opts);\n\n      if (\'mask\' in opts) {\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return factory(m);\n        }) : [];\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "_appendCharRaw",\n    value: function _appendCharRaw() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        var _this$currentMask;\n\n        details.aggregate((_this$currentMask = this.currentMask)._appendChar.apply(_this$currentMask, arguments));\n      }\n\n      return details;\n    }\n  }, {\n    key: "_applyDispatch",\n    value: function _applyDispatch() {\n      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      var inputValue = this.rawInputValue;\n      var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n      flags._beforeTailState._rawInputValue : inputValue;\n      var tailValue = inputValue.slice(insertValue.length);\n      var prevMask = this.currentMask;\n      var details = new change_details();\n      var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n      this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch\n\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset(); // $FlowFixMe - it\'s ok, we don\'t change current mask above\n\n          var d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n\n          if (tailValue) {\n            // $FlowFixMe - it\'s ok, we don\'t change current mask above\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: "_appendPlaceholder",\n    value: function _appendPlaceholder() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doDispatch",\n    value: function doDispatch(appended) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.dispatch(appended, this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doValidate",\n    value: function doValidate() {\n      var _get2, _this$currentMask2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask2 = this.currentMask).doValidate.apply(_this$currentMask2, args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "reset",\n    value: function reset() {\n      if (this.currentMask) this.currentMask.reset();\n      this.compiledMasks.forEach(function (m) {\n        return m.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "remove",\n\n    /**\r\n      @override\r\n    */\n    value: function remove() {\n      var details = new change_details();\n\n      if (this.currentMask) {\n        var _this$currentMask3;\n\n        details.aggregate((_this$currentMask3 = this.currentMask).remove.apply(_this$currentMask3, arguments)) // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractInput",\n\n    /**\r\n      @override\r\n    */\n    value: function extractInput() {\n      var _this$currentMask4;\n\n      return this.currentMask ? (_this$currentMask4 = this.currentMask).extractInput.apply(_this$currentMask4, arguments) : \'\';\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "extractTail",\n    value: function extractTail() {\n      var _this$currentMask5, _get3;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.currentMask ? (_this$currentMask5 = this.currentMask).extractTail.apply(_this$currentMask5, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "doCommit",\n    value: function doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n\n      _get(_getPrototypeOf(MaskedDynamic.prototype), "doCommit", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "nearestInputPos",\n    value: function nearestInputPos() {\n      var _this$currentMask6, _get4;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.currentMask ? (_this$currentMask6 = this.currentMask).nearestInputPos.apply(_this$currentMask6, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return this.currentMask ? this.currentMask.value : \'\';\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "value", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "unmaskedValue",\n    get: function get() {\n      return this.currentMask ? this.currentMask.unmaskedValue : \'\';\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "unmaskedValue", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "typedValue",\n    get: function get() {\n      return this.currentMask ? this.currentMask.typedValue : \'\';\n    } // probably typedValue should not be used with dynamic\n    ,\n    set: function set(value) {\n      var unmaskedValue = String(value); // double check it\n\n      if (this.currentMask) {\n        this.currentMask.typedValue = value;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n\n      this.unmaskedValue = unmaskedValue;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: "isComplete",\n    get: function get() {\n      return !!this.currentMask && this.currentMask.isComplete;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), "state", this), {\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(function (m) {\n          return m.state;\n        }),\n        currentMaskRef: this.currentMask,\n        currentMask: this.currentMask && this.currentMask.state\n      });\n    },\n    set: function set(state) {\n      var compiledMasks = state.compiledMasks,\n          currentMaskRef = state.currentMaskRef,\n          currentMask = state.currentMask,\n          maskedState = _objectWithoutProperties(state, ["compiledMasks", "currentMaskRef", "currentMask"]);\n\n      this.compiledMasks.forEach(function (m, mi) {\n        return m.state = compiledMasks[mi];\n      });\n\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n\n      _set(_getPrototypeOf(MaskedDynamic.prototype), "state", maskedState, this, true);\n    }\n  }, {\n    key: "overwrite",\n    get: function get() {\n      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), "overwrite", this);\n    },\n    set: function set(overwrite) {\n      console.warn(\'"overwrite" option is not available in dynamic mask, use this option in siblings\');\n    }\n  }]);\n\n  return MaskedDynamic;\n}(base);\n\ndynamic_MaskedDynamic.DEFAULTS = {\n  dispatch: function dispatch(appended, masked, flags) {\n    if (!masked.compiledMasks.length) return;\n    var inputValue = masked.rawInputValue; // simulate input\n\n    var inputs = masked.compiledMasks.map(function (m, index) {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, flags);\n      var weight = m.rawInputValue.length;\n      return {\n        weight: weight,\n        index: index\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort(function (i1, i2) {\n      return i2.weight - i1.weight;\n    });\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nholder.MaskedDynamic = dynamic_MaskedDynamic;\n/* harmony default export */ var dynamic = (dynamic_MaskedDynamic);\n// CONCATENATED MODULE: ./node_modules/imask/esm/masked/pipe.js\n\n\n\n\n/** Mask pipe source and destination types */\n\nvar PIPE_TYPE = {\n  MASKED: \'value\',\n  UNMASKED: \'unmaskedValue\',\n  TYPED: \'typedValue\'\n};\n/** Creates new pipe function depending on mask type, source and destination options */\n\nfunction createPipe(mask) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;\n  var masked = factory(mask);\n  return function (value) {\n    return masked.runIsolated(function (m) {\n      m[from] = value;\n      return m[to];\n    });\n  };\n}\n/** Pipes value through mask depending on mask type, source and destination options */\n\n\nfunction pipe(value) {\n  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pipeArgs[_key - 1] = arguments[_key];\n  }\n\n  return createPipe.apply(void 0, pipeArgs)(value);\n}\n\nholder.PIPE_TYPE = PIPE_TYPE;\nholder.createPipe = createPipe;\nholder.pipe = pipe;\n\n// CONCATENATED MODULE: ./node_modules/imask/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntry {\n  globalThis.IMask = imask;\n} catch (e) {}\n\n/* harmony default export */ var esm = __webpack_exports__["a"] = (imask);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanM/OWE2OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvdXRpbHMuanM/ZGZkNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvYWN0aW9uLWRldGFpbHMuanM/MzY3YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvY2hhbmdlLWRldGFpbHMuanM/MGUxYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanM/MjVjMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvcmUvaG9sZGVyLmpzPzQxNzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvYmFzZS5qcz8wMDAyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2ZhY3RvcnkuanM/NWQ5ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanM/NGY2MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2ZpeGVkLWRlZmluaXRpb24uanM/NzFiZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcz9kODBmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3JlZ2V4cC5qcz8zYTc2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3BhdHRlcm4uanM/OTY3ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL21hc2tlZC9yYW5nZS5qcz9mY2U4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2RhdGUuanM/YTA3YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvbnRyb2xzL21hc2stZWxlbWVudC5qcz81YTM3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vY29udHJvbHMvaHRtbC1tYXNrLWVsZW1lbnQuanM/YjE1MCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2NvbnRyb2xzL2h0bWwtY29udGVudGVkaXRhYmxlLW1hc2stZWxlbWVudC5qcz84NTY1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vY29udHJvbHMvaW5wdXQuanM/NTQ4YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2ltYXNrLmpzPzFmOGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvZW51bS5qcz9iNGI1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL251bWJlci5qcz8yNGMyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL2Z1bmN0aW9uLmpzPzc5MDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltYXNrL2VzbS9tYXNrZWQvZHluYW1pYy5qcz9iNzhhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbWFzay9lc20vbWFza2VkL3BpcGUuanM/NTE4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW1hc2svZXNtL2luZGV4LmpzPzBkMTYiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX3N1cGVyUHJvcEJhc2UiLCJvYmplY3QiLCJwcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwiX2dldCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImdldCIsImJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0IiwiX3NldCIsImlzU3RyaWN0IiwicyIsIkVycm9yIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiQXJyYXkiLCJpc0FycmF5IiwidG9TdHJpbmciLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicHVzaCIsImVyciIsImlzU3RyaW5nIiwic3RyIiwiU3RyaW5nIiwiRElSRUNUSU9OIiwiTk9ORSIsIkxFRlQiLCJGT1JDRV9MRUZUIiwiUklHSFQiLCJGT1JDRV9SSUdIVCIsImluZGV4SW5EaXJlY3Rpb24iLCJwb3MiLCJkaXJlY3Rpb24iLCJwb3NJbkRpcmVjdGlvbiIsImZvcmNlRGlyZWN0aW9uIiwiZXNjYXBlUmVnRXhwIiwicmVwbGFjZSIsIm9iamVjdEluY2x1ZGVzIiwiYiIsImEiLCJhcnJBIiwiYXJyQiIsImRhdGVBIiwiRGF0ZSIsImRhdGVCIiwiZ2V0VGltZSIsInJlZ2V4cEEiLCJSZWdFeHAiLCJyZWdleHBCIiwiQWN0aW9uRGV0YWlscyIsImN1cnNvclBvcyIsIm9sZFZhbHVlIiwib2xkU2VsZWN0aW9uIiwic2xpY2UiLCJzdGFydENoYW5nZVBvcyIsInN0YXJ0IiwiTWF0aCIsIm1pbiIsInN1YnN0ciIsImluc2VydGVkQ291bnQiLCJtYXgiLCJlbmQiLCJyZW1vdmVkQ291bnQiLCJzdWJzdHJpbmciLCJDaGFuZ2VEZXRhaWxzIiwiZGV0YWlscyIsImFzc2lnbiIsImluc2VydGVkIiwicmF3SW5zZXJ0ZWQiLCJza2lwIiwidGFpbFNoaWZ0IiwiYWdncmVnYXRlIiwiQ29udGludW91c1RhaWxEZXRhaWxzIiwiYXJndW1lbnRzIiwiZnJvbSIsInN0b3AiLCJleHRlbmQiLCJ0YWlsIiwiYXBwZW5kVG8iLCJtYXNrZWQiLCJhcHBlbmQiLCJfYXBwZW5kUGxhY2Vob2xkZXIiLCJzaGlmdEJlZm9yZSIsInNoaWZ0Q2hhciIsInN0YXRlIiwiSU1hc2siLCJlbCIsIm9wdHMiLCJJbnB1dE1hc2siLCJNYXNrZWQiLCJfdmFsdWUiLCJfdXBkYXRlIiwiREVGQVVMVFMiLCJpc0luaXRpYWxpemVkIiwidXBkYXRlT3B0aW9ucyIsIndpdGhWYWx1ZVJlZnJlc2giLCJiaW5kIiwicmVzZXQiLCJyZXNvbHZlIiwiaW5wdXQiLCJkb0NvbW1pdCIsIm5lYXJlc3RJbnB1dFBvcyIsImV4dHJhY3RJbnB1dCIsImZyb21Qb3MiLCJ0b1BvcyIsImV4dHJhY3RUYWlsIiwiYXBwZW5kVGFpbCIsIl9hcHBlbmRDaGFyUmF3IiwiY2giLCJmbGFncyIsImRvUHJlcGFyZSIsIl9hcHBlbmRDaGFyIiwiY2hlY2tUYWlsIiwiY29uc2lzdGVudFN0YXRlIiwiY29uc2lzdGVudFRhaWwiLCJhcHBlbmRlZCIsImRvVmFsaWRhdGUiLCJiZWZvcmVUYWlsU3RhdGUiLCJvdmVyd3JpdGUiLCJ0YWlsRGV0YWlscyIsIl9iZWZvcmVUYWlsU3RhdGUiLCJjaSIsInJlbW92ZSIsImZuIiwiX3JlZnJlc2hpbmciLCJyYXdJbnB1dCIsInJhd0lucHV0VmFsdWUiLCJyZXQiLCJydW5Jc29sYXRlZCIsIl9pc29sYXRlZCIsInByZXBhcmUiLCJ2YWxpZGF0ZSIsInBhcmVudCIsImNvbW1pdCIsImRvRm9ybWF0IiwiZm9ybWF0IiwiZG9QYXJzZSIsInBhcnNlIiwic3BsaWNlIiwiZGVsZXRlQ291bnQiLCJyZW1vdmVEaXJlY3Rpb24iLCJ0YWlsUG9zIiwiY2hhbmdlRGV0YWlscyIsInJhdyIsInYiLCJtYXNrZWRDbGFzcyIsIm1hc2siLCJNYXNrZWRSZWdFeHAiLCJNYXNrZWRQYXR0ZXJuIiwiTWFza2VkRGF0ZSIsIk51bWJlciIsIk1hc2tlZE51bWJlciIsIk1hc2tlZER5bmFtaWMiLCJGdW5jdGlvbiIsIk1hc2tlZEZ1bmN0aW9uIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVNYXNrIiwiTWFza2VkQ2xhc3MiLCJERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIiwiUGF0dGVybklucHV0RGVmaW5pdGlvbiIsImJsb2NrT3B0cyIsIl9pc0ZpbGxlZCIsImlzT3B0aW9uYWwiLCJsYXp5IiwicGxhY2Vob2xkZXJDaGFyIiwiQm9vbGVhbiIsIl90aGlzJG1hc2tlZCIsImFwcGx5IiwiX3RoaXMkbWFza2VkMiIsIl90aGlzJG1hc2tlZDMiLCJtaW5Qb3MiLCJtYXhQb3MiLCJib3VuZFBvcyIsImlzQ29tcGxldGUiLCJfdGhpcyRtYXNrZWQ0IiwiX3RoaXMkcGFyZW50IiwidW5tYXNrZWRWYWx1ZSIsIlBhdHRlcm5GaXhlZERlZmluaXRpb24iLCJfaXNSYXdJbnB1dCIsImNoYXIiLCJpc1Jlc29sdmVkIiwiaXNVbm1hc2tpbmciLCJDaHVua3NUYWlsRGV0YWlscyIsImNodW5rcyIsIm1hcCIsImpvaW4iLCJ0YWlsQ2h1bmsiLCJsYXN0Q2h1bmsiLCJleHRlbmRMYXN0IiwiZmlyc3RUYWlsQ2h1bmsiLCJzaGlmdCIsImJsb2NrSW5kZXgiLCJjaHVuayIsImxhc3RCbG9ja0l0ZXIiLCJfbWFwUG9zVG9CbG9jayIsImNodW5rQmxvY2siLCJpbmRleCIsIl9zdG9wcyIsIl9ibG9ja3MiLCJyZW1haW5DaGFycyIsImNodW5rU2hpZnRQb3MiLCJjIiwiY3N0YXRlIiwiX01hc2tlZCIsInNlYXJjaCIsImRlZmluaXRpb25zIiwiX3JlYnVpbGRNYXNrIiwiX3RoaXMiLCJkZWZzIiwiX21hc2tlZEJsb2NrcyIsInBhdHRlcm4iLCJ1bm1hc2tpbmdCbG9jayIsIm9wdGlvbmFsQmxvY2siLCJibG9ja3MiLCJfcmV0IiwiYk5hbWVzIiwiZmlsdGVyIiwiYk5hbWUiLCJzb3J0IiwibWFza2VkQmxvY2siLCJfaXNJbnB1dCIsIlNUT1BfQ0hBUiIsIkVTQ0FQRV9DSEFSIiwiZGVmIiwiZm9yRWFjaCIsImJsb2NrSXRlciIsImJpIiwiX2Jsb2NrIiwiYmxvY2tEZXRhaWxzIiwiX3RoaXMyIiwiY2h1bmtUYWlsIiwiX2ZvckVhY2hCbG9ja3NJblJhbmdlIiwiYkZyb21Qb3MiLCJiVG9Qb3MiLCJibG9ja0NodW5rIiwiX2ZpbmRTdG9wQmVmb3JlIiwiX2Jsb2NrU3RhcnRQb3MiLCJfIiwic3RvcEJlZm9yZSIsInNpIiwidG9CbG9ja0luZGV4IiwiX3RoaXMzIiwic3RhcnRCbG9ja0l0ZXIiLCJzdGFydEJsb2NrSW5kZXgiLCJlbmRCbG9ja0luZGV4IiwiYXJncyIsImJEZXRhaWxzIiwiYWNjVmFsIiwiX2Jsb2NrMiIsImJsb2NrU3RhcnRQb3MiLCJvZmZzZXQiLCJyZWR1Y2UiLCJmcm9tQmxvY2tJdGVyIiwidG9CbG9ja0l0ZXIiLCJpc1NhbWVCbG9jayIsImZyb21CbG9ja1N0YXJ0UG9zIiwiZnJvbUJsb2NrRW5kUG9zIiwicmVtb3ZlRGV0YWlscyIsImJlZ2luQmxvY2tEYXRhIiwiYmVnaW5CbG9ja09mZnNldCIsImJlZ2luQmxvY2tJbmRleCIsImJlZ2luQmxvY2siLCJiZWdpbkJsb2NrQ3Vyc29yUG9zIiwiY3Vyc29yQXRSaWdodCIsImN1cnNvckF0TGVmdCIsInNlYXJjaEJsb2NrSW5kZXgiLCJibG9ja0luZGV4QXRMZWZ0IiwiYmxvY2tBdExlZnQiLCJibG9ja0lucHV0UG9zIiwiZmlyc3RJbnB1dEF0UmlnaHQiLCJibG9ja0F0UmlnaHQiLCJfYmxvY2tJbnB1dFBvcyIsIl9iaSIsIl9ibG9jazMiLCJfYmxvY2tJbnB1dFBvczIiLCJmaXJzdEZpbGxlZEJsb2NrSW5kZXhBdFJpZ2h0IiwiX2JpMiIsImZpbGxlZEJsb2NrIiwiX2Jsb2NrSW5wdXRQb3MzIiwiZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXgiLCJmaXJzdEVtcHR5SW5wdXRCbG9ja0luZGV4IiwiX2JpMyIsIl9ibG9jazQiLCJfYmxvY2tJbnB1dFBvczQiLCJfYmk0IiwiX2Jsb2NrNSIsIl9ibG9ja0lucHV0UG9zNSIsImJsb2NrQWxpZ25lZFBvcyIsImlzSW5wdXQiLCJfYmk1IiwiX2Jsb2NrNiIsIl9ibG9ja0lucHV0UG9zNiIsImZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleCIsImZpcnN0SW5wdXRCbG9ja0FsaWduZWRQb3MiLCJfYmk2IiwiX2Jsb2NrNyIsIl9ibG9ja0lucHV0UG9zNyIsIl9iaTciLCJfYmxvY2s4IiwiX2Jsb2NrSW5wdXRQb3M4IiwiX2JpOCIsIl9ibG9jazkiLCJfYmxvY2tJbnB1dFBvczkiLCJhbGlnbmVkUG9zIiwibmFtZSIsIm1hc2tlZEJsb2NrcyIsIl90aGlzNCIsImluZGljZXMiLCJnaSIsIm1hc2tlZFN0YXRlIiwiZXZlcnkiLCJJbnB1dERlZmluaXRpb24iLCJGaXhlZERlZmluaXRpb24iLCJibG9jayIsIk1hc2tlZFJhbmdlIiwiX01hc2tlZFBhdHRlcm4iLCJ0byIsIm1heExlbmd0aCIsImZyb21TdHIiLCJwYWRTdGFydCIsInRvU3RyIiwic2FtZUNoYXJzQ291bnQiLCJyZXBlYXQiLCJib3VuZGFyaWVzIiwibWluc3RyIiwibWF4c3RyIiwiX3JlZiIsIm1hdGNoIiwiX3JlZjIiLCJwbGFjZWhvbGRlciIsIm51bSIsInBhZEVuZCIsImF1dG9maXgiLCJ2YWwiLCJwcmVwU3RyIiwibmV4dFZhbCIsIl90aGlzJGJvdW5kYXJpZXMiLCJfdGhpcyRib3VuZGFyaWVzMiIsIl9nZXQyIiwiZmlyc3ROb25aZXJvIiwiX21hdGNoRnJvbSIsIl90aGlzJGJvdW5kYXJpZXMzIiwiX3RoaXMkYm91bmRhcmllczQiLCJfbGVuIiwiX2tleSIsImNvbmNhdCIsIkdFVF9ERUZBVUxUX0JMT0NLUyIsIlkiLCJnZXRGdWxsWWVhciIsIm0iLCJnZXRNb250aCIsImQiLCJnZXREYXRlIiwiYmsiLCJkYXRlIiwiaXNEYXRlRXhpc3QiLCJ0eXBlZFZhbHVlIiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwiX3N0ciRzcGxpdCIsInNwbGl0IiwiX3N0ciRzcGxpdDIiLCJNYXNrRWxlbWVudCIsInNlbGVjdCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwiX3Vuc2FmZVNlbGVjdCIsImUiLCJiaW5kRXZlbnRzIiwiaGFuZGxlcnMiLCJ1bmJpbmRFdmVudHMiLCJfdW5zYWZlU2VsZWN0aW9uU3RhcnQiLCJfdW5zYWZlU2VsZWN0aW9uRW5kIiwiSFRNTE1hc2tFbGVtZW50IiwiX01hc2tFbGVtZW50IiwiX2hhbmRsZXJzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJldmVudCIsIl90b2dnbGVFdmVudEhhbmRsZXIiLCJFVkVOVFNfTUFQIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0Um9vdE5vZGUiLCJkb2N1bWVudCIsInJvb3RFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInNlbGVjdGlvbkNoYW5nZSIsImRyb3AiLCJjbGljayIsImZvY3VzIiwiSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50IiwiX0hUTUxNYXNrRWxlbWVudCIsImNyZWF0ZVJhbmdlIiwicmFuZ2UiLCJzZXRTdGFydCIsImZpcnN0Q2hpbGQiLCJzZXRFbmQiLCJsYXN0Q2hpbGQiLCJyb290Iiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJhbmNob3JPZmZzZXQiLCJ0ZXh0Q29udGVudCIsImlzQ29udGVudEVkaXRhYmxlIiwidGFnTmFtZSIsIl9saXN0ZW5lcnMiLCJfdW5tYXNrZWRWYWx1ZSIsIl9zYXZlU2VsZWN0aW9uIiwiX29uSW5wdXQiLCJfb25DaGFuZ2UiLCJfb25Ecm9wIiwiX29uRm9jdXMiLCJfb25DbGljayIsImFsaWduQ3Vyc29yIiwiYWxpZ25DdXJzb3JGcmllbmRseSIsIl9iaW5kRXZlbnRzIiwidXBkYXRlVmFsdWUiLCJtYXNrRXF1YWxzIiwiX3VuYmluZEV2ZW50cyIsIl9maXJlRXZlbnQiLCJldiIsImxpc3RlbmVycyIsImwiLCJfc2VsZWN0aW9uIiwidXBkYXRlQ29udHJvbCIsIm5ld1VubWFza2VkVmFsdWUiLCJuZXdWYWx1ZSIsImlzQ2hhbmdlZCIsIl9maXJlQ2hhbmdlRXZlbnRzIiwicmVzdE9wdHMiLCJ1cGRhdGVNYXNrIiwidXBkYXRlT3B0cyIsInVwZGF0ZUN1cnNvciIsIl9kZWxheVVwZGF0ZUN1cnNvciIsIl9hYm9ydFVwZGF0ZUN1cnNvciIsIl9jaGFuZ2luZ0N1cnNvclBvcyIsIl9jdXJzb3JDaGFuZ2luZyIsInNldFRpbWVvdXQiLCJfaW5wdXRFdmVudCIsImNsZWFyVGltZW91dCIsIm9uIiwib2ZmIiwiaEluZGV4Iiwib2xkUmF3VmFsdWUiLCJyZW1vdmVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJkZXN0cm95IiwiaXNBY3RpdmUiLCJNYXNrZWRFbnVtIiwiZW51bSIsInNvbWUiLCJfdXBkYXRlUmVnRXhwcyIsImFsbG93TmVnYXRpdmUiLCJtaWRJbnB1dCIsIm1pZCIsInNjYWxlIiwicmFkaXgiLCJfbnVtYmVyUmVnRXhwSW5wdXQiLCJfbnVtYmVyUmVnRXhwIiwiX21hcFRvUmFkaXhSZWdFeHAiLCJtYXBUb1JhZGl4IiwiX3Rob3VzYW5kc1NlcGFyYXRvclJlZ0V4cCIsInRob3VzYW5kc1NlcGFyYXRvciIsIl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzIiwiX2luc2VydFRob3VzYW5kc1NlcGFyYXRvcnMiLCJwYXJ0cyIsIl9zZXBhcmF0b3JzQ291bnQiLCJleHRlbmRPblNlcGFyYXRvcnMiLCJjb3VudCIsIl9zZXBhcmF0b3JzQ291bnRGcm9tU2xpY2UiLCJfdGhpcyRfYWRqdXN0UmFuZ2VXaXQiLCJfYWRqdXN0UmFuZ2VXaXRoU2VwYXJhdG9ycyIsIl90aGlzJF9hZGp1c3RSYW5nZVdpdDIiLCJwcmV2QmVmb3JlVGFpbFZhbHVlIiwicHJldkJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQiLCJhcHBlbmREZXRhaWxzIiwiYmVmb3JlVGFpbFZhbHVlIiwiYmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCIsIl9maW5kU2VwYXJhdG9yQXJvdW5kIiwic2VhcmNoRnJvbSIsInNlcGFyYXRvclBvcyIsInNlcGFyYXRvckFyb3VuZEZyb21Qb3MiLCJzZXBhcmF0b3JBcm91bmRUb1BvcyIsIl90aGlzJF9hZGp1c3RSYW5nZVdpdDMiLCJfdGhpcyRfYWRqdXN0UmFuZ2VXaXQ0IiwidmFsdWVCZWZvcmVQb3MiLCJ2YWx1ZUFmdGVyUG9zIiwic2VwYXJhdG9yQXRMZWZ0UG9zIiwic2VwYXJhdG9yQXRMZWZ0RW5kUG9zIiwic2VwYXJhdG9yQXRSaWdodFBvcyIsInJlZ2V4cCIsInZhbGlkIiwidGVzdCIsIm51bWJlciIsImlzTmFOIiwidmFsaWRudW0iLCJmb3JtYXR0ZWQiLCJub3JtYWxpemVaZXJvcyIsIl9ub3JtYWxpemVaZXJvcyIsInBhZEZyYWN0aW9uYWxaZXJvcyIsIl9wYWRGcmFjdGlvbmFsWmVyb3MiLCJzaWduIiwiemVyb3MiLCJuIiwic2lnbmVkIiwiY3VycmVudE1hc2siLCJjb21waWxlZE1hc2tzIiwiX2FwcGx5RGlzcGF0Y2giLCJfdGhpcyRjdXJyZW50TWFzayIsInByZXZWYWx1ZUJlZm9yZVRhaWwiLCJpbnB1dFZhbHVlIiwiaW5zZXJ0VmFsdWUiLCJfcmF3SW5wdXRWYWx1ZSIsInRhaWxWYWx1ZSIsInByZXZNYXNrIiwicHJldk1hc2tTdGF0ZSIsImRvRGlzcGF0Y2giLCJkaXNwYXRjaCIsIl90aGlzJGN1cnJlbnRNYXNrMiIsIl90aGlzJGN1cnJlbnRNYXNrMyIsIl90aGlzJGN1cnJlbnRNYXNrNCIsIl90aGlzJGN1cnJlbnRNYXNrNSIsIl9nZXQzIiwiX2xlbjIiLCJfa2V5MiIsIl90aGlzJGN1cnJlbnRNYXNrNiIsIl9nZXQ0IiwiX2xlbjMiLCJfa2V5MyIsImN1cnJlbnRNYXNrUmVmIiwibWkiLCJpbnB1dHMiLCJ3ZWlnaHQiLCJpMSIsImkyIiwiUElQRV9UWVBFIiwiTUFTS0VEIiwiVU5NQVNLRUQiLCJUWVBFRCIsImNyZWF0ZVBpcGUiLCJwaXBlIiwicGlwZUFyZ3MiLCJnbG9iYWxUaGlzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEI7O0FBRUEsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQ0MsUUFBZCxLQUEyQixRQUEvRCxFQUF5RTtBQUN2RUgsV0FBTyxHQUFHLFVBQVVDLEdBQVYsRUFBZTtBQUN2QixhQUFPLE9BQU9BLEdBQWQ7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPO0FBQ0xELFdBQU8sR0FBRyxVQUFVQyxHQUFWLEVBQWU7QUFDdkIsYUFBT0EsR0FBRyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNELEdBQUcsQ0FBQ0csV0FBSixLQUFvQkYsTUFBM0QsSUFBcUVELEdBQUcsS0FBS0MsTUFBTSxDQUFDRyxTQUFwRixHQUFnRyxRQUFoRyxHQUEyRyxPQUFPSixHQUF6SDtBQUNELEtBRkQ7QUFHRDs7QUFFRCxTQUFPRCxPQUFPLENBQUNDLEdBQUQsQ0FBZDtBQUNEOztBQUVELFNBQVNLLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxXQUFuQyxFQUFnRDtBQUM5QyxNQUFJLEVBQUVELFFBQVEsWUFBWUMsV0FBdEIsQ0FBSixFQUF3QztBQUN0QyxVQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0FBQ3hDLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtBQUNBRSxjQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtBQUNBRCxjQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7QUFDQSxRQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtBQUMzQkMsVUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7QUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JkLFdBQXRCLEVBQW1DZSxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFDMUQsTUFBSUQsVUFBSixFQUFnQmIsaUJBQWlCLENBQUNGLFdBQVcsQ0FBQ0gsU0FBYixFQUF3QmtCLFVBQXhCLENBQWpCO0FBQ2hCLE1BQUlDLFdBQUosRUFBaUJkLGlCQUFpQixDQUFDRixXQUFELEVBQWNnQixXQUFkLENBQWpCO0FBQ2pCLFNBQU9oQixXQUFQO0FBQ0Q7O0FBRUQsU0FBU2lCLGVBQVQsQ0FBeUJ4QixHQUF6QixFQUE4Qm9CLEdBQTlCLEVBQW1DSyxLQUFuQyxFQUEwQztBQUN4QyxNQUFJTCxHQUFHLElBQUlwQixHQUFYLEVBQWdCO0FBQ2RrQixVQUFNLENBQUNDLGNBQVAsQ0FBc0JuQixHQUF0QixFQUEyQm9CLEdBQTNCLEVBQWdDO0FBQzlCSyxXQUFLLEVBQUVBLEtBRHVCO0FBRTlCVixnQkFBVSxFQUFFLElBRmtCO0FBRzlCQyxrQkFBWSxFQUFFLElBSGdCO0FBSTlCQyxjQUFRLEVBQUU7QUFKb0IsS0FBaEM7QUFNRCxHQVBELE1BT087QUFDTGpCLE9BQUcsQ0FBQ29CLEdBQUQsQ0FBSCxHQUFXSyxLQUFYO0FBQ0Q7O0FBRUQsU0FBT3pCLEdBQVA7QUFDRDs7QUFFRCxTQUFTMEIsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQ3ZDLE1BQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsVUFBVSxLQUFLLElBQXZELEVBQTZEO0FBQzNELFVBQU0sSUFBSXBCLFNBQUosQ0FBYyxvREFBZCxDQUFOO0FBQ0Q7O0FBRURtQixVQUFRLENBQUN2QixTQUFULEdBQXFCYyxNQUFNLENBQUNXLE1BQVAsQ0FBY0QsVUFBVSxJQUFJQSxVQUFVLENBQUN4QixTQUF2QyxFQUFrRDtBQUNyRUQsZUFBVyxFQUFFO0FBQ1hzQixXQUFLLEVBQUVFLFFBREk7QUFFWFYsY0FBUSxFQUFFLElBRkM7QUFHWEQsa0JBQVksRUFBRTtBQUhIO0FBRHdELEdBQWxELENBQXJCO0FBT0EsTUFBSVksVUFBSixFQUFnQkUsZUFBZSxDQUFDSCxRQUFELEVBQVdDLFVBQVgsQ0FBZjtBQUNqQjs7QUFFRCxTQUFTRyxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtBQUMxQkQsaUJBQWUsR0FBR2IsTUFBTSxDQUFDZSxjQUFQLEdBQXdCZixNQUFNLENBQUNnQixjQUEvQixHQUFnRCxTQUFTSCxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtBQUM1RixXQUFPQSxDQUFDLENBQUNHLFNBQUYsSUFBZWpCLE1BQU0sQ0FBQ2dCLGNBQVAsQ0FBc0JGLENBQXRCLENBQXRCO0FBQ0QsR0FGRDtBQUdBLFNBQU9ELGVBQWUsQ0FBQ0MsQ0FBRCxDQUF0QjtBQUNEOztBQUVELFNBQVNGLGVBQVQsQ0FBeUJFLENBQXpCLEVBQTRCSSxDQUE1QixFQUErQjtBQUM3Qk4saUJBQWUsR0FBR1osTUFBTSxDQUFDZSxjQUFQLElBQXlCLFNBQVNILGVBQVQsQ0FBeUJFLENBQXpCLEVBQTRCSSxDQUE1QixFQUErQjtBQUN4RUosS0FBQyxDQUFDRyxTQUFGLEdBQWNDLENBQWQ7QUFDQSxXQUFPSixDQUFQO0FBQ0QsR0FIRDs7QUFLQSxTQUFPRixlQUFlLENBQUNFLENBQUQsRUFBSUksQ0FBSixDQUF0QjtBQUNEOztBQUVELFNBQVNDLDZCQUFULENBQXVDQyxNQUF2QyxFQUErQ0MsUUFBL0MsRUFBeUQ7QUFDdkQsTUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0IsT0FBTyxFQUFQO0FBQ3BCLE1BQUk1QixNQUFNLEdBQUcsRUFBYjtBQUNBLE1BQUk4QixVQUFVLEdBQUd0QixNQUFNLENBQUN1QixJQUFQLENBQVlILE1BQVosQ0FBakI7QUFDQSxNQUFJbEIsR0FBSixFQUFTUixDQUFUOztBQUVBLE9BQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzRCLFVBQVUsQ0FBQzNCLE1BQTNCLEVBQW1DRCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDUSxPQUFHLEdBQUdvQixVQUFVLENBQUM1QixDQUFELENBQWhCO0FBQ0EsUUFBSTJCLFFBQVEsQ0FBQ0csT0FBVCxDQUFpQnRCLEdBQWpCLEtBQXlCLENBQTdCLEVBQWdDO0FBQ2hDVixVQUFNLENBQUNVLEdBQUQsQ0FBTixHQUFja0IsTUFBTSxDQUFDbEIsR0FBRCxDQUFwQjtBQUNEOztBQUVELFNBQU9WLE1BQVA7QUFDRDs7QUFFRCxTQUFTaUMsd0JBQVQsQ0FBa0NMLE1BQWxDLEVBQTBDQyxRQUExQyxFQUFvRDtBQUNsRCxNQUFJRCxNQUFNLElBQUksSUFBZCxFQUFvQixPQUFPLEVBQVA7O0FBRXBCLE1BQUk1QixNQUFNLEdBQUcyQiw2QkFBNkIsQ0FBQ0MsTUFBRCxFQUFTQyxRQUFULENBQTFDOztBQUVBLE1BQUluQixHQUFKLEVBQVNSLENBQVQ7O0FBRUEsTUFBSU0sTUFBTSxDQUFDMEIscUJBQVgsRUFBa0M7QUFDaEMsUUFBSUMsZ0JBQWdCLEdBQUczQixNQUFNLENBQUMwQixxQkFBUCxDQUE2Qk4sTUFBN0IsQ0FBdkI7O0FBRUEsU0FBSzFCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2lDLGdCQUFnQixDQUFDaEMsTUFBakMsRUFBeUNELENBQUMsRUFBMUMsRUFBOEM7QUFDNUNRLFNBQUcsR0FBR3lCLGdCQUFnQixDQUFDakMsQ0FBRCxDQUF0QjtBQUNBLFVBQUkyQixRQUFRLENBQUNHLE9BQVQsQ0FBaUJ0QixHQUFqQixLQUF5QixDQUE3QixFQUFnQztBQUNoQyxVQUFJLENBQUNGLE1BQU0sQ0FBQ2QsU0FBUCxDQUFpQjBDLG9CQUFqQixDQUFzQ0MsSUFBdEMsQ0FBMkNULE1BQTNDLEVBQW1EbEIsR0FBbkQsQ0FBTCxFQUE4RDtBQUM5RFYsWUFBTSxDQUFDVSxHQUFELENBQU4sR0FBY2tCLE1BQU0sQ0FBQ2xCLEdBQUQsQ0FBcEI7QUFDRDtBQUNGOztBQUVELFNBQU9WLE1BQVA7QUFDRDs7QUFFRCxTQUFTc0Msc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0FBQ3BDLE1BQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0FBQ25CLFVBQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUNEOztBQUVELFNBQU9ELElBQVA7QUFDRDs7QUFFRCxTQUFTRSwwQkFBVCxDQUFvQ0YsSUFBcEMsRUFBMENGLElBQTFDLEVBQWdEO0FBQzlDLE1BQUlBLElBQUksS0FBSyxPQUFPQSxJQUFQLEtBQWdCLFFBQWhCLElBQTRCLE9BQU9BLElBQVAsS0FBZ0IsVUFBakQsQ0FBUixFQUFzRTtBQUNwRSxXQUFPQSxJQUFQO0FBQ0Q7O0FBRUQsU0FBT0Msc0JBQXNCLENBQUNDLElBQUQsQ0FBN0I7QUFDRDs7QUFFRCxTQUFTRyxjQUFULENBQXdCQyxNQUF4QixFQUFnQ0MsUUFBaEMsRUFBMEM7QUFDeEMsU0FBTyxDQUFDcEMsTUFBTSxDQUFDZCxTQUFQLENBQWlCbUQsY0FBakIsQ0FBZ0NSLElBQWhDLENBQXFDTSxNQUFyQyxFQUE2Q0MsUUFBN0MsQ0FBUixFQUFnRTtBQUM5REQsVUFBTSxHQUFHdEIsZUFBZSxDQUFDc0IsTUFBRCxDQUF4QjtBQUNBLFFBQUlBLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ3RCOztBQUVELFNBQU9BLE1BQVA7QUFDRDs7QUFFRCxTQUFTRyxJQUFULENBQWM5QyxNQUFkLEVBQXNCNEMsUUFBdEIsRUFBZ0NHLFFBQWhDLEVBQTBDO0FBQ3hDLE1BQUksT0FBT0MsT0FBUCxLQUFtQixXQUFuQixJQUFrQ0EsT0FBTyxDQUFDQyxHQUE5QyxFQUFtRDtBQUNqREgsUUFBSSxHQUFHRSxPQUFPLENBQUNDLEdBQWY7QUFDRCxHQUZELE1BRU87QUFDTEgsUUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBYzlDLE1BQWQsRUFBc0I0QyxRQUF0QixFQUFnQ0csUUFBaEMsRUFBMEM7QUFDL0MsVUFBSUcsSUFBSSxHQUFHUixjQUFjLENBQUMxQyxNQUFELEVBQVM0QyxRQUFULENBQXpCOztBQUVBLFVBQUksQ0FBQ00sSUFBTCxFQUFXO0FBQ1gsVUFBSUMsSUFBSSxHQUFHM0MsTUFBTSxDQUFDNEMsd0JBQVAsQ0FBZ0NGLElBQWhDLEVBQXNDTixRQUF0QyxDQUFYOztBQUVBLFVBQUlPLElBQUksQ0FBQ0YsR0FBVCxFQUFjO0FBQ1osZUFBT0UsSUFBSSxDQUFDRixHQUFMLENBQVNaLElBQVQsQ0FBY1UsUUFBZCxDQUFQO0FBQ0Q7O0FBRUQsYUFBT0ksSUFBSSxDQUFDcEMsS0FBWjtBQUNELEtBWEQ7QUFZRDs7QUFFRCxTQUFPK0IsSUFBSSxDQUFDOUMsTUFBRCxFQUFTNEMsUUFBVCxFQUFtQkcsUUFBUSxJQUFJL0MsTUFBL0IsQ0FBWDtBQUNEOztBQUVELFNBQVNxRCxzQ0FBVCxDQUFhckQsTUFBYixFQUFxQjRDLFFBQXJCLEVBQStCN0IsS0FBL0IsRUFBc0NnQyxRQUF0QyxFQUFnRDtBQUM5QyxNQUFJLE9BQU9DLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLE9BQU8sQ0FBQ0ssR0FBOUMsRUFBbUQ7QUFDakRBLDBDQUFHLEdBQUdMLE9BQU8sQ0FBQ0ssR0FBZDtBQUNELEdBRkQsTUFFTztBQUNMQSwwQ0FBRyxHQUFHLFNBQVNBLEdBQVQsQ0FBYXJELE1BQWIsRUFBcUI0QyxRQUFyQixFQUErQjdCLEtBQS9CLEVBQXNDZ0MsUUFBdEMsRUFBZ0Q7QUFDcEQsVUFBSUcsSUFBSSxHQUFHUixjQUFjLENBQUMxQyxNQUFELEVBQVM0QyxRQUFULENBQXpCOztBQUVBLFVBQUlPLElBQUo7O0FBRUEsVUFBSUQsSUFBSixFQUFVO0FBQ1JDLFlBQUksR0FBRzNDLE1BQU0sQ0FBQzRDLHdCQUFQLENBQWdDRixJQUFoQyxFQUFzQ04sUUFBdEMsQ0FBUDs7QUFFQSxZQUFJTyxJQUFJLENBQUNFLEdBQVQsRUFBYztBQUNaRixjQUFJLENBQUNFLEdBQUwsQ0FBU2hCLElBQVQsQ0FBY1UsUUFBZCxFQUF3QmhDLEtBQXhCO0FBQ0EsaUJBQU8sSUFBUDtBQUNELFNBSEQsTUFHTyxJQUFJLENBQUNvQyxJQUFJLENBQUM1QyxRQUFWLEVBQW9CO0FBQ3pCLGlCQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVENEMsVUFBSSxHQUFHM0MsTUFBTSxDQUFDNEMsd0JBQVAsQ0FBZ0NMLFFBQWhDLEVBQTBDSCxRQUExQyxDQUFQOztBQUVBLFVBQUlPLElBQUosRUFBVTtBQUNSLFlBQUksQ0FBQ0EsSUFBSSxDQUFDNUMsUUFBVixFQUFvQjtBQUNsQixpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQ0QyxZQUFJLENBQUNwQyxLQUFMLEdBQWFBLEtBQWI7QUFDQVAsY0FBTSxDQUFDQyxjQUFQLENBQXNCc0MsUUFBdEIsRUFBZ0NILFFBQWhDLEVBQTBDTyxJQUExQztBQUNELE9BUEQsTUFPTztBQUNMckMsdUJBQWUsQ0FBQ2lDLFFBQUQsRUFBV0gsUUFBWCxFQUFxQjdCLEtBQXJCLENBQWY7QUFDRDs7QUFFRCxhQUFPLElBQVA7QUFDRCxLQTlCRDtBQStCRDs7QUFFRCxTQUFPc0Msc0NBQUcsQ0FBQ3JELE1BQUQsRUFBUzRDLFFBQVQsRUFBbUI3QixLQUFuQixFQUEwQmdDLFFBQTFCLENBQVY7QUFDRDs7QUFFRCxTQUFTTyxJQUFULENBQWN0RCxNQUFkLEVBQXNCNEMsUUFBdEIsRUFBZ0M3QixLQUFoQyxFQUF1Q2dDLFFBQXZDLEVBQWlEUSxRQUFqRCxFQUEyRDtBQUN6RCxNQUFJQyxDQUFDLEdBQUdILHNDQUFHLENBQUNyRCxNQUFELEVBQVM0QyxRQUFULEVBQW1CN0IsS0FBbkIsRUFBMEJnQyxRQUFRLElBQUkvQyxNQUF0QyxDQUFYOztBQUVBLE1BQUksQ0FBQ3dELENBQUQsSUFBTUQsUUFBVixFQUFvQjtBQUNsQixVQUFNLElBQUlFLEtBQUosQ0FBVSx3QkFBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBTzFDLEtBQVA7QUFDRDs7QUFFRCxTQUFTMkMsY0FBVCxDQUF3QkMsR0FBeEIsRUFBNkJ6RCxDQUE3QixFQUFnQztBQUM5QixTQUFPMEQsZUFBZSxDQUFDRCxHQUFELENBQWYsSUFBd0JFLHFCQUFxQixDQUFDRixHQUFELEVBQU16RCxDQUFOLENBQTdDLElBQXlENEQsZ0JBQWdCLEVBQWhGO0FBQ0Q7O0FBRUQsU0FBU0YsZUFBVCxDQUF5QkQsR0FBekIsRUFBOEI7QUFDNUIsTUFBSUksS0FBSyxDQUFDQyxPQUFOLENBQWNMLEdBQWQsQ0FBSixFQUF3QixPQUFPQSxHQUFQO0FBQ3pCOztBQUVELFNBQVNFLHFCQUFULENBQStCRixHQUEvQixFQUFvQ3pELENBQXBDLEVBQXVDO0FBQ3JDLE1BQUksRUFBRVgsTUFBTSxDQUFDQyxRQUFQLElBQW1CZ0IsTUFBTSxDQUFDbUQsR0FBRCxDQUF6QixJQUFrQ25ELE1BQU0sQ0FBQ2QsU0FBUCxDQUFpQnVFLFFBQWpCLENBQTBCNUIsSUFBMUIsQ0FBK0JzQixHQUEvQixNQUF3QyxvQkFBNUUsQ0FBSixFQUF1RztBQUNyRztBQUNEOztBQUVELE1BQUlPLElBQUksR0FBRyxFQUFYO0FBQ0EsTUFBSUMsRUFBRSxHQUFHLElBQVQ7QUFDQSxNQUFJQyxFQUFFLEdBQUcsS0FBVDtBQUNBLE1BQUlDLEVBQUUsR0FBR0MsU0FBVDs7QUFFQSxNQUFJO0FBQ0YsU0FBSyxJQUFJQyxFQUFFLEdBQUdaLEdBQUcsQ0FBQ3BFLE1BQU0sQ0FBQ0MsUUFBUixDQUFILEVBQVQsRUFBaUNnRixFQUF0QyxFQUEwQyxFQUFFTCxFQUFFLEdBQUcsQ0FBQ0ssRUFBRSxHQUFHRCxFQUFFLENBQUNFLElBQUgsRUFBTixFQUFpQkMsSUFBeEIsQ0FBMUMsRUFBeUVQLEVBQUUsR0FBRyxJQUE5RSxFQUFvRjtBQUNsRkQsVUFBSSxDQUFDUyxJQUFMLENBQVVILEVBQUUsQ0FBQ3pELEtBQWI7O0FBRUEsVUFBSWIsQ0FBQyxJQUFJZ0UsSUFBSSxDQUFDL0QsTUFBTCxLQUFnQkQsQ0FBekIsRUFBNEI7QUFDN0I7QUFDRixHQU5ELENBTUUsT0FBTzBFLEdBQVAsRUFBWTtBQUNaUixNQUFFLEdBQUcsSUFBTDtBQUNBQyxNQUFFLEdBQUdPLEdBQUw7QUFDRCxHQVRELFNBU1U7QUFDUixRQUFJO0FBQ0YsVUFBSSxDQUFDVCxFQUFELElBQU9JLEVBQUUsQ0FBQyxRQUFELENBQUYsSUFBZ0IsSUFBM0IsRUFBaUNBLEVBQUUsQ0FBQyxRQUFELENBQUY7QUFDbEMsS0FGRCxTQUVVO0FBQ1IsVUFBSUgsRUFBSixFQUFRLE1BQU1DLEVBQU47QUFDVDtBQUNGOztBQUVELFNBQU9ILElBQVA7QUFDRDs7QUFFRCxTQUFTSixnQkFBVCxHQUE0QjtBQUMxQixRQUFNLElBQUloRSxTQUFKLENBQWMsc0RBQWQsQ0FBTjtBQUNEOzs7O0FDaFFEO0FBRUE7O0FBQ0EsU0FBUytFLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3JCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLEdBQUcsWUFBWUMsTUFBakQ7QUFDRDtBQUNEOzs7Ozs7Ozs7O0FBU0EsSUFBSUMsU0FBUyxHQUFHO0FBQ2RDLE1BQUksRUFBRSxNQURRO0FBRWRDLE1BQUksRUFBRSxNQUZRO0FBR2RDLFlBQVUsRUFBRSxZQUhFO0FBSWRDLE9BQUssRUFBRSxPQUpPO0FBS2RDLGFBQVcsRUFBRTtBQUxDLENBQWhCO0FBT0E7Ozs7O0FBS0E7O0FBQ0EsU0FBU0MsZ0JBQVQsQ0FBMEJDLEdBQTFCLEVBQStCQyxTQUEvQixFQUEwQztBQUN4QyxNQUFJQSxTQUFTLEtBQUtSLFNBQVMsQ0FBQ0UsSUFBNUIsRUFBa0MsRUFBRUssR0FBRjtBQUNsQyxTQUFPQSxHQUFQO0FBQ0Q7QUFDRDs7O0FBRUEsU0FBU0UsY0FBVCxDQUF3QkYsR0FBeEIsRUFBNkJDLFNBQTdCLEVBQXdDO0FBQ3RDLFVBQVFBLFNBQVI7QUFDRSxTQUFLUixTQUFTLENBQUNFLElBQWY7QUFDQSxTQUFLRixTQUFTLENBQUNHLFVBQWY7QUFDRSxhQUFPLEVBQUVJLEdBQVQ7O0FBRUYsU0FBS1AsU0FBUyxDQUFDSSxLQUFmO0FBQ0EsU0FBS0osU0FBUyxDQUFDSyxXQUFmO0FBQ0UsYUFBTyxFQUFFRSxHQUFUOztBQUVGO0FBQ0UsYUFBT0EsR0FBUDtBQVZKO0FBWUQ7QUFDRDs7O0FBRUEsU0FBU0csY0FBVCxDQUF3QkYsU0FBeEIsRUFBbUM7QUFDakMsVUFBUUEsU0FBUjtBQUNFLFNBQUtSLFNBQVMsQ0FBQ0UsSUFBZjtBQUNFLGFBQU9GLFNBQVMsQ0FBQ0csVUFBakI7O0FBRUYsU0FBS0gsU0FBUyxDQUFDSSxLQUFmO0FBQ0UsYUFBT0osU0FBUyxDQUFDSyxXQUFqQjs7QUFFRjtBQUNFLGFBQU9HLFNBQVA7QUFSSjtBQVVEO0FBQ0Q7OztBQUVBLFNBQVNHLFlBQVQsQ0FBc0JiLEdBQXRCLEVBQTJCO0FBQ3pCLFNBQU9BLEdBQUcsQ0FBQ2MsT0FBSixDQUFZLDJCQUFaLEVBQXlDLE1BQXpDLENBQVA7QUFDRCxDLENBQUM7OztBQUVGLFNBQVNDLGNBQVQsQ0FBd0JDLENBQXhCLEVBQTJCQyxDQUEzQixFQUE4QjtBQUM1QixNQUFJQSxDQUFDLEtBQUtELENBQVYsRUFBYSxPQUFPLElBQVA7QUFDYixNQUFJRSxJQUFJLEdBQUdqQyxLQUFLLENBQUNDLE9BQU4sQ0FBYytCLENBQWQsQ0FBWDtBQUFBLE1BQ0lFLElBQUksR0FBR2xDLEtBQUssQ0FBQ0MsT0FBTixDQUFjOEIsQ0FBZCxDQURYO0FBQUEsTUFFSTVGLENBRko7O0FBSUEsTUFBSThGLElBQUksSUFBSUMsSUFBWixFQUFrQjtBQUNoQixRQUFJRixDQUFDLENBQUM1RixNQUFGLElBQVkyRixDQUFDLENBQUMzRixNQUFsQixFQUEwQixPQUFPLEtBQVA7O0FBRTFCLFNBQUtELENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzZGLENBQUMsQ0FBQzVGLE1BQWxCLEVBQTBCRCxDQUFDLEVBQTNCLEVBQStCO0FBQzdCLFVBQUksQ0FBQzJGLGNBQWMsQ0FBQ0UsQ0FBQyxDQUFDN0YsQ0FBRCxDQUFGLEVBQU80RixDQUFDLENBQUM1RixDQUFELENBQVIsQ0FBbkIsRUFBaUMsT0FBTyxLQUFQO0FBQ2xDOztBQUVELFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUk4RixJQUFJLElBQUlDLElBQVosRUFBa0IsT0FBTyxLQUFQOztBQUVsQixNQUFJRixDQUFDLElBQUlELENBQUwsSUFBVXpHLE9BQU8sQ0FBQzBHLENBQUQsQ0FBUCxLQUFlLFFBQXpCLElBQXFDMUcsT0FBTyxDQUFDeUcsQ0FBRCxDQUFQLEtBQWUsUUFBeEQsRUFBa0U7QUFDaEUsUUFBSUksS0FBSyxHQUFHSCxDQUFDLFlBQVlJLElBQXpCO0FBQUEsUUFDSUMsS0FBSyxHQUFHTixDQUFDLFlBQVlLLElBRHpCO0FBRUEsUUFBSUQsS0FBSyxJQUFJRSxLQUFiLEVBQW9CLE9BQU9MLENBQUMsQ0FBQ00sT0FBRixNQUFlUCxDQUFDLENBQUNPLE9BQUYsRUFBdEI7QUFDcEIsUUFBSUgsS0FBSyxJQUFJRSxLQUFiLEVBQW9CLE9BQU8sS0FBUDtBQUNwQixRQUFJRSxPQUFPLEdBQUdQLENBQUMsWUFBWVEsTUFBM0I7QUFBQSxRQUNJQyxPQUFPLEdBQUdWLENBQUMsWUFBWVMsTUFEM0I7QUFFQSxRQUFJRCxPQUFPLElBQUlFLE9BQWYsRUFBd0IsT0FBT1QsQ0FBQyxDQUFDOUIsUUFBRixNQUFnQjZCLENBQUMsQ0FBQzdCLFFBQUYsRUFBdkI7QUFDeEIsUUFBSXFDLE9BQU8sSUFBSUUsT0FBZixFQUF3QixPQUFPLEtBQVA7QUFDeEIsUUFBSXpFLElBQUksR0FBR3ZCLE1BQU0sQ0FBQ3VCLElBQVAsQ0FBWWdFLENBQVosQ0FBWCxDQVRnRSxDQVNyQzs7QUFFM0IsU0FBSzdGLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzZCLElBQUksQ0FBQzVCLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQ2hDLFVBQUksQ0FBQ00sTUFBTSxDQUFDZCxTQUFQLENBQWlCbUQsY0FBakIsQ0FBZ0NSLElBQWhDLENBQXFDeUQsQ0FBckMsRUFBd0MvRCxJQUFJLENBQUM3QixDQUFELENBQTVDLENBQUwsRUFBdUQsT0FBTyxLQUFQO0FBQ3hEOztBQUVELFNBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzZCLElBQUksQ0FBQzVCLE1BQXJCLEVBQTZCRCxDQUFDLEVBQTlCLEVBQWtDO0FBQ2hDLFVBQUksQ0FBQzJGLGNBQWMsQ0FBQ0MsQ0FBQyxDQUFDL0QsSUFBSSxDQUFDN0IsQ0FBRCxDQUFMLENBQUYsRUFBYTZGLENBQUMsQ0FBQ2hFLElBQUksQ0FBQzdCLENBQUQsQ0FBTCxDQUFkLENBQW5CLEVBQTZDLE9BQU8sS0FBUDtBQUM5Qzs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQXBCRCxNQW9CTyxJQUFJNkYsQ0FBQyxJQUFJRCxDQUFMLElBQVUsT0FBT0MsQ0FBUCxLQUFhLFVBQXZCLElBQXFDLE9BQU9ELENBQVAsS0FBYSxVQUF0RCxFQUFrRTtBQUN2RSxXQUFPQyxDQUFDLENBQUM5QixRQUFGLE9BQWlCNkIsQ0FBQyxDQUFDN0IsUUFBRixFQUF4QjtBQUNEOztBQUVELFNBQU8sS0FBUDtBQUNEO0FBQ0Q7Ozs7O0FDaEhBO0FBQ0E7QUFFQTs7QUFFQSxJQUFJd0MsNEJBQWEsR0FDakIsYUFDQSxZQUFZO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxXQUFTQSxhQUFULENBQXVCMUYsS0FBdkIsRUFBOEIyRixTQUE5QixFQUF5Q0MsUUFBekMsRUFBbURDLFlBQW5ELEVBQWlFO0FBQy9EakgsbUJBQWUsQ0FBQyxJQUFELEVBQU84RyxhQUFQLENBQWY7O0FBRUEsU0FBSzFGLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUsyRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQkEsWUFBcEIsQ0FOK0QsQ0FNN0I7O0FBRWxDLFdBQU8sS0FBSzdGLEtBQUwsQ0FBVzhGLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0IsS0FBS0MsY0FBekIsTUFBNkMsS0FBS0gsUUFBTCxDQUFjRSxLQUFkLENBQW9CLENBQXBCLEVBQXVCLEtBQUtDLGNBQTVCLENBQXBELEVBQWlHO0FBQy9GLFFBQUUsS0FBS0YsWUFBTCxDQUFrQkcsS0FBcEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQU1BcEcsY0FBWSxDQUFDOEYsYUFBRCxFQUFnQixDQUFDO0FBQzNCL0YsT0FBRyxFQUFFLGdCQURzQjtBQUUzQnVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTytELElBQUksQ0FBQ0MsR0FBTCxDQUFTLEtBQUtQLFNBQWQsRUFBeUIsS0FBS0UsWUFBTCxDQUFrQkcsS0FBM0MsQ0FBUDtBQUNEO0FBQ0Q7Ozs7O0FBTDJCLEdBQUQsRUFVekI7QUFDRHJHLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS3lELFNBQUwsR0FBaUIsS0FBS0ksY0FBN0I7QUFDRDtBQUNEOzs7OztBQUxDLEdBVnlCLEVBb0J6QjtBQUNEcEcsT0FBRyxFQUFFLFVBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLbEMsS0FBTCxDQUFXbUcsTUFBWCxDQUFrQixLQUFLSixjQUF2QixFQUF1QyxLQUFLSyxhQUE1QyxDQUFQO0FBQ0Q7QUFDRDs7Ozs7QUFMQyxHQXBCeUIsRUE4QnpCO0FBQ0R6RyxPQUFHLEVBQUUsY0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQjtBQUNBLGFBQU8rRCxJQUFJLENBQUNJLEdBQUwsQ0FBUyxLQUFLUixZQUFMLENBQWtCUyxHQUFsQixHQUF3QixLQUFLUCxjQUE3QixJQUErQztBQUMvRCxXQUFLSCxRQUFMLENBQWN4RyxNQUFkLEdBQXVCLEtBQUtZLEtBQUwsQ0FBV1osTUFEM0IsRUFDbUMsQ0FEbkMsQ0FBUDtBQUVEO0FBQ0Q7Ozs7O0FBUEMsR0E5QnlCLEVBMEN6QjtBQUNETyxPQUFHLEVBQUUsU0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUswRCxRQUFMLENBQWNPLE1BQWQsQ0FBcUIsS0FBS0osY0FBMUIsRUFBMEMsS0FBS1EsWUFBL0MsQ0FBUDtBQUNEO0FBQ0Q7Ozs7O0FBTEMsR0ExQ3lCLEVBb0R6QjtBQUNENUcsT0FBRyxFQUFFLE1BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLbEMsS0FBTCxDQUFXd0csU0FBWCxDQUFxQixDQUFyQixFQUF3QixLQUFLVCxjQUE3QixDQUFQO0FBQ0Q7QUFDRDs7Ozs7QUFMQyxHQXBEeUIsRUE4RHpCO0FBQ0RwRyxPQUFHLEVBQUUsTUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtsQyxLQUFMLENBQVd3RyxTQUFYLENBQXFCLEtBQUtULGNBQUwsR0FBc0IsS0FBS0ssYUFBaEQsQ0FBUDtBQUNEO0FBQ0Q7Ozs7O0FBTEMsR0E5RHlCLEVBd0V6QjtBQUNEekcsT0FBRyxFQUFFLGlCQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFVBQUksQ0FBQyxLQUFLcUUsWUFBTixJQUFzQixLQUFLSCxhQUEvQixFQUE4QyxPQUFPbkMsU0FBUyxDQUFDQyxJQUFqQixDQUQ1QixDQUNtRDs7QUFFckUsYUFBTyxLQUFLMkIsWUFBTCxDQUFrQlMsR0FBbEIsS0FBMEIsS0FBS1gsU0FBL0IsSUFBNEMsS0FBS0UsWUFBTCxDQUFrQkcsS0FBbEIsS0FBNEIsS0FBS0wsU0FBN0UsR0FBeUYxQixTQUFTLENBQUNJLEtBQW5HLEdBQTJHSixTQUFTLENBQUNFLElBQTVIO0FBQ0Q7QUFOQSxHQXhFeUIsQ0FBaEIsQ0FBWjs7QUFpRkEsU0FBT3VCLGFBQVA7QUFDRCxDQTVHRCxFQUZBOztBQWdIZUEsK0VBQWYsRTs7QUNySEE7QUFFQTs7Ozs7Ozs7O0FBUUEsSUFBSWUsNEJBQWEsR0FDakIsYUFDQSxZQUFZO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxXQUFTQSxhQUFULENBQXVCQyxPQUF2QixFQUFnQztBQUM5QjlILG1CQUFlLENBQUMsSUFBRCxFQUFPNkgsYUFBUCxDQUFmOztBQUVBaEgsVUFBTSxDQUFDa0gsTUFBUCxDQUFjLElBQWQsRUFBb0I7QUFDbEJDLGNBQVEsRUFBRSxFQURRO0FBRWxCQyxpQkFBVyxFQUFFLEVBRks7QUFHbEJDLFVBQUksRUFBRSxLQUhZO0FBSWxCQyxlQUFTLEVBQUU7QUFKTyxLQUFwQixFQUtHTCxPQUxIO0FBTUQ7QUFDRDs7Ozs7O0FBTUE5RyxjQUFZLENBQUM2RyxhQUFELEVBQWdCLENBQUM7QUFDM0I5RyxPQUFHLEVBQUUsV0FEc0I7QUFFM0JLLFNBQUssRUFBRSxTQUFTZ0gsU0FBVCxDQUFtQk4sT0FBbkIsRUFBNEI7QUFDakMsV0FBS0csV0FBTCxJQUFvQkgsT0FBTyxDQUFDRyxXQUE1QjtBQUNBLFdBQUtDLElBQUwsR0FBWSxLQUFLQSxJQUFMLElBQWFKLE9BQU8sQ0FBQ0ksSUFBakM7QUFDQSxXQUFLRixRQUFMLElBQWlCRixPQUFPLENBQUNFLFFBQXpCO0FBQ0EsV0FBS0csU0FBTCxJQUFrQkwsT0FBTyxDQUFDSyxTQUExQjtBQUNBLGFBQU8sSUFBUDtBQUNEO0FBQ0Q7O0FBVDJCLEdBQUQsRUFXekI7QUFDRHBILE9BQUcsRUFBRSxRQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBSzZFLFNBQUwsR0FBaUIsS0FBS0gsUUFBTCxDQUFjeEgsTUFBdEM7QUFDRDtBQUpBLEdBWHlCLENBQWhCLENBQVo7O0FBa0JBLFNBQU9xSCxhQUFQO0FBQ0QsQ0EzQ0QsRUFGQTs7QUErQ2VBLCtFQUFmLEU7O0FDekRBO0FBRUE7O0FBQ0EsSUFBSVEsNkNBQXFCLEdBQ3pCLGFBQ0EsWUFBWTtBQUNWOztBQUVBOztBQUVBO0FBQ0EsV0FBU0EscUJBQVQsR0FBaUM7QUFDL0IsUUFBSWpILEtBQUssR0FBR2tILFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLFFBQUlDLElBQUksR0FBR0QsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLENBQS9FO0FBQ0EsUUFBSUUsSUFBSSxHQUFHRixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCOEgsU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0MzRCxTQUFqRDs7QUFFQTNFLG1CQUFlLENBQUMsSUFBRCxFQUFPcUkscUJBQVAsQ0FBZjs7QUFFQSxTQUFLakgsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS21ILElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtDLElBQUwsR0FBWUEsSUFBWjtBQUNEOztBQUVEeEgsY0FBWSxDQUFDcUgscUJBQUQsRUFBd0IsQ0FBQztBQUNuQ3RILE9BQUcsRUFBRSxVQUQ4QjtBQUVuQ0ssU0FBSyxFQUFFLFNBQVNrRCxRQUFULEdBQW9CO0FBQ3pCLGFBQU8sS0FBS2xELEtBQVo7QUFDRDtBQUprQyxHQUFELEVBS2pDO0FBQ0RMLE9BQUcsRUFBRSxRQURKO0FBRURLLFNBQUssRUFBRSxTQUFTcUgsTUFBVCxDQUFnQkMsSUFBaEIsRUFBc0I7QUFDM0IsV0FBS3RILEtBQUwsSUFBY2dFLE1BQU0sQ0FBQ3NELElBQUQsQ0FBcEI7QUFDRDtBQUpBLEdBTGlDLEVBVWpDO0FBQ0QzSCxPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3VILFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCO0FBQy9CLGFBQU9BLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEtBQUt2RSxRQUFMLEVBQWQsRUFBK0I7QUFDcENvRSxZQUFJLEVBQUU7QUFEOEIsT0FBL0IsRUFFSk4sU0FGSSxDQUVNUSxNQUFNLENBQUNFLGtCQUFQLEVBRk4sQ0FBUDtBQUdEO0FBTkEsR0FWaUMsRUFpQmpDO0FBQ0QvSCxPQUFHLEVBQUUsYUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzJILFdBQVQsQ0FBcUJuRCxHQUFyQixFQUEwQjtBQUMvQixVQUFJLEtBQUsyQyxJQUFMLElBQWEzQyxHQUFiLElBQW9CLENBQUMsS0FBS3hFLEtBQUwsQ0FBV1osTUFBcEMsRUFBNEMsT0FBTyxFQUFQO0FBQzVDLFVBQUl3SSxTQUFTLEdBQUcsS0FBSzVILEtBQUwsQ0FBVyxDQUFYLENBQWhCO0FBQ0EsV0FBS0EsS0FBTCxHQUFhLEtBQUtBLEtBQUwsQ0FBVzhGLEtBQVgsQ0FBaUIsQ0FBakIsQ0FBYjtBQUNBLGFBQU84QixTQUFQO0FBQ0Q7QUFQQSxHQWpCaUMsRUF5QmpDO0FBQ0RqSSxPQUFHLEVBQUUsT0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPO0FBQ0xsQyxhQUFLLEVBQUUsS0FBS0EsS0FEUDtBQUVMbUgsWUFBSSxFQUFFLEtBQUtBLElBRk47QUFHTEMsWUFBSSxFQUFFLEtBQUtBO0FBSE4sT0FBUDtBQUtELEtBUkE7QUFTRDlFLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF1RixLQUFiLEVBQW9CO0FBQ3ZCcEksWUFBTSxDQUFDa0gsTUFBUCxDQUFjLElBQWQsRUFBb0JrQixLQUFwQjtBQUNEO0FBWEEsR0F6QmlDLENBQXhCLENBQVo7O0FBdUNBLFNBQU9aLHFCQUFQO0FBQ0QsQ0ExREQsRUFGQTs7QUE4RGVBLHlHQUFmLEU7O0FDakVBOzs7Ozs7O0FBT0EsU0FBU2EsS0FBVCxDQUFlQyxFQUFmLEVBQW1CO0FBQ2pCLE1BQUlDLElBQUksR0FBR2QsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQS9FLENBRGlCLENBRWpCOztBQUNBLFNBQU8sSUFBSVksS0FBSyxDQUFDRyxTQUFWLENBQW9CRixFQUFwQixFQUF3QkMsSUFBeEIsQ0FBUDtBQUNEOztBQUVjRixnREFBZixFOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFDQSxJQUFJSSxXQUFNLEdBQ1YsYUFDQSxZQUFZO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVNBLE1BQVQsQ0FBZ0JGLElBQWhCLEVBQXNCO0FBQ3BCcEosbUJBQWUsQ0FBQyxJQUFELEVBQU9zSixNQUFQLENBQWY7O0FBRUEsU0FBS0MsTUFBTCxHQUFjLEVBQWQ7O0FBRUEsU0FBS0MsT0FBTCxDQUFhM0ksTUFBTSxDQUFDa0gsTUFBUCxDQUFjLEVBQWQsRUFBa0J1QixNQUFNLENBQUNHLFFBQXpCLEVBQW1DLEVBQW5DLEVBQXVDTCxJQUF2QyxDQUFiOztBQUVBLFNBQUtNLGFBQUwsR0FBcUIsSUFBckI7QUFDRDtBQUNEOzs7QUFHQTFJLGNBQVksQ0FBQ3NJLE1BQUQsRUFBUyxDQUFDO0FBQ3BCdkksT0FBRyxFQUFFLGVBRGU7QUFFcEJLLFNBQUssRUFBRSxTQUFTdUksYUFBVCxDQUF1QlAsSUFBdkIsRUFBNkI7QUFDbEMsVUFBSSxDQUFDdkksTUFBTSxDQUFDdUIsSUFBUCxDQUFZZ0gsSUFBWixFQUFrQjVJLE1BQXZCLEVBQStCO0FBQy9CLFdBQUtvSixnQkFBTCxDQUFzQixLQUFLSixPQUFMLENBQWFLLElBQWIsQ0FBa0IsSUFBbEIsRUFBd0JULElBQXhCLENBQXRCO0FBQ0Q7QUFDRDs7Ozs7QUFOb0IsR0FBRCxFQVdsQjtBQUNEckksT0FBRyxFQUFFLFNBREo7QUFFREssU0FBSyxFQUFFLFNBQVNvSSxPQUFULENBQWlCSixJQUFqQixFQUF1QjtBQUM1QnZJLFlBQU0sQ0FBQ2tILE1BQVAsQ0FBYyxJQUFkLEVBQW9CcUIsSUFBcEI7QUFDRDtBQUNEOztBQUxDLEdBWGtCLEVBa0JsQjtBQUNEckksT0FBRyxFQUFFLE9BREo7O0FBR0Q7QUFDQUssU0FBSyxFQUFFLFNBQVMwSSxLQUFULEdBQWlCO0FBQ3RCLFdBQUtQLE1BQUwsR0FBYyxFQUFkO0FBQ0Q7QUFDRDs7QUFQQyxHQWxCa0IsRUEyQmxCO0FBQ0R4SSxPQUFHLEVBQUUsU0FESjs7QUFHRDtBQUNBSyxTQUFLLEVBQUUsU0FBUzJJLE9BQVQsQ0FBaUIzSSxLQUFqQixFQUF3QjtBQUM3QixXQUFLMEksS0FBTDtBQUNBLFdBQUtqQixNQUFMLENBQVl6SCxLQUFaLEVBQW1CO0FBQ2pCNEksYUFBSyxFQUFFO0FBRFUsT0FBbkIsRUFFRyxFQUZIO0FBR0EsV0FBS0MsUUFBTDtBQUNBLGFBQU8sS0FBSzdJLEtBQVo7QUFDRDtBQUNEOztBQVpDLEdBM0JrQixFQXlDbEI7QUFDREwsT0FBRyxFQUFFLGlCQURKOztBQUdEO0FBQ0FLLFNBQUssRUFBRSxTQUFTOEksZUFBVCxDQUF5Qm5ELFNBQXpCLEVBQW9DbEIsU0FBcEMsRUFBK0M7QUFDcEQsYUFBT2tCLFNBQVA7QUFDRDtBQUNEOztBQVBDLEdBekNrQixFQWtEbEI7QUFDRGhHLE9BQUcsRUFBRSxjQURKO0FBRURLLFNBQUssRUFBRSxTQUFTK0ksWUFBVCxHQUF3QjtBQUM3QixVQUFJQyxPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGO0FBQ0EsYUFBTyxLQUFLWSxLQUFMLENBQVc4RixLQUFYLENBQWlCa0QsT0FBakIsRUFBMEJDLEtBQTFCLENBQVA7QUFDRDtBQUNEOztBQVBDLEdBbERrQixFQTJEbEI7QUFDRHRKLE9BQUcsRUFBRSxhQURKO0FBRURLLFNBQUssRUFBRSxTQUFTa0osV0FBVCxHQUF1QjtBQUM1QixVQUFJRixPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGO0FBQ0EsYUFBTyxJQUFJNkgsdUJBQUosQ0FBMEIsS0FBSzhCLFlBQUwsQ0FBa0JDLE9BQWxCLEVBQTJCQyxLQUEzQixDQUExQixFQUE2REQsT0FBN0QsQ0FBUDtBQUNEO0FBQ0Q7QUFDQTs7QUFSQyxHQTNEa0IsRUFxRWxCO0FBQ0RySixPQUFHLEVBQUUsWUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU21KLFVBQVQsQ0FBb0I3QixJQUFwQixFQUEwQjtBQUMvQixVQUFJeEQsUUFBUSxDQUFDd0QsSUFBRCxDQUFaLEVBQW9CQSxJQUFJLEdBQUcsSUFBSUwsdUJBQUosQ0FBMEJqRCxNQUFNLENBQUNzRCxJQUFELENBQWhDLENBQVA7QUFDcEIsYUFBT0EsSUFBSSxDQUFDQyxRQUFMLENBQWMsSUFBZCxDQUFQO0FBQ0Q7QUFDRDs7QUFOQyxHQXJFa0IsRUE2RWxCO0FBQ0Q1SCxPQUFHLEVBQUUsZ0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVNvSixjQUFULENBQXdCQyxFQUF4QixFQUE0QjtBQUNqQyxVQUFJQyxLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQW1DLFFBQUUsR0FBRyxLQUFLRSxTQUFMLENBQWVGLEVBQWYsRUFBbUJDLEtBQW5CLENBQUw7QUFDQSxVQUFJLENBQUNELEVBQUwsRUFBUyxPQUFPLElBQUk1QyxjQUFKLEVBQVA7QUFDVCxXQUFLMEIsTUFBTCxJQUFla0IsRUFBZjtBQUNBLGFBQU8sSUFBSTVDLGNBQUosQ0FBa0I7QUFDdkJHLGdCQUFRLEVBQUV5QyxFQURhO0FBRXZCeEMsbUJBQVcsRUFBRXdDO0FBRlUsT0FBbEIsQ0FBUDtBQUlEO0FBQ0Q7O0FBWkMsR0E3RWtCLEVBMkZsQjtBQUNEMUosT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVN3SixXQUFULENBQXFCSCxFQUFyQixFQUF5QjtBQUM5QixVQUFJQyxLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQSxVQUFJdUMsU0FBUyxHQUFHdkMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixHQUF1QjhILFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDM0QsU0FBdEQ7QUFDQSxVQUFJbUcsZUFBZSxHQUFHLEtBQUs3QixLQUEzQjs7QUFFQSxVQUFJbkIsT0FBTyxHQUFHLEtBQUswQyxjQUFMLENBQW9CQyxFQUFwQixFQUF3QkMsS0FBeEIsQ0FBZDs7QUFFQSxVQUFJNUMsT0FBTyxDQUFDRSxRQUFaLEVBQXNCO0FBQ3BCLFlBQUkrQyxjQUFKO0FBQ0EsWUFBSUMsUUFBUSxHQUFHLEtBQUtDLFVBQUwsQ0FBZ0JQLEtBQWhCLE1BQTJCLEtBQTFDOztBQUVBLFlBQUlNLFFBQVEsSUFBSUgsU0FBUyxJQUFJLElBQTdCLEVBQW1DO0FBQ2pDO0FBQ0EsY0FBSUssZUFBZSxHQUFHLEtBQUtqQyxLQUEzQjs7QUFFQSxjQUFJLEtBQUtrQyxTQUFULEVBQW9CO0FBQ2xCSiwwQkFBYyxHQUFHRixTQUFTLENBQUM1QixLQUEzQjtBQUNBNEIscUJBQVMsQ0FBQzlCLFdBQVYsQ0FBc0IsS0FBSzNILEtBQUwsQ0FBV1osTUFBakM7QUFDRDs7QUFFRCxjQUFJNEssV0FBVyxHQUFHLEtBQUtiLFVBQUwsQ0FBZ0JNLFNBQWhCLENBQWxCO0FBQ0FHLGtCQUFRLEdBQUdJLFdBQVcsQ0FBQ25ELFdBQVosS0FBNEI0QyxTQUFTLENBQUN2RyxRQUFWLEVBQXZDLENBVmlDLENBVTRCOztBQUU3RCxjQUFJMEcsUUFBUSxJQUFJSSxXQUFXLENBQUNwRCxRQUE1QixFQUFzQyxLQUFLaUIsS0FBTCxHQUFhaUMsZUFBYjtBQUN2QyxTQWpCbUIsQ0FpQmxCOzs7QUFHRixZQUFJLENBQUNGLFFBQUwsRUFBZTtBQUNibEQsaUJBQU8sR0FBRyxJQUFJRCxjQUFKLEVBQVY7QUFDQSxlQUFLb0IsS0FBTCxHQUFhNkIsZUFBYjtBQUNBLGNBQUlELFNBQVMsSUFBSUUsY0FBakIsRUFBaUNGLFNBQVMsQ0FBQzVCLEtBQVYsR0FBa0I4QixjQUFsQjtBQUNsQztBQUNGOztBQUVELGFBQU9qRCxPQUFQO0FBQ0Q7QUFDRDs7QUF0Q0MsR0EzRmtCLEVBbUlsQjtBQUNEL0csT0FBRyxFQUFFLG9CQURKO0FBRURLLFNBQUssRUFBRSxTQUFTMEgsa0JBQVQsR0FBOEI7QUFDbkMsYUFBTyxJQUFJakIsY0FBSixFQUFQO0FBQ0Q7QUFDRDtBQUNBOztBQU5DLEdBbklrQixFQTJJbEI7QUFDRDlHLE9BQUcsRUFBRSxRQURKO0FBRURLLFNBQUssRUFBRSxTQUFTeUgsTUFBVCxDQUFnQjFELEdBQWhCLEVBQXFCdUYsS0FBckIsRUFBNEJoQyxJQUE1QixFQUFrQztBQUN2QyxVQUFJLENBQUN4RCxRQUFRLENBQUNDLEdBQUQsQ0FBYixFQUFvQixNQUFNLElBQUlyQixLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUNwQixVQUFJZ0UsT0FBTyxHQUFHLElBQUlELGNBQUosRUFBZDtBQUNBLFVBQUlnRCxTQUFTLEdBQUczRixRQUFRLENBQUN3RCxJQUFELENBQVIsR0FBaUIsSUFBSUwsdUJBQUosQ0FBMEJqRCxNQUFNLENBQUNzRCxJQUFELENBQWhDLENBQWpCLEdBQTJEQSxJQUEzRTtBQUNBLFVBQUlnQyxLQUFLLENBQUNoQyxJQUFWLEVBQWdCZ0MsS0FBSyxDQUFDVyxnQkFBTixHQUF5QixLQUFLcEMsS0FBOUI7O0FBRWhCLFdBQUssSUFBSXFDLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUduRyxHQUFHLENBQUMzRSxNQUExQixFQUFrQyxFQUFFOEssRUFBcEMsRUFBd0M7QUFDdEN4RCxlQUFPLENBQUNNLFNBQVIsQ0FBa0IsS0FBS3dDLFdBQUwsQ0FBaUJ6RixHQUFHLENBQUNtRyxFQUFELENBQXBCLEVBQTBCWixLQUExQixFQUFpQ0csU0FBakMsQ0FBbEI7QUFDRCxPQVJzQyxDQVFyQzs7O0FBR0YsVUFBSUEsU0FBUyxJQUFJLElBQWpCLEVBQXVCO0FBQ3JCL0MsZUFBTyxDQUFDSyxTQUFSLElBQXFCLEtBQUtvQyxVQUFMLENBQWdCTSxTQUFoQixFQUEyQjFDLFNBQWhELENBRHFCLENBQ3NDO0FBQzNEO0FBQ0E7QUFDRDs7QUFFRCxhQUFPTCxPQUFQO0FBQ0Q7QUFDRDs7QUFyQkMsR0EzSWtCLEVBa0tsQjtBQUNEL0csT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtSyxNQUFULEdBQWtCO0FBQ3ZCLFVBQUluQixPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGO0FBQ0EsV0FBSytJLE1BQUwsR0FBYyxLQUFLbkksS0FBTCxDQUFXOEYsS0FBWCxDQUFpQixDQUFqQixFQUFvQmtELE9BQXBCLElBQStCLEtBQUtoSixLQUFMLENBQVc4RixLQUFYLENBQWlCbUQsS0FBakIsQ0FBN0M7QUFDQSxhQUFPLElBQUl4QyxjQUFKLEVBQVA7QUFDRDtBQUNEOztBQVJDLEdBbEtrQixFQTRLbEI7QUFDRDlHLE9BQUcsRUFBRSxrQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3dJLGdCQUFULENBQTBCNEIsRUFBMUIsRUFBOEI7QUFDbkMsVUFBSSxLQUFLQyxXQUFMLElBQW9CLENBQUMsS0FBSy9CLGFBQTlCLEVBQTZDLE9BQU84QixFQUFFLEVBQVQ7QUFDN0MsV0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFVBQUlDLFFBQVEsR0FBRyxLQUFLQyxhQUFwQjtBQUNBLFVBQUl2SyxLQUFLLEdBQUcsS0FBS0EsS0FBakI7QUFDQSxVQUFJd0ssR0FBRyxHQUFHSixFQUFFLEVBQVo7QUFDQSxXQUFLRyxhQUFMLEdBQXFCRCxRQUFyQixDQU5tQyxDQU1KOztBQUUvQixVQUFJLEtBQUt0SyxLQUFMLEtBQWVBLEtBQWYsSUFBd0JBLEtBQUssQ0FBQ2lCLE9BQU4sQ0FBYyxLQUFLakIsS0FBbkIsTUFBOEIsQ0FBMUQsRUFBNkQ7QUFDM0QsYUFBS3lILE1BQUwsQ0FBWXpILEtBQUssQ0FBQzhGLEtBQU4sQ0FBWSxLQUFLOUYsS0FBTCxDQUFXWixNQUF2QixDQUFaLEVBQTRDLEVBQTVDLEVBQWdELEVBQWhEO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLaUwsV0FBWjtBQUNBLGFBQU9HLEdBQVA7QUFDRDtBQUNEOztBQWpCQyxHQTVLa0IsRUErTGxCO0FBQ0Q3SyxPQUFHLEVBQUUsYUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3lLLFdBQVQsQ0FBcUJMLEVBQXJCLEVBQXlCO0FBQzlCLFVBQUksS0FBS00sU0FBTCxJQUFrQixDQUFDLEtBQUtwQyxhQUE1QixFQUEyQyxPQUFPOEIsRUFBRSxDQUFDLElBQUQsQ0FBVDtBQUMzQyxXQUFLTSxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsVUFBSTdDLEtBQUssR0FBRyxLQUFLQSxLQUFqQjtBQUNBLFVBQUkyQyxHQUFHLEdBQUdKLEVBQUUsQ0FBQyxJQUFELENBQVo7QUFDQSxXQUFLdkMsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBTyxLQUFLNkMsU0FBWjtBQUNBLGFBQU9GLEdBQVA7QUFDRDtBQUNEOzs7OztBQVhDLEdBL0xrQixFQStNbEI7QUFDRDdLLE9BQUcsRUFBRSxXQURKO0FBRURLLFNBQUssRUFBRSxTQUFTdUosU0FBVCxDQUFtQnhGLEdBQW5CLEVBQXdCO0FBQzdCLFVBQUl1RixLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQSxhQUFPLEtBQUt5RCxPQUFMLEdBQWUsS0FBS0EsT0FBTCxDQUFhNUcsR0FBYixFQUFrQixJQUFsQixFQUF3QnVGLEtBQXhCLENBQWYsR0FBZ0R2RixHQUF2RDtBQUNEO0FBQ0Q7Ozs7O0FBTkMsR0EvTWtCLEVBME5sQjtBQUNEcEUsT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2SixVQUFULENBQW9CUCxLQUFwQixFQUEyQjtBQUNoQyxhQUFPLENBQUMsQ0FBQyxLQUFLc0IsUUFBTixJQUFrQixLQUFLQSxRQUFMLENBQWMsS0FBSzVLLEtBQW5CLEVBQTBCLElBQTFCLEVBQWdDc0osS0FBaEMsQ0FBbkIsTUFBK0QsQ0FBQyxLQUFLdUIsTUFBTixJQUFnQixLQUFLQSxNQUFMLENBQVloQixVQUFaLENBQXVCUCxLQUF2QixDQUEvRSxDQUFQO0FBQ0Q7QUFDRDs7Ozs7QUFMQyxHQTFOa0IsRUFvT2xCO0FBQ0QzSixPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzZJLFFBQVQsR0FBb0I7QUFDekIsVUFBSSxLQUFLaUMsTUFBVCxFQUFpQixLQUFLQSxNQUFMLENBQVksS0FBSzlLLEtBQWpCLEVBQXdCLElBQXhCO0FBQ2xCO0FBQ0Q7O0FBTEMsR0FwT2tCLEVBMk9sQjtBQUNETCxPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUytLLFFBQVQsQ0FBa0IvSyxLQUFsQixFQUF5QjtBQUM5QixhQUFPLEtBQUtnTCxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZaEwsS0FBWixFQUFtQixJQUFuQixDQUFkLEdBQXlDQSxLQUFoRDtBQUNEO0FBQ0Q7O0FBTEMsR0EzT2tCLEVBa1BsQjtBQUNETCxPQUFHLEVBQUUsU0FESjtBQUVESyxTQUFLLEVBQUUsU0FBU2lMLE9BQVQsQ0FBaUJsSCxHQUFqQixFQUFzQjtBQUMzQixhQUFPLEtBQUttSCxLQUFMLEdBQWEsS0FBS0EsS0FBTCxDQUFXbkgsR0FBWCxFQUFnQixJQUFoQixDQUFiLEdBQXFDQSxHQUE1QztBQUNEO0FBQ0Q7O0FBTEMsR0FsUGtCLEVBeVBsQjtBQUNEcEUsT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtTCxNQUFULENBQWdCbkYsS0FBaEIsRUFBdUJvRixXQUF2QixFQUFvQ3hFLFFBQXBDLEVBQThDeUUsZUFBOUMsRUFBK0Q7QUFDcEUsVUFBSUMsT0FBTyxHQUFHdEYsS0FBSyxHQUFHb0YsV0FBdEI7QUFDQSxVQUFJOUQsSUFBSSxHQUFHLEtBQUs0QixXQUFMLENBQWlCb0MsT0FBakIsQ0FBWDtBQUNBLFVBQUl2RixjQUFjLEdBQUcsS0FBSytDLGVBQUwsQ0FBcUI5QyxLQUFyQixFQUE0QnFGLGVBQTVCLENBQXJCO0FBQ0EsVUFBSUUsYUFBYSxHQUFHLElBQUk5RSxjQUFKLENBQWtCO0FBQ3BDTSxpQkFBUyxFQUFFaEIsY0FBYyxHQUFHQyxLQURRLENBQ0Y7O0FBREUsT0FBbEIsRUFHakJnQixTQUhpQixDQUdQLEtBQUttRCxNQUFMLENBQVlwRSxjQUFaLENBSE8sRUFHc0JpQixTQUh0QixDQUdnQyxLQUFLUyxNQUFMLENBQVliLFFBQVosRUFBc0I7QUFDeEVnQyxhQUFLLEVBQUU7QUFEaUUsT0FBdEIsRUFFakR0QixJQUZpRCxDQUhoQyxDQUFwQjtBQU1BLGFBQU9pRSxhQUFQO0FBQ0Q7QUFiQSxHQXpQa0IsRUF1UWxCO0FBQ0Q1TCxPQUFHLEVBQUUsT0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPO0FBQ0xpRyxjQUFNLEVBQUUsS0FBS25JO0FBRFIsT0FBUDtBQUdELEtBTkE7QUFPRHNDLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF1RixLQUFiLEVBQW9CO0FBQ3ZCLFdBQUtNLE1BQUwsR0FBY04sS0FBSyxDQUFDTSxNQUFwQjtBQUNEO0FBVEEsR0F2UWtCLEVBaVJsQjtBQUNEeEksT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLaUcsTUFBWjtBQUNELEtBSkE7QUFLRDdGLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF0QyxLQUFiLEVBQW9CO0FBQ3ZCLFdBQUsySSxPQUFMLENBQWEzSSxLQUFiO0FBQ0Q7QUFQQSxHQWpSa0IsRUF5UmxCO0FBQ0RMLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS2xDLEtBQVo7QUFDRCxLQUpBO0FBS0RzQyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdEMsS0FBYixFQUFvQjtBQUN2QixXQUFLMEksS0FBTDtBQUNBLFdBQUtqQixNQUFMLENBQVl6SCxLQUFaLEVBQW1CLEVBQW5CLEVBQXVCLEVBQXZCO0FBQ0EsV0FBSzZJLFFBQUw7QUFDRDtBQUNEOztBQVZDLEdBelJrQixFQXFTbEI7QUFDRGxKLE9BQUcsRUFBRSxZQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBSytJLE9BQUwsQ0FBYSxLQUFLakwsS0FBbEIsQ0FBUDtBQUNELEtBSkE7QUFLRHNDLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF0QyxLQUFiLEVBQW9CO0FBQ3ZCLFdBQUtBLEtBQUwsR0FBYSxLQUFLK0ssUUFBTCxDQUFjL0ssS0FBZCxDQUFiO0FBQ0Q7QUFDRDs7QUFSQyxHQXJTa0IsRUErU2xCO0FBQ0RMLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBSzZHLFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIsS0FBSy9JLEtBQUwsQ0FBV1osTUFBaEMsRUFBd0M7QUFDN0NvTSxXQUFHLEVBQUU7QUFEd0MsT0FBeEMsQ0FBUDtBQUdELEtBTkE7QUFPRGxKLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF0QyxLQUFiLEVBQW9CO0FBQ3ZCLFdBQUswSSxLQUFMO0FBQ0EsV0FBS2pCLE1BQUwsQ0FBWXpILEtBQVosRUFBbUI7QUFDakJ3TCxXQUFHLEVBQUU7QUFEWSxPQUFuQixFQUVHLEVBRkg7QUFHQSxXQUFLM0MsUUFBTDtBQUNEO0FBQ0Q7O0FBZEMsR0EvU2tCLEVBK1RsQjtBQUNEbEosT0FBRyxFQUFFLFlBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxJQUFQO0FBQ0Q7QUFKQSxHQS9Ua0IsQ0FBVCxDQUFaOztBQXNVQSxTQUFPZ0csTUFBUDtBQUNELENBeFdELEVBRkE7O0FBMldBQSxXQUFNLENBQUNHLFFBQVAsR0FBa0I7QUFDaEIyQyxRQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQlMsQ0FBaEIsRUFBbUI7QUFDekIsV0FBT0EsQ0FBUDtBQUNELEdBSGU7QUFJaEJQLE9BQUssRUFBRSxTQUFTQSxLQUFULENBQWVPLENBQWYsRUFBa0I7QUFDdkIsV0FBT0EsQ0FBUDtBQUNEO0FBTmUsQ0FBbEI7QUFRQTNELE1BQUssQ0FBQ0ksTUFBTixHQUFlQSxXQUFmO0FBRWVBLG9EQUFmLEU7O0FDOVhBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLFNBQVN3RCxXQUFULENBQXFCQyxJQUFyQixFQUEyQjtBQUN6QixNQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtBQUNoQixVQUFNLElBQUlqSixLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNELEdBSHdCLENBR3ZCOzs7QUFHRixNQUFJaUosSUFBSSxZQUFZbkcsTUFBcEIsRUFBNEIsT0FBT3NDLE1BQUssQ0FBQzhELFlBQWIsQ0FOSCxDQU04Qjs7QUFFdkQsTUFBSTlILFFBQVEsQ0FBQzZILElBQUQsQ0FBWixFQUFvQixPQUFPN0QsTUFBSyxDQUFDK0QsYUFBYixDQVJLLENBUXVCOztBQUVoRCxNQUFJRixJQUFJLFlBQVl2RyxJQUFoQixJQUF3QnVHLElBQUksS0FBS3ZHLElBQXJDLEVBQTJDLE9BQU8wQyxNQUFLLENBQUNnRSxVQUFiLENBVmxCLENBVTJDOztBQUVwRSxNQUFJSCxJQUFJLFlBQVlJLE1BQWhCLElBQTBCLE9BQU9KLElBQVAsS0FBZ0IsUUFBMUMsSUFBc0RBLElBQUksS0FBS0ksTUFBbkUsRUFBMkUsT0FBT2pFLE1BQUssQ0FBQ2tFLFlBQWIsQ0FabEQsQ0FZNkU7O0FBRXRHLE1BQUloSixLQUFLLENBQUNDLE9BQU4sQ0FBYzBJLElBQWQsS0FBdUJBLElBQUksS0FBSzNJLEtBQXBDLEVBQTJDLE9BQU84RSxNQUFLLENBQUNtRSxhQUFiLENBZGxCLENBYzhDOztBQUV2RSxNQUFJbkUsTUFBSyxDQUFDSSxNQUFOLElBQWdCeUQsSUFBSSxDQUFDaE4sU0FBTCxZQUEwQm1KLE1BQUssQ0FBQ0ksTUFBcEQsRUFBNEQsT0FBT3lELElBQVAsQ0FoQm5DLENBZ0JnRDs7QUFFekUsTUFBSUEsSUFBSSxZQUFZTyxRQUFwQixFQUE4QixPQUFPcEUsTUFBSyxDQUFDcUUsY0FBYixDQWxCTCxDQWtCa0M7O0FBRTNELE1BQUlSLElBQUksWUFBWTdELE1BQUssQ0FBQ0ksTUFBMUIsRUFBa0MsT0FBT3lELElBQUksQ0FBQ2pOLFdBQVo7QUFDbEMwTixTQUFPLENBQUNDLElBQVIsQ0FBYSx5QkFBYixFQUF3Q1YsSUFBeEMsRUFyQnlCLENBcUJzQjtBQUMvQzs7QUFFQSxTQUFPN0QsTUFBSyxDQUFDSSxNQUFiO0FBQ0Q7QUFDRDs7O0FBRUEsU0FBU29FLFVBQVQsQ0FBb0J0RSxJQUFwQixFQUEwQjtBQUN4QjtBQUNBLE1BQUlGLE1BQUssQ0FBQ0ksTUFBTixJQUFnQkYsSUFBSSxZQUFZRixNQUFLLENBQUNJLE1BQTFDLEVBQWtELE9BQU9GLElBQVA7QUFDbERBLE1BQUksR0FBR3ZJLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYyxFQUFkLEVBQWtCcUIsSUFBbEIsQ0FBUDtBQUNBLE1BQUkyRCxJQUFJLEdBQUczRCxJQUFJLENBQUMyRCxJQUFoQixDQUp3QixDQUlGOztBQUV0QixNQUFJN0QsTUFBSyxDQUFDSSxNQUFOLElBQWdCeUQsSUFBSSxZQUFZN0QsTUFBSyxDQUFDSSxNQUExQyxFQUFrRCxPQUFPeUQsSUFBUDtBQUNsRCxNQUFJWSxXQUFXLEdBQUdiLFdBQVcsQ0FBQ0MsSUFBRCxDQUE3QjtBQUNBLE1BQUksQ0FBQ1ksV0FBTCxFQUFrQixNQUFNLElBQUk3SixLQUFKLENBQVUsbUhBQVYsQ0FBTjtBQUNsQixTQUFPLElBQUk2SixXQUFKLENBQWdCdkUsSUFBaEIsQ0FBUDtBQUNEOztBQUNERixNQUFLLENBQUN3RSxVQUFOLEdBQW1CQSxVQUFuQjtBQUVlQSxzREFBZjs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFJRSx5QkFBeUIsR0FBRztBQUM5QixPQUFLLElBRHlCO0FBRTlCLE9BQUsscW5JQUZ5QjtBQUc5QjtBQUNBLE9BQUs7QUFKeUIsQ0FBaEM7QUFNQTs7QUFFQSxJQUFJQyx1Q0FBc0IsR0FDMUIsYUFDQSxZQUFZO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxXQUFTQSxzQkFBVCxDQUFnQ3pFLElBQWhDLEVBQXNDO0FBQ3BDcEosbUJBQWUsQ0FBQyxJQUFELEVBQU82TixzQkFBUCxDQUFmOztBQUVBLFFBQUlkLElBQUksR0FBRzNELElBQUksQ0FBQzJELElBQWhCO0FBQUEsUUFDSWUsU0FBUyxHQUFHeEwsd0JBQXdCLENBQUM4RyxJQUFELEVBQU8sQ0FBQyxNQUFELENBQVAsQ0FEeEM7O0FBR0EsU0FBS1IsTUFBTCxHQUFjOEUsT0FBVSxDQUFDO0FBQ3ZCWCxVQUFJLEVBQUVBO0FBRGlCLEtBQUQsQ0FBeEI7QUFHQWxNLFVBQU0sQ0FBQ2tILE1BQVAsQ0FBYyxJQUFkLEVBQW9CK0YsU0FBcEI7QUFDRDs7QUFFRDlNLGNBQVksQ0FBQzZNLHNCQUFELEVBQXlCLENBQUM7QUFDcEM5TSxPQUFHLEVBQUUsT0FEK0I7QUFFcENLLFNBQUssRUFBRSxTQUFTMEksS0FBVCxHQUFpQjtBQUN0QixXQUFLaUUsU0FBTCxHQUFpQixLQUFqQjtBQUNBLFdBQUtuRixNQUFMLENBQVlrQixLQUFaO0FBQ0Q7QUFMbUMsR0FBRCxFQU1sQztBQUNEL0ksT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtSyxNQUFULEdBQWtCO0FBQ3ZCLFVBQUluQixPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGOztBQUVBLFVBQUk0SixPQUFPLEtBQUssQ0FBWixJQUFpQkMsS0FBSyxJQUFJLENBQTlCLEVBQWlDO0FBQy9CLGFBQUswRCxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsZUFBTyxLQUFLbkYsTUFBTCxDQUFZMkMsTUFBWixDQUFtQm5CLE9BQW5CLEVBQTRCQyxLQUE1QixDQUFQO0FBQ0Q7O0FBRUQsYUFBTyxJQUFJeEMsY0FBSixFQUFQO0FBQ0Q7QUFaQSxHQU5rQyxFQW1CbEM7QUFDRDlHLE9BQUcsRUFBRSxhQURKO0FBRURLLFNBQUssRUFBRSxTQUFTd0osV0FBVCxDQUFxQnpGLEdBQXJCLEVBQTBCO0FBQy9CLFVBQUl1RixLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQSxVQUFJLEtBQUt5RixTQUFULEVBQW9CLE9BQU8sSUFBSWxHLGNBQUosRUFBUDtBQUNwQixVQUFJb0IsS0FBSyxHQUFHLEtBQUtMLE1BQUwsQ0FBWUssS0FBeEIsQ0FIK0IsQ0FHQTs7QUFFL0IsVUFBSW5CLE9BQU8sR0FBRyxLQUFLYyxNQUFMLENBQVlnQyxXQUFaLENBQXdCekYsR0FBeEIsRUFBNkJ1RixLQUE3QixDQUFkOztBQUVBLFVBQUk1QyxPQUFPLENBQUNFLFFBQVIsSUFBb0IsS0FBS2lELFVBQUwsQ0FBZ0JQLEtBQWhCLE1BQTJCLEtBQW5ELEVBQTBEO0FBQ3hENUMsZUFBTyxDQUFDRSxRQUFSLEdBQW1CRixPQUFPLENBQUNHLFdBQVIsR0FBc0IsRUFBekM7QUFDQSxhQUFLVyxNQUFMLENBQVlLLEtBQVosR0FBb0JBLEtBQXBCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDbkIsT0FBTyxDQUFDRSxRQUFULElBQXFCLENBQUMsS0FBS2dHLFVBQTNCLElBQXlDLENBQUMsS0FBS0MsSUFBL0MsSUFBdUQsQ0FBQ3ZELEtBQUssQ0FBQ1YsS0FBbEUsRUFBeUU7QUFDdkVsQyxlQUFPLENBQUNFLFFBQVIsR0FBbUIsS0FBS2tHLGVBQXhCO0FBQ0Q7O0FBRURwRyxhQUFPLENBQUNJLElBQVIsR0FBZSxDQUFDSixPQUFPLENBQUNFLFFBQVQsSUFBcUIsQ0FBQyxLQUFLZ0csVUFBMUM7QUFDQSxXQUFLRCxTQUFMLEdBQWlCSSxPQUFPLENBQUNyRyxPQUFPLENBQUNFLFFBQVQsQ0FBeEI7QUFDQSxhQUFPRixPQUFQO0FBQ0Q7QUFyQkEsR0FuQmtDLEVBeUNsQztBQUNEL0csT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVN5SCxNQUFULEdBQWtCO0FBQ3ZCLFVBQUl1RixZQUFKOztBQUVBLGFBQU8sQ0FBQ0EsWUFBWSxHQUFHLEtBQUt4RixNQUFyQixFQUE2QkMsTUFBN0IsQ0FBb0N3RixLQUFwQyxDQUEwQ0QsWUFBMUMsRUFBd0Q5RixTQUF4RCxDQUFQO0FBQ0Q7QUFOQSxHQXpDa0MsRUFnRGxDO0FBQ0R2SCxPQUFHLEVBQUUsb0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVMwSCxrQkFBVCxHQUE4QjtBQUNuQyxVQUFJaEIsT0FBTyxHQUFHLElBQUlELGNBQUosRUFBZDtBQUNBLFVBQUksS0FBS2tHLFNBQUwsSUFBa0IsS0FBS0MsVUFBM0IsRUFBdUMsT0FBT2xHLE9BQVA7QUFDdkMsV0FBS2lHLFNBQUwsR0FBaUIsSUFBakI7QUFDQWpHLGFBQU8sQ0FBQ0UsUUFBUixHQUFtQixLQUFLa0csZUFBeEI7QUFDQSxhQUFPcEcsT0FBUDtBQUNEO0FBUkEsR0FoRGtDLEVBeURsQztBQUNEL0csT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNrSixXQUFULEdBQXVCO0FBQzVCLFVBQUlnRSxhQUFKOztBQUVBLGFBQU8sQ0FBQ0EsYUFBYSxHQUFHLEtBQUsxRixNQUF0QixFQUE4QjBCLFdBQTlCLENBQTBDK0QsS0FBMUMsQ0FBZ0RDLGFBQWhELEVBQStEaEcsU0FBL0QsQ0FBUDtBQUNEO0FBTkEsR0F6RGtDLEVBZ0VsQztBQUNEdkgsT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtSixVQUFULEdBQXNCO0FBQzNCLFVBQUlnRSxhQUFKOztBQUVBLGFBQU8sQ0FBQ0EsYUFBYSxHQUFHLEtBQUszRixNQUF0QixFQUE4QjJCLFVBQTlCLENBQXlDOEQsS0FBekMsQ0FBK0NFLGFBQS9DLEVBQThEakcsU0FBOUQsQ0FBUDtBQUNEO0FBTkEsR0FoRWtDLEVBdUVsQztBQUNEdkgsT0FBRyxFQUFFLGNBREo7QUFFREssU0FBSyxFQUFFLFNBQVMrSSxZQUFULEdBQXdCO0FBQzdCLFVBQUlDLE9BQU8sR0FBRzlCLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxDQUFsRjtBQUNBLFVBQUkrQixLQUFLLEdBQUcvQixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsS0FBS2xILEtBQUwsQ0FBV1osTUFBM0Y7QUFDQSxVQUFJa0ssS0FBSyxHQUFHcEMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixHQUF1QjhILFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDM0QsU0FBbEQ7QUFDQSxhQUFPLEtBQUtpRSxNQUFMLENBQVl1QixZQUFaLENBQXlCQyxPQUF6QixFQUFrQ0MsS0FBbEMsRUFBeUNLLEtBQXpDLENBQVA7QUFDRDtBQVBBLEdBdkVrQyxFQStFbEM7QUFDRDNKLE9BQUcsRUFBRSxpQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzhJLGVBQVQsQ0FBeUJuRCxTQUF6QixFQUFvQztBQUN6QyxVQUFJbEIsU0FBUyxHQUFHeUMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FakQsU0FBUyxDQUFDQyxJQUE5RjtBQUNBLFVBQUlrSixNQUFNLEdBQUcsQ0FBYjtBQUNBLFVBQUlDLE1BQU0sR0FBRyxLQUFLck4sS0FBTCxDQUFXWixNQUF4QjtBQUNBLFVBQUlrTyxRQUFRLEdBQUdySCxJQUFJLENBQUNDLEdBQUwsQ0FBU0QsSUFBSSxDQUFDSSxHQUFMLENBQVNWLFNBQVQsRUFBb0J5SCxNQUFwQixDQUFULEVBQXNDQyxNQUF0QyxDQUFmOztBQUVBLGNBQVE1SSxTQUFSO0FBQ0UsYUFBS1IsU0FBUyxDQUFDRSxJQUFmO0FBQ0EsYUFBS0YsU0FBUyxDQUFDRyxVQUFmO0FBQ0UsaUJBQU8sS0FBS21KLFVBQUwsR0FBa0JELFFBQWxCLEdBQTZCRixNQUFwQzs7QUFFRixhQUFLbkosU0FBUyxDQUFDSSxLQUFmO0FBQ0EsYUFBS0osU0FBUyxDQUFDSyxXQUFmO0FBQ0UsaUJBQU8sS0FBS2lKLFVBQUwsR0FBa0JELFFBQWxCLEdBQTZCRCxNQUFwQzs7QUFFRixhQUFLcEosU0FBUyxDQUFDQyxJQUFmO0FBQ0E7QUFDRSxpQkFBT29KLFFBQVA7QUFYSjtBQWFEO0FBckJBLEdBL0VrQyxFQXFHbEM7QUFDRDNOLE9BQUcsRUFBRSxZQURKO0FBRURLLFNBQUssRUFBRSxTQUFTNkosVUFBVCxHQUFzQjtBQUMzQixVQUFJMkQsYUFBSixFQUFtQkMsWUFBbkI7O0FBRUEsYUFBTyxDQUFDRCxhQUFhLEdBQUcsS0FBS2hHLE1BQXRCLEVBQThCcUMsVUFBOUIsQ0FBeUNvRCxLQUF6QyxDQUErQ08sYUFBL0MsRUFBOER0RyxTQUE5RCxNQUE2RSxDQUFDLEtBQUsyRCxNQUFOLElBQWdCLENBQUM0QyxZQUFZLEdBQUcsS0FBSzVDLE1BQXJCLEVBQTZCaEIsVUFBN0IsQ0FBd0NvRCxLQUF4QyxDQUE4Q1EsWUFBOUMsRUFBNER2RyxTQUE1RCxDQUE3RixDQUFQO0FBQ0Q7QUFOQSxHQXJHa0MsRUE0R2xDO0FBQ0R2SCxPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzZJLFFBQVQsR0FBb0I7QUFDekIsV0FBS3JCLE1BQUwsQ0FBWXFCLFFBQVo7QUFDRDtBQUpBLEdBNUdrQyxFQWlIbEM7QUFDRGxKLE9BQUcsRUFBRSxPQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS3NGLE1BQUwsQ0FBWXhILEtBQVosS0FBc0IsS0FBSzJNLFNBQUwsSUFBa0IsQ0FBQyxLQUFLQyxVQUF4QixHQUFxQyxLQUFLRSxlQUExQyxHQUE0RCxFQUFsRixDQUFQO0FBQ0Q7QUFKQSxHQWpIa0MsRUFzSGxDO0FBQ0RuTixPQUFHLEVBQUUsZUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtzRixNQUFMLENBQVlrRyxhQUFuQjtBQUNEO0FBSkEsR0F0SGtDLEVBMkhsQztBQUNEL04sT0FBRyxFQUFFLFlBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTzZLLE9BQU8sQ0FBQyxLQUFLdkYsTUFBTCxDQUFZeEgsS0FBYixDQUFQLElBQThCLEtBQUs0TSxVQUExQztBQUNEO0FBSkEsR0EzSGtDLEVBZ0lsQztBQUNEak4sT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTztBQUNMc0YsY0FBTSxFQUFFLEtBQUtBLE1BQUwsQ0FBWUssS0FEZjtBQUVMOEUsaUJBQVMsRUFBRSxLQUFLQTtBQUZYLE9BQVA7QUFJRCxLQVBBO0FBUURySyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdUYsS0FBYixFQUFvQjtBQUN2QixXQUFLTCxNQUFMLENBQVlLLEtBQVosR0FBb0JBLEtBQUssQ0FBQ0wsTUFBMUI7QUFDQSxXQUFLbUYsU0FBTCxHQUFpQjlFLEtBQUssQ0FBQzhFLFNBQXZCO0FBQ0Q7QUFYQSxHQWhJa0MsQ0FBekIsQ0FBWjs7QUE4SUEsU0FBT0Ysc0JBQVA7QUFDRCxDQXZLRCxFQUZBOztBQTJLZUEsNEZBQWY7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJa0IsdUNBQXNCLEdBQzFCLGFBQ0EsWUFBWTtBQUNWOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsV0FBU0Esc0JBQVQsQ0FBZ0MzRixJQUFoQyxFQUFzQztBQUNwQ3BKLG1CQUFlLENBQUMsSUFBRCxFQUFPK08sc0JBQVAsQ0FBZjs7QUFFQWxPLFVBQU0sQ0FBQ2tILE1BQVAsQ0FBYyxJQUFkLEVBQW9CcUIsSUFBcEI7QUFDQSxTQUFLRyxNQUFMLEdBQWMsRUFBZDtBQUNEOztBQUVEdkksY0FBWSxDQUFDK04sc0JBQUQsRUFBeUIsQ0FBQztBQUNwQ2hPLE9BQUcsRUFBRSxPQUQrQjtBQUVwQ0ssU0FBSyxFQUFFLFNBQVMwSSxLQUFULEdBQWlCO0FBQ3RCLFdBQUtrRixXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsV0FBS3pGLE1BQUwsR0FBYyxFQUFkO0FBQ0Q7QUFMbUMsR0FBRCxFQU1sQztBQUNEeEksT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtSyxNQUFULEdBQWtCO0FBQ3ZCLFVBQUluQixPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtpQixNQUFMLENBQVkvSSxNQUE1RjtBQUNBLFdBQUsrSSxNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZckMsS0FBWixDQUFrQixDQUFsQixFQUFxQmtELE9BQXJCLElBQWdDLEtBQUtiLE1BQUwsQ0FBWXJDLEtBQVosQ0FBa0JtRCxLQUFsQixDQUE5QztBQUNBLFVBQUksQ0FBQyxLQUFLZCxNQUFWLEVBQWtCLEtBQUt5RixXQUFMLEdBQW1CLEtBQW5CO0FBQ2xCLGFBQU8sSUFBSW5ILGNBQUosRUFBUDtBQUNEO0FBUkEsR0FOa0MsRUFlbEM7QUFDRDlHLE9BQUcsRUFBRSxpQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzhJLGVBQVQsQ0FBeUJuRCxTQUF6QixFQUFvQztBQUN6QyxVQUFJbEIsU0FBUyxHQUFHeUMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FakQsU0FBUyxDQUFDQyxJQUE5RjtBQUNBLFVBQUlrSixNQUFNLEdBQUcsQ0FBYjtBQUNBLFVBQUlDLE1BQU0sR0FBRyxLQUFLbEYsTUFBTCxDQUFZL0ksTUFBekI7O0FBRUEsY0FBUXFGLFNBQVI7QUFDRSxhQUFLUixTQUFTLENBQUNFLElBQWY7QUFDQSxhQUFLRixTQUFTLENBQUNHLFVBQWY7QUFDRSxpQkFBT2dKLE1BQVA7O0FBRUYsYUFBS25KLFNBQVMsQ0FBQ0MsSUFBZjtBQUNBLGFBQUtELFNBQVMsQ0FBQ0ksS0FBZjtBQUNBLGFBQUtKLFNBQVMsQ0FBQ0ssV0FBZjtBQUNBO0FBQ0UsaUJBQU8rSSxNQUFQO0FBVEo7QUFXRDtBQWxCQSxHQWZrQyxFQWtDbEM7QUFDRDFOLE9BQUcsRUFBRSxjQURKO0FBRURLLFNBQUssRUFBRSxTQUFTK0ksWUFBVCxHQUF3QjtBQUM3QixVQUFJQyxPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtpQixNQUFMLENBQVkvSSxNQUE1RjtBQUNBLFVBQUlrSyxLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQSxhQUFPb0MsS0FBSyxDQUFDa0MsR0FBTixJQUFhLEtBQUtvQyxXQUFsQixJQUFpQyxLQUFLekYsTUFBTCxDQUFZckMsS0FBWixDQUFrQmtELE9BQWxCLEVBQTJCQyxLQUEzQixDQUFqQyxJQUFzRSxFQUE3RTtBQUNEO0FBUEEsR0FsQ2tDLEVBMENsQztBQUNEdEosT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVN3SixXQUFULENBQXFCekYsR0FBckIsRUFBMEI7QUFDL0IsVUFBSXVGLEtBQUssR0FBR3BDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLFVBQUlSLE9BQU8sR0FBRyxJQUFJRCxjQUFKLEVBQWQ7QUFDQSxVQUFJLEtBQUswQixNQUFULEVBQWlCLE9BQU96QixPQUFQO0FBQ2pCLFVBQUlrRCxRQUFRLEdBQUcsS0FBS2lFLElBQUwsS0FBYzlKLEdBQUcsQ0FBQyxDQUFELENBQWhDO0FBQ0EsVUFBSStKLFVBQVUsR0FBR2xFLFFBQVEsS0FBSyxLQUFLbUUsV0FBTCxJQUFvQnpFLEtBQUssQ0FBQ1YsS0FBMUIsSUFBbUNVLEtBQUssQ0FBQ2tDLEdBQTlDLENBQVIsSUFBOEQsQ0FBQ2xDLEtBQUssQ0FBQ2hDLElBQXRGO0FBQ0EsVUFBSXdHLFVBQUosRUFBZ0JwSCxPQUFPLENBQUNHLFdBQVIsR0FBc0IsS0FBS2dILElBQTNCO0FBQ2hCLFdBQUsxRixNQUFMLEdBQWN6QixPQUFPLENBQUNFLFFBQVIsR0FBbUIsS0FBS2lILElBQXRDO0FBQ0EsV0FBS0QsV0FBTCxHQUFtQkUsVUFBVSxLQUFLeEUsS0FBSyxDQUFDa0MsR0FBTixJQUFhbEMsS0FBSyxDQUFDVixLQUF4QixDQUE3QjtBQUNBLGFBQU9sQyxPQUFQO0FBQ0Q7QUFaQSxHQTFDa0MsRUF1RGxDO0FBQ0QvRyxPQUFHLEVBQUUsb0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVMwSCxrQkFBVCxHQUE4QjtBQUNuQyxVQUFJaEIsT0FBTyxHQUFHLElBQUlELGNBQUosRUFBZDtBQUNBLFVBQUksS0FBSzBCLE1BQVQsRUFBaUIsT0FBT3pCLE9BQVA7QUFDakIsV0FBS3lCLE1BQUwsR0FBY3pCLE9BQU8sQ0FBQ0UsUUFBUixHQUFtQixLQUFLaUgsSUFBdEM7QUFDQSxhQUFPbkgsT0FBUDtBQUNEO0FBUEEsR0F2RGtDLEVBK0RsQztBQUNEL0csT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNrSixXQUFULEdBQXVCO0FBQzVCLFVBQUlELEtBQUssR0FBRy9CLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxLQUFLbEgsS0FBTCxDQUFXWixNQUEzRjtBQUNBLGFBQU8sSUFBSTZILHVCQUFKLENBQTBCLEVBQTFCLENBQVA7QUFDRCxLQUxBLENBS0M7O0FBTEQsR0EvRGtDLEVBc0VsQztBQUNEdEgsT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtSixVQUFULENBQW9CN0IsSUFBcEIsRUFBMEI7QUFDL0IsVUFBSXhELFFBQVEsQ0FBQ3dELElBQUQsQ0FBWixFQUFvQkEsSUFBSSxHQUFHLElBQUlMLHVCQUFKLENBQTBCakQsTUFBTSxDQUFDc0QsSUFBRCxDQUFoQyxDQUFQO0FBQ3BCLGFBQU9BLElBQUksQ0FBQ0MsUUFBTCxDQUFjLElBQWQsQ0FBUDtBQUNEO0FBTEEsR0F0RWtDLEVBNEVsQztBQUNENUgsT0FBRyxFQUFFLFFBREo7QUFFREssU0FBSyxFQUFFLFNBQVN5SCxNQUFULENBQWdCMUQsR0FBaEIsRUFBcUJ1RixLQUFyQixFQUE0QmhDLElBQTVCLEVBQWtDO0FBQ3ZDLFVBQUlaLE9BQU8sR0FBRyxLQUFLOEMsV0FBTCxDQUFpQnpGLEdBQWpCLEVBQXNCdUYsS0FBdEIsQ0FBZDs7QUFFQSxVQUFJaEMsSUFBSSxJQUFJLElBQVosRUFBa0I7QUFDaEJaLGVBQU8sQ0FBQ0ssU0FBUixJQUFxQixLQUFLb0MsVUFBTCxDQUFnQjdCLElBQWhCLEVBQXNCUCxTQUEzQztBQUNEOztBQUVELGFBQU9MLE9BQVA7QUFDRDtBQVZBLEdBNUVrQyxFQXVGbEM7QUFDRC9HLE9BQUcsRUFBRSxVQURKO0FBRURLLFNBQUssRUFBRSxTQUFTNkksUUFBVCxHQUFvQixDQUFFO0FBRjVCLEdBdkZrQyxFQTBGbEM7QUFDRGxKLE9BQUcsRUFBRSxPQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS2lHLE1BQVo7QUFDRDtBQUpBLEdBMUZrQyxFQStGbEM7QUFDRHhJLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBSzZMLFdBQUwsR0FBbUIsS0FBSy9OLEtBQXhCLEdBQWdDLEVBQXZDO0FBQ0Q7QUFKQSxHQS9Ga0MsRUFvR2xDO0FBQ0RMLE9BQUcsRUFBRSxZQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sSUFBUDtBQUNEO0FBSkEsR0FwR2tDLEVBeUdsQztBQUNEdkMsT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTztBQUNMaUcsY0FBTSxFQUFFLEtBQUtBLE1BRFI7QUFFTHlGLG1CQUFXLEVBQUUsS0FBS0E7QUFGYixPQUFQO0FBSUQsS0FQQTtBQVFEdEwsT0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYXVGLEtBQWIsRUFBb0I7QUFDdkJwSSxZQUFNLENBQUNrSCxNQUFQLENBQWMsSUFBZCxFQUFvQmtCLEtBQXBCO0FBQ0Q7QUFWQSxHQXpHa0MsQ0FBekIsQ0FBWjs7QUFzSEEsU0FBTzhGLHNCQUFQO0FBQ0QsQ0F0SUQsRUFGQTs7QUEwSWVBLDRGQUFmLEU7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUssb0NBQWlCLEdBQ3JCLGFBQ0EsWUFBWTtBQUNWO0FBQ0EsV0FBU0EsaUJBQVQsR0FBNkI7QUFDM0IsUUFBSUMsTUFBTSxHQUFHL0csU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQWpGO0FBQ0EsUUFBSUMsSUFBSSxHQUFHRCxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBL0U7O0FBRUF0SSxtQkFBZSxDQUFDLElBQUQsRUFBT29QLGlCQUFQLENBQWY7O0FBRUEsU0FBS0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBSzlHLElBQUwsR0FBWUEsSUFBWjtBQUNEOztBQUVEdkgsY0FBWSxDQUFDb08saUJBQUQsRUFBb0IsQ0FBQztBQUMvQnJPLE9BQUcsRUFBRSxVQUQwQjtBQUUvQkssU0FBSyxFQUFFLFNBQVNrRCxRQUFULEdBQW9CO0FBQ3pCLGFBQU8sS0FBSytLLE1BQUwsQ0FBWUMsR0FBWixDQUFnQmxLLE1BQWhCLEVBQXdCbUssSUFBeEIsQ0FBNkIsRUFBN0IsQ0FBUDtBQUNELEtBSjhCLENBSTdCOztBQUo2QixHQUFELEVBTTdCO0FBQ0R4TyxPQUFHLEVBQUUsUUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3FILE1BQVQsQ0FBZ0IrRyxTQUFoQixFQUEyQjtBQUNoQyxVQUFJLENBQUNwSyxNQUFNLENBQUNvSyxTQUFELENBQVgsRUFBd0I7QUFDeEIsVUFBSXRLLFFBQVEsQ0FBQ3NLLFNBQUQsQ0FBWixFQUF5QkEsU0FBUyxHQUFHLElBQUluSCx1QkFBSixDQUEwQmpELE1BQU0sQ0FBQ29LLFNBQUQsQ0FBaEMsQ0FBWjtBQUN6QixVQUFJQyxTQUFTLEdBQUcsS0FBS0osTUFBTCxDQUFZLEtBQUtBLE1BQUwsQ0FBWTdPLE1BQVosR0FBcUIsQ0FBakMsQ0FBaEI7QUFDQSxVQUFJa1AsVUFBVSxHQUFHRCxTQUFTLE1BQU07QUFDaENBLGVBQVMsQ0FBQ2pILElBQVYsS0FBbUJnSCxTQUFTLENBQUNoSCxJQUE3QixJQUFxQ2dILFNBQVMsQ0FBQ2hILElBQVYsSUFBa0IsSUFEN0IsQ0FBVCxJQUMrQztBQUNoRWdILGVBQVMsQ0FBQ2pILElBQVYsS0FBbUJrSCxTQUFTLENBQUNsSCxJQUFWLEdBQWlCa0gsU0FBUyxDQUFDbkwsUUFBVixHQUFxQjlELE1BRnpEOztBQUlBLFVBQUlnUCxTQUFTLFlBQVluSCx1QkFBekIsRUFBZ0Q7QUFDOUM7QUFDQSxZQUFJcUgsVUFBSixFQUFnQjtBQUNkO0FBQ0FELG1CQUFTLENBQUNoSCxNQUFWLENBQWlCK0csU0FBUyxDQUFDbEwsUUFBVixFQUFqQjtBQUNELFNBSEQsTUFHTztBQUNMO0FBQ0EsZUFBSytLLE1BQUwsQ0FBWXJLLElBQVosQ0FBaUJ3SyxTQUFqQjtBQUNEO0FBQ0YsT0FURCxNQVNPLElBQUlBLFNBQVMsWUFBWUosaUJBQXpCLEVBQTRDO0FBQ2pELFlBQUlJLFNBQVMsQ0FBQ2hILElBQVYsSUFBa0IsSUFBdEIsRUFBNEI7QUFDMUI7QUFDQSxjQUFJbUgsY0FBSjs7QUFFQSxpQkFBT0gsU0FBUyxDQUFDSCxNQUFWLENBQWlCN08sTUFBakIsSUFBMkJnUCxTQUFTLENBQUNILE1BQVYsQ0FBaUIsQ0FBakIsRUFBb0I3RyxJQUFwQixJQUE0QixJQUE5RCxFQUFvRTtBQUNsRW1ILDBCQUFjLEdBQUdILFNBQVMsQ0FBQ0gsTUFBVixDQUFpQk8sS0FBakIsRUFBakI7QUFDQUQsMEJBQWMsQ0FBQ3BILElBQWYsSUFBdUJpSCxTQUFTLENBQUNqSCxJQUFqQztBQUNBLGlCQUFLRSxNQUFMLENBQVlrSCxjQUFaO0FBQ0Q7QUFDRixTQVZnRCxDQVUvQzs7O0FBR0YsWUFBSUgsU0FBUyxDQUFDbEwsUUFBVixFQUFKLEVBQTBCO0FBQ3hCO0FBQ0FrTCxtQkFBUyxDQUFDaEgsSUFBVixHQUFpQmdILFNBQVMsQ0FBQ0ssVUFBM0I7QUFDQSxlQUFLUixNQUFMLENBQVlySyxJQUFaLENBQWlCd0ssU0FBakI7QUFDRDtBQUNGO0FBQ0Y7QUF0Q0EsR0FONkIsRUE2QzdCO0FBQ0R6TyxPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3VILFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCO0FBQy9CO0FBQ0EsVUFBSSxFQUFFQSxNQUFNLFlBQVlNLE1BQUssQ0FBQytELGFBQTFCLENBQUosRUFBOEM7QUFDNUMsWUFBSXZFLElBQUksR0FBRyxJQUFJTCx1QkFBSixDQUEwQixLQUFLL0QsUUFBTCxFQUExQixDQUFYO0FBQ0EsZUFBT29FLElBQUksQ0FBQ0MsUUFBTCxDQUFjQyxNQUFkLENBQVA7QUFDRDs7QUFFRCxVQUFJZCxPQUFPLEdBQUcsSUFBSUQsY0FBSixFQUFkOztBQUVBLFdBQUssSUFBSXlELEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUcsS0FBSytELE1BQUwsQ0FBWTdPLE1BQWpCLElBQTJCLENBQUNzSCxPQUFPLENBQUNJLElBQXJELEVBQTJELEVBQUVvRCxFQUE3RCxFQUFpRTtBQUMvRCxZQUFJd0UsS0FBSyxHQUFHLEtBQUtULE1BQUwsQ0FBWS9ELEVBQVosQ0FBWjs7QUFFQSxZQUFJeUUsYUFBYSxHQUFHbkgsTUFBTSxDQUFDb0gsY0FBUCxDQUFzQnBILE1BQU0sQ0FBQ3hILEtBQVAsQ0FBYVosTUFBbkMsQ0FBcEI7O0FBRUEsWUFBSWdJLElBQUksR0FBR3NILEtBQUssQ0FBQ3RILElBQWpCO0FBQ0EsWUFBSXlILFVBQVUsR0FBRyxLQUFLLENBQXRCOztBQUVBLFlBQUl6SCxJQUFJLElBQUksSUFBUixNQUFrQjtBQUN0QixTQUFDdUgsYUFBRCxJQUFrQkEsYUFBYSxDQUFDRyxLQUFkLElBQXVCMUgsSUFEckMsQ0FBSixFQUNnRDtBQUM5QyxjQUFJc0gsS0FBSyxZQUFZVixpQkFBakIsSUFBc0M7QUFDMUN4RyxnQkFBTSxDQUFDdUgsTUFBUCxDQUFjOU4sT0FBZCxDQUFzQm1HLElBQXRCLEtBQStCLENBRC9CLEVBQ2tDO0FBQ2hDVixtQkFBTyxDQUFDTSxTQUFSLENBQWtCUSxNQUFNLENBQUNFLGtCQUFQLENBQTBCTixJQUExQixDQUFsQjtBQUNEOztBQUVEeUgsb0JBQVUsR0FBR0gsS0FBSyxZQUFZVixpQkFBakIsSUFBc0N4RyxNQUFNLENBQUN3SCxPQUFQLENBQWU1SCxJQUFmLENBQW5EO0FBQ0Q7O0FBRUQsWUFBSXlILFVBQUosRUFBZ0I7QUFDZCxjQUFJN0UsV0FBVyxHQUFHNkUsVUFBVSxDQUFDMUYsVUFBWCxDQUFzQnVGLEtBQXRCLENBQWxCO0FBQ0ExRSxxQkFBVyxDQUFDbEQsSUFBWixHQUFtQixLQUFuQixDQUZjLENBRVk7O0FBRTFCSixpQkFBTyxDQUFDTSxTQUFSLENBQWtCZ0QsV0FBbEI7QUFDQXhDLGdCQUFNLENBQUNXLE1BQVAsSUFBaUI2QixXQUFXLENBQUNwRCxRQUE3QixDQUxjLENBS3lCOztBQUV2QyxjQUFJcUksV0FBVyxHQUFHUCxLQUFLLENBQUN4TCxRQUFOLEdBQWlCNEMsS0FBakIsQ0FBdUJrRSxXQUFXLENBQUNuRCxXQUFaLENBQXdCekgsTUFBL0MsQ0FBbEI7QUFDQSxjQUFJNlAsV0FBSixFQUFpQnZJLE9BQU8sQ0FBQ00sU0FBUixDQUFrQlEsTUFBTSxDQUFDQyxNQUFQLENBQWN3SCxXQUFkLEVBQTJCO0FBQzVEM0gsZ0JBQUksRUFBRTtBQURzRCxXQUEzQixDQUFsQjtBQUdsQixTQVhELE1BV087QUFDTFosaUJBQU8sQ0FBQ00sU0FBUixDQUFrQlEsTUFBTSxDQUFDQyxNQUFQLENBQWNpSCxLQUFLLENBQUN4TCxRQUFOLEVBQWQsRUFBZ0M7QUFDaERvRSxnQkFBSSxFQUFFO0FBRDBDLFdBQWhDLENBQWxCO0FBR0Q7QUFDRjs7QUFDRCxhQUFPWixPQUFQO0FBQ0Q7QUEvQ0EsR0E3QzZCLEVBNkY3QjtBQUNEL0csT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVMySCxXQUFULENBQXFCbkQsR0FBckIsRUFBMEI7QUFDL0IsVUFBSSxLQUFLMkMsSUFBTCxJQUFhM0MsR0FBYixJQUFvQixDQUFDLEtBQUt5SixNQUFMLENBQVk3TyxNQUFyQyxFQUE2QyxPQUFPLEVBQVA7QUFDN0MsVUFBSThQLGFBQWEsR0FBRzFLLEdBQUcsR0FBRyxLQUFLMkMsSUFBL0I7QUFDQSxVQUFJK0MsRUFBRSxHQUFHLENBQVQ7O0FBRUEsYUFBT0EsRUFBRSxHQUFHLEtBQUsrRCxNQUFMLENBQVk3TyxNQUF4QixFQUFnQztBQUM5QixZQUFJc1AsS0FBSyxHQUFHLEtBQUtULE1BQUwsQ0FBWS9ELEVBQVosQ0FBWjtBQUNBLFlBQUl0QyxTQUFTLEdBQUc4RyxLQUFLLENBQUMvRyxXQUFOLENBQWtCdUgsYUFBbEIsQ0FBaEI7O0FBRUEsWUFBSVIsS0FBSyxDQUFDeEwsUUFBTixFQUFKLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQSxjQUFJLENBQUMwRSxTQUFMLEVBQWdCO0FBQ2hCLFlBQUVzQyxFQUFGO0FBQ0QsU0FMRCxNQUtPO0FBQ0w7QUFDQSxlQUFLK0QsTUFBTCxDQUFZOUMsTUFBWixDQUFtQmpCLEVBQW5CLEVBQXVCLENBQXZCO0FBQ0Q7O0FBRUQsWUFBSXRDLFNBQUosRUFBZSxPQUFPQSxTQUFQO0FBQ2hCOztBQUVELGFBQU8sRUFBUDtBQUNEO0FBekJBLEdBN0Y2QixFQXVIN0I7QUFDRGpJLE9BQUcsRUFBRSxPQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU87QUFDTCtMLGNBQU0sRUFBRSxLQUFLQSxNQUFMLENBQVlDLEdBQVosQ0FBZ0IsVUFBVWlCLENBQVYsRUFBYTtBQUNuQyxpQkFBT0EsQ0FBQyxDQUFDdEgsS0FBVDtBQUNELFNBRk8sQ0FESDtBQUlMVixZQUFJLEVBQUUsS0FBS0EsSUFKTjtBQUtMQyxZQUFJLEVBQUUsS0FBS0EsSUFMTjtBQU1McUgsa0JBQVUsRUFBRSxLQUFLQTtBQU5aLE9BQVA7QUFRRCxLQVhBO0FBWURuTSxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdUYsS0FBYixFQUFvQjtBQUN2QixVQUFJb0csTUFBTSxHQUFHcEcsS0FBSyxDQUFDb0csTUFBbkI7QUFBQSxVQUNJL08sS0FBSyxHQUFHZ0Msd0JBQXdCLENBQUMyRyxLQUFELEVBQVEsQ0FBQyxRQUFELENBQVIsQ0FEcEM7O0FBR0FwSSxZQUFNLENBQUNrSCxNQUFQLENBQWMsSUFBZCxFQUFvQnpILEtBQXBCO0FBQ0EsV0FBSytPLE1BQUwsR0FBY0EsTUFBTSxDQUFDQyxHQUFQLENBQVcsVUFBVWtCLE1BQVYsRUFBa0I7QUFDekMsWUFBSVYsS0FBSyxHQUFHLFlBQVlVLE1BQVosR0FBcUIsSUFBSXBCLGlCQUFKLEVBQXJCLEdBQStDLElBQUkvRyx1QkFBSixFQUEzRCxDQUR5QyxDQUMrQzs7QUFFeEZ5SCxhQUFLLENBQUM3RyxLQUFOLEdBQWN1SCxNQUFkO0FBQ0EsZUFBT1YsS0FBUDtBQUNELE9BTGEsQ0FBZDtBQU1EO0FBdkJBLEdBdkg2QixDQUFwQixDQUFaOztBQWlKQSxTQUFPVixpQkFBUDtBQUNELENBOUpELEVBRkE7O0FBa0tlQSwyRkFBZixFOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQSxJQUFJcEMsbUJBQVksR0FDaEIsYUFDQSxVQUFVeUQsT0FBVixFQUFtQjtBQUNqQnBQLFdBQVMsQ0FBQzJMLFlBQUQsRUFBZXlELE9BQWYsQ0FBVDs7QUFFQSxXQUFTekQsWUFBVCxHQUF3QjtBQUN0QmhOLG1CQUFlLENBQUMsSUFBRCxFQUFPZ04sWUFBUCxDQUFmOztBQUVBLFdBQU9sSywwQkFBMEIsQ0FBQyxJQUFELEVBQU9wQixlQUFlLENBQUNzTCxZQUFELENBQWYsQ0FBOEJxQixLQUE5QixDQUFvQyxJQUFwQyxFQUEwQy9GLFNBQTFDLENBQVAsQ0FBakM7QUFDRDs7QUFFRHRILGNBQVksQ0FBQ2dNLFlBQUQsRUFBZSxDQUFDO0FBQzFCak0sT0FBRyxFQUFFLFNBRHFCOztBQUcxQjs7OztBQUlBSyxTQUFLLEVBQUUsU0FBU29JLE9BQVQsQ0FBaUJKLElBQWpCLEVBQXVCO0FBQzVCLFVBQUlBLElBQUksQ0FBQzJELElBQVQsRUFBZTNELElBQUksQ0FBQzRDLFFBQUwsR0FBZ0IsVUFBVTVLLEtBQVYsRUFBaUI7QUFDOUMsZUFBT0EsS0FBSyxDQUFDc1AsTUFBTixDQUFhdEgsSUFBSSxDQUFDMkQsSUFBbEIsS0FBMkIsQ0FBbEM7QUFDRCxPQUZjOztBQUlmNUosVUFBSSxDQUFDekIsZUFBZSxDQUFDc0wsWUFBWSxDQUFDak4sU0FBZCxDQUFoQixFQUEwQyxTQUExQyxFQUFxRCxJQUFyRCxDQUFKLENBQStEMkMsSUFBL0QsQ0FBb0UsSUFBcEUsRUFBMEUwRyxJQUExRTtBQUNEO0FBYnlCLEdBQUQsQ0FBZixDQUFaOztBQWdCQSxTQUFPNEQsWUFBUDtBQUNELENBMUJELENBMEJFMUQsSUExQkYsQ0FGQTs7QUE2QkFKLE1BQUssQ0FBQzhELFlBQU4sR0FBcUJBLG1CQUFyQjtBQUVlQSxxRUFBZixFOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBLElBQUlDLHFCQUFhLEdBQ2pCLGFBQ0EsVUFBVXdELE9BQVYsRUFBbUI7QUFDakJwUCxXQUFTLENBQUM0TCxhQUFELEVBQWdCd0QsT0FBaEIsQ0FBVDtBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFDQSxXQUFTeEQsYUFBVCxHQUF5QjtBQUN2QixRQUFJN0QsSUFBSSxHQUFHZCxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBL0U7O0FBRUF0SSxtQkFBZSxDQUFDLElBQUQsRUFBT2lOLGFBQVAsQ0FBZixDQUh1QixDQUt2Qjs7O0FBQ0E3RCxRQUFJLENBQUN1SCxXQUFMLEdBQW1COVAsTUFBTSxDQUFDa0gsTUFBUCxDQUFjLEVBQWQsRUFBa0I2Rix5QkFBbEIsRUFBNkN4RSxJQUFJLENBQUN1SCxXQUFsRCxDQUFuQjtBQUNBLFdBQU83TiwwQkFBMEIsQ0FBQyxJQUFELEVBQU9wQixlQUFlLENBQUN1TCxhQUFELENBQWYsQ0FBK0J2SyxJQUEvQixDQUFvQyxJQUFwQyxFQUEwQzdCLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYyxFQUFkLEVBQWtCa0YsYUFBYSxDQUFDeEQsUUFBaEMsRUFBMEMsRUFBMUMsRUFBOENMLElBQTlDLENBQTFDLENBQVAsQ0FBakM7QUFDRDtBQUNEOzs7Ozs7QUFNQXBJLGNBQVksQ0FBQ2lNLGFBQUQsRUFBZ0IsQ0FBQztBQUMzQmxNLE9BQUcsRUFBRSxTQURzQjtBQUUzQkssU0FBSyxFQUFFLFNBQVNvSSxPQUFULEdBQW1CO0FBQ3hCLFVBQUlKLElBQUksR0FBR2QsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQS9FO0FBQ0FjLFVBQUksQ0FBQ3VILFdBQUwsR0FBbUI5UCxNQUFNLENBQUNrSCxNQUFQLENBQWMsRUFBZCxFQUFrQixLQUFLNEksV0FBdkIsRUFBb0N2SCxJQUFJLENBQUN1SCxXQUF6QyxDQUFuQjs7QUFFQXhOLFVBQUksQ0FBQ3pCLGVBQWUsQ0FBQ3VMLGFBQWEsQ0FBQ2xOLFNBQWYsQ0FBaEIsRUFBMkMsU0FBM0MsRUFBc0QsSUFBdEQsQ0FBSixDQUFnRTJDLElBQWhFLENBQXFFLElBQXJFLEVBQTJFMEcsSUFBM0U7O0FBRUEsV0FBS3dILFlBQUw7QUFDRDtBQUNEOztBQVYyQixHQUFELEVBWXpCO0FBQ0Q3UCxPQUFHLEVBQUUsY0FESjtBQUVESyxTQUFLLEVBQUUsU0FBU3dQLFlBQVQsR0FBd0I7QUFDN0IsVUFBSUMsS0FBSyxHQUFHLElBQVo7O0FBRUEsVUFBSUMsSUFBSSxHQUFHLEtBQUtILFdBQWhCO0FBQ0EsV0FBS1AsT0FBTCxHQUFlLEVBQWY7QUFDQSxXQUFLRCxNQUFMLEdBQWMsRUFBZDtBQUNBLFdBQUtZLGFBQUwsR0FBcUIsRUFBckI7QUFDQSxVQUFJQyxPQUFPLEdBQUcsS0FBS2pFLElBQW5CO0FBQ0EsVUFBSSxDQUFDaUUsT0FBRCxJQUFZLENBQUNGLElBQWpCLEVBQXVCO0FBQ3ZCLFVBQUlHLGNBQWMsR0FBRyxLQUFyQjtBQUNBLFVBQUlDLGFBQWEsR0FBRyxLQUFwQjs7QUFFQSxXQUFLLElBQUkzUSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeVEsT0FBTyxDQUFDeFEsTUFBNUIsRUFBb0MsRUFBRUQsQ0FBdEMsRUFBeUM7QUFDdkMsWUFBSSxLQUFLNFEsTUFBVCxFQUFpQjtBQUNmLGNBQUlDLElBQUksR0FBRyxZQUFZO0FBQ3JCLGdCQUFJclAsQ0FBQyxHQUFHaVAsT0FBTyxDQUFDOUosS0FBUixDQUFjM0csQ0FBZCxDQUFSO0FBQ0EsZ0JBQUk4USxNQUFNLEdBQUd4USxNQUFNLENBQUN1QixJQUFQLENBQVl5TyxLQUFLLENBQUNNLE1BQWxCLEVBQTBCRyxNQUExQixDQUFpQyxVQUFVQyxLQUFWLEVBQWlCO0FBQzdELHFCQUFPeFAsQ0FBQyxDQUFDTSxPQUFGLENBQVVrUCxLQUFWLE1BQXFCLENBQTVCO0FBQ0QsYUFGWSxDQUFiLENBRnFCLENBSWpCOztBQUVKRixrQkFBTSxDQUFDRyxJQUFQLENBQVksVUFBVXBMLENBQVYsRUFBYUQsQ0FBYixFQUFnQjtBQUMxQixxQkFBT0EsQ0FBQyxDQUFDM0YsTUFBRixHQUFXNEYsQ0FBQyxDQUFDNUYsTUFBcEI7QUFDRCxhQUZELEVBTnFCLENBUWpCOztBQUVKLGdCQUFJK1EsS0FBSyxHQUFHRixNQUFNLENBQUMsQ0FBRCxDQUFsQjs7QUFFQSxnQkFBSUUsS0FBSixFQUFXO0FBQ1Qsa0JBQUlFLFdBQVcsR0FBRy9ELE9BQVUsQ0FBQzdNLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYztBQUN6Q2tFLHNCQUFNLEVBQUU0RSxLQURpQztBQUV6QzVDLG9CQUFJLEVBQUU0QyxLQUFLLENBQUM1QyxJQUY2QjtBQUd6Q0MsK0JBQWUsRUFBRTJDLEtBQUssQ0FBQzNDLGVBSGtCO0FBSXpDL0MseUJBQVMsRUFBRTBGLEtBQUssQ0FBQzFGO0FBSndCLGVBQWQsRUFLMUIwRixLQUFLLENBQUNNLE1BQU4sQ0FBYUksS0FBYixDQUwwQixDQUFELENBQTVCOztBQU9BLGtCQUFJRSxXQUFKLEVBQWlCO0FBQ2ZaLHFCQUFLLENBQUNULE9BQU4sQ0FBY3BMLElBQWQsQ0FBbUJ5TSxXQUFuQixFQURlLENBQ2tCOzs7QUFHakMsb0JBQUksQ0FBQ1osS0FBSyxDQUFDRSxhQUFOLENBQW9CUSxLQUFwQixDQUFMLEVBQWlDVixLQUFLLENBQUNFLGFBQU4sQ0FBb0JRLEtBQXBCLElBQTZCLEVBQTdCOztBQUVqQ1YscUJBQUssQ0FBQ0UsYUFBTixDQUFvQlEsS0FBcEIsRUFBMkJ2TSxJQUEzQixDQUFnQzZMLEtBQUssQ0FBQ1QsT0FBTixDQUFjNVAsTUFBZCxHQUF1QixDQUF2RDtBQUNEOztBQUVERCxlQUFDLElBQUlnUixLQUFLLENBQUMvUSxNQUFOLEdBQWUsQ0FBcEI7QUFDQSxxQkFBTyxVQUFQO0FBQ0Q7QUFDRixXQWhDVSxFQUFYOztBQWtDQSxjQUFJNFEsSUFBSSxLQUFLLFVBQWIsRUFBeUI7QUFDMUI7O0FBRUQsWUFBSW5DLElBQUksR0FBRytCLE9BQU8sQ0FBQ3pRLENBQUQsQ0FBbEI7O0FBRUEsWUFBSW1SLFFBQVEsSUFBR3pDLElBQUksSUFBSTZCLElBQVgsQ0FBWjs7QUFFQSxZQUFJN0IsSUFBSSxLQUFLaEMsYUFBYSxDQUFDMEUsU0FBM0IsRUFBc0M7QUFDcEMsZUFBS3hCLE1BQUwsQ0FBWW5MLElBQVosQ0FBaUIsS0FBS29MLE9BQUwsQ0FBYTVQLE1BQTlCOztBQUVBO0FBQ0Q7O0FBRUQsWUFBSXlPLElBQUksS0FBSyxHQUFULElBQWdCQSxJQUFJLEtBQUssR0FBN0IsRUFBa0M7QUFDaENnQyx3QkFBYyxHQUFHLENBQUNBLGNBQWxCO0FBQ0E7QUFDRDs7QUFFRCxZQUFJaEMsSUFBSSxLQUFLLEdBQVQsSUFBZ0JBLElBQUksS0FBSyxHQUE3QixFQUFrQztBQUNoQ2lDLHVCQUFhLEdBQUcsQ0FBQ0EsYUFBakI7QUFDQTtBQUNEOztBQUVELFlBQUlqQyxJQUFJLEtBQUtoQyxhQUFhLENBQUMyRSxXQUEzQixFQUF3QztBQUN0QyxZQUFFclIsQ0FBRjtBQUNBME8sY0FBSSxHQUFHK0IsT0FBTyxDQUFDelEsQ0FBRCxDQUFkO0FBQ0EsY0FBSSxDQUFDME8sSUFBTCxFQUFXO0FBQ1h5QyxrQkFBUSxHQUFHLEtBQVg7QUFDRDs7QUFFRCxZQUFJRyxHQUFHLEdBQUdILFFBQVEsR0FBRyxJQUFJN0QsZ0JBQUosQ0FBMkI7QUFDOUM1QixnQkFBTSxFQUFFLElBRHNDO0FBRTlDZ0MsY0FBSSxFQUFFLEtBQUtBLElBRm1DO0FBRzlDQyx5QkFBZSxFQUFFLEtBQUtBLGVBSHdCO0FBSTlDbkIsY0FBSSxFQUFFK0QsSUFBSSxDQUFDN0IsSUFBRCxDQUpvQztBQUs5Q2pCLG9CQUFVLEVBQUVrRDtBQUxrQyxTQUEzQixDQUFILEdBTWIsSUFBSW5DLGdCQUFKLENBQTJCO0FBQzlCRSxjQUFJLEVBQUVBLElBRHdCO0FBRTlCRSxxQkFBVyxFQUFFOEI7QUFGaUIsU0FBM0IsQ0FOTDs7QUFXQSxhQUFLYixPQUFMLENBQWFwTCxJQUFiLENBQWtCNk0sR0FBbEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7QUE5RkMsR0FaeUIsRUE4R3pCO0FBQ0Q5USxPQUFHLEVBQUUsT0FESjs7QUFHRDs7O0FBR0FLLFNBQUssRUFBRSxTQUFTMEksS0FBVCxHQUFpQjtBQUN0QjNHLFVBQUksQ0FBQ3pCLGVBQWUsQ0FBQ3VMLGFBQWEsQ0FBQ2xOLFNBQWYsQ0FBaEIsRUFBMkMsT0FBM0MsRUFBb0QsSUFBcEQsQ0FBSixDQUE4RDJDLElBQTlELENBQW1FLElBQW5FOztBQUVBLFdBQUswTixPQUFMLENBQWEwQixPQUFiLENBQXFCLFVBQVUzTCxDQUFWLEVBQWE7QUFDaEMsZUFBT0EsQ0FBQyxDQUFDMkQsS0FBRixFQUFQO0FBQ0QsT0FGRDtBQUdEO0FBQ0Q7Ozs7QUFiQyxHQTlHeUIsRUErSHpCO0FBQ0QvSSxPQUFHLEVBQUUsVUFESjs7QUFHRDs7O0FBR0FLLFNBQUssRUFBRSxTQUFTNkksUUFBVCxHQUFvQjtBQUN6QixXQUFLbUcsT0FBTCxDQUFhMEIsT0FBYixDQUFxQixVQUFVM0wsQ0FBVixFQUFhO0FBQ2hDLGVBQU9BLENBQUMsQ0FBQzhELFFBQUYsRUFBUDtBQUNELE9BRkQ7O0FBSUE5RyxVQUFJLENBQUN6QixlQUFlLENBQUN1TCxhQUFhLENBQUNsTixTQUFmLENBQWhCLEVBQTJDLFVBQTNDLEVBQXVELElBQXZELENBQUosQ0FBaUUyQyxJQUFqRSxDQUFzRSxJQUF0RTtBQUNEO0FBQ0Q7Ozs7QUFiQyxHQS9IeUIsRUFnSnpCO0FBQ0QzQixPQUFHLEVBQUUsWUFESjs7QUFHRDs7O0FBR0FLLFNBQUssRUFBRSxTQUFTbUosVUFBVCxDQUFvQjdCLElBQXBCLEVBQTBCO0FBQy9CLGFBQU92RixJQUFJLENBQUN6QixlQUFlLENBQUN1TCxhQUFhLENBQUNsTixTQUFmLENBQWhCLEVBQTJDLFlBQTNDLEVBQXlELElBQXpELENBQUosQ0FBbUUyQyxJQUFuRSxDQUF3RSxJQUF4RSxFQUE4RWdHLElBQTlFLEVBQW9GTixTQUFwRixDQUE4RixLQUFLVSxrQkFBTCxFQUE5RixDQUFQO0FBQ0Q7QUFDRDs7OztBQVRDLEdBaEp5QixFQTZKekI7QUFDRC9ILE9BQUcsRUFBRSxnQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU29KLGNBQVQsQ0FBd0JDLEVBQXhCLEVBQTRCO0FBQ2pDLFVBQUlDLEtBQUssR0FBR3BDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBbUMsUUFBRSxHQUFHLEtBQUtFLFNBQUwsQ0FBZUYsRUFBZixFQUFtQkMsS0FBbkIsQ0FBTDs7QUFFQSxVQUFJcUgsU0FBUyxHQUFHLEtBQUsvQixjQUFMLENBQW9CLEtBQUs1TyxLQUFMLENBQVdaLE1BQS9CLENBQWhCOztBQUVBLFVBQUlzSCxPQUFPLEdBQUcsSUFBSUQsY0FBSixFQUFkO0FBQ0EsVUFBSSxDQUFDa0ssU0FBTCxFQUFnQixPQUFPakssT0FBUDs7QUFFaEIsV0FBSyxJQUFJa0ssRUFBRSxHQUFHRCxTQUFTLENBQUM3QixLQUF4QixHQUFnQyxFQUFFOEIsRUFBbEMsRUFBc0M7QUFDcEMsWUFBSUMsTUFBTSxHQUFHLEtBQUs3QixPQUFMLENBQWE0QixFQUFiLENBQWI7QUFDQSxZQUFJLENBQUNDLE1BQUwsRUFBYTs7QUFFYixZQUFJQyxZQUFZLEdBQUdELE1BQU0sQ0FBQ3JILFdBQVAsQ0FBbUJILEVBQW5CLEVBQXVCQyxLQUF2QixDQUFuQjs7QUFFQSxZQUFJeEMsSUFBSSxHQUFHZ0ssWUFBWSxDQUFDaEssSUFBeEI7QUFDQUosZUFBTyxDQUFDTSxTQUFSLENBQWtCOEosWUFBbEI7QUFDQSxZQUFJaEssSUFBSSxJQUFJZ0ssWUFBWSxDQUFDakssV0FBekIsRUFBc0MsTUFSRixDQVFTO0FBQzlDOztBQUVELGFBQU9ILE9BQVA7QUFDRDtBQUNEOzs7O0FBeEJDLEdBN0p5QixFQXlMekI7QUFDRC9HLE9BQUcsRUFBRSxhQURKO0FBRURLLFNBQUssRUFBRSxTQUFTa0osV0FBVCxHQUF1QjtBQUM1QixVQUFJNkgsTUFBTSxHQUFHLElBQWI7O0FBRUEsVUFBSS9ILE9BQU8sR0FBRzlCLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxDQUFsRjtBQUNBLFVBQUkrQixLQUFLLEdBQUcvQixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsS0FBS2xILEtBQUwsQ0FBV1osTUFBM0Y7QUFDQSxVQUFJNFIsU0FBUyxHQUFHLElBQUloRCxrQkFBSixFQUFoQjtBQUNBLFVBQUloRixPQUFPLEtBQUtDLEtBQWhCLEVBQXVCLE9BQU8rSCxTQUFQOztBQUV2QixXQUFLQyxxQkFBTCxDQUEyQmpJLE9BQTNCLEVBQW9DQyxLQUFwQyxFQUEyQyxVQUFVbEUsQ0FBVixFQUFhNkwsRUFBYixFQUFpQk0sUUFBakIsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQzVFLFlBQUlDLFVBQVUsR0FBR3JNLENBQUMsQ0FBQ21FLFdBQUYsQ0FBY2dJLFFBQWQsRUFBd0JDLE1BQXhCLENBQWpCO0FBQ0FDLGtCQUFVLENBQUNoSyxJQUFYLEdBQWtCMkosTUFBTSxDQUFDTSxlQUFQLENBQXVCVCxFQUF2QixDQUFsQjtBQUNBUSxrQkFBVSxDQUFDakssSUFBWCxHQUFrQjRKLE1BQU0sQ0FBQ08sY0FBUCxDQUFzQlYsRUFBdEIsQ0FBbEI7QUFDQSxZQUFJUSxVQUFVLFlBQVlwRCxrQkFBMUIsRUFBNkNvRCxVQUFVLENBQUMzQyxVQUFYLEdBQXdCbUMsRUFBeEI7QUFDN0NJLGlCQUFTLENBQUMzSixNQUFWLENBQWlCK0osVUFBakI7QUFDRCxPQU5EOztBQVFBLGFBQU9KLFNBQVA7QUFDRDtBQUNEOzs7O0FBcEJDLEdBekx5QixFQWlOekI7QUFDRHJSLE9BQUcsRUFBRSxjQURKO0FBRURLLFNBQUssRUFBRSxTQUFTK0ksWUFBVCxHQUF3QjtBQUM3QixVQUFJQyxPQUFPLEdBQUc5QixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsQ0FBbEY7QUFDQSxVQUFJK0IsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGO0FBQ0EsVUFBSWtLLEtBQUssR0FBR3BDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLFVBQUk4QixPQUFPLEtBQUtDLEtBQWhCLEVBQXVCLE9BQU8sRUFBUDtBQUN2QixVQUFJTCxLQUFLLEdBQUcsRUFBWjs7QUFFQSxXQUFLcUkscUJBQUwsQ0FBMkJqSSxPQUEzQixFQUFvQ0MsS0FBcEMsRUFBMkMsVUFBVWxFLENBQVYsRUFBYXdNLENBQWIsRUFBZ0J2SSxPQUFoQixFQUF5QkMsS0FBekIsRUFBZ0M7QUFDekVMLGFBQUssSUFBSTdELENBQUMsQ0FBQ2dFLFlBQUYsQ0FBZUMsT0FBZixFQUF3QkMsS0FBeEIsRUFBK0JLLEtBQS9CLENBQVQ7QUFDRCxPQUZEOztBQUlBLGFBQU9WLEtBQVA7QUFDRDtBQWRBLEdBak55QixFQWdPekI7QUFDRGpKLE9BQUcsRUFBRSxpQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3FSLGVBQVQsQ0FBeUI1QyxVQUF6QixFQUFxQztBQUMxQyxVQUFJK0MsVUFBSjs7QUFFQSxXQUFLLElBQUlDLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUcsS0FBSzFDLE1BQUwsQ0FBWTNQLE1BQWxDLEVBQTBDLEVBQUVxUyxFQUE1QyxFQUFnRDtBQUM5QyxZQUFJckssSUFBSSxHQUFHLEtBQUsySCxNQUFMLENBQVkwQyxFQUFaLENBQVg7QUFDQSxZQUFJckssSUFBSSxJQUFJcUgsVUFBWixFQUF3QitDLFVBQVUsR0FBR3BLLElBQWIsQ0FBeEIsS0FBK0M7QUFDaEQ7O0FBRUQsYUFBT29LLFVBQVA7QUFDRDtBQUNEOztBQVpDLEdBaE95QixFQThPekI7QUFDRDdSLE9BQUcsRUFBRSxvQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzBILGtCQUFULENBQTRCZ0ssWUFBNUIsRUFBMEM7QUFDL0MsVUFBSUMsTUFBTSxHQUFHLElBQWI7O0FBRUEsVUFBSWpMLE9BQU8sR0FBRyxJQUFJRCxjQUFKLEVBQWQ7QUFDQSxVQUFJLEtBQUtvRyxJQUFMLElBQWE2RSxZQUFZLElBQUksSUFBakMsRUFBdUMsT0FBT2hMLE9BQVA7O0FBRXZDLFVBQUlrTCxjQUFjLEdBQUcsS0FBS2hELGNBQUwsQ0FBb0IsS0FBSzVPLEtBQUwsQ0FBV1osTUFBL0IsQ0FBckI7O0FBRUEsVUFBSSxDQUFDd1MsY0FBTCxFQUFxQixPQUFPbEwsT0FBUDtBQUNyQixVQUFJbUwsZUFBZSxHQUFHRCxjQUFjLENBQUM5QyxLQUFyQztBQUNBLFVBQUlnRCxhQUFhLEdBQUdKLFlBQVksSUFBSSxJQUFoQixHQUF1QkEsWUFBdkIsR0FBc0MsS0FBSzFDLE9BQUwsQ0FBYTVQLE1BQXZFOztBQUVBLFdBQUs0UCxPQUFMLENBQWFsSixLQUFiLENBQW1CK0wsZUFBbkIsRUFBb0NDLGFBQXBDLEVBQW1EcEIsT0FBbkQsQ0FBMkQsVUFBVTNMLENBQVYsRUFBYTtBQUN0RSxZQUFJLENBQUNBLENBQUMsQ0FBQzhILElBQUgsSUFBVzZFLFlBQVksSUFBSSxJQUEvQixFQUFxQztBQUNuQztBQUNBLGNBQUlLLElBQUksR0FBR2hOLENBQUMsQ0FBQ2lLLE9BQUYsSUFBYSxJQUFiLEdBQW9CLENBQUNqSyxDQUFDLENBQUNpSyxPQUFGLENBQVU1UCxNQUFYLENBQXBCLEdBQXlDLEVBQXBEOztBQUVBLGNBQUk0UyxRQUFRLEdBQUdqTixDQUFDLENBQUMyQyxrQkFBRixDQUFxQnVGLEtBQXJCLENBQTJCbEksQ0FBM0IsRUFBOEJnTixJQUE5QixDQUFmOztBQUVBSixnQkFBTSxDQUFDeEosTUFBUCxJQUFpQjZKLFFBQVEsQ0FBQ3BMLFFBQTFCO0FBQ0FGLGlCQUFPLENBQUNNLFNBQVIsQ0FBa0JnTCxRQUFsQjtBQUNEO0FBQ0YsT0FWRDs7QUFZQSxhQUFPdEwsT0FBUDtBQUNEO0FBQ0Q7O0FBNUJDLEdBOU95QixFQTRRekI7QUFDRC9HLE9BQUcsRUFBRSxnQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzRPLGNBQVQsQ0FBd0JwSyxHQUF4QixFQUE2QjtBQUNsQyxVQUFJeU4sTUFBTSxHQUFHLEVBQWI7O0FBRUEsV0FBSyxJQUFJckIsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBRyxLQUFLNUIsT0FBTCxDQUFhNVAsTUFBbkMsRUFBMkMsRUFBRXdSLEVBQTdDLEVBQWlEO0FBQy9DLFlBQUlzQixPQUFPLEdBQUcsS0FBS2xELE9BQUwsQ0FBYTRCLEVBQWIsQ0FBZDtBQUNBLFlBQUl1QixhQUFhLEdBQUdGLE1BQU0sQ0FBQzdTLE1BQTNCO0FBQ0E2UyxjQUFNLElBQUlDLE9BQU8sQ0FBQ2xTLEtBQWxCOztBQUVBLFlBQUl3RSxHQUFHLElBQUl5TixNQUFNLENBQUM3UyxNQUFsQixFQUEwQjtBQUN4QixpQkFBTztBQUNMMFAsaUJBQUssRUFBRThCLEVBREY7QUFFTHdCLGtCQUFNLEVBQUU1TixHQUFHLEdBQUcyTjtBQUZULFdBQVA7QUFJRDtBQUNGO0FBQ0Y7QUFDRDs7QUFsQkMsR0E1UXlCLEVBZ1N6QjtBQUNEeFMsT0FBRyxFQUFFLGdCQURKO0FBRURLLFNBQUssRUFBRSxTQUFTc1IsY0FBVCxDQUF3QjdDLFVBQXhCLEVBQW9DO0FBQ3pDLGFBQU8sS0FBS08sT0FBTCxDQUFhbEosS0FBYixDQUFtQixDQUFuQixFQUFzQjJJLFVBQXRCLEVBQWtDNEQsTUFBbEMsQ0FBeUMsVUFBVTdOLEdBQVYsRUFBZU8sQ0FBZixFQUFrQjtBQUNoRSxlQUFPUCxHQUFHLElBQUlPLENBQUMsQ0FBQy9FLEtBQUYsQ0FBUVosTUFBdEI7QUFDRCxPQUZNLEVBRUosQ0FGSSxDQUFQO0FBR0Q7QUFDRDs7QUFQQyxHQWhTeUIsRUF5U3pCO0FBQ0RPLE9BQUcsRUFBRSx1QkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU2lSLHFCQUFULENBQStCakksT0FBL0IsRUFBd0M7QUFDN0MsVUFBSUMsS0FBSyxHQUFHL0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtsSCxLQUFMLENBQVdaLE1BQTNGO0FBQ0EsVUFBSWdMLEVBQUUsR0FBR2xELFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUI4SCxTQUFTLENBQUMsQ0FBRCxDQUFoQyxHQUFzQzNELFNBQS9DOztBQUVBLFVBQUkrTyxhQUFhLEdBQUcsS0FBSzFELGNBQUwsQ0FBb0I1RixPQUFwQixDQUFwQjs7QUFFQSxVQUFJc0osYUFBSixFQUFtQjtBQUNqQixZQUFJQyxXQUFXLEdBQUcsS0FBSzNELGNBQUwsQ0FBb0IzRixLQUFwQixDQUFsQixDQURpQixDQUM2Qjs7O0FBRzlDLFlBQUl1SixXQUFXLEdBQUdELFdBQVcsSUFBSUQsYUFBYSxDQUFDeEQsS0FBZCxLQUF3QnlELFdBQVcsQ0FBQ3pELEtBQXJFO0FBQ0EsWUFBSTJELGlCQUFpQixHQUFHSCxhQUFhLENBQUNGLE1BQXRDO0FBQ0EsWUFBSU0sZUFBZSxHQUFHSCxXQUFXLElBQUlDLFdBQWYsR0FBNkJELFdBQVcsQ0FBQ0gsTUFBekMsR0FBa0QsS0FBS3BELE9BQUwsQ0FBYXNELGFBQWEsQ0FBQ3hELEtBQTNCLEVBQWtDOU8sS0FBbEMsQ0FBd0NaLE1BQWhIO0FBQ0FnTCxVQUFFLENBQUMsS0FBSzRFLE9BQUwsQ0FBYXNELGFBQWEsQ0FBQ3hELEtBQTNCLENBQUQsRUFBb0N3RCxhQUFhLENBQUN4RCxLQUFsRCxFQUF5RDJELGlCQUF6RCxFQUE0RUMsZUFBNUUsQ0FBRjs7QUFFQSxZQUFJSCxXQUFXLElBQUksQ0FBQ0MsV0FBcEIsRUFBaUM7QUFDL0I7QUFDQSxlQUFLLElBQUk1QixFQUFFLEdBQUcwQixhQUFhLENBQUN4RCxLQUFkLEdBQXNCLENBQXBDLEVBQXVDOEIsRUFBRSxHQUFHMkIsV0FBVyxDQUFDekQsS0FBeEQsRUFBK0QsRUFBRThCLEVBQWpFLEVBQXFFO0FBQ25FeEcsY0FBRSxDQUFDLEtBQUs0RSxPQUFMLENBQWE0QixFQUFiLENBQUQsRUFBbUJBLEVBQW5CLEVBQXVCLENBQXZCLEVBQTBCLEtBQUs1QixPQUFMLENBQWE0QixFQUFiLEVBQWlCNVEsS0FBakIsQ0FBdUJaLE1BQWpELENBQUY7QUFDRCxXQUo4QixDQUk3Qjs7O0FBR0ZnTCxZQUFFLENBQUMsS0FBSzRFLE9BQUwsQ0FBYXVELFdBQVcsQ0FBQ3pELEtBQXpCLENBQUQsRUFBa0N5RCxXQUFXLENBQUN6RCxLQUE5QyxFQUFxRCxDQUFyRCxFQUF3RHlELFdBQVcsQ0FBQ0gsTUFBcEUsQ0FBRjtBQUNEO0FBQ0Y7QUFDRjtBQUNEOzs7O0FBNUJDLEdBelN5QixFQXlVekI7QUFDRHpTLE9BQUcsRUFBRSxRQURKO0FBRURLLFNBQUssRUFBRSxTQUFTbUssTUFBVCxHQUFrQjtBQUN2QixVQUFJbkIsT0FBTyxHQUFHOUIsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLENBQWxGO0FBQ0EsVUFBSStCLEtBQUssR0FBRy9CLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxLQUFLbEgsS0FBTCxDQUFXWixNQUEzRjs7QUFFQSxVQUFJdVQsYUFBYSxHQUFHNVEsSUFBSSxDQUFDekIsZUFBZSxDQUFDdUwsYUFBYSxDQUFDbE4sU0FBZixDQUFoQixFQUEyQyxRQUEzQyxFQUFxRCxJQUFyRCxDQUFKLENBQStEMkMsSUFBL0QsQ0FBb0UsSUFBcEUsRUFBMEUwSCxPQUExRSxFQUFtRkMsS0FBbkYsQ0FBcEI7O0FBRUEsV0FBS2dJLHFCQUFMLENBQTJCakksT0FBM0IsRUFBb0NDLEtBQXBDLEVBQTJDLFVBQVVsRSxDQUFWLEVBQWF3TSxDQUFiLEVBQWdCTCxRQUFoQixFQUEwQkMsTUFBMUIsRUFBa0M7QUFDM0V3QixxQkFBYSxDQUFDM0wsU0FBZCxDQUF3QmpDLENBQUMsQ0FBQ29GLE1BQUYsQ0FBUytHLFFBQVQsRUFBbUJDLE1BQW5CLENBQXhCO0FBQ0QsT0FGRDs7QUFJQSxhQUFPd0IsYUFBUDtBQUNEO0FBQ0Q7Ozs7QUFkQyxHQXpVeUIsRUEyVnpCO0FBQ0RoVCxPQUFHLEVBQUUsaUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4SSxlQUFULENBQXlCbkQsU0FBekIsRUFBb0M7QUFDekMsVUFBSWxCLFNBQVMsR0FBR3lDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRWpELFNBQVMsQ0FBQ0MsSUFBOUYsQ0FEeUMsQ0FFekM7O0FBQ0EsVUFBSTBPLGNBQWMsR0FBRyxLQUFLaEUsY0FBTCxDQUFvQmpKLFNBQXBCLEtBQWtDO0FBQ3JEbUosYUFBSyxFQUFFLENBRDhDO0FBRXJEc0QsY0FBTSxFQUFFO0FBRjZDLE9BQXZEO0FBSUEsVUFBSVMsZ0JBQWdCLEdBQUdELGNBQWMsQ0FBQ1IsTUFBdEM7QUFBQSxVQUNJVSxlQUFlLEdBQUdGLGNBQWMsQ0FBQzlELEtBRHJDO0FBRUEsVUFBSWlFLFVBQVUsR0FBRyxLQUFLL0QsT0FBTCxDQUFhOEQsZUFBYixDQUFqQjtBQUNBLFVBQUksQ0FBQ0MsVUFBTCxFQUFpQixPQUFPcE4sU0FBUDtBQUNqQixVQUFJcU4sbUJBQW1CLEdBQUdILGdCQUExQixDQVh5QyxDQVdHOztBQUU1QyxVQUFJRyxtQkFBbUIsS0FBSyxDQUF4QixJQUE2QkEsbUJBQW1CLEdBQUdELFVBQVUsQ0FBQy9TLEtBQVgsQ0FBaUJaLE1BQXhFLEVBQWdGO0FBQzlFNFQsMkJBQW1CLEdBQUdELFVBQVUsQ0FBQ2pLLGVBQVgsQ0FBMkIrSixnQkFBM0IsRUFBNkNsTyxjQUFjLENBQUNGLFNBQUQsQ0FBM0QsQ0FBdEI7QUFDRDs7QUFFRCxVQUFJd08sYUFBYSxHQUFHRCxtQkFBbUIsS0FBS0QsVUFBVSxDQUFDL1MsS0FBWCxDQUFpQlosTUFBN0Q7QUFDQSxVQUFJOFQsWUFBWSxHQUFHRixtQkFBbUIsS0FBSyxDQUEzQyxDQWxCeUMsQ0FrQks7O0FBRTlDLFVBQUksQ0FBQ0UsWUFBRCxJQUFpQixDQUFDRCxhQUF0QixFQUFxQyxPQUFPLEtBQUszQixjQUFMLENBQW9Cd0IsZUFBcEIsSUFBdUNFLG1CQUE5QztBQUNyQyxVQUFJRyxnQkFBZ0IsR0FBR0YsYUFBYSxHQUFHSCxlQUFlLEdBQUcsQ0FBckIsR0FBeUJBLGVBQTdEOztBQUVBLFVBQUlyTyxTQUFTLEtBQUtSLFNBQVMsQ0FBQ0MsSUFBNUIsRUFBa0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSWlQLGdCQUFnQixHQUFHLENBQXZCLEVBQTBCO0FBQ3hCLGNBQUlDLGdCQUFnQixHQUFHRCxnQkFBZ0IsR0FBRyxDQUExQztBQUNBLGNBQUlFLFdBQVcsR0FBRyxLQUFLckUsT0FBTCxDQUFhb0UsZ0JBQWIsQ0FBbEI7QUFDQSxjQUFJRSxhQUFhLEdBQUdELFdBQVcsQ0FBQ3ZLLGVBQVosQ0FBNEIsQ0FBNUIsRUFBK0I3RSxTQUFTLENBQUNDLElBQXpDLENBQXBCLENBSHdCLENBRzRDOztBQUVwRSxjQUFJLENBQUNtUCxXQUFXLENBQUNyVCxLQUFaLENBQWtCWixNQUFuQixJQUE2QmtVLGFBQWEsS0FBS0QsV0FBVyxDQUFDclQsS0FBWixDQUFrQlosTUFBckUsRUFBNkU7QUFDM0UsbUJBQU8sS0FBS2tTLGNBQUwsQ0FBb0I2QixnQkFBcEIsQ0FBUDtBQUNEO0FBQ0YsU0FsQitCLENBa0I5Qjs7O0FBR0YsWUFBSUksaUJBQWlCLEdBQUdKLGdCQUF4Qjs7QUFFQSxhQUFLLElBQUl2QyxFQUFFLEdBQUcyQyxpQkFBZCxFQUFpQzNDLEVBQUUsR0FBRyxLQUFLNUIsT0FBTCxDQUFhNVAsTUFBbkQsRUFBMkQsRUFBRXdSLEVBQTdELEVBQWlFO0FBQy9ELGNBQUk0QyxZQUFZLEdBQUcsS0FBS3hFLE9BQUwsQ0FBYTRCLEVBQWIsQ0FBbkI7O0FBRUEsY0FBSTZDLGNBQWMsR0FBR0QsWUFBWSxDQUFDMUssZUFBYixDQUE2QixDQUE3QixFQUFnQzdFLFNBQVMsQ0FBQ0MsSUFBMUMsQ0FBckI7O0FBRUEsY0FBSSxDQUFDc1AsWUFBWSxDQUFDeFQsS0FBYixDQUFtQlosTUFBcEIsSUFBOEJxVSxjQUFjLEtBQUtELFlBQVksQ0FBQ3hULEtBQWIsQ0FBbUJaLE1BQXhFLEVBQWdGO0FBQzlFLG1CQUFPLEtBQUtrUyxjQUFMLENBQW9CVixFQUFwQixJQUEwQjZDLGNBQWpDO0FBQ0Q7QUFDRixTQS9CK0IsQ0ErQjlCO0FBQ0Y7OztBQUdBLGFBQUssSUFBSUMsR0FBRyxHQUFHUCxnQkFBZ0IsR0FBRyxDQUFsQyxFQUFxQ08sR0FBRyxJQUFJLENBQTVDLEVBQStDLEVBQUVBLEdBQWpELEVBQXNEO0FBQ3BELGNBQUlDLE9BQU8sR0FBRyxLQUFLM0UsT0FBTCxDQUFhMEUsR0FBYixDQUFkOztBQUVBLGNBQUlFLGVBQWUsR0FBR0QsT0FBTyxDQUFDN0ssZUFBUixDQUF3QixDQUF4QixFQUEyQjdFLFNBQVMsQ0FBQ0MsSUFBckMsQ0FBdEIsQ0FIb0QsQ0FHYzs7O0FBR2xFLGNBQUksQ0FBQ3lQLE9BQU8sQ0FBQzNULEtBQVIsQ0FBY1osTUFBZixJQUF5QndVLGVBQWUsS0FBS0QsT0FBTyxDQUFDM1QsS0FBUixDQUFjWixNQUEvRCxFQUF1RTtBQUNyRSxtQkFBTyxLQUFLa1MsY0FBTCxDQUFvQm9DLEdBQXBCLElBQTJCQyxPQUFPLENBQUMzVCxLQUFSLENBQWNaLE1BQWhEO0FBQ0Q7QUFDRjs7QUFFRCxlQUFPdUcsU0FBUDtBQUNEOztBQUVELFVBQUlsQixTQUFTLEtBQUtSLFNBQVMsQ0FBQ0UsSUFBeEIsSUFBZ0NNLFNBQVMsS0FBS1IsU0FBUyxDQUFDRyxVQUE1RCxFQUF3RTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSXlQLDRCQUFKOztBQUVBLGFBQUssSUFBSUMsSUFBSSxHQUFHWCxnQkFBaEIsRUFBa0NXLElBQUksR0FBRyxLQUFLOUUsT0FBTCxDQUFhNVAsTUFBdEQsRUFBOEQsRUFBRTBVLElBQWhFLEVBQXNFO0FBQ3BFLGNBQUksS0FBSzlFLE9BQUwsQ0FBYThFLElBQWIsRUFBbUI5VCxLQUF2QixFQUE4QjtBQUM1QjZULHdDQUE0QixHQUFHQyxJQUEvQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJRCw0QkFBNEIsSUFBSSxJQUFwQyxFQUEwQztBQUN4QyxjQUFJRSxXQUFXLEdBQUcsS0FBSy9FLE9BQUwsQ0FBYTZFLDRCQUFiLENBQWxCOztBQUVBLGNBQUlHLGVBQWUsR0FBR0QsV0FBVyxDQUFDakwsZUFBWixDQUE0QixDQUE1QixFQUErQjdFLFNBQVMsQ0FBQ0ksS0FBekMsQ0FBdEI7O0FBRUEsY0FBSTJQLGVBQWUsS0FBSyxDQUFwQixJQUF5QkQsV0FBVyxDQUFDckcsYUFBWixDQUEwQnRPLE1BQXZELEVBQStEO0FBQzdEO0FBQ0EsbUJBQU8sS0FBS2tTLGNBQUwsQ0FBb0J1Qyw0QkFBcEIsSUFBb0RHLGVBQTNEO0FBQ0Q7QUFDRixTQTNCcUUsQ0EyQnBFO0FBQ0Y7OztBQUdBLFlBQUlDLDBCQUEwQixHQUFHLENBQUMsQ0FBbEM7QUFDQSxZQUFJQyx5QkFBSixDQWhDc0UsQ0FnQ3ZDOztBQUUvQixhQUFLLElBQUlDLElBQUksR0FBR2hCLGdCQUFnQixHQUFHLENBQW5DLEVBQXNDZ0IsSUFBSSxJQUFJLENBQTlDLEVBQWlELEVBQUVBLElBQW5ELEVBQXlEO0FBQ3ZELGNBQUlDLE9BQU8sR0FBRyxLQUFLcEYsT0FBTCxDQUFhbUYsSUFBYixDQUFkOztBQUVBLGNBQUlFLGVBQWUsR0FBR0QsT0FBTyxDQUFDdEwsZUFBUixDQUF3QnNMLE9BQU8sQ0FBQ3BVLEtBQVIsQ0FBY1osTUFBdEMsRUFBOEM2RSxTQUFTLENBQUNHLFVBQXhELENBQXRCOztBQUVBLGNBQUksQ0FBQ2dRLE9BQU8sQ0FBQ3BVLEtBQVQsSUFBa0JxVSxlQUFlLEtBQUssQ0FBMUMsRUFBNkNILHlCQUF5QixHQUFHQyxJQUE1Qjs7QUFFN0MsY0FBSUUsZUFBZSxLQUFLLENBQXhCLEVBQTJCO0FBQ3pCLGdCQUFJQSxlQUFlLEtBQUtELE9BQU8sQ0FBQ3BVLEtBQVIsQ0FBY1osTUFBdEMsRUFBOEM7QUFDNUM7QUFDQSxxQkFBTyxLQUFLa1MsY0FBTCxDQUFvQjZDLElBQXBCLElBQTRCRSxlQUFuQztBQUNELGFBSEQsTUFHTztBQUNMO0FBQ0FKLHdDQUEwQixHQUFHRSxJQUE3QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFlBQUkxUCxTQUFTLEtBQUtSLFNBQVMsQ0FBQ0UsSUFBNUIsRUFBa0M7QUFDaEM7QUFDQSxlQUFLLElBQUltUSxJQUFJLEdBQUdMLDBCQUEwQixHQUFHLENBQTdDLEVBQWdESyxJQUFJLElBQUlyTyxJQUFJLENBQUNDLEdBQUwsQ0FBU2lOLGdCQUFULEVBQTJCLEtBQUtuRSxPQUFMLENBQWE1UCxNQUFiLEdBQXNCLENBQWpELENBQXhELEVBQTZHLEVBQUVrVixJQUEvRyxFQUFxSDtBQUNuSCxnQkFBSUMsT0FBTyxHQUFHLEtBQUt2RixPQUFMLENBQWFzRixJQUFiLENBQWQ7O0FBRUEsZ0JBQUlFLGVBQWUsR0FBR0QsT0FBTyxDQUFDekwsZUFBUixDQUF3QixDQUF4QixFQUEyQjdFLFNBQVMsQ0FBQ0MsSUFBckMsQ0FBdEI7O0FBRUEsZ0JBQUl1USxlQUFlLEdBQUcsS0FBS25ELGNBQUwsQ0FBb0JnRCxJQUFwQixJQUE0QkUsZUFBbEQ7O0FBRUEsZ0JBQUlDLGVBQWUsR0FBRzlPLFNBQXRCLEVBQWlDLE1BUGtGLENBTzNFOztBQUV4QyxnQkFBSTZPLGVBQWUsS0FBS0QsT0FBTyxDQUFDdlUsS0FBUixDQUFjWixNQUF0QyxFQUE4QyxPQUFPcVYsZUFBUDtBQUMvQztBQUNGLFNBbEVxRSxDQWtFcEU7OztBQUdGLFlBQUlSLDBCQUEwQixJQUFJLENBQWxDLEVBQXFDO0FBQ25DLGlCQUFPLEtBQUszQyxjQUFMLENBQW9CMkMsMEJBQXBCLElBQWtELEtBQUtqRixPQUFMLENBQWFpRiwwQkFBYixFQUF5Q2pVLEtBQXpDLENBQStDWixNQUF4RztBQUNELFNBdkVxRSxDQXVFcEU7OztBQUdGLFlBQUlxRixTQUFTLEtBQUtSLFNBQVMsQ0FBQ0csVUFBeEIsSUFBc0MsS0FBS3lJLElBQUwsSUFBYSxDQUFDLEtBQUs5RCxZQUFMLEVBQWQsSUFBcUMsQ0FBQzJMLE9BQU8sQ0FBQyxLQUFLMUYsT0FBTCxDQUFhbUUsZ0JBQWIsQ0FBRCxDQUF2RixFQUF5SDtBQUN2SCxpQkFBTyxDQUFQO0FBQ0Q7O0FBRUQsWUFBSWUseUJBQXlCLElBQUksSUFBakMsRUFBdUM7QUFDckMsaUJBQU8sS0FBSzVDLGNBQUwsQ0FBb0I0Qyx5QkFBcEIsQ0FBUDtBQUNELFNBaEZxRSxDQWdGcEU7OztBQUdGLGFBQUssSUFBSVMsSUFBSSxHQUFHeEIsZ0JBQWhCLEVBQWtDd0IsSUFBSSxHQUFHLEtBQUszRixPQUFMLENBQWE1UCxNQUF0RCxFQUE4RCxFQUFFdVYsSUFBaEUsRUFBc0U7QUFDcEUsY0FBSUMsT0FBTyxHQUFHLEtBQUs1RixPQUFMLENBQWEyRixJQUFiLENBQWQ7O0FBRUEsY0FBSUUsZUFBZSxHQUFHRCxPQUFPLENBQUM5TCxlQUFSLENBQXdCLENBQXhCLEVBQTJCN0UsU0FBUyxDQUFDQyxJQUFyQyxDQUF0QixDQUhvRSxDQUdGOzs7QUFHbEUsY0FBSSxDQUFDMFEsT0FBTyxDQUFDNVUsS0FBUixDQUFjWixNQUFmLElBQXlCeVYsZUFBZSxLQUFLRCxPQUFPLENBQUM1VSxLQUFSLENBQWNaLE1BQS9ELEVBQXVFO0FBQ3JFLG1CQUFPLEtBQUtrUyxjQUFMLENBQW9CcUQsSUFBcEIsSUFBNEJFLGVBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxlQUFPLENBQVA7QUFDRDs7QUFFRCxVQUFJcFEsU0FBUyxLQUFLUixTQUFTLENBQUNJLEtBQXhCLElBQWlDSSxTQUFTLEtBQUtSLFNBQVMsQ0FBQ0ssV0FBN0QsRUFBMEU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUl3USwyQkFBSjtBQUNBLFlBQUlDLHlCQUFKOztBQUVBLGFBQUssSUFBSUMsSUFBSSxHQUFHN0IsZ0JBQWhCLEVBQWtDNkIsSUFBSSxHQUFHLEtBQUtoRyxPQUFMLENBQWE1UCxNQUF0RCxFQUE4RCxFQUFFNFYsSUFBaEUsRUFBc0U7QUFDcEUsY0FBSUMsT0FBTyxHQUFHLEtBQUtqRyxPQUFMLENBQWFnRyxJQUFiLENBQWQ7O0FBRUEsY0FBSUUsZUFBZSxHQUFHRCxPQUFPLENBQUNuTSxlQUFSLENBQXdCLENBQXhCLEVBQTJCN0UsU0FBUyxDQUFDQyxJQUFyQyxDQUF0Qjs7QUFFQSxjQUFJZ1IsZUFBZSxLQUFLRCxPQUFPLENBQUNqVixLQUFSLENBQWNaLE1BQXRDLEVBQThDO0FBQzVDMlYscUNBQXlCLEdBQUcsS0FBS3pELGNBQUwsQ0FBb0IwRCxJQUFwQixJQUE0QkUsZUFBeEQ7QUFDQUosdUNBQTJCLEdBQUdFLElBQTlCO0FBQ0E7QUFDRDtBQUNGOztBQUVELFlBQUlGLDJCQUEyQixJQUFJLElBQS9CLElBQXVDQyx5QkFBeUIsSUFBSSxJQUF4RSxFQUE4RTtBQUM1RSxlQUFLLElBQUlJLElBQUksR0FBR0wsMkJBQWhCLEVBQTZDSyxJQUFJLEdBQUcsS0FBS25HLE9BQUwsQ0FBYTVQLE1BQWpFLEVBQXlFLEVBQUUrVixJQUEzRSxFQUFpRjtBQUMvRSxnQkFBSUMsT0FBTyxHQUFHLEtBQUtwRyxPQUFMLENBQWFtRyxJQUFiLENBQWQ7O0FBRUEsZ0JBQUlFLGVBQWUsR0FBR0QsT0FBTyxDQUFDdE0sZUFBUixDQUF3QixDQUF4QixFQUEyQjdFLFNBQVMsQ0FBQ0ssV0FBckMsQ0FBdEI7O0FBRUEsZ0JBQUkrUSxlQUFlLEtBQUtELE9BQU8sQ0FBQ3BWLEtBQVIsQ0FBY1osTUFBdEMsRUFBOEM7QUFDNUMscUJBQU8sS0FBS2tTLGNBQUwsQ0FBb0I2RCxJQUFwQixJQUE0QkUsZUFBbkM7QUFDRDtBQUNGOztBQUVELGlCQUFPNVEsU0FBUyxLQUFLUixTQUFTLENBQUNLLFdBQXhCLEdBQXNDLEtBQUt0RSxLQUFMLENBQVdaLE1BQWpELEdBQTBEMlYseUJBQWpFO0FBQ0Q7O0FBRUQsYUFBSyxJQUFJTyxJQUFJLEdBQUdyUCxJQUFJLENBQUNDLEdBQUwsQ0FBU2lOLGdCQUFULEVBQTJCLEtBQUtuRSxPQUFMLENBQWE1UCxNQUFiLEdBQXNCLENBQWpELENBQWhCLEVBQXFFa1csSUFBSSxJQUFJLENBQTdFLEVBQWdGLEVBQUVBLElBQWxGLEVBQXdGO0FBQ3RGLGNBQUlDLE9BQU8sR0FBRyxLQUFLdkcsT0FBTCxDQUFhc0csSUFBYixDQUFkOztBQUVBLGNBQUlFLGVBQWUsR0FBR0QsT0FBTyxDQUFDek0sZUFBUixDQUF3QnlNLE9BQU8sQ0FBQ3ZWLEtBQVIsQ0FBY1osTUFBdEMsRUFBOEM2RSxTQUFTLENBQUNFLElBQXhELENBQXRCOztBQUVBLGNBQUlxUixlQUFlLEtBQUssQ0FBeEIsRUFBMkI7QUFDekIsZ0JBQUlDLFVBQVUsR0FBRyxLQUFLbkUsY0FBTCxDQUFvQmdFLElBQXBCLElBQTRCRSxlQUE3Qzs7QUFFQSxnQkFBSUMsVUFBVSxJQUFJOVAsU0FBbEIsRUFBNkIsT0FBTzhQLFVBQVA7QUFDN0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBTzlQLFNBQVA7QUFDRDtBQUNEOztBQTlOQyxHQTNWeUIsRUEyakJ6QjtBQUNEaEcsT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVNxUSxXQUFULENBQXFCcUYsSUFBckIsRUFBMkI7QUFDaEMsYUFBTyxLQUFLQyxZQUFMLENBQWtCRCxJQUFsQixFQUF3QixDQUF4QixDQUFQO0FBQ0Q7QUFDRDs7QUFMQyxHQTNqQnlCLEVBa2tCekI7QUFDRC9WLE9BQUcsRUFBRSxjQURKO0FBRURLLFNBQUssRUFBRSxTQUFTMlYsWUFBVCxDQUFzQkQsSUFBdEIsRUFBNEI7QUFDakMsVUFBSUUsTUFBTSxHQUFHLElBQWI7O0FBRUEsVUFBSUMsT0FBTyxHQUFHLEtBQUtsRyxhQUFMLENBQW1CK0YsSUFBbkIsQ0FBZDtBQUNBLFVBQUksQ0FBQ0csT0FBTCxFQUFjLE9BQU8sRUFBUDtBQUNkLGFBQU9BLE9BQU8sQ0FBQzNILEdBQVIsQ0FBWSxVQUFVNEgsRUFBVixFQUFjO0FBQy9CLGVBQU9GLE1BQU0sQ0FBQzVHLE9BQVAsQ0FBZThHLEVBQWYsQ0FBUDtBQUNELE9BRk0sQ0FBUDtBQUdEO0FBVkEsR0Fsa0J5QixFQTZrQnpCO0FBQ0RuVyxPQUFHLEVBQUUsT0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPekMsTUFBTSxDQUFDa0gsTUFBUCxDQUFjLEVBQWQsRUFBa0I1RSxJQUFJLENBQUN6QixlQUFlLENBQUN1TCxhQUFhLENBQUNsTixTQUFmLENBQWhCLEVBQTJDLE9BQTNDLEVBQW9ELElBQXBELENBQXRCLEVBQWlGO0FBQ3RGcVEsZUFBTyxFQUFFLEtBQUtBLE9BQUwsQ0FBYWQsR0FBYixDQUFpQixVQUFVbkosQ0FBVixFQUFhO0FBQ3JDLGlCQUFPQSxDQUFDLENBQUM4QyxLQUFUO0FBQ0QsU0FGUTtBQUQ2RSxPQUFqRixDQUFQO0FBS0QsS0FSQTtBQVNEdkYsT0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYXVGLEtBQWIsRUFBb0I7QUFDdkIsVUFBSW1ILE9BQU8sR0FBR25ILEtBQUssQ0FBQ21ILE9BQXBCO0FBQUEsVUFDSStHLFdBQVcsR0FBRzdVLHdCQUF3QixDQUFDMkcsS0FBRCxFQUFRLENBQUMsU0FBRCxDQUFSLENBRDFDOztBQUdBLFdBQUttSCxPQUFMLENBQWEwQixPQUFiLENBQXFCLFVBQVUzTCxDQUFWLEVBQWE2TCxFQUFiLEVBQWlCO0FBQ3BDLGVBQU83TCxDQUFDLENBQUM4QyxLQUFGLEdBQVVtSCxPQUFPLENBQUM0QixFQUFELENBQXhCO0FBQ0QsT0FGRDs7QUFJQXJPLFVBQUksQ0FBQ2pDLGVBQWUsQ0FBQ3VMLGFBQWEsQ0FBQ2xOLFNBQWYsQ0FBaEIsRUFBMkMsT0FBM0MsRUFBb0RvWCxXQUFwRCxFQUFpRSxJQUFqRSxFQUF1RSxJQUF2RSxDQUFKO0FBQ0Q7QUFsQkEsR0E3a0J5QixFQWdtQnpCO0FBQ0RwVyxPQUFHLEVBQUUsWUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUs4TSxPQUFMLENBQWFnSCxLQUFiLENBQW1CLFVBQVVqUixDQUFWLEVBQWE7QUFDckMsZUFBT0EsQ0FBQyxDQUFDd0ksVUFBVDtBQUNELE9BRk0sQ0FBUDtBQUdEO0FBTkEsR0FobUJ5QixFQXVtQnpCO0FBQ0Q1TixPQUFHLEVBQUUsZUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUs4TSxPQUFMLENBQWFxRCxNQUFiLENBQW9CLFVBQVV0TyxHQUFWLEVBQWVnQixDQUFmLEVBQWtCO0FBQzNDLGVBQU9oQixHQUFHLElBQUlnQixDQUFDLENBQUMySSxhQUFoQjtBQUNELE9BRk0sRUFFSixFQUZJLENBQVA7QUFHRCxLQU5BO0FBT0RwTCxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhb0wsYUFBYixFQUE0QjtBQUMvQm5MLFVBQUksQ0FBQ2pDLGVBQWUsQ0FBQ3VMLGFBQWEsQ0FBQ2xOLFNBQWYsQ0FBaEIsRUFBMkMsZUFBM0MsRUFBNEQrTyxhQUE1RCxFQUEyRSxJQUEzRSxFQUFpRixJQUFqRixDQUFKO0FBQ0Q7QUFDRDs7OztBQVZDLEdBdm1CeUIsRUFxbkJ6QjtBQUNEL04sT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEI7QUFDQSxhQUFPLEtBQUs4TSxPQUFMLENBQWFxRCxNQUFiLENBQW9CLFVBQVV0TyxHQUFWLEVBQWVnQixDQUFmLEVBQWtCO0FBQzNDLGVBQU9oQixHQUFHLElBQUlnQixDQUFDLENBQUMvRSxLQUFoQjtBQUNELE9BRk0sRUFFSixFQUZJLENBQVA7QUFHRCxLQVBBO0FBUURzQyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdEMsS0FBYixFQUFvQjtBQUN2QnVDLFVBQUksQ0FBQ2pDLGVBQWUsQ0FBQ3VMLGFBQWEsQ0FBQ2xOLFNBQWYsQ0FBaEIsRUFBMkMsT0FBM0MsRUFBb0RxQixLQUFwRCxFQUEyRCxJQUEzRCxFQUFpRSxJQUFqRSxDQUFKO0FBQ0Q7QUFWQSxHQXJuQnlCLENBQWhCLENBQVo7O0FBa29CQSxTQUFPNkwsYUFBUDtBQUNELENBNXBCRCxDQTRwQkUzRCxJQTVwQkYsQ0FGQTs7QUErcEJBMkQscUJBQWEsQ0FBQ3hELFFBQWQsR0FBeUI7QUFDdkJ3RSxNQUFJLEVBQUUsSUFEaUI7QUFFdkJDLGlCQUFlLEVBQUU7QUFGTSxDQUF6QjtBQUlBakIscUJBQWEsQ0FBQzBFLFNBQWQsR0FBMEIsR0FBMUI7QUFDQTFFLHFCQUFhLENBQUMyRSxXQUFkLEdBQTRCLElBQTVCO0FBQ0EzRSxxQkFBYSxDQUFDb0ssZUFBZCxHQUFnQ3hKLGdCQUFoQztBQUNBWixxQkFBYSxDQUFDcUssZUFBZCxHQUFnQ3ZJLGdCQUFoQzs7QUFFQSxTQUFTK0csT0FBVCxDQUFpQnlCLEtBQWpCLEVBQXdCO0FBQ3RCLE1BQUksQ0FBQ0EsS0FBTCxFQUFZLE9BQU8sS0FBUDtBQUNaLE1BQUluVyxLQUFLLEdBQUdtVyxLQUFLLENBQUNuVyxLQUFsQjtBQUNBLFNBQU8sQ0FBQ0EsS0FBRCxJQUFVbVcsS0FBSyxDQUFDck4sZUFBTixDQUFzQixDQUF0QixFQUF5QjdFLFNBQVMsQ0FBQ0MsSUFBbkMsTUFBNkNsRSxLQUFLLENBQUNaLE1BQXBFO0FBQ0Q7O0FBRUQwSSxNQUFLLENBQUMrRCxhQUFOLEdBQXNCQSxxQkFBdEI7QUFFZUEsd0VBQWYsRTs7QUNwc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUl1SyxpQkFBVyxHQUNmLGFBQ0EsVUFBVUMsY0FBVixFQUEwQjtBQUN4QnBXLFdBQVMsQ0FBQ21XLFdBQUQsRUFBY0MsY0FBZCxDQUFUOztBQUVBLFdBQVNELFdBQVQsR0FBdUI7QUFDckJ4WCxtQkFBZSxDQUFDLElBQUQsRUFBT3dYLFdBQVAsQ0FBZjs7QUFFQSxXQUFPMVUsMEJBQTBCLENBQUMsSUFBRCxFQUFPcEIsZUFBZSxDQUFDOFYsV0FBRCxDQUFmLENBQTZCbkosS0FBN0IsQ0FBbUMsSUFBbkMsRUFBeUMvRixTQUF6QyxDQUFQLENBQWpDO0FBQ0Q7O0FBRUR0SCxjQUFZLENBQUN3VyxXQUFELEVBQWMsQ0FBQztBQUN6QnpXLE9BQUcsRUFBRSxTQURvQjs7QUFHekI7OztBQUdBSyxTQUFLLEVBQUUsU0FBU29JLE9BQVQsQ0FBaUJKLElBQWpCLEVBQXVCO0FBQzVCO0FBQ0FBLFVBQUksR0FBR3ZJLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYztBQUNuQjJQLFVBQUUsRUFBRSxLQUFLQSxFQUFMLElBQVcsQ0FESTtBQUVuQm5QLFlBQUksRUFBRSxLQUFLQSxJQUFMLElBQWE7QUFGQSxPQUFkLEVBR0phLElBSEksQ0FBUDtBQUlBLFVBQUl1TyxTQUFTLEdBQUd2UyxNQUFNLENBQUNnRSxJQUFJLENBQUNzTyxFQUFOLENBQU4sQ0FBZ0JsWCxNQUFoQztBQUNBLFVBQUk0SSxJQUFJLENBQUN1TyxTQUFMLElBQWtCLElBQXRCLEVBQTRCQSxTQUFTLEdBQUd0USxJQUFJLENBQUNJLEdBQUwsQ0FBU2tRLFNBQVQsRUFBb0J2TyxJQUFJLENBQUN1TyxTQUF6QixDQUFaO0FBQzVCdk8sVUFBSSxDQUFDdU8sU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxVQUFJQyxPQUFPLEdBQUd4UyxNQUFNLENBQUNnRSxJQUFJLENBQUNiLElBQU4sQ0FBTixDQUFrQnNQLFFBQWxCLENBQTJCRixTQUEzQixFQUFzQyxHQUF0QyxDQUFkO0FBQ0EsVUFBSUcsS0FBSyxHQUFHMVMsTUFBTSxDQUFDZ0UsSUFBSSxDQUFDc08sRUFBTixDQUFOLENBQWdCRyxRQUFoQixDQUF5QkYsU0FBekIsRUFBb0MsR0FBcEMsQ0FBWjtBQUNBLFVBQUlJLGNBQWMsR0FBRyxDQUFyQjs7QUFFQSxhQUFPQSxjQUFjLEdBQUdELEtBQUssQ0FBQ3RYLE1BQXZCLElBQWlDc1gsS0FBSyxDQUFDQyxjQUFELENBQUwsS0FBMEJILE9BQU8sQ0FBQ0csY0FBRCxDQUF6RSxFQUEyRjtBQUN6RixVQUFFQSxjQUFGO0FBQ0Q7O0FBRUQzTyxVQUFJLENBQUMyRCxJQUFMLEdBQVkrSyxLQUFLLENBQUM1USxLQUFOLENBQVksQ0FBWixFQUFlNlEsY0FBZixFQUErQjlSLE9BQS9CLENBQXVDLElBQXZDLEVBQTZDLEtBQTdDLElBQXNELElBQUkrUixNQUFKLENBQVdMLFNBQVMsR0FBR0ksY0FBdkIsQ0FBbEU7O0FBRUE1VSxVQUFJLENBQUN6QixlQUFlLENBQUM4VixXQUFXLENBQUN6WCxTQUFiLENBQWhCLEVBQXlDLFNBQXpDLEVBQW9ELElBQXBELENBQUosQ0FBOEQyQyxJQUE5RCxDQUFtRSxJQUFuRSxFQUF5RTBHLElBQXpFO0FBQ0Q7QUFDRDs7OztBQTNCeUIsR0FBRCxFQStCdkI7QUFDRHJJLE9BQUcsRUFBRSxZQURKO0FBRURLLFNBQUssRUFBRSxTQUFTNlcsVUFBVCxDQUFvQjlTLEdBQXBCLEVBQXlCO0FBQzlCLFVBQUkrUyxNQUFNLEdBQUcsRUFBYjtBQUNBLFVBQUlDLE1BQU0sR0FBRyxFQUFiOztBQUVBLFVBQUlDLElBQUksR0FBR2pULEdBQUcsQ0FBQ2tULEtBQUosQ0FBVSxrQkFBVixLQUFpQyxFQUE1QztBQUFBLFVBQ0lDLEtBQUssR0FBR3ZVLGNBQWMsQ0FBQ3FVLElBQUQsRUFBTyxDQUFQLENBRDFCO0FBQUEsVUFFSUcsV0FBVyxHQUFHRCxLQUFLLENBQUMsQ0FBRCxDQUZ2QjtBQUFBLFVBR0lFLEdBQUcsR0FBR0YsS0FBSyxDQUFDLENBQUQsQ0FIZjs7QUFLQSxVQUFJRSxHQUFKLEVBQVM7QUFDUE4sY0FBTSxHQUFHLElBQUlGLE1BQUosQ0FBV08sV0FBVyxDQUFDL1gsTUFBdkIsSUFBaUNnWSxHQUExQztBQUNBTCxjQUFNLEdBQUcsSUFBSUgsTUFBSixDQUFXTyxXQUFXLENBQUMvWCxNQUF2QixJQUFpQ2dZLEdBQTFDO0FBQ0Q7O0FBRUROLFlBQU0sR0FBR0EsTUFBTSxDQUFDTyxNQUFQLENBQWMsS0FBS2QsU0FBbkIsRUFBOEIsR0FBOUIsQ0FBVDtBQUNBUSxZQUFNLEdBQUdBLE1BQU0sQ0FBQ00sTUFBUCxDQUFjLEtBQUtkLFNBQW5CLEVBQThCLEdBQTlCLENBQVQ7QUFDQSxhQUFPLENBQUNPLE1BQUQsRUFBU0MsTUFBVCxDQUFQO0FBQ0Q7QUFDRDs7OztBQXBCQyxHQS9CdUIsRUF1RHZCO0FBQ0RwWCxPQUFHLEVBQUUsV0FESjtBQUVESyxTQUFLLEVBQUUsU0FBU3VKLFNBQVQsQ0FBbUJ4RixHQUFuQixFQUF3QjtBQUM3QixVQUFJdUYsS0FBSyxHQUFHcEMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQWhGO0FBQ0FuRCxTQUFHLEdBQUdoQyxJQUFJLENBQUN6QixlQUFlLENBQUM4VixXQUFXLENBQUN6WCxTQUFiLENBQWhCLEVBQXlDLFdBQXpDLEVBQXNELElBQXRELENBQUosQ0FBZ0UyQyxJQUFoRSxDQUFxRSxJQUFyRSxFQUEyRXlDLEdBQTNFLEVBQWdGdUYsS0FBaEYsRUFBdUZ6RSxPQUF2RixDQUErRixLQUEvRixFQUFzRyxFQUF0RyxDQUFOO0FBQ0EsVUFBSSxDQUFDLEtBQUt5UyxPQUFWLEVBQW1CLE9BQU92VCxHQUFQO0FBQ25CLFVBQUl5UyxPQUFPLEdBQUd4UyxNQUFNLENBQUMsS0FBS21ELElBQU4sQ0FBTixDQUFrQnNQLFFBQWxCLENBQTJCLEtBQUtGLFNBQWhDLEVBQTJDLEdBQTNDLENBQWQ7QUFDQSxVQUFJRyxLQUFLLEdBQUcxUyxNQUFNLENBQUMsS0FBS3NTLEVBQU4sQ0FBTixDQUFnQkcsUUFBaEIsQ0FBeUIsS0FBS0YsU0FBOUIsRUFBeUMsR0FBekMsQ0FBWjtBQUNBLFVBQUlnQixHQUFHLEdBQUcsS0FBS3ZYLEtBQWY7QUFDQSxVQUFJd1gsT0FBTyxHQUFHLEVBQWQ7O0FBRUEsV0FBSyxJQUFJdE4sRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR25HLEdBQUcsQ0FBQzNFLE1BQTFCLEVBQWtDLEVBQUU4SyxFQUFwQyxFQUF3QztBQUN0QyxZQUFJdU4sT0FBTyxHQUFHRixHQUFHLEdBQUdDLE9BQU4sR0FBZ0J6VCxHQUFHLENBQUNtRyxFQUFELENBQWpDOztBQUVBLFlBQUl3TixnQkFBZ0IsR0FBRyxLQUFLYixVQUFMLENBQWdCWSxPQUFoQixDQUF2QjtBQUFBLFlBQ0lFLGlCQUFpQixHQUFHaFYsY0FBYyxDQUFDK1UsZ0JBQUQsRUFBbUIsQ0FBbkIsQ0FEdEM7QUFBQSxZQUVJWixNQUFNLEdBQUdhLGlCQUFpQixDQUFDLENBQUQsQ0FGOUI7QUFBQSxZQUdJWixNQUFNLEdBQUdZLGlCQUFpQixDQUFDLENBQUQsQ0FIOUI7O0FBS0EsWUFBSTVMLE1BQU0sQ0FBQ2dMLE1BQUQsQ0FBTixHQUFpQixLQUFLNVAsSUFBMUIsRUFBZ0NxUSxPQUFPLElBQUloQixPQUFPLENBQUNpQixPQUFPLENBQUNyWSxNQUFSLEdBQWlCLENBQWxCLENBQWxCLENBQWhDLEtBQTRFLElBQUkyTSxNQUFNLENBQUMrSyxNQUFELENBQU4sR0FBaUIsS0FBS1IsRUFBMUIsRUFBOEJrQixPQUFPLElBQUlkLEtBQUssQ0FBQ2UsT0FBTyxDQUFDclksTUFBUixHQUFpQixDQUFsQixDQUFoQixDQUE5QixLQUF3RW9ZLE9BQU8sSUFBSXpULEdBQUcsQ0FBQ21HLEVBQUQsQ0FBZDtBQUNySjs7QUFFRCxhQUFPc04sT0FBUDtBQUNEO0FBQ0Q7Ozs7QUF4QkMsR0F2RHVCLEVBbUZ2QjtBQUNEN1gsT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2SixVQUFULEdBQXNCO0FBQzNCLFVBQUkrTixLQUFKOztBQUVBLFVBQUk3VCxHQUFHLEdBQUcsS0FBSy9ELEtBQWY7QUFDQSxVQUFJNlgsWUFBWSxHQUFHOVQsR0FBRyxDQUFDdUwsTUFBSixDQUFXLE1BQVgsQ0FBbkI7QUFDQSxVQUFJdUksWUFBWSxLQUFLLENBQUMsQ0FBbEIsSUFBdUI5VCxHQUFHLENBQUMzRSxNQUFKLElBQWMsS0FBSzBZLFVBQTlDLEVBQTBELE9BQU8sSUFBUDs7QUFFMUQsVUFBSUMsaUJBQWlCLEdBQUcsS0FBS2xCLFVBQUwsQ0FBZ0I5UyxHQUFoQixDQUF4QjtBQUFBLFVBQ0lpVSxpQkFBaUIsR0FBR3JWLGNBQWMsQ0FBQ29WLGlCQUFELEVBQW9CLENBQXBCLENBRHRDO0FBQUEsVUFFSWpCLE1BQU0sR0FBR2tCLGlCQUFpQixDQUFDLENBQUQsQ0FGOUI7QUFBQSxVQUdJakIsTUFBTSxHQUFHaUIsaUJBQWlCLENBQUMsQ0FBRCxDQUg5Qjs7QUFLQSxXQUFLLElBQUlDLElBQUksR0FBRy9RLFNBQVMsQ0FBQzlILE1BQXJCLEVBQTZCMlMsSUFBSSxHQUFHLElBQUkvTyxLQUFKLENBQVVpVixJQUFWLENBQXBDLEVBQXFEQyxJQUFJLEdBQUcsQ0FBakUsRUFBb0VBLElBQUksR0FBR0QsSUFBM0UsRUFBaUZDLElBQUksRUFBckYsRUFBeUY7QUFDdkZuRyxZQUFJLENBQUNtRyxJQUFELENBQUosR0FBYWhSLFNBQVMsQ0FBQ2dSLElBQUQsQ0FBdEI7QUFDRDs7QUFFRCxhQUFPLEtBQUsvUSxJQUFMLElBQWE0RSxNQUFNLENBQUNnTCxNQUFELENBQW5CLElBQStCaEwsTUFBTSxDQUFDK0ssTUFBRCxDQUFOLElBQWtCLEtBQUtSLEVBQXRELElBQTRELENBQUNzQixLQUFLLEdBQUc3VixJQUFJLENBQUN6QixlQUFlLENBQUM4VixXQUFXLENBQUN6WCxTQUFiLENBQWhCLEVBQXlDLFlBQXpDLEVBQXVELElBQXZELENBQWIsRUFBMkUyQyxJQUEzRSxDQUFnRjJMLEtBQWhGLENBQXNGMkssS0FBdEYsRUFBNkYsQ0FBQyxJQUFELEVBQU9PLE1BQVAsQ0FBY3BHLElBQWQsQ0FBN0YsQ0FBbkU7QUFDRDtBQW5CQSxHQW5GdUIsRUF1R3ZCO0FBQ0RwUyxPQUFHLEVBQUUsWUFESjs7QUFHRDs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtxVSxTQUFMLEdBQWlCdlMsTUFBTSxDQUFDLEtBQUttRCxJQUFOLENBQU4sQ0FBa0IvSCxNQUExQztBQUNEO0FBZkEsR0F2R3VCLEVBdUh2QjtBQUNETyxPQUFHLEVBQUUsWUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPSCxJQUFJLENBQUN6QixlQUFlLENBQUM4VixXQUFXLENBQUN6WCxTQUFiLENBQWhCLEVBQXlDLFlBQXpDLEVBQXVELElBQXZELENBQUosSUFBb0VvTyxPQUFPLENBQUMsS0FBSy9NLEtBQU4sQ0FBbEY7QUFDRDtBQUpBLEdBdkh1QixDQUFkLENBQVo7O0FBOEhBLFNBQU9vVyxXQUFQO0FBQ0QsQ0F4SUQsQ0F3SUV2SyxjQXhJRixDQUZBOztBQTJJQS9ELE1BQUssQ0FBQ3NPLFdBQU4sR0FBb0JBLGlCQUFwQjtBQUVlQSwyREFBZixFOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUl0SyxlQUFVLEdBQ2QsYUFDQSxVQUFVdUssY0FBVixFQUEwQjtBQUN4QnBXLFdBQVMsQ0FBQzZMLFVBQUQsRUFBYXVLLGNBQWIsQ0FBVDtBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7OztBQUdBLFdBQVN2SyxVQUFULENBQW9COUQsSUFBcEIsRUFBMEI7QUFDeEJwSixtQkFBZSxDQUFDLElBQUQsRUFBT2tOLFVBQVAsQ0FBZjs7QUFFQSxXQUFPcEssMEJBQTBCLENBQUMsSUFBRCxFQUFPcEIsZUFBZSxDQUFDd0wsVUFBRCxDQUFmLENBQTRCeEssSUFBNUIsQ0FBaUMsSUFBakMsRUFBdUM3QixNQUFNLENBQUNrSCxNQUFQLENBQWMsRUFBZCxFQUFrQm1GLFVBQVUsQ0FBQ3pELFFBQTdCLEVBQXVDLEVBQXZDLEVBQTJDTCxJQUEzQyxDQUF2QyxDQUFQLENBQWpDO0FBQ0Q7QUFDRDs7Ozs7QUFLQXBJLGNBQVksQ0FBQ2tNLFVBQUQsRUFBYSxDQUFDO0FBQ3hCbk0sT0FBRyxFQUFFLFNBRG1CO0FBRXhCSyxTQUFLLEVBQUUsU0FBU29JLE9BQVQsQ0FBaUJKLElBQWpCLEVBQXVCO0FBQzVCLFVBQUlBLElBQUksQ0FBQzJELElBQUwsS0FBY3ZHLElBQWxCLEVBQXdCLE9BQU80QyxJQUFJLENBQUMyRCxJQUFaO0FBQ3hCLFVBQUkzRCxJQUFJLENBQUM0SCxPQUFULEVBQWtCNUgsSUFBSSxDQUFDMkQsSUFBTCxHQUFZM0QsSUFBSSxDQUFDNEgsT0FBakI7QUFDbEIsVUFBSUcsTUFBTSxHQUFHL0gsSUFBSSxDQUFDK0gsTUFBbEI7QUFDQS9ILFVBQUksQ0FBQytILE1BQUwsR0FBY3RRLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYyxFQUFkLEVBQWtCbUYsVUFBVSxDQUFDc00sa0JBQVgsRUFBbEIsQ0FBZCxDQUo0QixDQUlzQzs7QUFFbEUsVUFBSXBRLElBQUksQ0FBQzlCLEdBQVQsRUFBYzhCLElBQUksQ0FBQytILE1BQUwsQ0FBWXNJLENBQVosQ0FBY2xSLElBQWQsR0FBcUJhLElBQUksQ0FBQzlCLEdBQUwsQ0FBU29TLFdBQVQsRUFBckI7QUFDZCxVQUFJdFEsSUFBSSxDQUFDM0IsR0FBVCxFQUFjMkIsSUFBSSxDQUFDK0gsTUFBTCxDQUFZc0ksQ0FBWixDQUFjL0IsRUFBZCxHQUFtQnRPLElBQUksQ0FBQzNCLEdBQUwsQ0FBU2lTLFdBQVQsRUFBbkI7O0FBRWQsVUFBSXRRLElBQUksQ0FBQzlCLEdBQUwsSUFBWThCLElBQUksQ0FBQzNCLEdBQWpCLElBQXdCMkIsSUFBSSxDQUFDK0gsTUFBTCxDQUFZc0ksQ0FBWixDQUFjbFIsSUFBZCxLQUF1QmEsSUFBSSxDQUFDK0gsTUFBTCxDQUFZc0ksQ0FBWixDQUFjL0IsRUFBakUsRUFBcUU7QUFDbkV0TyxZQUFJLENBQUMrSCxNQUFMLENBQVl3SSxDQUFaLENBQWNwUixJQUFkLEdBQXFCYSxJQUFJLENBQUM5QixHQUFMLENBQVNzUyxRQUFULEtBQXNCLENBQTNDO0FBQ0F4USxZQUFJLENBQUMrSCxNQUFMLENBQVl3SSxDQUFaLENBQWNqQyxFQUFkLEdBQW1CdE8sSUFBSSxDQUFDM0IsR0FBTCxDQUFTbVMsUUFBVCxLQUFzQixDQUF6Qzs7QUFFQSxZQUFJeFEsSUFBSSxDQUFDK0gsTUFBTCxDQUFZd0ksQ0FBWixDQUFjcFIsSUFBZCxLQUF1QmEsSUFBSSxDQUFDK0gsTUFBTCxDQUFZd0ksQ0FBWixDQUFjakMsRUFBekMsRUFBNkM7QUFDM0N0TyxjQUFJLENBQUMrSCxNQUFMLENBQVkwSSxDQUFaLENBQWN0UixJQUFkLEdBQXFCYSxJQUFJLENBQUM5QixHQUFMLENBQVN3UyxPQUFULEVBQXJCO0FBQ0ExUSxjQUFJLENBQUMrSCxNQUFMLENBQVkwSSxDQUFaLENBQWNuQyxFQUFkLEdBQW1CdE8sSUFBSSxDQUFDM0IsR0FBTCxDQUFTcVMsT0FBVCxFQUFuQjtBQUNEO0FBQ0Y7O0FBRURqWixZQUFNLENBQUNrSCxNQUFQLENBQWNxQixJQUFJLENBQUMrSCxNQUFuQixFQUEyQkEsTUFBM0IsRUFuQjRCLENBbUJROztBQUVwQ3RRLFlBQU0sQ0FBQ3VCLElBQVAsQ0FBWWdILElBQUksQ0FBQytILE1BQWpCLEVBQXlCVyxPQUF6QixDQUFpQyxVQUFVaUksRUFBVixFQUFjO0FBQzdDLFlBQUk1VCxDQUFDLEdBQUdpRCxJQUFJLENBQUMrSCxNQUFMLENBQVk0SSxFQUFaLENBQVI7QUFDQSxZQUFJLEVBQUUsYUFBYTVULENBQWYsQ0FBSixFQUF1QkEsQ0FBQyxDQUFDdVMsT0FBRixHQUFZdFAsSUFBSSxDQUFDc1AsT0FBakI7QUFDeEIsT0FIRDs7QUFLQXZWLFVBQUksQ0FBQ3pCLGVBQWUsQ0FBQ3dMLFVBQVUsQ0FBQ25OLFNBQVosQ0FBaEIsRUFBd0MsU0FBeEMsRUFBbUQsSUFBbkQsQ0FBSixDQUE2RDJDLElBQTdELENBQWtFLElBQWxFLEVBQXdFMEcsSUFBeEU7QUFDRDtBQUNEOzs7O0FBOUJ3QixHQUFELEVBa0N0QjtBQUNEckksT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2SixVQUFULEdBQXNCO0FBQzNCLFVBQUkrTixLQUFKOztBQUVBLFVBQUlnQixJQUFJLEdBQUcsS0FBS0EsSUFBaEI7O0FBRUEsV0FBSyxJQUFJWCxJQUFJLEdBQUcvUSxTQUFTLENBQUM5SCxNQUFyQixFQUE2QjJTLElBQUksR0FBRyxJQUFJL08sS0FBSixDQUFVaVYsSUFBVixDQUFwQyxFQUFxREMsSUFBSSxHQUFHLENBQWpFLEVBQW9FQSxJQUFJLEdBQUdELElBQTNFLEVBQWlGQyxJQUFJLEVBQXJGLEVBQXlGO0FBQ3ZGbkcsWUFBSSxDQUFDbUcsSUFBRCxDQUFKLEdBQWFoUixTQUFTLENBQUNnUixJQUFELENBQXRCO0FBQ0Q7O0FBRUQsYUFBTyxDQUFDTixLQUFLLEdBQUc3VixJQUFJLENBQUN6QixlQUFlLENBQUN3TCxVQUFVLENBQUNuTixTQUFaLENBQWhCLEVBQXdDLFlBQXhDLEVBQXNELElBQXRELENBQWIsRUFBMEUyQyxJQUExRSxDQUErRTJMLEtBQS9FLENBQXFGMkssS0FBckYsRUFBNEYsQ0FBQyxJQUFELEVBQU9PLE1BQVAsQ0FBY3BHLElBQWQsQ0FBNUYsTUFBcUgsQ0FBQyxLQUFLeEUsVUFBTixJQUFvQixLQUFLc0wsV0FBTCxDQUFpQixLQUFLN1ksS0FBdEIsS0FBZ0M0WSxJQUFJLElBQUksSUFBeEMsS0FBaUQsS0FBSzFTLEdBQUwsSUFBWSxJQUFaLElBQW9CLEtBQUtBLEdBQUwsSUFBWTBTLElBQWpGLE1BQTJGLEtBQUt2UyxHQUFMLElBQVksSUFBWixJQUFvQnVTLElBQUksSUFBSSxLQUFLdlMsR0FBNUgsQ0FBekksQ0FBUDtBQUNEO0FBQ0Q7O0FBYkMsR0FsQ3NCLEVBaUR0QjtBQUNEMUcsT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2WSxXQUFULENBQXFCOVUsR0FBckIsRUFBMEI7QUFDL0IsYUFBTyxLQUFLaUgsTUFBTCxDQUFZLEtBQUtFLEtBQUwsQ0FBV25ILEdBQVgsRUFBZ0IsSUFBaEIsQ0FBWixFQUFtQyxJQUFuQyxFQUF5QzlDLE9BQXpDLENBQWlEOEMsR0FBakQsS0FBeUQsQ0FBaEU7QUFDRDtBQUNEOztBQUxDLEdBakRzQixFQXdEdEI7QUFDRHBFLE9BQUcsRUFBRSxNQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBSzRXLFVBQVo7QUFDRCxLQUpBO0FBS0R4VyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhc1csSUFBYixFQUFtQjtBQUN0QixXQUFLRSxVQUFMLEdBQWtCRixJQUFsQjtBQUNEO0FBQ0Q7Ozs7QUFSQyxHQXhEc0IsRUFvRXRCO0FBQ0RqWixPQUFHLEVBQUUsWUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtxTCxVQUFMLEdBQWtCeEwsSUFBSSxDQUFDekIsZUFBZSxDQUFDd0wsVUFBVSxDQUFDbk4sU0FBWixDQUFoQixFQUF3QyxZQUF4QyxFQUFzRCxJQUF0RCxDQUF0QixHQUFvRixJQUEzRjtBQUNELEtBSkE7QUFLRDJELE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF0QyxLQUFiLEVBQW9CO0FBQ3ZCdUMsVUFBSSxDQUFDakMsZUFBZSxDQUFDd0wsVUFBVSxDQUFDbk4sU0FBWixDQUFoQixFQUF3QyxZQUF4QyxFQUFzRHFCLEtBQXRELEVBQTZELElBQTdELEVBQW1FLElBQW5FLENBQUo7QUFDRDtBQVBBLEdBcEVzQixDQUFiLENBQVo7O0FBOEVBLFNBQU84TCxVQUFQO0FBQ0QsQ0F2R0QsQ0F1R0VELGNBdkdGLENBRkE7O0FBMEdBQyxlQUFVLENBQUN6RCxRQUFYLEdBQXNCO0FBQ3BCdUgsU0FBTyxFQUFFLGFBRFc7QUFFcEI1RSxRQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQjROLElBQWhCLEVBQXNCO0FBQzVCLFFBQUlHLEdBQUcsR0FBRy9VLE1BQU0sQ0FBQzRVLElBQUksQ0FBQ0YsT0FBTCxFQUFELENBQU4sQ0FBdUJqQyxRQUF2QixDQUFnQyxDQUFoQyxFQUFtQyxHQUFuQyxDQUFWO0FBQ0EsUUFBSXVDLEtBQUssR0FBR2hWLE1BQU0sQ0FBQzRVLElBQUksQ0FBQ0osUUFBTCxLQUFrQixDQUFuQixDQUFOLENBQTRCL0IsUUFBNUIsQ0FBcUMsQ0FBckMsRUFBd0MsR0FBeEMsQ0FBWjtBQUNBLFFBQUl3QyxJQUFJLEdBQUdMLElBQUksQ0FBQ04sV0FBTCxFQUFYO0FBQ0EsV0FBTyxDQUFDUyxHQUFELEVBQU1DLEtBQU4sRUFBYUMsSUFBYixFQUFtQjlLLElBQW5CLENBQXdCLEdBQXhCLENBQVA7QUFDRCxHQVBtQjtBQVFwQmpELE9BQUssRUFBRSxTQUFTQSxLQUFULENBQWVuSCxHQUFmLEVBQW9CO0FBQ3pCLFFBQUltVixVQUFVLEdBQUduVixHQUFHLENBQUNvVixLQUFKLENBQVUsR0FBVixDQUFqQjtBQUFBLFFBQ0lDLFdBQVcsR0FBR3pXLGNBQWMsQ0FBQ3VXLFVBQUQsRUFBYSxDQUFiLENBRGhDO0FBQUEsUUFFSUgsR0FBRyxHQUFHSyxXQUFXLENBQUMsQ0FBRCxDQUZyQjtBQUFBLFFBR0lKLEtBQUssR0FBR0ksV0FBVyxDQUFDLENBQUQsQ0FIdkI7QUFBQSxRQUlJSCxJQUFJLEdBQUdHLFdBQVcsQ0FBQyxDQUFELENBSnRCOztBQU1BLFdBQU8sSUFBSWhVLElBQUosQ0FBUzZULElBQVQsRUFBZUQsS0FBSyxHQUFHLENBQXZCLEVBQTBCRCxHQUExQixDQUFQO0FBQ0Q7QUFoQm1CLENBQXRCOztBQW1CQWpOLGVBQVUsQ0FBQ3NNLGtCQUFYLEdBQWdDLFlBQVk7QUFDMUMsU0FBTztBQUNMSyxLQUFDLEVBQUU7QUFDRDlNLFVBQUksRUFBRXlLLEtBREw7QUFFRGpQLFVBQUksRUFBRSxDQUZMO0FBR0RtUCxRQUFFLEVBQUUsRUFISDtBQUlEQyxlQUFTLEVBQUU7QUFKVixLQURFO0FBT0xnQyxLQUFDLEVBQUU7QUFDRDVNLFVBQUksRUFBRXlLLEtBREw7QUFFRGpQLFVBQUksRUFBRSxDQUZMO0FBR0RtUCxRQUFFLEVBQUUsRUFISDtBQUlEQyxlQUFTLEVBQUU7QUFKVixLQVBFO0FBYUw4QixLQUFDLEVBQUU7QUFDRDFNLFVBQUksRUFBRXlLLEtBREw7QUFFRGpQLFVBQUksRUFBRSxJQUZMO0FBR0RtUCxRQUFFLEVBQUU7QUFISDtBQWJFLEdBQVA7QUFtQkQsQ0FwQkQ7O0FBc0JBeE8sTUFBSyxDQUFDZ0UsVUFBTixHQUFtQkEsZUFBbkI7QUFFZUEsK0RBQWYsRTs7QUNyS0E7QUFDQTtBQUVBOzs7OztBQUlBLElBQUl1Tix3QkFBVyxHQUNmLGFBQ0EsWUFBWTtBQUNWLFdBQVNBLFdBQVQsR0FBdUI7QUFDckJ6YSxtQkFBZSxDQUFDLElBQUQsRUFBT3lhLFdBQVAsQ0FBZjtBQUNEOztBQUVEelosY0FBWSxDQUFDeVosV0FBRCxFQUFjLENBQUM7QUFDekIxWixPQUFHLEVBQUUsUUFEb0I7O0FBR3pCO0FBQ0FLLFNBQUssRUFBRSxTQUFTc1osTUFBVCxDQUFnQnRULEtBQWhCLEVBQXVCTSxHQUF2QixFQUE0QjtBQUNqQyxVQUFJTixLQUFLLElBQUksSUFBVCxJQUFpQk0sR0FBRyxJQUFJLElBQXhCLElBQWdDTixLQUFLLEtBQUssS0FBS3VULGNBQWYsSUFBaUNqVCxHQUFHLEtBQUssS0FBS2tULFlBQWxGLEVBQWdHOztBQUVoRyxVQUFJO0FBQ0YsYUFBS0MsYUFBTCxDQUFtQnpULEtBQW5CLEVBQTBCTSxHQUExQjtBQUNELE9BRkQsQ0FFRSxPQUFPb1QsQ0FBUCxFQUFVLENBQUU7QUFDZjtBQUNEOztBQVh5QixHQUFELEVBYXZCO0FBQ0QvWixPQUFHLEVBQUUsZUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3laLGFBQVQsQ0FBdUJ6VCxLQUF2QixFQUE4Qk0sR0FBOUIsRUFBbUMsQ0FBRTtBQUM1Qzs7QUFIQyxHQWJ1QixFQWtCdkI7QUFDRDNHLE9BQUcsRUFBRSxZQURKOztBQUdEO0FBQ0FLLFNBQUssRUFBRSxTQUFTMlosVUFBVCxDQUFvQkMsUUFBcEIsRUFBOEIsQ0FBRTtBQUN2Qzs7QUFMQyxHQWxCdUIsRUF5QnZCO0FBQ0RqYSxPQUFHLEVBQUUsY0FESjtBQUVESyxTQUFLLEVBQUUsU0FBUzZaLFlBQVQsR0FBd0IsQ0FBRTtBQUZoQyxHQXpCdUIsRUE0QnZCO0FBQ0RsYSxPQUFHLEVBQUUsZ0JBREo7O0FBR0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQXVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsVUFBSThELEtBQUo7O0FBRUEsVUFBSTtBQUNGQSxhQUFLLEdBQUcsS0FBSzhULHFCQUFiO0FBQ0QsT0FGRCxDQUVFLE9BQU9KLENBQVAsRUFBVSxDQUFFOztBQUVkLGFBQU8xVCxLQUFLLElBQUksSUFBVCxHQUFnQkEsS0FBaEIsR0FBd0IsS0FBS2hHLEtBQUwsQ0FBV1osTUFBMUM7QUFDRDtBQUNEOztBQW5CQyxHQTVCdUIsRUFpRHZCO0FBQ0RPLE9BQUcsRUFBRSxjQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFVBQUlvRSxHQUFKOztBQUVBLFVBQUk7QUFDRkEsV0FBRyxHQUFHLEtBQUt5VCxtQkFBWDtBQUNELE9BRkQsQ0FFRSxPQUFPTCxDQUFQLEVBQVUsQ0FBRTs7QUFFZCxhQUFPcFQsR0FBRyxJQUFJLElBQVAsR0FBY0EsR0FBZCxHQUFvQixLQUFLdEcsS0FBTCxDQUFXWixNQUF0QztBQUNEO0FBVkEsR0FqRHVCLEVBNER2QjtBQUNETyxPQUFHLEVBQUUsVUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQVA7QUFDRDtBQUpBLEdBNUR1QixDQUFkLENBQVo7O0FBbUVBLFNBQU9tWCxXQUFQO0FBQ0QsQ0F6RUQsRUFGQTs7QUE0RUF2UixNQUFLLENBQUN1UixXQUFOLEdBQW9CQSx3QkFBcEI7QUFFZUEseUVBQWYsRTs7QUNyRkE7QUFDQTtBQUNBO0FBRUE7O0FBRUEsSUFBSVcsaUNBQWUsR0FDbkIsYUFDQSxVQUFVQyxZQUFWLEVBQXdCO0FBQ3RCaGEsV0FBUyxDQUFDK1osZUFBRCxFQUFrQkMsWUFBbEIsQ0FBVDtBQUVBOztBQUVBOztBQUVBOzs7OztBQUdBLFdBQVNELGVBQVQsQ0FBeUJwUixLQUF6QixFQUFnQztBQUM5QixRQUFJNkcsS0FBSjs7QUFFQTdRLG1CQUFlLENBQUMsSUFBRCxFQUFPb2IsZUFBUCxDQUFmOztBQUVBdkssU0FBSyxHQUFHL04sMEJBQTBCLENBQUMsSUFBRCxFQUFPcEIsZUFBZSxDQUFDMFosZUFBRCxDQUFmLENBQWlDMVksSUFBakMsQ0FBc0MsSUFBdEMsQ0FBUCxDQUFsQztBQUNBbU8sU0FBSyxDQUFDN0csS0FBTixHQUFjQSxLQUFkO0FBQ0E2RyxTQUFLLENBQUN5SyxTQUFOLEdBQWtCLEVBQWxCO0FBQ0EsV0FBT3pLLEtBQVA7QUFDRDtBQUNEO0FBQ0E7OztBQUdBN1AsY0FBWSxDQUFDb2EsZUFBRCxFQUFrQixDQUFDO0FBQzdCcmEsT0FBRyxFQUFFLGVBRHdCOztBQUc3Qjs7OztBQUlBSyxTQUFLLEVBQUUsU0FBU3laLGFBQVQsQ0FBdUJ6VCxLQUF2QixFQUE4Qk0sR0FBOUIsRUFBbUM7QUFDeEMsV0FBS3NDLEtBQUwsQ0FBV3VSLGlCQUFYLENBQTZCblUsS0FBN0IsRUFBb0NNLEdBQXBDO0FBQ0Q7QUFDRDs7Ozs7QUFWNkIsR0FBRCxFQWUzQjtBQUNEM0csT0FBRyxFQUFFLFlBREo7O0FBR0Q7Ozs7QUFJQUssU0FBSyxFQUFFLFNBQVMyWixVQUFULENBQW9CQyxRQUFwQixFQUE4QjtBQUNuQyxVQUFJN0ksTUFBTSxHQUFHLElBQWI7O0FBRUF0UixZQUFNLENBQUN1QixJQUFQLENBQVk0WSxRQUFaLEVBQXNCbEosT0FBdEIsQ0FBOEIsVUFBVTBKLEtBQVYsRUFBaUI7QUFDN0MsZUFBT3JKLE1BQU0sQ0FBQ3NKLG1CQUFQLENBQTJCTCxlQUFlLENBQUNNLFVBQWhCLENBQTJCRixLQUEzQixDQUEzQixFQUE4RFIsUUFBUSxDQUFDUSxLQUFELENBQXRFLENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRDs7Ozs7QUFkQyxHQWYyQixFQWtDM0I7QUFDRHphLE9BQUcsRUFBRSxjQURKO0FBRURLLFNBQUssRUFBRSxTQUFTNlosWUFBVCxHQUF3QjtBQUM3QixVQUFJbEksTUFBTSxHQUFHLElBQWI7O0FBRUFsUyxZQUFNLENBQUN1QixJQUFQLENBQVksS0FBS2taLFNBQWpCLEVBQTRCeEosT0FBNUIsQ0FBb0MsVUFBVTBKLEtBQVYsRUFBaUI7QUFDbkQsZUFBT3pJLE1BQU0sQ0FBQzBJLG1CQUFQLENBQTJCRCxLQUEzQixDQUFQO0FBQ0QsT0FGRDtBQUdEO0FBQ0Q7O0FBVEMsR0FsQzJCLEVBNkMzQjtBQUNEemEsT0FBRyxFQUFFLHFCQURKO0FBRURLLFNBQUssRUFBRSxTQUFTcWEsbUJBQVQsQ0FBNkJELEtBQTdCLEVBQW9DRyxPQUFwQyxFQUE2QztBQUNsRCxVQUFJLEtBQUtMLFNBQUwsQ0FBZUUsS0FBZixDQUFKLEVBQTJCO0FBQ3pCLGFBQUt4UixLQUFMLENBQVc0UixtQkFBWCxDQUErQkosS0FBL0IsRUFBc0MsS0FBS0YsU0FBTCxDQUFlRSxLQUFmLENBQXRDO0FBQ0EsZUFBTyxLQUFLRixTQUFMLENBQWVFLEtBQWYsQ0FBUDtBQUNEOztBQUVELFVBQUlHLE9BQUosRUFBYTtBQUNYLGFBQUszUixLQUFMLENBQVc2UixnQkFBWCxDQUE0QkwsS0FBNUIsRUFBbUNHLE9BQW5DO0FBQ0EsYUFBS0wsU0FBTCxDQUFlRSxLQUFmLElBQXdCRyxPQUF4QjtBQUNEO0FBQ0Y7QUFaQSxHQTdDMkIsRUEwRDNCO0FBQ0Q1YSxPQUFHLEVBQUUsYUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUswRyxLQUFMLENBQVc4UixXQUFYLEdBQXlCLEtBQUs5UixLQUFMLENBQVc4UixXQUFYLEVBQXpCLEdBQW9EQyxRQUEzRDtBQUNEO0FBQ0Q7Ozs7O0FBTEMsR0ExRDJCLEVBb0UzQjtBQUNEaGIsT0FBRyxFQUFFLFVBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEI7QUFDQSxhQUFPLEtBQUswRyxLQUFMLEtBQWUsS0FBS2dTLFdBQUwsQ0FBaUJDLGFBQXZDO0FBQ0Q7QUFDRDs7Ozs7QUFOQyxHQXBFMkIsRUErRTNCO0FBQ0RsYixPQUFHLEVBQUUsdUJBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLMEcsS0FBTCxDQUFXMlEsY0FBbEI7QUFDRDtBQUNEOzs7OztBQUxDLEdBL0UyQixFQXlGM0I7QUFDRDVaLE9BQUcsRUFBRSxxQkFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUswRyxLQUFMLENBQVc0USxZQUFsQjtBQUNEO0FBSkEsR0F6RjJCLEVBOEYzQjtBQUNEN1osT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLMEcsS0FBTCxDQUFXNUksS0FBbEI7QUFDRCxLQUpBO0FBS0RzQyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdEMsS0FBYixFQUFvQjtBQUN2QixXQUFLNEksS0FBTCxDQUFXNUksS0FBWCxHQUFtQkEsS0FBbkI7QUFDRDtBQVBBLEdBOUYyQixDQUFsQixDQUFaOztBQXdHQSxTQUFPZ2EsZUFBUDtBQUNELENBaklELENBaUlFWCxZQWpJRixDQUZBOztBQW9JQVcsaUNBQWUsQ0FBQ00sVUFBaEIsR0FBNkI7QUFDM0JRLGlCQUFlLEVBQUUsU0FEVTtBQUUzQmxTLE9BQUssRUFBRSxPQUZvQjtBQUczQm1TLE1BQUksRUFBRSxNQUhxQjtBQUkzQkMsT0FBSyxFQUFFLE9BSm9CO0FBSzNCQyxPQUFLLEVBQUUsT0FMb0I7QUFNM0JuUSxRQUFNLEVBQUU7QUFObUIsQ0FBN0I7QUFRQWhELE1BQUssQ0FBQ2tTLGVBQU4sR0FBd0JBLGlDQUF4QjtBQUVlQSx1RkFBZixFOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJa0IsZ0VBQThCLEdBQ2xDLGFBQ0EsVUFBVUMsZ0JBQVYsRUFBNEI7QUFDMUJsYixXQUFTLENBQUNpYiw4QkFBRCxFQUFpQ0MsZ0JBQWpDLENBQVQ7O0FBRUEsV0FBU0QsOEJBQVQsR0FBMEM7QUFDeEN0YyxtQkFBZSxDQUFDLElBQUQsRUFBT3NjLDhCQUFQLENBQWY7O0FBRUEsV0FBT3haLDBCQUEwQixDQUFDLElBQUQsRUFBT3BCLGVBQWUsQ0FBQzRhLDhCQUFELENBQWYsQ0FBZ0RqTyxLQUFoRCxDQUFzRCxJQUF0RCxFQUE0RC9GLFNBQTVELENBQVAsQ0FBakM7QUFDRDs7QUFFRHRILGNBQVksQ0FBQ3NiLDhCQUFELEVBQWlDLENBQUM7QUFDNUN2YixPQUFHLEVBQUUsZUFEdUM7O0FBRzVDOzs7O0FBSUFLLFNBQUssRUFBRSxTQUFTeVosYUFBVCxDQUF1QnpULEtBQXZCLEVBQThCTSxHQUE5QixFQUFtQztBQUN4QyxVQUFJLENBQUMsS0FBS3NVLFdBQUwsQ0FBaUJRLFdBQXRCLEVBQW1DO0FBQ25DLFVBQUlDLEtBQUssR0FBRyxLQUFLVCxXQUFMLENBQWlCUSxXQUFqQixFQUFaO0FBQ0FDLFdBQUssQ0FBQ0MsUUFBTixDQUFlLEtBQUsxUyxLQUFMLENBQVcyUyxVQUFYLElBQXlCLEtBQUszUyxLQUE3QyxFQUFvRDVDLEtBQXBEO0FBQ0FxVixXQUFLLENBQUNHLE1BQU4sQ0FBYSxLQUFLNVMsS0FBTCxDQUFXNlMsU0FBWCxJQUF3QixLQUFLN1MsS0FBMUMsRUFBaUR0QyxHQUFqRDtBQUNBLFVBQUlvVixJQUFJLEdBQUcsS0FBS2QsV0FBaEI7QUFDQSxVQUFJZSxTQUFTLEdBQUdELElBQUksQ0FBQ0UsWUFBTCxJQUFxQkYsSUFBSSxDQUFDRSxZQUFMLEVBQXJDOztBQUVBLFVBQUlELFNBQUosRUFBZTtBQUNiQSxpQkFBUyxDQUFDRSxlQUFWO0FBQ0FGLGlCQUFTLENBQUNHLFFBQVYsQ0FBbUJULEtBQW5CO0FBQ0Q7QUFDRjtBQUNEOzs7OztBQXBCNEMsR0FBRCxFQXlCMUM7QUFDRDFiLE9BQUcsRUFBRSx1QkFESjs7QUFHRDs7OztBQUlBdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixVQUFJd1osSUFBSSxHQUFHLEtBQUtkLFdBQWhCO0FBQ0EsVUFBSWUsU0FBUyxHQUFHRCxJQUFJLENBQUNFLFlBQUwsSUFBcUJGLElBQUksQ0FBQ0UsWUFBTCxFQUFyQztBQUNBLGFBQU9ELFNBQVMsSUFBSUEsU0FBUyxDQUFDSSxZQUE5QjtBQUNEO0FBQ0Q7Ozs7O0FBWkMsR0F6QjBDLEVBMEMxQztBQUNEcGMsT0FBRyxFQUFFLHFCQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFVBQUl3WixJQUFJLEdBQUcsS0FBS2QsV0FBaEI7QUFDQSxVQUFJZSxTQUFTLEdBQUdELElBQUksQ0FBQ0UsWUFBTCxJQUFxQkYsSUFBSSxDQUFDRSxZQUFMLEVBQXJDO0FBQ0EsYUFBT0QsU0FBUyxJQUFJLEtBQUs3QixxQkFBTCxHQUE2QjlWLE1BQU0sQ0FBQzJYLFNBQUQsQ0FBTixDQUFrQnZjLE1BQW5FO0FBQ0Q7QUFOQSxHQTFDMEMsRUFpRDFDO0FBQ0RPLE9BQUcsRUFBRSxPQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCO0FBQ0EsYUFBTyxLQUFLMEcsS0FBTCxDQUFXb1QsV0FBbEI7QUFDRCxLQUxBO0FBTUQxWixPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhdEMsS0FBYixFQUFvQjtBQUN2QixXQUFLNEksS0FBTCxDQUFXb1QsV0FBWCxHQUF5QmhjLEtBQXpCO0FBQ0Q7QUFSQSxHQWpEMEMsQ0FBakMsQ0FBWjs7QUE0REEsU0FBT2tiLDhCQUFQO0FBQ0QsQ0F0RUQsQ0FzRUVsQixpQkF0RUYsQ0FGQTs7QUF5RUFsUyxNQUFLLENBQUNvVCw4QkFBTixHQUF1Q0EsZ0VBQXZDO0FBRWVBLHNJQUFmLEU7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUlqVCxlQUFTLEdBQ2IsYUFDQSxZQUFZO0FBQ1Y7Ozs7O0FBS0E7Ozs7O0FBS0E7Ozs7QUFJQSxXQUFTQSxTQUFULENBQW1CRixFQUFuQixFQUF1QkMsSUFBdkIsRUFBNkI7QUFDM0JwSixtQkFBZSxDQUFDLElBQUQsRUFBT3FKLFNBQVAsQ0FBZjs7QUFFQSxTQUFLRixFQUFMLEdBQVVBLEVBQUUsWUFBWXNSLFlBQWQsR0FBNEJ0UixFQUE1QixHQUFpQ0EsRUFBRSxDQUFDa1UsaUJBQUgsSUFBd0JsVSxFQUFFLENBQUNtVSxPQUFILEtBQWUsT0FBdkMsSUFBa0RuVSxFQUFFLENBQUNtVSxPQUFILEtBQWUsVUFBakUsR0FBOEUsSUFBSWhCLGlDQUFKLENBQW1DblQsRUFBbkMsQ0FBOUUsR0FBdUgsSUFBSWlTLGlCQUFKLENBQW9CalMsRUFBcEIsQ0FBbEs7QUFDQSxTQUFLUCxNQUFMLEdBQWM4RSxPQUFVLENBQUN0RSxJQUFELENBQXhCO0FBQ0EsU0FBS21VLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLaFUsTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLaVUsY0FBTCxHQUFzQixFQUF0QjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsS0FBS0EsY0FBTCxDQUFvQjVULElBQXBCLENBQXlCLElBQXpCLENBQXRCO0FBQ0EsU0FBSzZULFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxDQUFjN1QsSUFBZCxDQUFtQixJQUFuQixDQUFoQjtBQUNBLFNBQUs4VCxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsQ0FBZTlULElBQWYsQ0FBb0IsSUFBcEIsQ0FBakI7QUFDQSxTQUFLK1QsT0FBTCxHQUFlLEtBQUtBLE9BQUwsQ0FBYS9ULElBQWIsQ0FBa0IsSUFBbEIsQ0FBZjtBQUNBLFNBQUtnVSxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY2hVLElBQWQsQ0FBbUIsSUFBbkIsQ0FBaEI7QUFDQSxTQUFLaVUsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWNqVSxJQUFkLENBQW1CLElBQW5CLENBQWhCO0FBQ0EsU0FBS2tVLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQmxVLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsU0FBS21VLG1CQUFMLEdBQTJCLEtBQUtBLG1CQUFMLENBQXlCblUsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBM0I7O0FBRUEsU0FBS29VLFdBQUwsR0FqQjJCLENBaUJQOzs7QUFHcEIsU0FBS0MsV0FBTDs7QUFFQSxTQUFLUCxTQUFMO0FBQ0Q7QUFDRDs7O0FBR0EzYyxjQUFZLENBQUNxSSxTQUFELEVBQVksQ0FBQztBQUN2QnRJLE9BQUcsRUFBRSxZQURrQjtBQUV2QkssU0FBSyxFQUFFLFNBQVMrYyxVQUFULENBQW9CcFIsSUFBcEIsRUFBMEI7QUFDL0IsYUFBT0EsSUFBSSxJQUFJLElBQVIsSUFBZ0JBLElBQUksS0FBSyxLQUFLbkUsTUFBTCxDQUFZbUUsSUFBckMsSUFBNkNBLElBQUksS0FBS3ZHLElBQVQsSUFBaUIsS0FBS29DLE1BQUwsWUFBdUJzRSxXQUE1RjtBQUNEO0FBSnNCLEdBQUQsRUFLckI7QUFDRG5NLE9BQUcsRUFBRSxhQURKOztBQUdEOzs7O0FBSUFLLFNBQUssRUFBRSxTQUFTNmMsV0FBVCxHQUF1QjtBQUM1QixXQUFLOVUsRUFBTCxDQUFRNFIsVUFBUixDQUFtQjtBQUNqQm1CLHVCQUFlLEVBQUUsS0FBS3VCLGNBREw7QUFFakJ6VCxhQUFLLEVBQUUsS0FBSzBULFFBRks7QUFHakJ2QixZQUFJLEVBQUUsS0FBS3lCLE9BSE07QUFJakJ4QixhQUFLLEVBQUUsS0FBSzBCLFFBSks7QUFLakJ6QixhQUFLLEVBQUUsS0FBS3dCLFFBTEs7QUFNakIzUixjQUFNLEVBQUUsS0FBS3lSO0FBTkksT0FBbkI7QUFRRDtBQUNEOzs7OztBQWpCQyxHQUxxQixFQTJCckI7QUFDRDVjLE9BQUcsRUFBRSxlQURKO0FBRURLLFNBQUssRUFBRSxTQUFTZ2QsYUFBVCxHQUF5QjtBQUM5QixVQUFJLEtBQUtqVixFQUFULEVBQWEsS0FBS0EsRUFBTCxDQUFROFIsWUFBUjtBQUNkO0FBQ0Q7Ozs7O0FBTEMsR0EzQnFCLEVBcUNyQjtBQUNEbGEsT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVNpZCxVQUFULENBQW9CQyxFQUFwQixFQUF3QjtBQUM3QixXQUFLLElBQUlqRixJQUFJLEdBQUcvUSxTQUFTLENBQUM5SCxNQUFyQixFQUE2QjJTLElBQUksR0FBRyxJQUFJL08sS0FBSixDQUFVaVYsSUFBSSxHQUFHLENBQVAsR0FBV0EsSUFBSSxHQUFHLENBQWxCLEdBQXNCLENBQWhDLENBQXBDLEVBQXdFQyxJQUFJLEdBQUcsQ0FBcEYsRUFBdUZBLElBQUksR0FBR0QsSUFBOUYsRUFBb0dDLElBQUksRUFBeEcsRUFBNEc7QUFDMUduRyxZQUFJLENBQUNtRyxJQUFJLEdBQUcsQ0FBUixDQUFKLEdBQWlCaFIsU0FBUyxDQUFDZ1IsSUFBRCxDQUExQjtBQUNEOztBQUVELFVBQUlpRixTQUFTLEdBQUcsS0FBS2hCLFVBQUwsQ0FBZ0JlLEVBQWhCLENBQWhCO0FBQ0EsVUFBSSxDQUFDQyxTQUFMLEVBQWdCO0FBQ2hCQSxlQUFTLENBQUN6TSxPQUFWLENBQWtCLFVBQVUwTSxDQUFWLEVBQWE7QUFDN0IsZUFBT0EsQ0FBQyxDQUFDblEsS0FBRixDQUFRLEtBQUssQ0FBYixFQUFnQjhFLElBQWhCLENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRDs7Ozs7QUFiQyxHQXJDcUIsRUF1RHJCO0FBQ0RwUyxPQUFHLEVBQUUsZ0JBREo7O0FBR0Q7Ozs7QUFJQUssU0FBSyxFQUFFLFNBQVNxYyxjQUFUO0FBQ1A7QUFDQTtBQUNFLFVBQUksS0FBS3JjLEtBQUwsS0FBZSxLQUFLK0gsRUFBTCxDQUFRL0gsS0FBM0IsRUFBa0M7QUFDaENvTSxlQUFPLENBQUNDLElBQVIsQ0FBYSx5R0FBYixFQURnQyxDQUN5RjtBQUMxSDs7QUFFRCxXQUFLZ1IsVUFBTCxHQUFrQjtBQUNoQnJYLGFBQUssRUFBRSxLQUFLdVQsY0FESTtBQUVoQmpULFdBQUcsRUFBRSxLQUFLWDtBQUZNLE9BQWxCO0FBSUQ7QUFDRDs7QUFuQkMsR0F2RHFCLEVBNEVyQjtBQUNEaEcsT0FBRyxFQUFFLGFBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4YyxXQUFULEdBQXVCO0FBQzVCLFdBQUt0VixNQUFMLENBQVl4SCxLQUFaLEdBQW9CLEtBQUsrSCxFQUFMLENBQVEvSCxLQUE1QjtBQUNBLFdBQUttSSxNQUFMLEdBQWMsS0FBS1gsTUFBTCxDQUFZeEgsS0FBMUI7QUFDRDtBQUNEOztBQU5DLEdBNUVxQixFQW9GckI7QUFDREwsT0FBRyxFQUFFLGVBREo7QUFFREssU0FBSyxFQUFFLFNBQVNzZCxhQUFULEdBQXlCO0FBQzlCLFVBQUlDLGdCQUFnQixHQUFHLEtBQUsvVixNQUFMLENBQVlrRyxhQUFuQztBQUNBLFVBQUk4UCxRQUFRLEdBQUcsS0FBS2hXLE1BQUwsQ0FBWXhILEtBQTNCO0FBQ0EsVUFBSXlkLFNBQVMsR0FBRyxLQUFLL1AsYUFBTCxLQUF1QjZQLGdCQUF2QixJQUEyQyxLQUFLdmQsS0FBTCxLQUFld2QsUUFBMUU7QUFDQSxXQUFLcEIsY0FBTCxHQUFzQm1CLGdCQUF0QjtBQUNBLFdBQUtwVixNQUFMLEdBQWNxVixRQUFkO0FBQ0EsVUFBSSxLQUFLelYsRUFBTCxDQUFRL0gsS0FBUixLQUFrQndkLFFBQXRCLEVBQWdDLEtBQUt6VixFQUFMLENBQVEvSCxLQUFSLEdBQWdCd2QsUUFBaEI7QUFDaEMsVUFBSUMsU0FBSixFQUFlLEtBQUtDLGlCQUFMO0FBQ2hCO0FBQ0Q7O0FBWEMsR0FwRnFCLEVBaUdyQjtBQUNEL2QsT0FBRyxFQUFFLGVBREo7QUFFREssU0FBSyxFQUFFLFNBQVN1SSxhQUFULENBQXVCUCxJQUF2QixFQUE2QjtBQUNsQyxVQUFJMkQsSUFBSSxHQUFHM0QsSUFBSSxDQUFDMkQsSUFBaEI7QUFBQSxVQUNJZ1MsUUFBUSxHQUFHemMsd0JBQXdCLENBQUM4RyxJQUFELEVBQU8sQ0FBQyxNQUFELENBQVAsQ0FEdkM7O0FBR0EsVUFBSTRWLFVBQVUsR0FBRyxDQUFDLEtBQUtiLFVBQUwsQ0FBZ0JwUixJQUFoQixDQUFsQjtBQUNBLFVBQUlrUyxVQUFVLEdBQUcsQ0FBQy9ZLGNBQWMsQ0FBQyxLQUFLMEMsTUFBTixFQUFjbVcsUUFBZCxDQUFoQztBQUNBLFVBQUlDLFVBQUosRUFBZ0IsS0FBS2pTLElBQUwsR0FBWUEsSUFBWjtBQUNoQixVQUFJa1MsVUFBSixFQUFnQixLQUFLclcsTUFBTCxDQUFZZSxhQUFaLENBQTBCb1YsUUFBMUI7QUFDaEIsVUFBSUMsVUFBVSxJQUFJQyxVQUFsQixFQUE4QixLQUFLUCxhQUFMO0FBQy9CO0FBQ0Q7O0FBWkMsR0FqR3FCLEVBK0dyQjtBQUNEM2QsT0FBRyxFQUFFLGNBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4ZCxZQUFULENBQXNCblksU0FBdEIsRUFBaUM7QUFDdEMsVUFBSUEsU0FBUyxJQUFJLElBQWpCLEVBQXVCO0FBQ3ZCLFdBQUtBLFNBQUwsR0FBaUJBLFNBQWpCLENBRnNDLENBRVY7O0FBRTVCLFdBQUtvWSxrQkFBTCxDQUF3QnBZLFNBQXhCO0FBQ0Q7QUFDRDs7Ozs7QUFSQyxHQS9HcUIsRUE0SHJCO0FBQ0RoRyxPQUFHLEVBQUUsb0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVMrZCxrQkFBVCxDQUE0QnBZLFNBQTVCLEVBQXVDO0FBQzVDLFVBQUk4SixLQUFLLEdBQUcsSUFBWjs7QUFFQSxXQUFLdU8sa0JBQUw7O0FBRUEsV0FBS0Msa0JBQUwsR0FBMEJ0WSxTQUExQjtBQUNBLFdBQUt1WSxlQUFMLEdBQXVCQyxVQUFVLENBQUMsWUFBWTtBQUM1QyxZQUFJLENBQUMxTyxLQUFLLENBQUMxSCxFQUFYLEVBQWUsT0FENkIsQ0FDckI7O0FBRXZCMEgsYUFBSyxDQUFDOUosU0FBTixHQUFrQjhKLEtBQUssQ0FBQ3dPLGtCQUF4Qjs7QUFFQXhPLGFBQUssQ0FBQ3VPLGtCQUFOO0FBQ0QsT0FOZ0MsRUFNOUIsRUFOOEIsQ0FBakM7QUFPRDtBQUNEOzs7OztBQWhCQyxHQTVIcUIsRUFpSnJCO0FBQ0RyZSxPQUFHLEVBQUUsbUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVMwZCxpQkFBVCxHQUE2QjtBQUNsQyxXQUFLVCxVQUFMLENBQWdCLFFBQWhCLEVBQTBCLEtBQUttQixXQUEvQjs7QUFFQSxVQUFJLEtBQUs1VyxNQUFMLENBQVkrRixVQUFoQixFQUE0QixLQUFLMFAsVUFBTCxDQUFnQixVQUFoQixFQUE0QixLQUFLbUIsV0FBakM7QUFDN0I7QUFDRDs7Ozs7QUFQQyxHQWpKcUIsRUE2SnJCO0FBQ0R6ZSxPQUFHLEVBQUUsb0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVNnZSxrQkFBVCxHQUE4QjtBQUNuQyxVQUFJLEtBQUtFLGVBQVQsRUFBMEI7QUFDeEJHLG9CQUFZLENBQUMsS0FBS0gsZUFBTixDQUFaO0FBQ0EsZUFBTyxLQUFLQSxlQUFaO0FBQ0Q7QUFDRjtBQUNEOztBQVJDLEdBN0pxQixFQXVLckI7QUFDRHZlLE9BQUcsRUFBRSxhQURKO0FBRURLLFNBQUssRUFBRSxTQUFTMmMsV0FBVCxHQUF1QjtBQUM1QixXQUFLaFgsU0FBTCxHQUFpQixLQUFLNkIsTUFBTCxDQUFZc0IsZUFBWixDQUE0QixLQUFLbkQsU0FBakMsRUFBNEMxQixTQUFTLENBQUNFLElBQXRELENBQWpCO0FBQ0Q7QUFDRDs7QUFMQyxHQXZLcUIsRUE4S3JCO0FBQ0R4RSxPQUFHLEVBQUUscUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVM0YyxtQkFBVCxHQUErQjtBQUNwQyxVQUFJLEtBQUtyRCxjQUFMLEtBQXdCLEtBQUs1VCxTQUFqQyxFQUE0QyxPQURSLENBQ2dCOztBQUVwRCxXQUFLZ1gsV0FBTDtBQUNEO0FBQ0Q7O0FBUEMsR0E5S3FCLEVBdUxyQjtBQUNEaGQsT0FBRyxFQUFFLElBREo7QUFFREssU0FBSyxFQUFFLFNBQVNzZSxFQUFULENBQVlwQixFQUFaLEVBQWdCM0MsT0FBaEIsRUFBeUI7QUFDOUIsVUFBSSxDQUFDLEtBQUs0QixVQUFMLENBQWdCZSxFQUFoQixDQUFMLEVBQTBCLEtBQUtmLFVBQUwsQ0FBZ0JlLEVBQWhCLElBQXNCLEVBQXRCOztBQUUxQixXQUFLZixVQUFMLENBQWdCZSxFQUFoQixFQUFvQnRaLElBQXBCLENBQXlCMlcsT0FBekI7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7QUFDRDs7QUFUQyxHQXZMcUIsRUFrTXJCO0FBQ0Q1YSxPQUFHLEVBQUUsS0FESjtBQUVESyxTQUFLLEVBQUUsU0FBU3VlLEdBQVQsQ0FBYXJCLEVBQWIsRUFBaUIzQyxPQUFqQixFQUEwQjtBQUMvQixVQUFJLENBQUMsS0FBSzRCLFVBQUwsQ0FBZ0JlLEVBQWhCLENBQUwsRUFBMEIsT0FBTyxJQUFQOztBQUUxQixVQUFJLENBQUMzQyxPQUFMLEVBQWM7QUFDWixlQUFPLEtBQUs0QixVQUFMLENBQWdCZSxFQUFoQixDQUFQO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBSXNCLE1BQU0sR0FBRyxLQUFLckMsVUFBTCxDQUFnQmUsRUFBaEIsRUFBb0JqYyxPQUFwQixDQUE0QnNaLE9BQTVCLENBQWI7O0FBRUEsVUFBSWlFLE1BQU0sSUFBSSxDQUFkLEVBQWlCLEtBQUtyQyxVQUFMLENBQWdCZSxFQUFoQixFQUFvQi9SLE1BQXBCLENBQTJCcVQsTUFBM0IsRUFBbUMsQ0FBbkM7QUFDakIsYUFBTyxJQUFQO0FBQ0Q7QUFDRDs7QUFmQyxHQWxNcUIsRUFtTnJCO0FBQ0Q3ZSxPQUFHLEVBQUUsVUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3NjLFFBQVQsQ0FBa0I1QyxDQUFsQixFQUFxQjtBQUMxQixXQUFLMEUsV0FBTCxHQUFtQjFFLENBQW5COztBQUVBLFdBQUtzRSxrQkFBTCxHQUgwQixDQUdDOzs7QUFHM0IsVUFBSSxDQUFDLEtBQUtYLFVBQVYsRUFBc0IsT0FBTyxLQUFLUCxXQUFMLEVBQVA7QUFDdEIsVUFBSXBXLE9BQU8sR0FBRyxJQUFJaEIsY0FBSixFQUFtQjtBQUNqQyxXQUFLcUMsRUFBTCxDQUFRL0gsS0FETSxFQUNDLEtBQUsyRixTQUROLEVBQ2lCO0FBQy9CLFdBQUszRixLQUZTLEVBRUYsS0FBS3FkLFVBRkgsQ0FBZDtBQUdBLFVBQUlvQixXQUFXLEdBQUcsS0FBS2pYLE1BQUwsQ0FBWStDLGFBQTlCO0FBQ0EsVUFBSTZILE1BQU0sR0FBRyxLQUFLNUssTUFBTCxDQUFZMkQsTUFBWixDQUFtQnpFLE9BQU8sQ0FBQ1gsY0FBM0IsRUFBMkNXLE9BQU8sQ0FBQ2dZLE9BQVIsQ0FBZ0J0ZixNQUEzRCxFQUFtRXNILE9BQU8sQ0FBQ0UsUUFBM0UsRUFBcUZGLE9BQU8sQ0FBQzJFLGVBQTdGLEVBQThHK0csTUFBM0gsQ0FYMEIsQ0FXeUc7QUFDbkk7O0FBRUEsVUFBSS9HLGVBQWUsR0FBR29ULFdBQVcsS0FBSyxLQUFLalgsTUFBTCxDQUFZK0MsYUFBNUIsR0FBNEM3RCxPQUFPLENBQUMyRSxlQUFwRCxHQUFzRXBILFNBQVMsQ0FBQ0MsSUFBdEc7QUFDQSxVQUFJeUIsU0FBUyxHQUFHLEtBQUs2QixNQUFMLENBQVlzQixlQUFaLENBQTRCcEMsT0FBTyxDQUFDWCxjQUFSLEdBQXlCcU0sTUFBckQsRUFBNkQvRyxlQUE3RCxDQUFoQjtBQUNBLFdBQUtpUyxhQUFMO0FBQ0EsV0FBS1EsWUFBTCxDQUFrQm5ZLFNBQWxCO0FBQ0EsYUFBTyxLQUFLeVksV0FBWjtBQUNEO0FBQ0Q7O0FBdEJDLEdBbk5xQixFQTJPckI7QUFDRHplLE9BQUcsRUFBRSxXQURKO0FBRURLLFNBQUssRUFBRSxTQUFTdWMsU0FBVCxHQUFxQjtBQUMxQixVQUFJLEtBQUt2YyxLQUFMLEtBQWUsS0FBSytILEVBQUwsQ0FBUS9ILEtBQTNCLEVBQWtDO0FBQ2hDLGFBQUs4YyxXQUFMO0FBQ0Q7O0FBRUQsV0FBS3RWLE1BQUwsQ0FBWXFCLFFBQVo7QUFDQSxXQUFLeVUsYUFBTDs7QUFFQSxXQUFLakIsY0FBTDtBQUNEO0FBQ0Q7O0FBWkMsR0EzT3FCLEVBeVByQjtBQUNEMWMsT0FBRyxFQUFFLFNBREo7QUFFREssU0FBSyxFQUFFLFNBQVN3YyxPQUFULENBQWlCVSxFQUFqQixFQUFxQjtBQUMxQkEsUUFBRSxDQUFDeUIsY0FBSDtBQUNBekIsUUFBRSxDQUFDMEIsZUFBSDtBQUNEO0FBQ0Q7O0FBTkMsR0F6UHFCLEVBaVFyQjtBQUNEamYsT0FBRyxFQUFFLFVBREo7QUFFREssU0FBSyxFQUFFLFNBQVN5YyxRQUFULENBQWtCUyxFQUFsQixFQUFzQjtBQUMzQixXQUFLTixtQkFBTDtBQUNEO0FBQ0Q7O0FBTEMsR0FqUXFCLEVBd1FyQjtBQUNEamQsT0FBRyxFQUFFLFVBREo7QUFFREssU0FBSyxFQUFFLFNBQVMwYyxRQUFULENBQWtCUSxFQUFsQixFQUFzQjtBQUMzQixXQUFLTixtQkFBTDtBQUNEO0FBQ0Q7O0FBTEMsR0F4UXFCLEVBK1FyQjtBQUNEamQsT0FBRyxFQUFFLFNBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2ZSxPQUFULEdBQW1CO0FBQ3hCLFdBQUs3QixhQUFMLEdBRHdCLENBQ0Y7OztBQUd0QixXQUFLYixVQUFMLENBQWdCL2MsTUFBaEIsR0FBeUIsQ0FBekIsQ0FKd0IsQ0FJSTs7QUFFNUIsYUFBTyxLQUFLMkksRUFBWjtBQUNEO0FBVEEsR0EvUXFCLEVBeVJyQjtBQUNEcEksT0FBRyxFQUFFLE1BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLc0YsTUFBTCxDQUFZbUUsSUFBbkI7QUFDRCxLQUpBO0FBS0RySixPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhcUosSUFBYixFQUFtQjtBQUN0QixVQUFJLEtBQUtvUixVQUFMLENBQWdCcFIsSUFBaEIsQ0FBSixFQUEyQjs7QUFFM0IsVUFBSSxFQUFFQSxJQUFJLFlBQVk3RCxNQUFLLENBQUNJLE1BQXhCLEtBQW1DLEtBQUtWLE1BQUwsQ0FBWTlJLFdBQVosS0FBNEJnTixXQUFXLENBQUNDLElBQUQsQ0FBOUUsRUFBc0Y7QUFDcEYsYUFBS25FLE1BQUwsQ0FBWWUsYUFBWixDQUEwQjtBQUN4Qm9ELGNBQUksRUFBRUE7QUFEa0IsU0FBMUI7QUFHQTtBQUNEOztBQUVELFVBQUluRSxNQUFNLEdBQUc4RSxPQUFVLENBQUM7QUFDdEJYLFlBQUksRUFBRUE7QUFEZ0IsT0FBRCxDQUF2QjtBQUdBbkUsWUFBTSxDQUFDa0csYUFBUCxHQUF1QixLQUFLbEcsTUFBTCxDQUFZa0csYUFBbkM7QUFDQSxXQUFLbEcsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7QUFDRDs7QUFyQkMsR0F6UnFCLEVBZ1RyQjtBQUNEN0gsT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLaUcsTUFBWjtBQUNELEtBSkE7QUFLRDdGLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF5QixHQUFiLEVBQWtCO0FBQ3JCLFdBQUt5RCxNQUFMLENBQVl4SCxLQUFaLEdBQW9CK0QsR0FBcEI7QUFDQSxXQUFLdVosYUFBTDtBQUNBLFdBQUtYLFdBQUw7QUFDRDtBQUNEOztBQVZDLEdBaFRxQixFQTRUckI7QUFDRGhkLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS2thLGNBQVo7QUFDRCxLQUpBO0FBS0Q5WixPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFheUIsR0FBYixFQUFrQjtBQUNyQixXQUFLeUQsTUFBTCxDQUFZa0csYUFBWixHQUE0QjNKLEdBQTVCO0FBQ0EsV0FBS3VaLGFBQUw7QUFDQSxXQUFLWCxXQUFMO0FBQ0Q7QUFDRDs7QUFWQyxHQTVUcUIsRUF3VXJCO0FBQ0RoZCxPQUFHLEVBQUUsWUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtzRixNQUFMLENBQVlzUixVQUFuQjtBQUNELEtBSkE7QUFLRHhXLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWFpVixHQUFiLEVBQWtCO0FBQ3JCLFdBQUsvUCxNQUFMLENBQVlzUixVQUFaLEdBQXlCdkIsR0FBekI7QUFDQSxXQUFLK0YsYUFBTDtBQUNBLFdBQUtYLFdBQUw7QUFDRDtBQVRBLEdBeFVxQixFQWtWckI7QUFDRGhkLE9BQUcsRUFBRSxnQkFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtnYyxlQUFMLEdBQXVCLEtBQUtELGtCQUE1QixHQUFpRCxLQUFLbFcsRUFBTCxDQUFRd1IsY0FBaEU7QUFDRDtBQUNEOztBQUxDLEdBbFZxQixFQXlWckI7QUFDRDVaLE9BQUcsRUFBRSxXQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS2djLGVBQUwsR0FBdUIsS0FBS0Qsa0JBQTVCLEdBQWlELEtBQUtsVyxFQUFMLENBQVF5UixZQUFoRTtBQUNELEtBSkE7QUFLRGxYLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWFrQyxHQUFiLEVBQWtCO0FBQ3JCLFVBQUksQ0FBQyxLQUFLdUQsRUFBTixJQUFZLENBQUMsS0FBS0EsRUFBTCxDQUFRK1csUUFBekIsRUFBbUM7QUFDbkMsV0FBSy9XLEVBQUwsQ0FBUXVSLE1BQVIsQ0FBZTlVLEdBQWYsRUFBb0JBLEdBQXBCOztBQUVBLFdBQUs2WCxjQUFMO0FBQ0Q7QUFWQSxHQXpWcUIsQ0FBWixDQUFaOztBQXNXQSxTQUFPcFUsU0FBUDtBQUNELENBalpELEVBRkE7O0FBb1pBSCxNQUFLLENBQUNHLFNBQU4sR0FBa0JBLGVBQWxCO0FBRWVBLGtFQUFmLEU7O0FDM2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSWVILGdEQUFmLEU7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUlpWCxlQUFVLEdBQ2QsYUFDQSxVQUFVMUksY0FBVixFQUEwQjtBQUN4QnBXLFdBQVMsQ0FBQzhlLFVBQUQsRUFBYTFJLGNBQWIsQ0FBVDs7QUFFQSxXQUFTMEksVUFBVCxHQUFzQjtBQUNwQm5nQixtQkFBZSxDQUFDLElBQUQsRUFBT21nQixVQUFQLENBQWY7O0FBRUEsV0FBT3JkLDBCQUEwQixDQUFDLElBQUQsRUFBT3BCLGVBQWUsQ0FBQ3llLFVBQUQsQ0FBZixDQUE0QjlSLEtBQTVCLENBQWtDLElBQWxDLEVBQXdDL0YsU0FBeEMsQ0FBUCxDQUFqQztBQUNEOztBQUVEdEgsY0FBWSxDQUFDbWYsVUFBRCxFQUFhLENBQUM7QUFDeEJwZixPQUFHLEVBQUUsU0FEbUI7O0FBR3hCOzs7O0FBSUFLLFNBQUssRUFBRSxTQUFTb0ksT0FBVCxDQUFpQkosSUFBakIsRUFBdUI7QUFDNUI7QUFDQSxVQUFJQSxJQUFJLENBQUNnWCxJQUFULEVBQWVoWCxJQUFJLENBQUMyRCxJQUFMLEdBQVksSUFBSWlMLE1BQUosQ0FBVzVPLElBQUksQ0FBQ2dYLElBQUwsQ0FBVSxDQUFWLEVBQWE1ZixNQUF4QixDQUFaOztBQUVmMkMsVUFBSSxDQUFDekIsZUFBZSxDQUFDeWUsVUFBVSxDQUFDcGdCLFNBQVosQ0FBaEIsRUFBd0MsU0FBeEMsRUFBbUQsSUFBbkQsQ0FBSixDQUE2RDJDLElBQTdELENBQWtFLElBQWxFLEVBQXdFMEcsSUFBeEU7QUFDRDtBQUNEOzs7O0FBYndCLEdBQUQsRUFpQnRCO0FBQ0RySSxPQUFHLEVBQUUsWUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzZKLFVBQVQsR0FBc0I7QUFDM0IsVUFBSTRGLEtBQUssR0FBRyxJQUFaO0FBQUEsVUFDSW1JLEtBREo7O0FBR0EsV0FBSyxJQUFJSyxJQUFJLEdBQUcvUSxTQUFTLENBQUM5SCxNQUFyQixFQUE2QjJTLElBQUksR0FBRyxJQUFJL08sS0FBSixDQUFVaVYsSUFBVixDQUFwQyxFQUFxREMsSUFBSSxHQUFHLENBQWpFLEVBQW9FQSxJQUFJLEdBQUdELElBQTNFLEVBQWlGQyxJQUFJLEVBQXJGLEVBQXlGO0FBQ3ZGbkcsWUFBSSxDQUFDbUcsSUFBRCxDQUFKLEdBQWFoUixTQUFTLENBQUNnUixJQUFELENBQXRCO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLOEcsSUFBTCxDQUFVQyxJQUFWLENBQWUsVUFBVXZGLENBQVYsRUFBYTtBQUNqQyxlQUFPQSxDQUFDLENBQUN6WSxPQUFGLENBQVV3TyxLQUFLLENBQUMvQixhQUFoQixLQUFrQyxDQUF6QztBQUNELE9BRk0sS0FFRCxDQUFDa0ssS0FBSyxHQUFHN1YsSUFBSSxDQUFDekIsZUFBZSxDQUFDeWUsVUFBVSxDQUFDcGdCLFNBQVosQ0FBaEIsRUFBd0MsWUFBeEMsRUFBc0QsSUFBdEQsQ0FBYixFQUEwRTJDLElBQTFFLENBQStFMkwsS0FBL0UsQ0FBcUYySyxLQUFyRixFQUE0RixDQUFDLElBQUQsRUFBT08sTUFBUCxDQUFjcEcsSUFBZCxDQUE1RixDQUZOO0FBR0Q7QUFiQSxHQWpCc0IsQ0FBYixDQUFaOztBQWlDQSxTQUFPZ04sVUFBUDtBQUNELENBM0NELENBMkNFbFQsY0EzQ0YsQ0FGQTs7QUE4Q0EvRCxNQUFLLENBQUNpWCxVQUFOLEdBQW1CQSxlQUFuQjtBQUVlQSwrREFBZixFOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFhQSxJQUFJL1MsbUJBQVksR0FDaEIsYUFDQSxVQUFVcUQsT0FBVixFQUFtQjtBQUNqQnBQLFdBQVMsQ0FBQytMLFlBQUQsRUFBZXFELE9BQWYsQ0FBVDtBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFDQSxXQUFTckQsWUFBVCxDQUFzQmhFLElBQXRCLEVBQTRCO0FBQzFCcEosbUJBQWUsQ0FBQyxJQUFELEVBQU9vTixZQUFQLENBQWY7O0FBRUEsV0FBT3RLLDBCQUEwQixDQUFDLElBQUQsRUFBT3BCLGVBQWUsQ0FBQzBMLFlBQUQsQ0FBZixDQUE4QjFLLElBQTlCLENBQW1DLElBQW5DLEVBQXlDN0IsTUFBTSxDQUFDa0gsTUFBUCxDQUFjLEVBQWQsRUFBa0JxRixZQUFZLENBQUMzRCxRQUEvQixFQUF5QyxFQUF6QyxFQUE2Q0wsSUFBN0MsQ0FBekMsQ0FBUCxDQUFqQztBQUNEO0FBQ0Q7Ozs7O0FBS0FwSSxjQUFZLENBQUNvTSxZQUFELEVBQWUsQ0FBQztBQUMxQnJNLE9BQUcsRUFBRSxTQURxQjtBQUUxQkssU0FBSyxFQUFFLFNBQVNvSSxPQUFULENBQWlCSixJQUFqQixFQUF1QjtBQUM1QmpHLFVBQUksQ0FBQ3pCLGVBQWUsQ0FBQzBMLFlBQVksQ0FBQ3JOLFNBQWQsQ0FBaEIsRUFBMEMsU0FBMUMsRUFBcUQsSUFBckQsQ0FBSixDQUErRDJDLElBQS9ELENBQW9FLElBQXBFLEVBQTBFMEcsSUFBMUU7O0FBRUEsV0FBS2tYLGNBQUw7QUFDRDtBQUNEOztBQVAwQixHQUFELEVBU3hCO0FBQ0R2ZixPQUFHLEVBQUUsZ0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVNrZixjQUFULEdBQTBCO0FBQy9CO0FBQ0EsVUFBSWxaLEtBQUssR0FBRyxPQUFPLEtBQUttWixhQUFMLEdBQXFCLFVBQXJCLEdBQWtDLEVBQXpDLENBQVo7QUFDQSxVQUFJQyxRQUFRLEdBQUcsbUJBQWY7QUFDQSxVQUFJQyxHQUFHLEdBQUcsTUFBVjtBQUNBLFVBQUkvWSxHQUFHLEdBQUcsQ0FBQyxLQUFLZ1osS0FBTCxHQUFhLE1BQU0xYSxZQUFZLENBQUMsS0FBSzJhLEtBQU4sQ0FBbEIsR0FBaUMsUUFBakMsR0FBNEMsS0FBS0QsS0FBakQsR0FBeUQsS0FBdEUsR0FBOEUsRUFBL0UsSUFBcUYsR0FBL0Y7QUFDQSxXQUFLRSxrQkFBTCxHQUEwQixJQUFJaGEsTUFBSixDQUFXUSxLQUFLLEdBQUdvWixRQUFSLEdBQW1COVksR0FBOUIsQ0FBMUI7QUFDQSxXQUFLbVosYUFBTCxHQUFxQixJQUFJamEsTUFBSixDQUFXUSxLQUFLLEdBQUdxWixHQUFSLEdBQWMvWSxHQUF6QixDQUFyQjtBQUNBLFdBQUtvWixpQkFBTCxHQUF5QixJQUFJbGEsTUFBSixDQUFXLE1BQU0sS0FBS21hLFVBQUwsQ0FBZ0J6UixHQUFoQixDQUFvQnRKLFlBQXBCLEVBQWtDdUosSUFBbEMsQ0FBdUMsRUFBdkMsQ0FBTixHQUFtRCxHQUE5RCxFQUFtRSxHQUFuRSxDQUF6QjtBQUNBLFdBQUt5Uix5QkFBTCxHQUFpQyxJQUFJcGEsTUFBSixDQUFXWixZQUFZLENBQUMsS0FBS2liLGtCQUFOLENBQXZCLEVBQWtELEdBQWxELENBQWpDO0FBQ0Q7QUFDRDs7QUFiQyxHQVR3QixFQXdCeEI7QUFDRGxnQixPQUFHLEVBQUUsNEJBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4ZiwwQkFBVCxDQUFvQzlmLEtBQXBDLEVBQTJDO0FBQ2hELGFBQU9BLEtBQUssQ0FBQzZFLE9BQU4sQ0FBYyxLQUFLK2EseUJBQW5CLEVBQThDLEVBQTlDLENBQVA7QUFDRDtBQUNEOztBQUxDLEdBeEJ3QixFQStCeEI7QUFDRGpnQixPQUFHLEVBQUUsNEJBREo7QUFFREssU0FBSyxFQUFFLFNBQVMrZiwwQkFBVCxDQUFvQy9mLEtBQXBDLEVBQTJDO0FBQ2hEO0FBQ0EsVUFBSWdnQixLQUFLLEdBQUdoZ0IsS0FBSyxDQUFDbVosS0FBTixDQUFZLEtBQUtvRyxLQUFqQixDQUFaO0FBQ0FTLFdBQUssQ0FBQyxDQUFELENBQUwsR0FBV0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTbmIsT0FBVCxDQUFpQix1QkFBakIsRUFBMEMsS0FBS2diLGtCQUEvQyxDQUFYO0FBQ0EsYUFBT0csS0FBSyxDQUFDN1IsSUFBTixDQUFXLEtBQUtvUixLQUFoQixDQUFQO0FBQ0Q7QUFDRDs7OztBQVJDLEdBL0J3QixFQTJDeEI7QUFDRDVmLE9BQUcsRUFBRSxXQURKO0FBRURLLFNBQUssRUFBRSxTQUFTdUosU0FBVCxDQUFtQnhGLEdBQW5CLEVBQXdCO0FBQzdCLFVBQUk2VCxLQUFKOztBQUVBLFdBQUssSUFBSUssSUFBSSxHQUFHL1EsU0FBUyxDQUFDOUgsTUFBckIsRUFBNkIyUyxJQUFJLEdBQUcsSUFBSS9PLEtBQUosQ0FBVWlWLElBQUksR0FBRyxDQUFQLEdBQVdBLElBQUksR0FBRyxDQUFsQixHQUFzQixDQUFoQyxDQUFwQyxFQUF3RUMsSUFBSSxHQUFHLENBQXBGLEVBQXVGQSxJQUFJLEdBQUdELElBQTlGLEVBQW9HQyxJQUFJLEVBQXhHLEVBQTRHO0FBQzFHbkcsWUFBSSxDQUFDbUcsSUFBSSxHQUFHLENBQVIsQ0FBSixHQUFpQmhSLFNBQVMsQ0FBQ2dSLElBQUQsQ0FBMUI7QUFDRDs7QUFFRCxhQUFPLENBQUNOLEtBQUssR0FBRzdWLElBQUksQ0FBQ3pCLGVBQWUsQ0FBQzBMLFlBQVksQ0FBQ3JOLFNBQWQsQ0FBaEIsRUFBMEMsV0FBMUMsRUFBdUQsSUFBdkQsQ0FBYixFQUEyRTJDLElBQTNFLENBQWdGMkwsS0FBaEYsQ0FBc0YySyxLQUF0RixFQUE2RixDQUFDLElBQUQsRUFBTyxLQUFLa0ksMEJBQUwsQ0FBZ0MvYixHQUFHLENBQUNjLE9BQUosQ0FBWSxLQUFLNmEsaUJBQWpCLEVBQW9DLEtBQUtILEtBQXpDLENBQWhDLENBQVAsRUFBeUZwSCxNQUF6RixDQUFnR3BHLElBQWhHLENBQTdGLENBQVA7QUFDRDtBQUNEOztBQVhDLEdBM0N3QixFQXdEeEI7QUFDRHBTLE9BQUcsRUFBRSxrQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU2lnQixnQkFBVCxDQUEwQjNKLEVBQTFCLEVBQThCO0FBQ25DLFVBQUk0SixrQkFBa0IsR0FBR2haLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxLQUE3RjtBQUNBLFVBQUlpWixLQUFLLEdBQUcsQ0FBWjs7QUFFQSxXQUFLLElBQUkzYixHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHOFIsRUFBeEIsRUFBNEIsRUFBRTlSLEdBQTlCLEVBQW1DO0FBQ2pDLFlBQUksS0FBSzJELE1BQUwsQ0FBWWxILE9BQVosQ0FBb0IsS0FBSzRlLGtCQUF6QixFQUE2Q3JiLEdBQTdDLE1BQXNEQSxHQUExRCxFQUErRDtBQUM3RCxZQUFFMmIsS0FBRjtBQUNBLGNBQUlELGtCQUFKLEVBQXdCNUosRUFBRSxJQUFJLEtBQUt1SixrQkFBTCxDQUF3QnpnQixNQUE5QjtBQUN6QjtBQUNGOztBQUVELGFBQU8rZ0IsS0FBUDtBQUNEO0FBQ0Q7O0FBZkMsR0F4RHdCLEVBeUV4QjtBQUNEeGdCLE9BQUcsRUFBRSwyQkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU29nQix5QkFBVCxHQUFxQztBQUMxQyxVQUFJdGEsS0FBSyxHQUFHb0IsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQUtpQixNQUFyRjtBQUNBLGFBQU8sS0FBSzhYLGdCQUFMLENBQXNCLEtBQUtILDBCQUFMLENBQWdDaGEsS0FBaEMsRUFBdUMxRyxNQUE3RCxFQUFxRSxJQUFyRSxDQUFQO0FBQ0Q7QUFDRDs7OztBQU5DLEdBekV3QixFQW1GeEI7QUFDRE8sT0FBRyxFQUFFLGNBREo7QUFFREssU0FBSyxFQUFFLFNBQVMrSSxZQUFULEdBQXdCO0FBQzdCLFVBQUlDLE9BQU8sR0FBRzlCLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxDQUFsRjtBQUNBLFVBQUkrQixLQUFLLEdBQUcvQixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsS0FBS2xILEtBQUwsQ0FBV1osTUFBM0Y7QUFDQSxVQUFJa0ssS0FBSyxHQUFHcEMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixHQUF1QjhILFNBQVMsQ0FBQyxDQUFELENBQWhDLEdBQXNDM0QsU0FBbEQ7O0FBRUEsVUFBSThjLHFCQUFxQixHQUFHLEtBQUtDLDBCQUFMLENBQWdDdFgsT0FBaEMsRUFBeUNDLEtBQXpDLENBQTVCOztBQUVBLFVBQUlzWCxzQkFBc0IsR0FBRzVkLGNBQWMsQ0FBQzBkLHFCQUFELEVBQXdCLENBQXhCLENBQTNDOztBQUVBclgsYUFBTyxHQUFHdVgsc0JBQXNCLENBQUMsQ0FBRCxDQUFoQztBQUNBdFgsV0FBSyxHQUFHc1gsc0JBQXNCLENBQUMsQ0FBRCxDQUE5QjtBQUNBLGFBQU8sS0FBS1QsMEJBQUwsQ0FBZ0MvZCxJQUFJLENBQUN6QixlQUFlLENBQUMwTCxZQUFZLENBQUNyTixTQUFkLENBQWhCLEVBQTBDLGNBQTFDLEVBQTBELElBQTFELENBQUosQ0FBb0UyQyxJQUFwRSxDQUF5RSxJQUF6RSxFQUErRTBILE9BQS9FLEVBQXdGQyxLQUF4RixFQUErRkssS0FBL0YsQ0FBaEMsQ0FBUDtBQUNEO0FBQ0Q7Ozs7QUFmQyxHQW5Gd0IsRUFzR3hCO0FBQ0QzSixPQUFHLEVBQUUsZ0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVNvSixjQUFULENBQXdCQyxFQUF4QixFQUE0QjtBQUNqQyxVQUFJQyxLQUFLLEdBQUdwQyxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsRUFBaEY7QUFDQSxVQUFJLENBQUMsS0FBSzJZLGtCQUFWLEVBQThCLE9BQU85ZCxJQUFJLENBQUN6QixlQUFlLENBQUMwTCxZQUFZLENBQUNyTixTQUFkLENBQWhCLEVBQTBDLGdCQUExQyxFQUE0RCxJQUE1RCxDQUFKLENBQXNFMkMsSUFBdEUsQ0FBMkUsSUFBM0UsRUFBaUYrSCxFQUFqRixFQUFxRkMsS0FBckYsQ0FBUDtBQUM5QixVQUFJa1gsbUJBQW1CLEdBQUdsWCxLQUFLLENBQUNoQyxJQUFOLElBQWNnQyxLQUFLLENBQUNXLGdCQUFwQixHQUF1Q1gsS0FBSyxDQUFDVyxnQkFBTixDQUF1QjlCLE1BQTlELEdBQXVFLEtBQUtBLE1BQXRHOztBQUVBLFVBQUlzWSw2QkFBNkIsR0FBRyxLQUFLTCx5QkFBTCxDQUErQkksbUJBQS9CLENBQXBDOztBQUVBLFdBQUtyWSxNQUFMLEdBQWMsS0FBSzJYLDBCQUFMLENBQWdDLEtBQUs5ZixLQUFyQyxDQUFkOztBQUVBLFVBQUkwZ0IsYUFBYSxHQUFHM2UsSUFBSSxDQUFDekIsZUFBZSxDQUFDMEwsWUFBWSxDQUFDck4sU0FBZCxDQUFoQixFQUEwQyxnQkFBMUMsRUFBNEQsSUFBNUQsQ0FBSixDQUFzRTJDLElBQXRFLENBQTJFLElBQTNFLEVBQWlGK0gsRUFBakYsRUFBcUZDLEtBQXJGLENBQXBCOztBQUVBLFdBQUtuQixNQUFMLEdBQWMsS0FBSzRYLDBCQUFMLENBQWdDLEtBQUs1WCxNQUFyQyxDQUFkO0FBQ0EsVUFBSXdZLGVBQWUsR0FBR3JYLEtBQUssQ0FBQ2hDLElBQU4sSUFBY2dDLEtBQUssQ0FBQ1csZ0JBQXBCLEdBQXVDWCxLQUFLLENBQUNXLGdCQUFOLENBQXVCOUIsTUFBOUQsR0FBdUUsS0FBS0EsTUFBbEc7O0FBRUEsVUFBSXlZLHlCQUF5QixHQUFHLEtBQUtSLHlCQUFMLENBQStCTyxlQUEvQixDQUFoQzs7QUFFQUQsbUJBQWEsQ0FBQzNaLFNBQWQsSUFBMkIsQ0FBQzZaLHlCQUF5QixHQUFHSCw2QkFBN0IsSUFBOEQsS0FBS1osa0JBQUwsQ0FBd0J6Z0IsTUFBakg7QUFDQXNoQixtQkFBYSxDQUFDNVosSUFBZCxHQUFxQixDQUFDNFosYUFBYSxDQUFDN1osV0FBZixJQUE4QndDLEVBQUUsS0FBSyxLQUFLd1csa0JBQS9EO0FBQ0EsYUFBT2EsYUFBUDtBQUNEO0FBQ0Q7O0FBdEJDLEdBdEd3QixFQThIeEI7QUFDRC9nQixPQUFHLEVBQUUsc0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2Z0Isb0JBQVQsQ0FBOEJyYyxHQUE5QixFQUFtQztBQUN4QyxVQUFJLEtBQUtxYixrQkFBVCxFQUE2QjtBQUMzQixZQUFJaUIsVUFBVSxHQUFHdGMsR0FBRyxHQUFHLEtBQUtxYixrQkFBTCxDQUF3QnpnQixNQUE5QixHQUF1QyxDQUF4RDtBQUNBLFlBQUkyaEIsWUFBWSxHQUFHLEtBQUsvZ0IsS0FBTCxDQUFXaUIsT0FBWCxDQUFtQixLQUFLNGUsa0JBQXhCLEVBQTRDaUIsVUFBNUMsQ0FBbkI7QUFDQSxZQUFJQyxZQUFZLElBQUl2YyxHQUFwQixFQUF5QixPQUFPdWMsWUFBUDtBQUMxQjs7QUFFRCxhQUFPLENBQUMsQ0FBUjtBQUNEO0FBVkEsR0E5SHdCLEVBeUl4QjtBQUNEcGhCLE9BQUcsRUFBRSw0QkFESjtBQUVESyxTQUFLLEVBQUUsU0FBU3NnQiwwQkFBVCxDQUFvQ25aLElBQXBDLEVBQTBDbVAsRUFBMUMsRUFBOEM7QUFDbkQsVUFBSTBLLHNCQUFzQixHQUFHLEtBQUtILG9CQUFMLENBQTBCMVosSUFBMUIsQ0FBN0I7O0FBRUEsVUFBSTZaLHNCQUFzQixJQUFJLENBQTlCLEVBQWlDN1osSUFBSSxHQUFHNlosc0JBQVA7O0FBRWpDLFVBQUlDLG9CQUFvQixHQUFHLEtBQUtKLG9CQUFMLENBQTBCdkssRUFBMUIsQ0FBM0I7O0FBRUEsVUFBSTJLLG9CQUFvQixJQUFJLENBQTVCLEVBQStCM0ssRUFBRSxHQUFHMkssb0JBQW9CLEdBQUcsS0FBS3BCLGtCQUFMLENBQXdCemdCLE1BQXBEO0FBQy9CLGFBQU8sQ0FBQytILElBQUQsRUFBT21QLEVBQVAsQ0FBUDtBQUNEO0FBQ0Q7Ozs7QUFaQyxHQXpJd0IsRUF5SnhCO0FBQ0QzVyxPQUFHLEVBQUUsUUFESjtBQUVESyxTQUFLLEVBQUUsU0FBU21LLE1BQVQsR0FBa0I7QUFDdkIsVUFBSW5CLE9BQU8sR0FBRzlCLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxDQUFsRjtBQUNBLFVBQUkrQixLQUFLLEdBQUcvQixTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsS0FBS2xILEtBQUwsQ0FBV1osTUFBM0Y7O0FBRUEsVUFBSThoQixzQkFBc0IsR0FBRyxLQUFLWiwwQkFBTCxDQUFnQ3RYLE9BQWhDLEVBQXlDQyxLQUF6QyxDQUE3Qjs7QUFFQSxVQUFJa1ksc0JBQXNCLEdBQUd4ZSxjQUFjLENBQUN1ZSxzQkFBRCxFQUF5QixDQUF6QixDQUEzQzs7QUFFQWxZLGFBQU8sR0FBR21ZLHNCQUFzQixDQUFDLENBQUQsQ0FBaEM7QUFDQWxZLFdBQUssR0FBR2tZLHNCQUFzQixDQUFDLENBQUQsQ0FBOUI7QUFDQSxVQUFJQyxjQUFjLEdBQUcsS0FBS3BoQixLQUFMLENBQVc4RixLQUFYLENBQWlCLENBQWpCLEVBQW9Ca0QsT0FBcEIsQ0FBckI7QUFDQSxVQUFJcVksYUFBYSxHQUFHLEtBQUtyaEIsS0FBTCxDQUFXOEYsS0FBWCxDQUFpQm1ELEtBQWpCLENBQXBCOztBQUVBLFVBQUl3WCw2QkFBNkIsR0FBRyxLQUFLUixnQkFBTCxDQUFzQm1CLGNBQWMsQ0FBQ2hpQixNQUFyQyxDQUFwQzs7QUFFQSxXQUFLK0ksTUFBTCxHQUFjLEtBQUs0WCwwQkFBTCxDQUFnQyxLQUFLRCwwQkFBTCxDQUFnQ3NCLGNBQWMsR0FBR0MsYUFBakQsQ0FBaEMsQ0FBZDs7QUFFQSxVQUFJVCx5QkFBeUIsR0FBRyxLQUFLUix5QkFBTCxDQUErQmdCLGNBQS9CLENBQWhDOztBQUVBLGFBQU8sSUFBSTNhLGNBQUosQ0FBa0I7QUFDdkJNLGlCQUFTLEVBQUUsQ0FBQzZaLHlCQUF5QixHQUFHSCw2QkFBN0IsSUFBOEQsS0FBS1osa0JBQUwsQ0FBd0J6Z0I7QUFEMUUsT0FBbEIsQ0FBUDtBQUdEO0FBQ0Q7Ozs7QUF6QkMsR0F6SndCLEVBc0x4QjtBQUNETyxPQUFHLEVBQUUsaUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4SSxlQUFULENBQXlCbkQsU0FBekIsRUFBb0NsQixTQUFwQyxFQUErQztBQUNwRCxVQUFJLENBQUMsS0FBS29iLGtCQUFWLEVBQThCLE9BQU9sYSxTQUFQOztBQUU5QixjQUFRbEIsU0FBUjtBQUNFLGFBQUtSLFNBQVMsQ0FBQ0MsSUFBZjtBQUNBLGFBQUtELFNBQVMsQ0FBQ0UsSUFBZjtBQUNBLGFBQUtGLFNBQVMsQ0FBQ0csVUFBZjtBQUNFO0FBQ0UsZ0JBQUlrZCxrQkFBa0IsR0FBRyxLQUFLVCxvQkFBTCxDQUEwQmxiLFNBQVMsR0FBRyxDQUF0QyxDQUF6Qjs7QUFFQSxnQkFBSTJiLGtCQUFrQixJQUFJLENBQTFCLEVBQTZCO0FBQzNCLGtCQUFJQyxxQkFBcUIsR0FBR0Qsa0JBQWtCLEdBQUcsS0FBS3pCLGtCQUFMLENBQXdCemdCLE1BQXpFOztBQUVBLGtCQUFJdUcsU0FBUyxHQUFHNGIscUJBQVosSUFBcUMsS0FBS3ZoQixLQUFMLENBQVdaLE1BQVgsSUFBcUJtaUIscUJBQTFELElBQW1GOWMsU0FBUyxLQUFLUixTQUFTLENBQUNHLFVBQS9HLEVBQTJIO0FBQ3pILHVCQUFPa2Qsa0JBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0Q7O0FBRUgsYUFBS3JkLFNBQVMsQ0FBQ0ksS0FBZjtBQUNBLGFBQUtKLFNBQVMsQ0FBQ0ssV0FBZjtBQUNFO0FBQ0UsZ0JBQUlrZCxtQkFBbUIsR0FBRyxLQUFLWCxvQkFBTCxDQUEwQmxiLFNBQTFCLENBQTFCOztBQUVBLGdCQUFJNmIsbUJBQW1CLElBQUksQ0FBM0IsRUFBOEI7QUFDNUIscUJBQU9BLG1CQUFtQixHQUFHLEtBQUszQixrQkFBTCxDQUF3QnpnQixNQUFyRDtBQUNEO0FBQ0Y7QUExQkw7O0FBNkJBLGFBQU91RyxTQUFQO0FBQ0Q7QUFDRDs7OztBQXBDQyxHQXRMd0IsRUE4TnhCO0FBQ0RoRyxPQUFHLEVBQUUsWUFESjtBQUVESyxTQUFLLEVBQUUsU0FBUzZKLFVBQVQsQ0FBb0JQLEtBQXBCLEVBQTJCO0FBQ2hDLFVBQUltWSxNQUFNLEdBQUduWSxLQUFLLENBQUNWLEtBQU4sR0FBYyxLQUFLNFcsa0JBQW5CLEdBQXdDLEtBQUtDLGFBQTFELENBRGdDLENBQ3lDOztBQUV6RSxVQUFJaUMsS0FBSyxHQUFHRCxNQUFNLENBQUNFLElBQVAsQ0FBWSxLQUFLN0IsMEJBQUwsQ0FBZ0MsS0FBSzlmLEtBQXJDLENBQVosQ0FBWjs7QUFFQSxVQUFJMGhCLEtBQUosRUFBVztBQUNUO0FBQ0EsWUFBSUUsTUFBTSxHQUFHLEtBQUtBLE1BQWxCO0FBQ0FGLGFBQUssR0FBR0EsS0FBSyxJQUFJLENBQUNHLEtBQUssQ0FBQ0QsTUFBRCxDQUFmLE1BQTZCO0FBQ3JDLGFBQUsxYixHQUFMLElBQVksSUFBWixJQUFvQixLQUFLQSxHQUFMLElBQVksQ0FBaEMsSUFBcUMsS0FBS0EsR0FBTCxJQUFZLEtBQUswYixNQUQ5QyxPQUMyRDtBQUNuRSxhQUFLdmIsR0FBTCxJQUFZLElBQVosSUFBb0IsS0FBS0EsR0FBTCxJQUFZLENBQWhDLElBQXFDLEtBQUt1YixNQUFMLElBQWUsS0FBS3ZiLEdBRmpELENBQVI7QUFHRDs7QUFFRCxhQUFPcWIsS0FBSyxJQUFJM2YsSUFBSSxDQUFDekIsZUFBZSxDQUFDMEwsWUFBWSxDQUFDck4sU0FBZCxDQUFoQixFQUEwQyxZQUExQyxFQUF3RCxJQUF4RCxDQUFKLENBQWtFMkMsSUFBbEUsQ0FBdUUsSUFBdkUsRUFBNkVnSSxLQUE3RSxDQUFoQjtBQUNEO0FBQ0Q7Ozs7QUFqQkMsR0E5TndCLEVBbVB4QjtBQUNEM0osT0FBRyxFQUFFLFVBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2SSxRQUFULEdBQW9CO0FBQ3pCLFVBQUksS0FBSzdJLEtBQVQsRUFBZ0I7QUFDZCxZQUFJNGhCLE1BQU0sR0FBRyxLQUFLQSxNQUFsQjtBQUNBLFlBQUlFLFFBQVEsR0FBR0YsTUFBZixDQUZjLENBRVM7O0FBRXZCLFlBQUksS0FBSzFiLEdBQUwsSUFBWSxJQUFoQixFQUFzQjRiLFFBQVEsR0FBRzdiLElBQUksQ0FBQ0ksR0FBTCxDQUFTeWIsUUFBVCxFQUFtQixLQUFLNWIsR0FBeEIsQ0FBWDtBQUN0QixZQUFJLEtBQUtHLEdBQUwsSUFBWSxJQUFoQixFQUFzQnliLFFBQVEsR0FBRzdiLElBQUksQ0FBQ0MsR0FBTCxDQUFTNGIsUUFBVCxFQUFtQixLQUFLemIsR0FBeEIsQ0FBWDtBQUN0QixZQUFJeWIsUUFBUSxLQUFLRixNQUFqQixFQUF5QixLQUFLbFUsYUFBTCxHQUFxQjFKLE1BQU0sQ0FBQzhkLFFBQUQsQ0FBM0I7QUFDekIsWUFBSUMsU0FBUyxHQUFHLEtBQUsvaEIsS0FBckI7QUFDQSxZQUFJLEtBQUtnaUIsY0FBVCxFQUF5QkQsU0FBUyxHQUFHLEtBQUtFLGVBQUwsQ0FBcUJGLFNBQXJCLENBQVo7QUFDekIsWUFBSSxLQUFLRyxrQkFBVCxFQUE2QkgsU0FBUyxHQUFHLEtBQUtJLG1CQUFMLENBQXlCSixTQUF6QixDQUFaO0FBQzdCLGFBQUs1WixNQUFMLEdBQWM0WixTQUFkO0FBQ0Q7O0FBRURoZ0IsVUFBSSxDQUFDekIsZUFBZSxDQUFDMEwsWUFBWSxDQUFDck4sU0FBZCxDQUFoQixFQUEwQyxVQUExQyxFQUFzRCxJQUF0RCxDQUFKLENBQWdFMkMsSUFBaEUsQ0FBcUUsSUFBckU7QUFDRDtBQUNEOztBQWxCQyxHQW5Qd0IsRUF1UXhCO0FBQ0QzQixPQUFHLEVBQUUsaUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVNpaUIsZUFBVCxDQUF5QmppQixLQUF6QixFQUFnQztBQUNyQyxVQUFJZ2dCLEtBQUssR0FBRyxLQUFLRiwwQkFBTCxDQUFnQzlmLEtBQWhDLEVBQXVDbVosS0FBdkMsQ0FBNkMsS0FBS29HLEtBQWxELENBQVosQ0FEcUMsQ0FDaUM7OztBQUd0RVMsV0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNuYixPQUFULENBQWlCLGlCQUFqQixFQUFvQyxVQUFVb1MsS0FBVixFQUFpQm1MLElBQWpCLEVBQXVCQyxLQUF2QixFQUE4QmpMLEdBQTlCLEVBQW1DO0FBQ2hGLGVBQU9nTCxJQUFJLEdBQUdoTCxHQUFkO0FBQ0QsT0FGVSxDQUFYLENBSnFDLENBTWpDOztBQUVKLFVBQUlwWCxLQUFLLENBQUNaLE1BQU4sSUFBZ0IsQ0FBQyxNQUFNdWlCLElBQU4sQ0FBVzNCLEtBQUssQ0FBQyxDQUFELENBQWhCLENBQXJCLEVBQTJDQSxLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxHQUF0Qjs7QUFFM0MsVUFBSUEsS0FBSyxDQUFDNWdCLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNwQjRnQixhQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU25iLE9BQVQsQ0FBaUIsS0FBakIsRUFBd0IsRUFBeEIsQ0FBWCxDQURvQixDQUNvQjs7QUFFeEMsWUFBSSxDQUFDbWIsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTNWdCLE1BQWQsRUFBc0I0Z0IsS0FBSyxDQUFDNWdCLE1BQU4sR0FBZSxDQUFmLENBSEYsQ0FHb0I7QUFDekM7O0FBRUQsYUFBTyxLQUFLMmdCLDBCQUFMLENBQWdDQyxLQUFLLENBQUM3UixJQUFOLENBQVcsS0FBS29SLEtBQWhCLENBQWhDLENBQVA7QUFDRDtBQUNEOztBQXBCQyxHQXZRd0IsRUE2UnhCO0FBQ0Q1ZixPQUFHLEVBQUUscUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtaUIsbUJBQVQsQ0FBNkJuaUIsS0FBN0IsRUFBb0M7QUFDekMsVUFBSSxDQUFDQSxLQUFMLEVBQVksT0FBT0EsS0FBUDtBQUNaLFVBQUlnZ0IsS0FBSyxHQUFHaGdCLEtBQUssQ0FBQ21aLEtBQU4sQ0FBWSxLQUFLb0csS0FBakIsQ0FBWjtBQUNBLFVBQUlTLEtBQUssQ0FBQzVnQixNQUFOLEdBQWUsQ0FBbkIsRUFBc0I0Z0IsS0FBSyxDQUFDcGMsSUFBTixDQUFXLEVBQVg7QUFDdEJvYyxXQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzNJLE1BQVQsQ0FBZ0IsS0FBS2lJLEtBQXJCLEVBQTRCLEdBQTVCLENBQVg7QUFDQSxhQUFPVSxLQUFLLENBQUM3UixJQUFOLENBQVcsS0FBS29SLEtBQWhCLENBQVA7QUFDRDtBQUNEOzs7O0FBVEMsR0E3UndCLEVBMFN4QjtBQUNENWYsT0FBRyxFQUFFLGVBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLNGQsMEJBQUwsQ0FBZ0MsS0FBS21DLGVBQUwsQ0FBcUIsS0FBS2ppQixLQUExQixDQUFoQyxFQUFrRTZFLE9BQWxFLENBQTBFLEtBQUswYSxLQUEvRSxFQUFzRixHQUF0RixDQUFQO0FBQ0QsS0FKQTtBQUtEamQsT0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYW9MLGFBQWIsRUFBNEI7QUFDL0JuTCxVQUFJLENBQUNqQyxlQUFlLENBQUMwTCxZQUFZLENBQUNyTixTQUFkLENBQWhCLEVBQTBDLGVBQTFDLEVBQTJEK08sYUFBYSxDQUFDN0ksT0FBZCxDQUFzQixHQUF0QixFQUEyQixLQUFLMGEsS0FBaEMsQ0FBM0QsRUFBbUcsSUFBbkcsRUFBeUcsSUFBekcsQ0FBSjtBQUNEO0FBQ0Q7Ozs7QUFSQyxHQTFTd0IsRUFzVHhCO0FBQ0Q1ZixPQUFHLEVBQUUsWUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPNkosTUFBTSxDQUFDLEtBQUsyQixhQUFOLENBQWI7QUFDRCxLQUpBO0FBS0RwTCxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhZ2dCLENBQWIsRUFBZ0I7QUFDbkIvZixVQUFJLENBQUNqQyxlQUFlLENBQUMwTCxZQUFZLENBQUNyTixTQUFkLENBQWhCLEVBQTBDLGVBQTFDLEVBQTJEcUYsTUFBTSxDQUFDc2UsQ0FBRCxDQUFqRSxFQUFzRSxJQUF0RSxFQUE0RSxJQUE1RSxDQUFKO0FBQ0Q7QUFDRDs7QUFSQyxHQXRUd0IsRUFnVXhCO0FBQ0QzaUIsT0FBRyxFQUFFLFFBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLNFcsVUFBWjtBQUNELEtBSkE7QUFLRHhXLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWFzZixNQUFiLEVBQXFCO0FBQ3hCLFdBQUs5SSxVQUFMLEdBQWtCOEksTUFBbEI7QUFDRDtBQUNEOzs7OztBQVJDLEdBaFV3QixFQTZVeEI7QUFDRGppQixPQUFHLEVBQUUsZUFESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtxZ0IsTUFBTCxJQUFlLEtBQUtyYyxHQUFMLElBQVksSUFBWixJQUFvQixLQUFLQSxHQUFMLEdBQVcsQ0FBOUMsSUFBbUQsS0FBS0csR0FBTCxJQUFZLElBQVosSUFBb0IsS0FBS0EsR0FBTCxHQUFXLENBQXpGO0FBQ0Q7QUFKQSxHQTdVd0IsQ0FBZixDQUFaOztBQW9WQSxTQUFPMkYsWUFBUDtBQUNELENBblhELENBbVhFOUQsSUFuWEYsQ0FGQTs7QUFzWEE4RCxtQkFBWSxDQUFDM0QsUUFBYixHQUF3QjtBQUN0QmtYLE9BQUssRUFBRSxHQURlO0FBRXRCTSxvQkFBa0IsRUFBRSxFQUZFO0FBR3RCRixZQUFVLEVBQUUsQ0FBQyxHQUFELENBSFU7QUFJdEJMLE9BQUssRUFBRSxDQUplO0FBS3RCaUQsUUFBTSxFQUFFLEtBTGM7QUFNdEJQLGdCQUFjLEVBQUUsSUFOTTtBQU90QkUsb0JBQWtCLEVBQUU7QUFQRSxDQUF4QjtBQVNBcGEsTUFBSyxDQUFDa0UsWUFBTixHQUFxQkEsbUJBQXJCO0FBRWVBLHFFQUFmLEU7O0FDclpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUlHLHVCQUFjLEdBQ2xCLGFBQ0EsVUFBVWtELE9BQVYsRUFBbUI7QUFDakJwUCxXQUFTLENBQUNrTSxjQUFELEVBQWlCa0QsT0FBakIsQ0FBVDs7QUFFQSxXQUFTbEQsY0FBVCxHQUEwQjtBQUN4QnZOLG1CQUFlLENBQUMsSUFBRCxFQUFPdU4sY0FBUCxDQUFmOztBQUVBLFdBQU96SywwQkFBMEIsQ0FBQyxJQUFELEVBQU9wQixlQUFlLENBQUM2TCxjQUFELENBQWYsQ0FBZ0NjLEtBQWhDLENBQXNDLElBQXRDLEVBQTRDL0YsU0FBNUMsQ0FBUCxDQUFqQztBQUNEOztBQUVEdEgsY0FBWSxDQUFDdU0sY0FBRCxFQUFpQixDQUFDO0FBQzVCeE0sT0FBRyxFQUFFLFNBRHVCOztBQUc1Qjs7OztBQUlBSyxTQUFLLEVBQUUsU0FBU29JLE9BQVQsQ0FBaUJKLElBQWpCLEVBQXVCO0FBQzVCLFVBQUlBLElBQUksQ0FBQzJELElBQVQsRUFBZTNELElBQUksQ0FBQzRDLFFBQUwsR0FBZ0I1QyxJQUFJLENBQUMyRCxJQUFyQjs7QUFFZjVKLFVBQUksQ0FBQ3pCLGVBQWUsQ0FBQzZMLGNBQWMsQ0FBQ3hOLFNBQWhCLENBQWhCLEVBQTRDLFNBQTVDLEVBQXVELElBQXZELENBQUosQ0FBaUUyQyxJQUFqRSxDQUFzRSxJQUF0RSxFQUE0RTBHLElBQTVFO0FBQ0Q7QUFYMkIsR0FBRCxDQUFqQixDQUFaOztBQWNBLFNBQU9tRSxjQUFQO0FBQ0QsQ0F4QkQsQ0F3QkVqRSxJQXhCRixDQUZBOztBQTJCQUosTUFBSyxDQUFDcUUsY0FBTixHQUF1QkEsdUJBQXZCO0FBRWVBLDJFQUFmLEU7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0EsSUFBSUYscUJBQWEsR0FDakIsYUFDQSxVQUFVb0QsT0FBVixFQUFtQjtBQUNqQnBQLFdBQVMsQ0FBQ2dNLGFBQUQsRUFBZ0JvRCxPQUFoQixDQUFUO0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7O0FBR0EsV0FBU3BELGFBQVQsQ0FBdUJqRSxJQUF2QixFQUE2QjtBQUMzQixRQUFJeUgsS0FBSjs7QUFFQTdRLG1CQUFlLENBQUMsSUFBRCxFQUFPcU4sYUFBUCxDQUFmOztBQUVBd0QsU0FBSyxHQUFHL04sMEJBQTBCLENBQUMsSUFBRCxFQUFPcEIsZUFBZSxDQUFDMkwsYUFBRCxDQUFmLENBQStCM0ssSUFBL0IsQ0FBb0MsSUFBcEMsRUFBMEM3QixNQUFNLENBQUNrSCxNQUFQLENBQWMsRUFBZCxFQUFrQnNGLGFBQWEsQ0FBQzVELFFBQWhDLEVBQTBDLEVBQTFDLEVBQThDTCxJQUE5QyxDQUExQyxDQUFQLENBQWxDO0FBQ0F5SCxTQUFLLENBQUMrUyxXQUFOLEdBQW9CLElBQXBCO0FBQ0EsV0FBTy9TLEtBQVA7QUFDRDtBQUNEOzs7OztBQUtBN1AsY0FBWSxDQUFDcU0sYUFBRCxFQUFnQixDQUFDO0FBQzNCdE0sT0FBRyxFQUFFLFNBRHNCO0FBRTNCSyxTQUFLLEVBQUUsU0FBU29JLE9BQVQsQ0FBaUJKLElBQWpCLEVBQXVCO0FBQzVCakcsVUFBSSxDQUFDekIsZUFBZSxDQUFDMkwsYUFBYSxDQUFDdE4sU0FBZixDQUFoQixFQUEyQyxTQUEzQyxFQUFzRCxJQUF0RCxDQUFKLENBQWdFMkMsSUFBaEUsQ0FBcUUsSUFBckUsRUFBMkUwRyxJQUEzRTs7QUFFQSxVQUFJLFVBQVVBLElBQWQsRUFBb0I7QUFDbEI7QUFDQSxhQUFLeWEsYUFBTCxHQUFxQnpmLEtBQUssQ0FBQ0MsT0FBTixDQUFjK0UsSUFBSSxDQUFDMkQsSUFBbkIsSUFBMkIzRCxJQUFJLENBQUMyRCxJQUFMLENBQVV1QyxHQUFWLENBQWMsVUFBVXFLLENBQVYsRUFBYTtBQUN6RSxpQkFBT2pNLE9BQVUsQ0FBQ2lNLENBQUQsQ0FBakI7QUFDRCxTQUYrQyxDQUEzQixHQUVoQixFQUZMO0FBR0Q7QUFDRjtBQUNEOzs7O0FBWjJCLEdBQUQsRUFnQnpCO0FBQ0Q1WSxPQUFHLEVBQUUsZ0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVNvSixjQUFULEdBQTBCO0FBQy9CLFVBQUkxQyxPQUFPLEdBQUcsS0FBS2djLGNBQUwsQ0FBb0J6VixLQUFwQixDQUEwQixJQUExQixFQUFnQy9GLFNBQWhDLENBQWQ7O0FBRUEsVUFBSSxLQUFLc2IsV0FBVCxFQUFzQjtBQUNwQixZQUFJRyxpQkFBSjs7QUFFQWpjLGVBQU8sQ0FBQ00sU0FBUixDQUFrQixDQUFDMmIsaUJBQWlCLEdBQUcsS0FBS0gsV0FBMUIsRUFBdUNoWixXQUF2QyxDQUFtRHlELEtBQW5ELENBQXlEMFYsaUJBQXpELEVBQTRFemIsU0FBNUUsQ0FBbEI7QUFDRDs7QUFFRCxhQUFPUixPQUFQO0FBQ0Q7QUFaQSxHQWhCeUIsRUE2QnpCO0FBQ0QvRyxPQUFHLEVBQUUsZ0JBREo7QUFFREssU0FBSyxFQUFFLFNBQVMwaUIsY0FBVCxHQUEwQjtBQUMvQixVQUFJOVksUUFBUSxHQUFHMUMsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEVBQW5GO0FBQ0EsVUFBSW9DLEtBQUssR0FBR3BDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLFVBQUkwYixtQkFBbUIsR0FBR3RaLEtBQUssQ0FBQ2hDLElBQU4sSUFBY2dDLEtBQUssQ0FBQ1csZ0JBQU4sSUFBMEIsSUFBeEMsR0FBK0NYLEtBQUssQ0FBQ1csZ0JBQU4sQ0FBdUI5QixNQUF0RSxHQUErRSxLQUFLbkksS0FBOUc7QUFDQSxVQUFJNmlCLFVBQVUsR0FBRyxLQUFLdFksYUFBdEI7QUFDQSxVQUFJdVksV0FBVyxHQUFHeFosS0FBSyxDQUFDaEMsSUFBTixJQUFjZ0MsS0FBSyxDQUFDVyxnQkFBTixJQUEwQixJQUF4QyxHQUErQztBQUNqRVgsV0FBSyxDQUFDVyxnQkFBTixDQUF1QjhZLGNBREwsR0FDc0JGLFVBRHhDO0FBRUEsVUFBSUcsU0FBUyxHQUFHSCxVQUFVLENBQUMvYyxLQUFYLENBQWlCZ2QsV0FBVyxDQUFDMWpCLE1BQTdCLENBQWhCO0FBQ0EsVUFBSTZqQixRQUFRLEdBQUcsS0FBS1QsV0FBcEI7QUFDQSxVQUFJOWIsT0FBTyxHQUFHLElBQUlELGNBQUosRUFBZDtBQUNBLFVBQUl5YyxhQUFhLEdBQUdELFFBQVEsSUFBSUEsUUFBUSxDQUFDcGIsS0FBekMsQ0FWK0IsQ0FVaUI7O0FBRWhELFdBQUsyYSxXQUFMLEdBQW1CLEtBQUtXLFVBQUwsQ0FBZ0J2WixRQUFoQixFQUEwQm5LLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYyxFQUFkLEVBQWtCMkMsS0FBbEIsQ0FBMUIsQ0FBbkIsQ0FaK0IsQ0FZeUM7O0FBRXhFLFVBQUksS0FBS2taLFdBQVQsRUFBc0I7QUFDcEIsWUFBSSxLQUFLQSxXQUFMLEtBQXFCUyxRQUF6QixFQUFtQztBQUNqQztBQUNBLGVBQUtULFdBQUwsQ0FBaUI5WixLQUFqQixHQUZpQyxDQUVQOztBQUUxQixjQUFJK1AsQ0FBQyxHQUFHLEtBQUsrSixXQUFMLENBQWlCL2EsTUFBakIsQ0FBd0JxYixXQUF4QixFQUFxQztBQUMzQ3RYLGVBQUcsRUFBRTtBQURzQyxXQUFyQyxDQUFSO0FBR0E5RSxpQkFBTyxDQUFDSyxTQUFSLEdBQW9CMFIsQ0FBQyxDQUFDN1IsUUFBRixDQUFXeEgsTUFBWCxHQUFvQndqQixtQkFBbUIsQ0FBQ3hqQixNQUE1RDs7QUFFQSxjQUFJNGpCLFNBQUosRUFBZTtBQUNiO0FBQ0F0YyxtQkFBTyxDQUFDSyxTQUFSLElBQXFCLEtBQUt5YixXQUFMLENBQWlCL2EsTUFBakIsQ0FBd0J1YixTQUF4QixFQUFtQztBQUN0RHhYLGlCQUFHLEVBQUUsSUFEaUQ7QUFFdERsRSxrQkFBSSxFQUFFO0FBRmdELGFBQW5DLEVBR2xCUCxTQUhIO0FBSUQ7QUFDRixTQWhCRCxNQWdCTztBQUNMO0FBQ0E7QUFDQSxlQUFLeWIsV0FBTCxDQUFpQjNhLEtBQWpCLEdBQXlCcWIsYUFBekI7QUFDRDtBQUNGOztBQUVELGFBQU94YyxPQUFQO0FBQ0Q7QUF6Q0EsR0E3QnlCLEVBdUV6QjtBQUNEL0csT0FBRyxFQUFFLG9CQURKO0FBRURLLFNBQUssRUFBRSxTQUFTMEgsa0JBQVQsR0FBOEI7QUFDbkMsVUFBSWhCLE9BQU8sR0FBRyxLQUFLZ2MsY0FBTCxDQUFvQnpWLEtBQXBCLENBQTBCLElBQTFCLEVBQWdDL0YsU0FBaEMsQ0FBZDs7QUFFQSxVQUFJLEtBQUtzYixXQUFULEVBQXNCO0FBQ3BCOWIsZUFBTyxDQUFDTSxTQUFSLENBQWtCLEtBQUt3YixXQUFMLENBQWlCOWEsa0JBQWpCLEVBQWxCO0FBQ0Q7O0FBRUQsYUFBT2hCLE9BQVA7QUFDRDtBQUNEOzs7O0FBWEMsR0F2RXlCLEVBc0Z6QjtBQUNEL0csT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVNtakIsVUFBVCxDQUFvQnZaLFFBQXBCLEVBQThCO0FBQ25DLFVBQUlOLEtBQUssR0FBR3BDLFNBQVMsQ0FBQzlILE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0I4SCxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCM0QsU0FBekMsR0FBcUQyRCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxFQUFoRjtBQUNBLGFBQU8sS0FBS2tjLFFBQUwsQ0FBY3haLFFBQWQsRUFBd0IsSUFBeEIsRUFBOEJOLEtBQTlCLENBQVA7QUFDRDtBQUNEOzs7O0FBTkMsR0F0RnlCLEVBZ0d6QjtBQUNEM0osT0FBRyxFQUFFLFlBREo7QUFFREssU0FBSyxFQUFFLFNBQVM2SixVQUFULEdBQXNCO0FBQzNCLFVBQUkrTixLQUFKLEVBQVd5TCxrQkFBWDs7QUFFQSxXQUFLLElBQUlwTCxJQUFJLEdBQUcvUSxTQUFTLENBQUM5SCxNQUFyQixFQUE2QjJTLElBQUksR0FBRyxJQUFJL08sS0FBSixDQUFVaVYsSUFBVixDQUFwQyxFQUFxREMsSUFBSSxHQUFHLENBQWpFLEVBQW9FQSxJQUFJLEdBQUdELElBQTNFLEVBQWlGQyxJQUFJLEVBQXJGLEVBQXlGO0FBQ3ZGbkcsWUFBSSxDQUFDbUcsSUFBRCxDQUFKLEdBQWFoUixTQUFTLENBQUNnUixJQUFELENBQXRCO0FBQ0Q7O0FBRUQsYUFBTyxDQUFDTixLQUFLLEdBQUc3VixJQUFJLENBQUN6QixlQUFlLENBQUMyTCxhQUFhLENBQUN0TixTQUFmLENBQWhCLEVBQTJDLFlBQTNDLEVBQXlELElBQXpELENBQWIsRUFBNkUyQyxJQUE3RSxDQUFrRjJMLEtBQWxGLENBQXdGMkssS0FBeEYsRUFBK0YsQ0FBQyxJQUFELEVBQU9PLE1BQVAsQ0FBY3BHLElBQWQsQ0FBL0YsTUFBd0gsQ0FBQyxLQUFLeVEsV0FBTixJQUFxQixDQUFDYSxrQkFBa0IsR0FBRyxLQUFLYixXQUEzQixFQUF3QzNZLFVBQXhDLENBQW1Eb0QsS0FBbkQsQ0FBeURvVyxrQkFBekQsRUFBNkV0UixJQUE3RSxDQUE3SSxDQUFQO0FBQ0Q7QUFDRDs7OztBQVhDLEdBaEd5QixFQStHekI7QUFDRHBTLE9BQUcsRUFBRSxPQURKO0FBRURLLFNBQUssRUFBRSxTQUFTMEksS0FBVCxHQUFpQjtBQUN0QixVQUFJLEtBQUs4WixXQUFULEVBQXNCLEtBQUtBLFdBQUwsQ0FBaUI5WixLQUFqQjtBQUN0QixXQUFLK1osYUFBTCxDQUFtQi9SLE9BQW5CLENBQTJCLFVBQVU2SCxDQUFWLEVBQWE7QUFDdEMsZUFBT0EsQ0FBQyxDQUFDN1AsS0FBRixFQUFQO0FBQ0QsT0FGRDtBQUdEO0FBQ0Q7Ozs7QUFSQyxHQS9HeUIsRUEySHpCO0FBQ0QvSSxPQUFHLEVBQUUsUUFESjs7QUFHRDs7O0FBR0FLLFNBQUssRUFBRSxTQUFTbUssTUFBVCxHQUFrQjtBQUN2QixVQUFJekQsT0FBTyxHQUFHLElBQUlELGNBQUosRUFBZDs7QUFFQSxVQUFJLEtBQUsrYixXQUFULEVBQXNCO0FBQ3BCLFlBQUljLGtCQUFKOztBQUVBNWMsZUFBTyxDQUFDTSxTQUFSLENBQWtCLENBQUNzYyxrQkFBa0IsR0FBRyxLQUFLZCxXQUEzQixFQUF3Q3JZLE1BQXhDLENBQStDOEMsS0FBL0MsQ0FBcURxVyxrQkFBckQsRUFBeUVwYyxTQUF6RSxDQUFsQixFQUF1RztBQUF2RyxTQUNDRixTQURELENBQ1csS0FBSzBiLGNBQUwsRUFEWDtBQUVEOztBQUVELGFBQU9oYyxPQUFQO0FBQ0Q7QUFDRDs7OztBQWxCQyxHQTNIeUIsRUFpSnpCO0FBQ0QvRyxPQUFHLEVBQUUsY0FESjs7QUFHRDs7O0FBR0FLLFNBQUssRUFBRSxTQUFTK0ksWUFBVCxHQUF3QjtBQUM3QixVQUFJd2Esa0JBQUo7O0FBRUEsYUFBTyxLQUFLZixXQUFMLEdBQW1CLENBQUNlLGtCQUFrQixHQUFHLEtBQUtmLFdBQTNCLEVBQXdDelosWUFBeEMsQ0FBcURrRSxLQUFyRCxDQUEyRHNXLGtCQUEzRCxFQUErRXJjLFNBQS9FLENBQW5CLEdBQStHLEVBQXRIO0FBQ0Q7QUFDRDs7OztBQVhDLEdBakp5QixFQWdLekI7QUFDRHZILE9BQUcsRUFBRSxhQURKO0FBRURLLFNBQUssRUFBRSxTQUFTa0osV0FBVCxHQUF1QjtBQUM1QixVQUFJc2Esa0JBQUosRUFBd0JDLEtBQXhCOztBQUVBLFdBQUssSUFBSUMsS0FBSyxHQUFHeGMsU0FBUyxDQUFDOUgsTUFBdEIsRUFBOEIyUyxJQUFJLEdBQUcsSUFBSS9PLEtBQUosQ0FBVTBnQixLQUFWLENBQXJDLEVBQXVEQyxLQUFLLEdBQUcsQ0FBcEUsRUFBdUVBLEtBQUssR0FBR0QsS0FBL0UsRUFBc0ZDLEtBQUssRUFBM0YsRUFBK0Y7QUFDN0Y1UixZQUFJLENBQUM0UixLQUFELENBQUosR0FBY3pjLFNBQVMsQ0FBQ3ljLEtBQUQsQ0FBdkI7QUFDRDs7QUFFRCxhQUFPLEtBQUtuQixXQUFMLEdBQW1CLENBQUNnQixrQkFBa0IsR0FBRyxLQUFLaEIsV0FBM0IsRUFBd0N0WixXQUF4QyxDQUFvRCtELEtBQXBELENBQTBEdVcsa0JBQTFELEVBQThFelIsSUFBOUUsQ0FBbkIsR0FBeUcsQ0FBQzBSLEtBQUssR0FBRzFoQixJQUFJLENBQUN6QixlQUFlLENBQUMyTCxhQUFhLENBQUN0TixTQUFmLENBQWhCLEVBQTJDLGFBQTNDLEVBQTBELElBQTFELENBQWIsRUFBOEUyQyxJQUE5RSxDQUFtRjJMLEtBQW5GLENBQXlGd1csS0FBekYsRUFBZ0csQ0FBQyxJQUFELEVBQU90TCxNQUFQLENBQWNwRyxJQUFkLENBQWhHLENBQWhIO0FBQ0Q7QUFDRDs7OztBQVhDLEdBaEt5QixFQStLekI7QUFDRHBTLE9BQUcsRUFBRSxVQURKO0FBRURLLFNBQUssRUFBRSxTQUFTNkksUUFBVCxHQUFvQjtBQUN6QixVQUFJLEtBQUsyWixXQUFULEVBQXNCLEtBQUtBLFdBQUwsQ0FBaUIzWixRQUFqQjs7QUFFdEI5RyxVQUFJLENBQUN6QixlQUFlLENBQUMyTCxhQUFhLENBQUN0TixTQUFmLENBQWhCLEVBQTJDLFVBQTNDLEVBQXVELElBQXZELENBQUosQ0FBaUUyQyxJQUFqRSxDQUFzRSxJQUF0RTtBQUNEO0FBQ0Q7Ozs7QUFQQyxHQS9LeUIsRUEwTHpCO0FBQ0QzQixPQUFHLEVBQUUsaUJBREo7QUFFREssU0FBSyxFQUFFLFNBQVM4SSxlQUFULEdBQTJCO0FBQ2hDLFVBQUk4YSxrQkFBSixFQUF3QkMsS0FBeEI7O0FBRUEsV0FBSyxJQUFJQyxLQUFLLEdBQUc1YyxTQUFTLENBQUM5SCxNQUF0QixFQUE4QjJTLElBQUksR0FBRyxJQUFJL08sS0FBSixDQUFVOGdCLEtBQVYsQ0FBckMsRUFBdURDLEtBQUssR0FBRyxDQUFwRSxFQUF1RUEsS0FBSyxHQUFHRCxLQUEvRSxFQUFzRkMsS0FBSyxFQUEzRixFQUErRjtBQUM3RmhTLFlBQUksQ0FBQ2dTLEtBQUQsQ0FBSixHQUFjN2MsU0FBUyxDQUFDNmMsS0FBRCxDQUF2QjtBQUNEOztBQUVELGFBQU8sS0FBS3ZCLFdBQUwsR0FBbUIsQ0FBQ29CLGtCQUFrQixHQUFHLEtBQUtwQixXQUEzQixFQUF3QzFaLGVBQXhDLENBQXdEbUUsS0FBeEQsQ0FBOEQyVyxrQkFBOUQsRUFBa0Y3UixJQUFsRixDQUFuQixHQUE2RyxDQUFDOFIsS0FBSyxHQUFHOWhCLElBQUksQ0FBQ3pCLGVBQWUsQ0FBQzJMLGFBQWEsQ0FBQ3ROLFNBQWYsQ0FBaEIsRUFBMkMsaUJBQTNDLEVBQThELElBQTlELENBQWIsRUFBa0YyQyxJQUFsRixDQUF1RjJMLEtBQXZGLENBQTZGNFcsS0FBN0YsRUFBb0csQ0FBQyxJQUFELEVBQU8xTCxNQUFQLENBQWNwRyxJQUFkLENBQXBHLENBQXBIO0FBQ0Q7QUFWQSxHQTFMeUIsRUFxTXpCO0FBQ0RwUyxPQUFHLEVBQUUsT0FESjtBQUVEdUMsT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPLEtBQUtzZ0IsV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCeGlCLEtBQXBDLEdBQTRDLEVBQW5EO0FBQ0QsS0FKQTtBQUtEc0MsT0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYXRDLEtBQWIsRUFBb0I7QUFDdkJ1QyxVQUFJLENBQUNqQyxlQUFlLENBQUMyTCxhQUFhLENBQUN0TixTQUFmLENBQWhCLEVBQTJDLE9BQTNDLEVBQW9EcUIsS0FBcEQsRUFBMkQsSUFBM0QsRUFBaUUsSUFBakUsQ0FBSjtBQUNEO0FBQ0Q7Ozs7QUFSQyxHQXJNeUIsRUFpTnpCO0FBQ0RMLE9BQUcsRUFBRSxlQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS3NnQixXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUI5VSxhQUFwQyxHQUFvRCxFQUEzRDtBQUNELEtBSkE7QUFLRHBMLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWFvTCxhQUFiLEVBQTRCO0FBQy9CbkwsVUFBSSxDQUFDakMsZUFBZSxDQUFDMkwsYUFBYSxDQUFDdE4sU0FBZixDQUFoQixFQUEyQyxlQUEzQyxFQUE0RCtPLGFBQTVELEVBQTJFLElBQTNFLEVBQWlGLElBQWpGLENBQUo7QUFDRDtBQUNEOzs7O0FBUkMsR0FqTnlCLEVBNk56QjtBQUNEL04sT0FBRyxFQUFFLFlBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLc2dCLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQjFKLFVBQXBDLEdBQWlELEVBQXhEO0FBQ0QsS0FKQSxDQUlDO0FBSkQ7QUFNRHhXLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF0QyxLQUFiLEVBQW9CO0FBQ3ZCLFVBQUkwTixhQUFhLEdBQUcxSixNQUFNLENBQUNoRSxLQUFELENBQTFCLENBRHVCLENBQ1k7O0FBRW5DLFVBQUksS0FBS3dpQixXQUFULEVBQXNCO0FBQ3BCLGFBQUtBLFdBQUwsQ0FBaUIxSixVQUFqQixHQUE4QjlZLEtBQTlCO0FBQ0EwTixxQkFBYSxHQUFHLEtBQUs4VSxXQUFMLENBQWlCOVUsYUFBakM7QUFDRDs7QUFFRCxXQUFLQSxhQUFMLEdBQXFCQSxhQUFyQjtBQUNEO0FBQ0Q7Ozs7QUFoQkMsR0E3TnlCLEVBaVB6QjtBQUNEL04sT0FBRyxFQUFFLFlBREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxDQUFDLENBQUMsS0FBS3NnQixXQUFQLElBQXNCLEtBQUtBLFdBQUwsQ0FBaUJqVixVQUE5QztBQUNEO0FBSkEsR0FqUHlCLEVBc1B6QjtBQUNENU4sT0FBRyxFQUFFLE9BREo7QUFFRHVDLE9BQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBT3pDLE1BQU0sQ0FBQ2tILE1BQVAsQ0FBYyxFQUFkLEVBQWtCNUUsSUFBSSxDQUFDekIsZUFBZSxDQUFDMkwsYUFBYSxDQUFDdE4sU0FBZixDQUFoQixFQUEyQyxPQUEzQyxFQUFvRCxJQUFwRCxDQUF0QixFQUFpRjtBQUN0Rm9rQixzQkFBYyxFQUFFLEtBQUt4WSxhQURpRTtBQUV0RmtZLHFCQUFhLEVBQUUsS0FBS0EsYUFBTCxDQUFtQnZVLEdBQW5CLENBQXVCLFVBQVVxSyxDQUFWLEVBQWE7QUFDakQsaUJBQU9BLENBQUMsQ0FBQzFRLEtBQVQ7QUFDRCxTQUZjLENBRnVFO0FBS3RGbWMsc0JBQWMsRUFBRSxLQUFLeEIsV0FMaUU7QUFNdEZBLG1CQUFXLEVBQUUsS0FBS0EsV0FBTCxJQUFvQixLQUFLQSxXQUFMLENBQWlCM2E7QUFOb0MsT0FBakYsQ0FBUDtBQVFELEtBWEE7QUFZRHZGLE9BQUcsRUFBRSxTQUFTQSxHQUFULENBQWF1RixLQUFiLEVBQW9CO0FBQ3ZCLFVBQUk0YSxhQUFhLEdBQUc1YSxLQUFLLENBQUM0YSxhQUExQjtBQUFBLFVBQ0l1QixjQUFjLEdBQUduYyxLQUFLLENBQUNtYyxjQUQzQjtBQUFBLFVBRUl4QixXQUFXLEdBQUczYSxLQUFLLENBQUMyYSxXQUZ4QjtBQUFBLFVBR0l6TSxXQUFXLEdBQUc3VSx3QkFBd0IsQ0FBQzJHLEtBQUQsRUFBUSxDQUFDLGVBQUQsRUFBa0IsZ0JBQWxCLEVBQW9DLGFBQXBDLENBQVIsQ0FIMUM7O0FBS0EsV0FBSzRhLGFBQUwsQ0FBbUIvUixPQUFuQixDQUEyQixVQUFVNkgsQ0FBVixFQUFhMEwsRUFBYixFQUFpQjtBQUMxQyxlQUFPMUwsQ0FBQyxDQUFDMVEsS0FBRixHQUFVNGEsYUFBYSxDQUFDd0IsRUFBRCxDQUE5QjtBQUNELE9BRkQ7O0FBSUEsVUFBSUQsY0FBYyxJQUFJLElBQXRCLEVBQTRCO0FBQzFCLGFBQUt4QixXQUFMLEdBQW1Cd0IsY0FBbkI7QUFDQSxhQUFLeEIsV0FBTCxDQUFpQjNhLEtBQWpCLEdBQXlCMmEsV0FBekI7QUFDRDs7QUFFRGpnQixVQUFJLENBQUNqQyxlQUFlLENBQUMyTCxhQUFhLENBQUN0TixTQUFmLENBQWhCLEVBQTJDLE9BQTNDLEVBQW9Eb1gsV0FBcEQsRUFBaUUsSUFBakUsRUFBdUUsSUFBdkUsQ0FBSjtBQUNEO0FBNUJBLEdBdFB5QixFQW1SekI7QUFDRHBXLE9BQUcsRUFBRSxXQURKO0FBRUR1QyxPQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS3NnQixXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJ6WSxTQUFwQyxHQUFnRGhJLElBQUksQ0FBQ3pCLGVBQWUsQ0FBQzJMLGFBQWEsQ0FBQ3ROLFNBQWYsQ0FBaEIsRUFBMkMsV0FBM0MsRUFBd0QsSUFBeEQsQ0FBM0Q7QUFDRCxLQUpBO0FBS0QyRCxPQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFheUgsU0FBYixFQUF3QjtBQUMzQnFDLGFBQU8sQ0FBQ0MsSUFBUixDQUFhLGtGQUFiO0FBQ0Q7QUFQQSxHQW5SeUIsQ0FBaEIsQ0FBWjs7QUE2UkEsU0FBT0osYUFBUDtBQUNELENBeFRELENBd1RFL0QsSUF4VEYsQ0FGQTs7QUEyVEErRCxxQkFBYSxDQUFDNUQsUUFBZCxHQUF5QjtBQUN2QithLFVBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCeFosUUFBbEIsRUFBNEJwQyxNQUE1QixFQUFvQzhCLEtBQXBDLEVBQTJDO0FBQ25ELFFBQUksQ0FBQzlCLE1BQU0sQ0FBQ2liLGFBQVAsQ0FBcUJyakIsTUFBMUIsRUFBa0M7QUFDbEMsUUFBSXlqQixVQUFVLEdBQUdyYixNQUFNLENBQUMrQyxhQUF4QixDQUZtRCxDQUVaOztBQUV2QyxRQUFJMlosTUFBTSxHQUFHMWMsTUFBTSxDQUFDaWIsYUFBUCxDQUFxQnZVLEdBQXJCLENBQXlCLFVBQVVxSyxDQUFWLEVBQWF6SixLQUFiLEVBQW9CO0FBQ3hEeUosT0FBQyxDQUFDN1AsS0FBRjtBQUNBNlAsT0FBQyxDQUFDOVEsTUFBRixDQUFTb2IsVUFBVCxFQUFxQjtBQUNuQnJYLFdBQUcsRUFBRTtBQURjLE9BQXJCO0FBR0ErTSxPQUFDLENBQUM5USxNQUFGLENBQVNtQyxRQUFULEVBQW1CTixLQUFuQjtBQUNBLFVBQUk2YSxNQUFNLEdBQUc1TCxDQUFDLENBQUNoTyxhQUFGLENBQWdCbkwsTUFBN0I7QUFDQSxhQUFPO0FBQ0wra0IsY0FBTSxFQUFFQSxNQURIO0FBRUxyVixhQUFLLEVBQUVBO0FBRkYsT0FBUDtBQUlELEtBWFksQ0FBYixDQUptRCxDQWUvQzs7QUFFSm9WLFVBQU0sQ0FBQzlULElBQVAsQ0FBWSxVQUFVZ1UsRUFBVixFQUFjQyxFQUFkLEVBQWtCO0FBQzVCLGFBQU9BLEVBQUUsQ0FBQ0YsTUFBSCxHQUFZQyxFQUFFLENBQUNELE1BQXRCO0FBQ0QsS0FGRDtBQUdBLFdBQU8zYyxNQUFNLENBQUNpYixhQUFQLENBQXFCeUIsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVcFYsS0FBL0IsQ0FBUDtBQUNEO0FBdEJzQixDQUF6QjtBQXdCQWhILE1BQUssQ0FBQ21FLGFBQU4sR0FBc0JBLHFCQUF0QjtBQUVlQSxpRUFBZixFOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBLElBQUlxWSxTQUFTLEdBQUc7QUFDZEMsUUFBTSxFQUFFLE9BRE07QUFFZEMsVUFBUSxFQUFFLGVBRkk7QUFHZEMsT0FBSyxFQUFFO0FBSE8sQ0FBaEI7QUFLQTs7QUFFQSxTQUFTQyxVQUFULENBQW9CL1ksSUFBcEIsRUFBMEI7QUFDeEIsTUFBSXhFLElBQUksR0FBR0QsU0FBUyxDQUFDOUgsTUFBVixHQUFtQixDQUFuQixJQUF3QjhILFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIzRCxTQUF6QyxHQUFxRDJELFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9Fb2QsU0FBUyxDQUFDQyxNQUF6RjtBQUNBLE1BQUlqTyxFQUFFLEdBQUdwUCxTQUFTLENBQUM5SCxNQUFWLEdBQW1CLENBQW5CLElBQXdCOEgsU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQjNELFNBQXpDLEdBQXFEMkQsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0VvZCxTQUFTLENBQUNDLE1BQXZGO0FBQ0EsTUFBSS9jLE1BQU0sR0FBRzhFLE9BQVUsQ0FBQ1gsSUFBRCxDQUF2QjtBQUNBLFNBQU8sVUFBVTNMLEtBQVYsRUFBaUI7QUFDdEIsV0FBT3dILE1BQU0sQ0FBQ2lELFdBQVAsQ0FBbUIsVUFBVThOLENBQVYsRUFBYTtBQUNyQ0EsT0FBQyxDQUFDcFIsSUFBRCxDQUFELEdBQVVuSCxLQUFWO0FBQ0EsYUFBT3VZLENBQUMsQ0FBQ2pDLEVBQUQsQ0FBUjtBQUNELEtBSE0sQ0FBUDtBQUlELEdBTEQ7QUFNRDtBQUNEOzs7QUFFQSxTQUFTcU8sSUFBVCxDQUFjM2tCLEtBQWQsRUFBcUI7QUFDbkIsT0FBSyxJQUFJaVksSUFBSSxHQUFHL1EsU0FBUyxDQUFDOUgsTUFBckIsRUFBNkJ3bEIsUUFBUSxHQUFHLElBQUk1aEIsS0FBSixDQUFVaVYsSUFBSSxHQUFHLENBQVAsR0FBV0EsSUFBSSxHQUFHLENBQWxCLEdBQXNCLENBQWhDLENBQXhDLEVBQTRFQyxJQUFJLEdBQUcsQ0FBeEYsRUFBMkZBLElBQUksR0FBR0QsSUFBbEcsRUFBd0dDLElBQUksRUFBNUcsRUFBZ0g7QUFDOUcwTSxZQUFRLENBQUMxTSxJQUFJLEdBQUcsQ0FBUixDQUFSLEdBQXFCaFIsU0FBUyxDQUFDZ1IsSUFBRCxDQUE5QjtBQUNEOztBQUVELFNBQU93TSxVQUFVLENBQUN6WCxLQUFYLENBQWlCLEtBQUssQ0FBdEIsRUFBeUIyWCxRQUF6QixFQUFtQzVrQixLQUFuQyxDQUFQO0FBQ0Q7O0FBQ0Q4SCxNQUFLLENBQUN3YyxTQUFOLEdBQWtCQSxTQUFsQjtBQUNBeGMsTUFBSyxDQUFDNGMsVUFBTixHQUFtQkEsVUFBbkI7QUFDQTVjLE1BQUssQ0FBQzZjLElBQU4sR0FBYUEsSUFBYjs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDRkUsWUFBVSxDQUFDL2MsS0FBWCxHQUFtQkEsS0FBbkI7QUFDRCxDQUZELENBRUUsT0FBTzRSLENBQVAsRUFBVSxDQUFFOztBQUVDNVIsd0VBQWYiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5zZXQpIHtcbiAgICBzZXQgPSBSZWZsZWN0LnNldDtcbiAgfSBlbHNlIHtcbiAgICBzZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuXG4gICAgICB2YXIgZGVzYztcblxuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xufVxuXG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2V0IHByb3BlcnR5Jyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbmV4cG9ydCB7IF90eXBlb2YgYXMgXywgX2NyZWF0ZUNsYXNzIGFzIGEsIF9jbGFzc0NhbGxDaGVjayBhcyBiLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgYXMgYywgX2luaGVyaXRzIGFzIGQsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGFzIGUsIF9nZXRQcm90b3R5cGVPZiBhcyBmLCBfZ2V0IGFzIGcsIF9zZXQgYXMgaCwgX3NsaWNlZFRvQXJyYXkgYXMgaSB9O1xuIiwiaW1wb3J0IHsgXyBhcyBfdHlwZW9mIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5cbi8qKiBDaGVja3MgaWYgdmFsdWUgaXMgc3RyaW5nICovXG5mdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZztcbn1cbi8qKlxyXG4gIERpcmVjdGlvblxyXG4gIEBwcm9wIHtzdHJpbmd9IE5PTkVcclxuICBAcHJvcCB7c3RyaW5nfSBMRUZUXHJcbiAgQHByb3Age3N0cmluZ30gRk9SQ0VfTEVGVFxyXG4gIEBwcm9wIHtzdHJpbmd9IFJJR0hUXHJcbiAgQHByb3Age3N0cmluZ30gRk9SQ0VfUklHSFRcclxuKi9cblxudmFyIERJUkVDVElPTiA9IHtcbiAgTk9ORTogJ05PTkUnLFxuICBMRUZUOiAnTEVGVCcsXG4gIEZPUkNFX0xFRlQ6ICdGT1JDRV9MRUZUJyxcbiAgUklHSFQ6ICdSSUdIVCcsXG4gIEZPUkNFX1JJR0hUOiAnRk9SQ0VfUklHSFQnXG59O1xuLyoqXHJcbiAgRGlyZWN0aW9uXHJcbiAgQGVudW0ge3N0cmluZ31cclxuKi9cblxuLyoqIFJldHVybnMgbmV4dCBjaGFyIGluZGV4IGluIGRpcmVjdGlvbiAqL1xuZnVuY3Rpb24gaW5kZXhJbkRpcmVjdGlvbihwb3MsIGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTEVGVCkgLS1wb3M7XG4gIHJldHVybiBwb3M7XG59XG4vKiogUmV0dXJucyBuZXh0IGNoYXIgcG9zaXRpb24gaW4gZGlyZWN0aW9uICovXG5cbmZ1bmN0aW9uIHBvc0luRGlyZWN0aW9uKHBvcywgZGlyZWN0aW9uKSB7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9MRUZUOlxuICAgICAgcmV0dXJuIC0tcG9zO1xuXG4gICAgY2FzZSBESVJFQ1RJT04uUklHSFQ6XG4gICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfUklHSFQ6XG4gICAgICByZXR1cm4gKytwb3M7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBvcztcbiAgfVxufVxuLyoqICovXG5cbmZ1bmN0aW9uIGZvcmNlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgRElSRUNUSU9OLkxFRlQ6XG4gICAgICByZXR1cm4gRElSRUNUSU9OLkZPUkNFX0xFRlQ7XG5cbiAgICBjYXNlIERJUkVDVElPTi5SSUdIVDpcbiAgICAgIHJldHVybiBESVJFQ1RJT04uRk9SQ0VfUklHSFQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxufVxuLyoqIEVzY2FwZXMgcmVndWxhciBleHByZXNzaW9uIGNvbnRyb2wgY2hhcnMgKi9cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59IC8vIGNsb25lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWRlZXAtZXF1YWwgd2l0aCBzbWFsbCBjaGFuZ2VzXG5cbmZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKGIsIGEpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICB2YXIgYXJyQSA9IEFycmF5LmlzQXJyYXkoYSksXG4gICAgICBhcnJCID0gQXJyYXkuaXNBcnJheShiKSxcbiAgICAgIGk7XG5cbiAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqZWN0SW5jbHVkZXMoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhcnJBICE9IGFyckIpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYSAmJiBiICYmIF90eXBlb2YoYSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoYikgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGRhdGVBID0gYSBpbnN0YW5jZW9mIERhdGUsXG4gICAgICAgIGRhdGVCID0gYiBpbnN0YW5jZW9mIERhdGU7XG4gICAgaWYgKGRhdGVBICYmIGRhdGVCKSByZXR1cm4gYS5nZXRUaW1lKCkgPT0gYi5nZXRUaW1lKCk7XG4gICAgaWYgKGRhdGVBICE9IGRhdGVCKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlZ2V4cEEgPSBhIGluc3RhbmNlb2YgUmVnRXhwLFxuICAgICAgICByZWdleHBCID0gYiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICBpZiAocmVnZXhwQSAmJiByZWdleHBCKSByZXR1cm4gYS50b1N0cmluZygpID09IGIudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnZXhwQSAhPSByZWdleHBCKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTsgLy8gaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iamVjdEluY2x1ZGVzKGJba2V5c1tpXV0sIGFba2V5c1tpXV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqIFNlbGVjdGlvbiByYW5nZSAqL1xuXG5leHBvcnQgeyBESVJFQ1RJT04sIGVzY2FwZVJlZ0V4cCwgZm9yY2VEaXJlY3Rpb24sIGluZGV4SW5EaXJlY3Rpb24sIGlzU3RyaW5nLCBvYmplY3RJbmNsdWRlcywgcG9zSW5EaXJlY3Rpb24gfTtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgRElSRUNUSU9OIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKiBQcm92aWRlcyBkZXRhaWxzIG9mIGNoYW5naW5nIGlucHV0ICovXG5cbnZhciBBY3Rpb25EZXRhaWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqIEN1cnJlbnQgaW5wdXQgdmFsdWUgKi9cblxuICAvKiogQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gKi9cblxuICAvKiogT2xkIGlucHV0IHZhbHVlICovXG5cbiAgLyoqIE9sZCBzZWxlY3Rpb24gKi9cbiAgZnVuY3Rpb24gQWN0aW9uRGV0YWlscyh2YWx1ZSwgY3Vyc29yUG9zLCBvbGRWYWx1ZSwgb2xkU2VsZWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjdGlvbkRldGFpbHMpO1xuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICB0aGlzLm9sZFNlbGVjdGlvbiA9IG9sZFNlbGVjdGlvbjsgLy8gZG91YmxlIGNoZWNrIGlmIGxlZnQgcGFydCB3YXMgY2hhbmdlZCAoYXV0b2ZpbGxpbmcsIG90aGVyIG5vbi1zdGFuZGFyZCBpbnB1dCB0cmlnZ2VycylcblxuICAgIHdoaWxlICh0aGlzLnZhbHVlLnNsaWNlKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpICE9PSB0aGlzLm9sZFZhbHVlLnNsaWNlKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpKSB7XG4gICAgICAtLXRoaXMub2xkU2VsZWN0aW9uLnN0YXJ0O1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgIFN0YXJ0IGNoYW5naW5nIHBvc2l0aW9uXHJcbiAgICBAcmVhZG9ubHlcclxuICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFjdGlvbkRldGFpbHMsIFt7XG4gICAga2V5OiBcInN0YXJ0Q2hhbmdlUG9zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5jdXJzb3JQb3MsIHRoaXMub2xkU2VsZWN0aW9uLnN0YXJ0KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEluc2VydGVkIHN5bWJvbHMgY291bnRcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0ZWRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdGFydENoYW5nZVBvcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEluc2VydGVkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cih0aGlzLnN0YXJ0Q2hhbmdlUG9zLCB0aGlzLmluc2VydGVkQ291bnQpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUmVtb3ZlZCBzeW1ib2xzIGNvdW50XHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZWRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gTWF0aC5tYXggZm9yIG9wcG9zaXRlIG9wZXJhdGlvblxuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub2xkU2VsZWN0aW9uLmVuZCAtIHRoaXMuc3RhcnRDaGFuZ2VQb3MgfHwgLy8gZm9yIERlbGV0ZVxuICAgICAgdGhpcy5vbGRWYWx1ZS5sZW5ndGggLSB0aGlzLnZhbHVlLmxlbmd0aCwgMCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZW1vdmVkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub2xkVmFsdWUuc3Vic3RyKHRoaXMuc3RhcnRDaGFuZ2VQb3MsIHRoaXMucmVtb3ZlZENvdW50KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFVuY2hhbmdlZCBoZWFkIHN5bWJvbHNcclxuICAgICAgQHJlYWRvbmx5XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc3RhcnRDaGFuZ2VQb3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgVW5jaGFuZ2VkIHRhaWwgc3ltYm9sc1xyXG4gICAgICBAcmVhZG9ubHlcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0YWlsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5zdGFydENoYW5nZVBvcyArIHRoaXMuaW5zZXJ0ZWRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZW1vdmUgZGlyZWN0aW9uXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZURpcmVjdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnJlbW92ZWRDb3VudCB8fCB0aGlzLmluc2VydGVkQ291bnQpIHJldHVybiBESVJFQ1RJT04uTk9ORTsgLy8gYWxpZ24gcmlnaHQgaWYgZGVsZXRlIGF0IHJpZ2h0IG9yIGlmIHJhbmdlIHJlbW92ZWQgKGV2ZW50IHdpdGggYmFja3NwYWNlKVxuXG4gICAgICByZXR1cm4gdGhpcy5vbGRTZWxlY3Rpb24uZW5kID09PSB0aGlzLmN1cnNvclBvcyB8fCB0aGlzLm9sZFNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy5jdXJzb3JQb3MgPyBESVJFQ1RJT04uUklHSFQgOiBESVJFQ1RJT04uTEVGVDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWN0aW9uRGV0YWlscztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aW9uRGV0YWlscztcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuXG4vKipcclxuICBQcm92aWRlcyBkZXRhaWxzIG9mIGNoYW5naW5nIG1vZGVsIHZhbHVlXHJcbiAgQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxzXVxyXG4gIEBwYXJhbSB7c3RyaW5nfSBbZGV0YWlscy5pbnNlcnRlZF0gLSBJbnNlcnRlZCBzeW1ib2xzXHJcbiAgQHBhcmFtIHtib29sZWFufSBbZGV0YWlscy5za2lwXSAtIENhbiBza2lwIGNoYXJzXHJcbiAgQHBhcmFtIHtudW1iZXJ9IFtkZXRhaWxzLnJlbW92ZUNvdW50XSAtIFJlbW92ZWQgc3ltYm9scyBjb3VudFxyXG4gIEBwYXJhbSB7bnVtYmVyfSBbZGV0YWlscy50YWlsU2hpZnRdIC0gQWRkaXRpb25hbCBvZmZzZXQgaWYgYW55IGNoYW5nZXMgb2NjdXJyZWQgYmVmb3JlIHRhaWxcclxuKi9cbnZhciBDaGFuZ2VEZXRhaWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqIEluc2VydGVkIHN5bWJvbHMgKi9cblxuICAvKiogQ2FuIHNraXAgY2hhcnMgKi9cblxuICAvKiogQWRkaXRpb25hbCBvZmZzZXQgaWYgYW55IGNoYW5nZXMgb2NjdXJyZWQgYmVmb3JlIHRhaWwgKi9cblxuICAvKiogUmF3IGluc2VydGVkIGlzIHVzZWQgYnkgZHluYW1pYyBtYXNrICovXG4gIGZ1bmN0aW9uIENoYW5nZURldGFpbHMoZGV0YWlscykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFuZ2VEZXRhaWxzKTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgaW5zZXJ0ZWQ6ICcnLFxuICAgICAgcmF3SW5zZXJ0ZWQ6ICcnLFxuICAgICAgc2tpcDogZmFsc2UsXG4gICAgICB0YWlsU2hpZnQ6IDBcbiAgICB9LCBkZXRhaWxzKTtcbiAgfVxuICAvKipcclxuICAgIEFnZ3JlZ2F0ZSBjaGFuZ2VzXHJcbiAgICBAcmV0dXJucyB7Q2hhbmdlRGV0YWlsc30gYHRoaXNgXHJcbiAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDaGFuZ2VEZXRhaWxzLCBbe1xuICAgIGtleTogXCJhZ2dyZWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWdncmVnYXRlKGRldGFpbHMpIHtcbiAgICAgIHRoaXMucmF3SW5zZXJ0ZWQgKz0gZGV0YWlscy5yYXdJbnNlcnRlZDtcbiAgICAgIHRoaXMuc2tpcCA9IHRoaXMuc2tpcCB8fCBkZXRhaWxzLnNraXA7XG4gICAgICB0aGlzLmluc2VydGVkICs9IGRldGFpbHMuaW5zZXJ0ZWQ7XG4gICAgICB0aGlzLnRhaWxTaGlmdCArPSBkZXRhaWxzLnRhaWxTaGlmdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogVG90YWwgb2Zmc2V0IGNvbnNpZGVyaW5nIGFsbCBjaGFuZ2VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWxTaGlmdCArIHRoaXMuaW5zZXJ0ZWQubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaGFuZ2VEZXRhaWxzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBDaGFuZ2VEZXRhaWxzO1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5cbi8qKiBQcm92aWRlcyBkZXRhaWxzIG9mIGNvbnRpbnVvdXMgZXh0cmFjdGVkIHRhaWwgKi9cbnZhciBDb250aW51b3VzVGFpbERldGFpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogVGFpbCB2YWx1ZSBhcyBzdHJpbmcgKi9cblxuICAvKiogVGFpbCBzdGFydCBwb3NpdGlvbiAqL1xuXG4gIC8qKiBTdGFydCBwb3NpdGlvbiAqL1xuICBmdW5jdGlvbiBDb250aW51b3VzVGFpbERldGFpbHMoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgc3RvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRpbnVvdXNUYWlsRGV0YWlscyk7XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnN0b3AgPSBzdG9wO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRpbnVvdXNUYWlsRGV0YWlscywgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZCh0YWlsKSB7XG4gICAgICB0aGlzLnZhbHVlICs9IFN0cmluZyh0YWlsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVG8obWFza2VkKSB7XG4gICAgICByZXR1cm4gbWFza2VkLmFwcGVuZCh0aGlzLnRvU3RyaW5nKCksIHtcbiAgICAgICAgdGFpbDogdHJ1ZVxuICAgICAgfSkuYWdncmVnYXRlKG1hc2tlZC5fYXBwZW5kUGxhY2Vob2xkZXIoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0QmVmb3JlKHBvcykge1xuICAgICAgaWYgKHRoaXMuZnJvbSA+PSBwb3MgfHwgIXRoaXMudmFsdWUubGVuZ3RoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgc2hpZnRDaGFyID0gdGhpcy52YWx1ZVswXTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIHNoaWZ0Q2hhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHN0b3A6IHRoaXMuc3RvcFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udGludW91c1RhaWxEZXRhaWxzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBDb250aW51b3VzVGFpbERldGFpbHM7XG4iLCIvKipcclxuICogQXBwbGllcyBtYXNrIG9uIGVsZW1lbnQuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8SFRNTFRleHRBcmVhRWxlbWVudHxNYXNrRWxlbWVudH0gZWwgLSBFbGVtZW50IHRvIGFwcGx5IG1hc2tcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBDdXN0b20gbWFzayBvcHRpb25zXHJcbiAqIEByZXR1cm4ge0lucHV0TWFza31cclxuICovXG5mdW5jdGlvbiBJTWFzayhlbCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIC8vIGN1cnJlbnRseSBhdmFpbGFibGUgb25seSBmb3IgaW5wdXQtbGlrZSBlbGVtZW50c1xuICByZXR1cm4gbmV3IElNYXNrLklucHV0TWFzayhlbCwgb3B0cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IENoYW5nZURldGFpbHMgZnJvbSAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgQ29udGludW91c1RhaWxEZXRhaWxzIGZyb20gJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcblxuLyoqIFN1cHBvcnRlZCBtYXNrIHR5cGUgKi9cblxuLyoqIFByb3ZpZGVzIGNvbW1vbiBtYXNraW5nIHN0dWZmICovXG52YXIgTWFza2VkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gJFNoYXBlPE1hc2tlZE9wdGlvbnM+OyBUT0RPIGFmdGVyIGZpeCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDc3M1xuXG4gIC8qKiBAdHlwZSB7TWFza30gKi9cblxuICAvKiogKi9cbiAgLy8gJEZsb3dGaXhNZSBubyBpZGVhc1xuXG4gIC8qKiBUcmFuc2Zvcm1zIHZhbHVlIGJlZm9yZSBtYXNrIHByb2Nlc3NpbmcgKi9cblxuICAvKiogVmFsaWRhdGVzIGlmIHZhbHVlIGlzIGFjY2VwdGFibGUgKi9cblxuICAvKiogRG9lcyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgLyoqIEZvcm1hdCB0eXBlZCB2YWx1ZSB0byBzdHJpbmcgKi9cblxuICAvKiogUGFyc2Ugc3RyZ2luIHRvIGdldCB0eXBlZCB2YWx1ZSAqL1xuXG4gIC8qKiBFbmFibGUgY2hhcmFjdGVycyBvdmVyd3JpdGluZyAqL1xuXG4gIC8qKiAqL1xuICBmdW5jdGlvbiBNYXNrZWQob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWQpO1xuXG4gICAgdGhpcy5fdmFsdWUgPSAnJztcblxuICAgIHRoaXMuX3VwZGF0ZShPYmplY3QuYXNzaWduKHt9LCBNYXNrZWQuREVGQVVMVFMsIHt9LCBvcHRzKSk7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIC8qKiBTZXRzIGFuZCBhcHBsaWVzIG5ldyBvcHRpb25zICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkLCBbe1xuICAgIGtleTogXCJ1cGRhdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0cykge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGgpIHJldHVybjtcbiAgICAgIHRoaXMud2l0aFZhbHVlUmVmcmVzaCh0aGlzLl91cGRhdGUuYmluZCh0aGlzLCBvcHRzKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBTZXRzIG5ldyBvcHRpb25zXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqIE1hc2sgc3RhdGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG5cbiAgICAvKiogUmVzZXRzIHZhbHVlICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG5cbiAgICAvKiogUmVzb2x2ZSBuZXcgdmFsdWUgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hcHBlbmQodmFsdWUsIHtcbiAgICAgICAgaW5wdXQ6IHRydWVcbiAgICAgIH0sICcnKTtcbiAgICAgIHRoaXMuZG9Db21taXQoKTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJlc3RJbnB1dFBvc1wiLFxuXG4gICAgLyoqIEZpbmRzIG5lYXJlc3QgaW5wdXQgcG9zaXRpb24gaW4gZGlyZWN0aW9uICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3RJbnB1dFBvcyhjdXJzb3JQb3MsIGRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICB9XG4gICAgLyoqIEV4dHJhY3RzIHZhbHVlIGluIHJhbmdlIGNvbnNpZGVyaW5nIGZsYWdzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdElucHV0KCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2xpY2UoZnJvbVBvcywgdG9Qb3MpO1xuICAgIH1cbiAgICAvKiogRXh0cmFjdHMgdGFpbCBpbiByYW5nZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdFRhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdFRhaWwoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICByZXR1cm4gbmV3IENvbnRpbnVvdXNUYWlsRGV0YWlscyh0aGlzLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcyksIGZyb21Qb3MpO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyB0YWlsICovXG4gICAgLy8gJEZsb3dGaXhNZSBubyBpZGVhc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUYWlsKHRhaWwpIHtcbiAgICAgIGlmIChpc1N0cmluZyh0YWlsKSkgdGFpbCA9IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWwpKTtcbiAgICAgIHJldHVybiB0YWlsLmFwcGVuZFRvKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyBjaGFyICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhclJhdyhjaCkge1xuICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNoID0gdGhpcy5kb1ByZXBhcmUoY2gsIGZsYWdzKTtcbiAgICAgIGlmICghY2gpIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdGhpcy5fdmFsdWUgKz0gY2g7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICBpbnNlcnRlZDogY2gsXG4gICAgICAgIHJhd0luc2VydGVkOiBjaFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBBcHBlbmRzIGNoYXIgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRDaGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRDaGFyKGNoKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNoZWNrVGFpbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNvbnNpc3RlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5fYXBwZW5kQ2hhclJhdyhjaCwgZmxhZ3MpO1xuXG4gICAgICBpZiAoZGV0YWlscy5pbnNlcnRlZCkge1xuICAgICAgICB2YXIgY29uc2lzdGVudFRhaWw7XG4gICAgICAgIHZhciBhcHBlbmRlZCA9IHRoaXMuZG9WYWxpZGF0ZShmbGFncykgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmIChhcHBlbmRlZCAmJiBjaGVja1RhaWwgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2ssIGNoZWNrIHRhaWxcbiAgICAgICAgICB2YXIgYmVmb3JlVGFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgY29uc2lzdGVudFRhaWwgPSBjaGVja1RhaWwuc3RhdGU7XG4gICAgICAgICAgICBjaGVja1RhaWwuc2hpZnRCZWZvcmUodGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0YWlsRGV0YWlscyA9IHRoaXMuYXBwZW5kVGFpbChjaGVja1RhaWwpO1xuICAgICAgICAgIGFwcGVuZGVkID0gdGFpbERldGFpbHMucmF3SW5zZXJ0ZWQgPT09IGNoZWNrVGFpbC50b1N0cmluZygpOyAvLyBpZiBvaywgcm9sbGJhY2sgc3RhdGUgYWZ0ZXIgdGFpbFxuXG4gICAgICAgICAgaWYgKGFwcGVuZGVkICYmIHRhaWxEZXRhaWxzLmluc2VydGVkKSB0aGlzLnN0YXRlID0gYmVmb3JlVGFpbFN0YXRlO1xuICAgICAgICB9IC8vIHJldmVydCBhbGwgaWYgc29tZXRoaW5nIHdlbnQgd3JvbmdcblxuXG4gICAgICAgIGlmICghYXBwZW5kZWQpIHtcbiAgICAgICAgICBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gY29uc2lzdGVudFN0YXRlO1xuICAgICAgICAgIGlmIChjaGVja1RhaWwgJiYgY29uc2lzdGVudFRhaWwpIGNoZWNrVGFpbC5zdGF0ZSA9IGNvbnNpc3RlbnRUYWlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgICAvKiogQXBwZW5kcyBvcHRpb25hbCBwbGFjZWhvbGRlciBhdCBlbmQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRQbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGxhY2Vob2xkZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICB9XG4gICAgLyoqIEFwcGVuZHMgc3ltYm9scyBjb25zaWRlcmluZyBmbGFncyAqL1xuICAgIC8vICRGbG93Rml4TWUgbm8gaWRlYXNcblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoc3RyLCBmbGFncywgdGFpbCkge1xuICAgICAgaWYgKCFpc1N0cmluZyhzdHIpKSB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgIHZhciBjaGVja1RhaWwgPSBpc1N0cmluZyh0YWlsKSA/IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWwpKSA6IHRhaWw7XG4gICAgICBpZiAoZmxhZ3MudGFpbCkgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBzdHIubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKHRoaXMuX2FwcGVuZENoYXIoc3RyW2NpXSwgZmxhZ3MsIGNoZWNrVGFpbCkpO1xuICAgICAgfSAvLyBhcHBlbmQgdGFpbCBidXQgYWdncmVnYXRlIG9ubHkgdGFpbFNoaWZ0XG5cblxuICAgICAgaWYgKGNoZWNrVGFpbCAhPSBudWxsKSB7XG4gICAgICAgIGRldGFpbHMudGFpbFNoaWZ0ICs9IHRoaXMuYXBwZW5kVGFpbChjaGVja1RhaWwpLnRhaWxTaGlmdDsgLy8gVE9ETyBpdCdzIGEgZ29vZCBpZGVhIHRvIGNsZWFyIHN0YXRlIGFmdGVyIGFwcGVuZGluZyBlbmRzXG4gICAgICAgIC8vIGJ1dCBpdCBjYXVzZXMgYnVncyB3aGVuIG9uZSBhcHBlbmQgY2FsbHMgYW5vdGhlciAod2hlbiBkeW5hbWljIGRpc3BhdGNoIHNldCByYXdJbnB1dFZhbHVlKVxuICAgICAgICAvLyB0aGlzLl9yZXNldEJlZm9yZVRhaWxTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpICsgdGhpcy52YWx1ZS5zbGljZSh0b1Bvcyk7XG4gICAgICByZXR1cm4gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICB9XG4gICAgLyoqIENhbGxzIGZ1bmN0aW9uIGFuZCByZWFwcGxpZXMgY3VycmVudCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFZhbHVlUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoVmFsdWVSZWZyZXNoKGZuKSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaGluZyB8fCAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZm4oKTtcbiAgICAgIHRoaXMuX3JlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgdmFyIHJhd0lucHV0ID0gdGhpcy5yYXdJbnB1dFZhbHVlO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciByZXQgPSBmbigpO1xuICAgICAgdGhpcy5yYXdJbnB1dFZhbHVlID0gcmF3SW5wdXQ7IC8vIGFwcGVuZCBsb3N0IHRyYWlsaW5nIGNoYXJzIGF0IGVuZFxuXG4gICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUgJiYgdmFsdWUuaW5kZXhPZih0aGlzLnZhbHVlKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZCh2YWx1ZS5zbGljZSh0aGlzLnZhbHVlLmxlbmd0aCksIHt9LCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoaW5nO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJydW5Jc29sYXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5Jc29sYXRlZChmbikge1xuICAgICAgaWYgKHRoaXMuX2lzb2xhdGVkIHx8ICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBmbih0aGlzKTtcbiAgICAgIHRoaXMuX2lzb2xhdGVkID0gdHJ1ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICB2YXIgcmV0ID0gZm4odGhpcyk7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICBkZWxldGUgdGhpcy5faXNvbGF0ZWQ7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUHJlcGFyZXMgc3RyaW5nIGJlZm9yZSBtYXNrIHByb2Nlc3NpbmdcclxuICAgICAgQHByb3RlY3RlZFxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvUHJlcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ByZXBhcmUoc3RyKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZSA/IHRoaXMucHJlcGFyZShzdHIsIHRoaXMsIGZsYWdzKSA6IHN0cjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFZhbGlkYXRlcyBpZiB2YWx1ZSBpcyBhY2NlcHRhYmxlXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgIHJldHVybiAoIXRoaXMudmFsaWRhdGUgfHwgdGhpcy52YWxpZGF0ZSh0aGlzLnZhbHVlLCB0aGlzLCBmbGFncykpICYmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuZG9WYWxpZGF0ZShmbGFncykpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgRG9lcyBhZGRpdGlvbmFsIHByb2Nlc3NpbmcgaW4gdGhlIGVuZCBvZiBlZGl0aW5nXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1pdCkgdGhpcy5jb21taXQodGhpcy52YWx1ZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9Gb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Gb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA/IHRoaXMuZm9ybWF0KHZhbHVlLCB0aGlzKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvUGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9QYXJzZShzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlID8gdGhpcy5wYXJzZShzdHIsIHRoaXMpIDogc3RyO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBpbnNlcnRlZCwgcmVtb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB2YXIgdGFpbFBvcyA9IHN0YXJ0ICsgZGVsZXRlQ291bnQ7XG4gICAgICB2YXIgdGFpbCA9IHRoaXMuZXh0cmFjdFRhaWwodGFpbFBvcyk7XG4gICAgICB2YXIgc3RhcnRDaGFuZ2VQb3MgPSB0aGlzLm5lYXJlc3RJbnB1dFBvcyhzdGFydCwgcmVtb3ZlRGlyZWN0aW9uKTtcbiAgICAgIHZhciBjaGFuZ2VEZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoe1xuICAgICAgICB0YWlsU2hpZnQ6IHN0YXJ0Q2hhbmdlUG9zIC0gc3RhcnQgLy8gYWRqdXN0IHRhaWxTaGlmdCBpZiBzdGFydCB3YXMgYWxpZ25lZFxuXG4gICAgICB9KS5hZ2dyZWdhdGUodGhpcy5yZW1vdmUoc3RhcnRDaGFuZ2VQb3MpKS5hZ2dyZWdhdGUodGhpcy5hcHBlbmQoaW5zZXJ0ZWQsIHtcbiAgICAgICAgaW5wdXQ6IHRydWVcbiAgICAgIH0sIHRhaWwpKTtcbiAgICAgIHJldHVybiBjaGFuZ2VEZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3ZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gc3RhdGUuX3ZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVubWFza2VkVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuYXBwZW5kKHZhbHVlLCB7fSwgJycpO1xuICAgICAgdGhpcy5kb0NvbW1pdCgpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVkVmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFyc2UodGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZG9Gb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogVmFsdWUgdGhhdCBpbmNsdWRlcyByYXcgdXNlciBpbnB1dCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmF3SW5wdXRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdElucHV0KDAsIHRoaXMudmFsdWUubGVuZ3RoLCB7XG4gICAgICAgIHJhdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5hcHBlbmQodmFsdWUsIHtcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9LCAnJyk7XG4gICAgICB0aGlzLmRvQ29tbWl0KCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZDtcbn0oKTtcbk1hc2tlZC5ERUZBVUxUUyA9IHtcbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodikge1xuICAgIHJldHVybiB2O1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2Uodikge1xuICAgIHJldHVybiB2O1xuICB9XG59O1xuSU1hc2suTWFza2VkID0gTWFza2VkO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWQ7XG4iLCJpbXBvcnQgJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5cbi8qKiBHZXQgTWFza2VkIGNsYXNzIGJ5IG1hc2sgdHlwZSAqL1xuXG5mdW5jdGlvbiBtYXNrZWRDbGFzcyhtYXNrKSB7XG4gIGlmIChtYXNrID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgcHJvcGVydHkgc2hvdWxkIGJlIGRlZmluZWQnKTtcbiAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICBpZiAobWFzayBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIElNYXNrLk1hc2tlZFJlZ0V4cDsgLy8gJEZsb3dGaXhNZVxuXG4gIGlmIChpc1N0cmluZyhtYXNrKSkgcmV0dXJuIElNYXNrLk1hc2tlZFBhdHRlcm47IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIERhdGUgfHwgbWFzayA9PT0gRGF0ZSkgcmV0dXJuIElNYXNrLk1hc2tlZERhdGU7IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIE51bWJlciB8fCB0eXBlb2YgbWFzayA9PT0gJ251bWJlcicgfHwgbWFzayA9PT0gTnVtYmVyKSByZXR1cm4gSU1hc2suTWFza2VkTnVtYmVyOyAvLyAkRmxvd0ZpeE1lXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWFzaykgfHwgbWFzayA9PT0gQXJyYXkpIHJldHVybiBJTWFzay5NYXNrZWREeW5hbWljOyAvLyAkRmxvd0ZpeE1lXG5cbiAgaWYgKElNYXNrLk1hc2tlZCAmJiBtYXNrLnByb3RvdHlwZSBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2s7IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gSU1hc2suTWFza2VkRnVuY3Rpb247IC8vICRGbG93Rml4TWVcblxuICBpZiAobWFzayBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2suY29uc3RydWN0b3I7XG4gIGNvbnNvbGUud2FybignTWFzayBub3QgZm91bmQgZm9yIG1hc2snLCBtYXNrKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIC8vICRGbG93Rml4TWVcblxuICByZXR1cm4gSU1hc2suTWFza2VkO1xufVxuLyoqIENyZWF0ZXMgbmV3IHtAbGluayBNYXNrZWR9IGRlcGVuZGluZyBvbiBtYXNrIHR5cGUgKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFzayhvcHRzKSB7XG4gIC8vICRGbG93Rml4TWVcbiAgaWYgKElNYXNrLk1hc2tlZCAmJiBvcHRzIGluc3RhbmNlb2YgSU1hc2suTWFza2VkKSByZXR1cm4gb3B0cztcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICB2YXIgbWFzayA9IG9wdHMubWFzazsgLy8gJEZsb3dGaXhNZVxuXG4gIGlmIChJTWFzay5NYXNrZWQgJiYgbWFzayBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZCkgcmV0dXJuIG1hc2s7XG4gIHZhciBNYXNrZWRDbGFzcyA9IG1hc2tlZENsYXNzKG1hc2spO1xuICBpZiAoIU1hc2tlZENsYXNzKSB0aHJvdyBuZXcgRXJyb3IoJ01hc2tlZCBjbGFzcyBpcyBub3QgZm91bmQgZm9yIHByb3ZpZGVkIG1hc2ssIGFwcHJvcHJpYXRlIG1vZHVsZSBuZWVkcyB0byBiZSBpbXBvcnQgbWFudWFsbHkgYmVmb3JlIGNyZWF0aW5nIG1hc2suJyk7XG4gIHJldHVybiBuZXcgTWFza2VkQ2xhc3Mob3B0cyk7XG59XG5JTWFzay5jcmVhdGVNYXNrID0gY3JlYXRlTWFzaztcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWFzaztcbmV4cG9ydCB7IG1hc2tlZENsYXNzIH07XG4iLCJpbXBvcnQgeyBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGMgYXMgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgeyBESVJFQ1RJT04gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uLy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi8uLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgY3JlYXRlTWFzayBmcm9tICcuLi9mYWN0b3J5LmpzJztcblxudmFyIERFRkFVTFRfSU5QVVRfREVGSU5JVElPTlMgPSB7XG4gICcwJzogL1xcZC8sXG4gICdhJzogL1tcXHUwMDQxLVxcdTAwNUFcXHUwMDYxLVxcdTAwN0FcXHUwMEFBXFx1MDBCNVxcdTAwQkFcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLyxcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjIwNzUwNzBcbiAgJyonOiAvLi9cbn07XG4vKiogKi9cblxudmFyIFBhdHRlcm5JbnB1dERlZmluaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cbiAgZnVuY3Rpb24gUGF0dGVybklucHV0RGVmaW5pdGlvbihvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdHRlcm5JbnB1dERlZmluaXRpb24pO1xuXG4gICAgdmFyIG1hc2sgPSBvcHRzLm1hc2ssXG4gICAgICAgIGJsb2NrT3B0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRzLCBbXCJtYXNrXCJdKTtcblxuICAgIHRoaXMubWFza2VkID0gY3JlYXRlTWFzayh7XG4gICAgICBtYXNrOiBtYXNrXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBibG9ja09wdHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdHRlcm5JbnB1dERlZmluaXRpb24sIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubWFza2VkLnJlc2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmIChmcm9tUG9zID09PSAwICYmIHRvUG9zID49IDEpIHtcbiAgICAgICAgdGhpcy5faXNGaWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFza2VkLnJlbW92ZShmcm9tUG9zLCB0b1Bvcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhcihzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBpZiAodGhpcy5faXNGaWxsZWQpIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5tYXNrZWQuc3RhdGU7IC8vIHNpbXVsYXRlIGlucHV0XG5cbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5tYXNrZWQuX2FwcGVuZENoYXIoc3RyLCBmbGFncyk7XG5cbiAgICAgIGlmIChkZXRhaWxzLmluc2VydGVkICYmIHRoaXMuZG9WYWxpZGF0ZShmbGFncykgPT09IGZhbHNlKSB7XG4gICAgICAgIGRldGFpbHMuaW5zZXJ0ZWQgPSBkZXRhaWxzLnJhd0luc2VydGVkID0gJyc7XG4gICAgICAgIHRoaXMubWFza2VkLnN0YXRlID0gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGV0YWlscy5pbnNlcnRlZCAmJiAhdGhpcy5pc09wdGlvbmFsICYmICF0aGlzLmxhenkgJiYgIWZsYWdzLmlucHV0KSB7XG4gICAgICAgIGRldGFpbHMuaW5zZXJ0ZWQgPSB0aGlzLnBsYWNlaG9sZGVyQ2hhcjtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscy5za2lwID0gIWRldGFpbHMuaW5zZXJ0ZWQgJiYgIXRoaXMuaXNPcHRpb25hbDtcbiAgICAgIHRoaXMuX2lzRmlsbGVkID0gQm9vbGVhbihkZXRhaWxzLmluc2VydGVkKTtcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDtcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQgPSB0aGlzLm1hc2tlZCkuYXBwZW5kLmFwcGx5KF90aGlzJG1hc2tlZCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcigpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbmV3IENoYW5nZURldGFpbHMoKTtcbiAgICAgIGlmICh0aGlzLl9pc0ZpbGxlZCB8fCB0aGlzLmlzT3B0aW9uYWwpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSB0cnVlO1xuICAgICAgZGV0YWlscy5pbnNlcnRlZCA9IHRoaXMucGxhY2Vob2xkZXJDaGFyO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RUYWlsKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkbWFza2VkMiA9IHRoaXMubWFza2VkKS5leHRyYWN0VGFpbC5hcHBseShfdGhpcyRtYXNrZWQyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZFRhaWwoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFza2VkMztcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQzID0gdGhpcy5tYXNrZWQpLmFwcGVuZFRhaWwuYXBwbHkoX3RoaXMkbWFza2VkMywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMubWFza2VkLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcywgZmxhZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKGN1cnNvclBvcykge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRElSRUNUSU9OLk5PTkU7XG4gICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgIHZhciBtYXhQb3MgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBib3VuZFBvcyA9IE1hdGgubWluKE1hdGgubWF4KGN1cnNvclBvcywgbWluUG9zKSwgbWF4UG9zKTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlID8gYm91bmRQb3MgOiBtaW5Qb3M7XG5cbiAgICAgICAgY2FzZSBESVJFQ1RJT04uUklHSFQ6XG4gICAgICAgIGNhc2UgRElSRUNUSU9OLkZPUkNFX1JJR0hUOlxuICAgICAgICAgIHJldHVybiB0aGlzLmlzQ29tcGxldGUgPyBib3VuZFBvcyA6IG1heFBvcztcblxuICAgICAgICBjYXNlIERJUkVDVElPTi5OT05FOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBib3VuZFBvcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tlZDQsIF90aGlzJHBhcmVudDtcblxuICAgICAgcmV0dXJuIChfdGhpcyRtYXNrZWQ0ID0gdGhpcy5tYXNrZWQpLmRvVmFsaWRhdGUuYXBwbHkoX3RoaXMkbWFza2VkNCwgYXJndW1lbnRzKSAmJiAoIXRoaXMucGFyZW50IHx8IChfdGhpcyRwYXJlbnQgPSB0aGlzLnBhcmVudCkuZG9WYWxpZGF0ZS5hcHBseShfdGhpcyRwYXJlbnQsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NvbW1pdCgpIHtcbiAgICAgIHRoaXMubWFza2VkLmRvQ29tbWl0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWQudmFsdWUgfHwgKHRoaXMuX2lzRmlsbGVkICYmICF0aGlzLmlzT3B0aW9uYWwgPyB0aGlzLnBsYWNlaG9sZGVyQ2hhciA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFza2VkLnVubWFza2VkVmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ29tcGxldGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMubWFza2VkLnZhbHVlKSB8fCB0aGlzLmlzT3B0aW9uYWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXNrZWQ6IHRoaXMubWFza2VkLnN0YXRlLFxuICAgICAgICBfaXNGaWxsZWQ6IHRoaXMuX2lzRmlsbGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHRoaXMubWFza2VkLnN0YXRlID0gc3RhdGUubWFza2VkO1xuICAgICAgdGhpcy5faXNGaWxsZWQgPSBzdGF0ZS5faXNGaWxsZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhdHRlcm5JbnB1dERlZmluaXRpb247XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFBhdHRlcm5JbnB1dERlZmluaXRpb247XG5leHBvcnQgeyBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIH07XG4iLCJpbXBvcnQgeyBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2sgfSBmcm9tICcuLi8uLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IERJUkVDVElPTiwgaXNTdHJpbmcgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uLy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0IENvbnRpbnVvdXNUYWlsRGV0YWlscyBmcm9tICcuLi8uLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcblxudmFyIFBhdHRlcm5GaXhlZERlZmluaXRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cblxuICAvKiogKi9cbiAgZnVuY3Rpb24gUGF0dGVybkZpeGVkRGVmaW5pdGlvbihvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdHRlcm5GaXhlZERlZmluaXRpb24pO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRzKTtcbiAgICB0aGlzLl92YWx1ZSA9ICcnO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdHRlcm5GaXhlZERlZmluaXRpb24sIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5faXNSYXdJbnB1dCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl92YWx1ZS5sZW5ndGg7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3ZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpICsgdGhpcy5fdmFsdWUuc2xpY2UodG9Qb3MpO1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZSkgdGhpcy5faXNSYXdJbnB1dCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lYXJlc3RJbnB1dFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWFyZXN0SW5wdXRQb3MoY3Vyc29yUG9zKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHZhciBtaW5Qb3MgPSAwO1xuICAgICAgdmFyIG1heFBvcyA9IHRoaXMuX3ZhbHVlLmxlbmd0aDtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICByZXR1cm4gbWluUG9zO1xuXG4gICAgICAgIGNhc2UgRElSRUNUSU9OLk5PTkU6XG4gICAgICAgIGNhc2UgRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9SSUdIVDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbWF4UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdElucHV0KCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX3ZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gZmxhZ3MucmF3ICYmIHRoaXMuX2lzUmF3SW5wdXQgJiYgdGhpcy5fdmFsdWUuc2xpY2UoZnJvbVBvcywgdG9Qb3MpIHx8ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhcihzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdmFyIGFwcGVuZGVkID0gdGhpcy5jaGFyID09PSBzdHJbMF07XG4gICAgICB2YXIgaXNSZXNvbHZlZCA9IGFwcGVuZGVkICYmICh0aGlzLmlzVW5tYXNraW5nIHx8IGZsYWdzLmlucHV0IHx8IGZsYWdzLnJhdykgJiYgIWZsYWdzLnRhaWw7XG4gICAgICBpZiAoaXNSZXNvbHZlZCkgZGV0YWlscy5yYXdJbnNlcnRlZCA9IHRoaXMuY2hhcjtcbiAgICAgIHRoaXMuX3ZhbHVlID0gZGV0YWlscy5pbnNlcnRlZCA9IHRoaXMuY2hhcjtcbiAgICAgIHRoaXMuX2lzUmF3SW5wdXQgPSBpc1Jlc29sdmVkICYmIChmbGFncy5yYXcgfHwgZmxhZ3MuaW5wdXQpO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRQbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kUGxhY2Vob2xkZXIoKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdGhpcy5fdmFsdWUgPSBkZXRhaWxzLmluc2VydGVkID0gdGhpcy5jaGFyO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RUYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RUYWlsKCkge1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHJldHVybiBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKCcnKTtcbiAgICB9IC8vICRGbG93Rml4TWUgbm8gaWRlYXNcblxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFRhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVGFpbCh0YWlsKSB7XG4gICAgICBpZiAoaXNTdHJpbmcodGFpbCkpIHRhaWwgPSBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKFN0cmluZyh0YWlsKSk7XG4gICAgICByZXR1cm4gdGFpbC5hcHBlbmRUbyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZChzdHIsIGZsYWdzLCB0YWlsKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuX2FwcGVuZENoYXIoc3RyLCBmbGFncyk7XG5cbiAgICAgIGlmICh0YWlsICE9IG51bGwpIHtcbiAgICAgICAgZGV0YWlscy50YWlsU2hpZnQgKz0gdGhpcy5hcHBlbmRUYWlsKHRhaWwpLnRhaWxTaGlmdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvQ29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ29tbWl0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bm1hc2tlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1VubWFza2luZyA/IHRoaXMudmFsdWUgOiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfdmFsdWU6IHRoaXMuX3ZhbHVlLFxuICAgICAgICBfaXNSYXdJbnB1dDogdGhpcy5faXNSYXdJbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgYyBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgfSBmcm9tICcuLi8uLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgQ2hhbmdlRGV0YWlscyBmcm9tICcuLi8uLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCBDb250aW51b3VzVGFpbERldGFpbHMgZnJvbSAnLi4vLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vLi4vY29yZS9ob2xkZXIuanMnO1xuXG52YXIgQ2h1bmtzVGFpbERldGFpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQ2h1bmtzVGFpbERldGFpbHMoKSB7XG4gICAgdmFyIGNodW5rcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2h1bmtzVGFpbERldGFpbHMpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBjaHVua3M7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaHVua3NUYWlsRGV0YWlscywgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaHVua3MubWFwKFN0cmluZykuam9pbignJyk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG5vIGlkZWFzXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhaWxDaHVuaykge1xuICAgICAgaWYgKCFTdHJpbmcodGFpbENodW5rKSkgcmV0dXJuO1xuICAgICAgaWYgKGlzU3RyaW5nKHRhaWxDaHVuaykpIHRhaWxDaHVuayA9IG5ldyBDb250aW51b3VzVGFpbERldGFpbHMoU3RyaW5nKHRhaWxDaHVuaykpO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGV4dGVuZExhc3QgPSBsYXN0Q2h1bmsgJiYgKCAvLyBpZiBzdG9wcyBhcmUgc2FtZSBvciB0YWlsIGhhcyBubyBzdG9wXG4gICAgICBsYXN0Q2h1bmsuc3RvcCA9PT0gdGFpbENodW5rLnN0b3AgfHwgdGFpbENodW5rLnN0b3AgPT0gbnVsbCkgJiYgLy8gaWYgdGFpbCBjaHVuayBnb2VzIGp1c3QgYWZ0ZXIgbGFzdCBjaHVua1xuICAgICAgdGFpbENodW5rLmZyb20gPT09IGxhc3RDaHVuay5mcm9tICsgbGFzdENodW5rLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gICAgICBpZiAodGFpbENodW5rIGluc3RhbmNlb2YgQ29udGludW91c1RhaWxEZXRhaWxzKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBhYmlsaXR5IHRvIGV4dGVuZCBwcmV2aW91cyBjaHVua1xuICAgICAgICBpZiAoZXh0ZW5kTGFzdCkge1xuICAgICAgICAgIC8vIGV4dGVuZCBwcmV2aW91cyBjaHVua1xuICAgICAgICAgIGxhc3RDaHVuay5leHRlbmQodGFpbENodW5rLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFwcGVuZCBuZXcgY2h1bmtcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRhaWxDaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFpbENodW5rIGluc3RhbmNlb2YgQ2h1bmtzVGFpbERldGFpbHMpIHtcbiAgICAgICAgaWYgKHRhaWxDaHVuay5zdG9wID09IG51bGwpIHtcbiAgICAgICAgICAvLyB1bndyYXAgZmxvYXRpbmcgY2h1bmtzIHRvIHBhcmVudCwga2VlcGluZyBgZnJvbWAgcG9zXG4gICAgICAgICAgdmFyIGZpcnN0VGFpbENodW5rO1xuXG4gICAgICAgICAgd2hpbGUgKHRhaWxDaHVuay5jaHVua3MubGVuZ3RoICYmIHRhaWxDaHVuay5jaHVua3NbMF0uc3RvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaXJzdFRhaWxDaHVuayA9IHRhaWxDaHVuay5jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIGZpcnN0VGFpbENodW5rLmZyb20gKz0gdGFpbENodW5rLmZyb207XG4gICAgICAgICAgICB0aGlzLmV4dGVuZChmaXJzdFRhaWxDaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHRhaWwgY2h1bmsgc3RpbGwgaGFzIHZhbHVlXG5cblxuICAgICAgICBpZiAodGFpbENodW5rLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAvLyBpZiBjaHVua3MgY29udGFpbnMgc3RvcHMsIHRoZW4gcG9wdXAgc3RvcCB0byBjb250YWluZXJcbiAgICAgICAgICB0YWlsQ2h1bmsuc3RvcCA9IHRhaWxDaHVuay5ibG9ja0luZGV4O1xuICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godGFpbENodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUbyhtYXNrZWQpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGlmICghKG1hc2tlZCBpbnN0YW5jZW9mIElNYXNrLk1hc2tlZFBhdHRlcm4pKSB7XG4gICAgICAgIHZhciB0YWlsID0gbmV3IENvbnRpbnVvdXNUYWlsRGV0YWlscyh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdGFpbC5hcHBlbmRUbyhtYXNrZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCB0aGlzLmNodW5rcy5sZW5ndGggJiYgIWRldGFpbHMuc2tpcDsgKytjaSkge1xuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tjaV07XG5cbiAgICAgICAgdmFyIGxhc3RCbG9ja0l0ZXIgPSBtYXNrZWQuX21hcFBvc1RvQmxvY2sobWFza2VkLnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgdmFyIHN0b3AgPSBjaHVuay5zdG9wO1xuICAgICAgICB2YXIgY2h1bmtCbG9jayA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoc3RvcCAhPSBudWxsICYmICggLy8gaWYgYmxvY2sgbm90IGZvdW5kIG9yIHN0b3AgaXMgYmVoaW5kIGxhc3RCbG9ja1xuICAgICAgICAhbGFzdEJsb2NrSXRlciB8fCBsYXN0QmxvY2tJdGVyLmluZGV4IDw9IHN0b3ApKSB7XG4gICAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQ2h1bmtzVGFpbERldGFpbHMgfHwgLy8gZm9yIGNvbnRpbnVvdXMgYmxvY2sgYWxzbyBjaGVjayBpZiBzdG9wIGlzIGV4aXN0XG4gICAgICAgICAgbWFza2VkLl9zdG9wcy5pbmRleE9mKHN0b3ApID49IDApIHtcbiAgICAgICAgICAgIGRldGFpbHMuYWdncmVnYXRlKG1hc2tlZC5fYXBwZW5kUGxhY2Vob2xkZXIoc3RvcCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rQmxvY2sgPSBjaHVuayBpbnN0YW5jZW9mIENodW5rc1RhaWxEZXRhaWxzICYmIG1hc2tlZC5fYmxvY2tzW3N0b3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNodW5rQmxvY2spIHtcbiAgICAgICAgICB2YXIgdGFpbERldGFpbHMgPSBjaHVua0Jsb2NrLmFwcGVuZFRhaWwoY2h1bmspO1xuICAgICAgICAgIHRhaWxEZXRhaWxzLnNraXAgPSBmYWxzZTsgLy8gYWx3YXlzIGlnbm9yZSBza2lwLCBpdCB3aWxsIGJlIHNldCBvbiBsYXN0XG5cbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSh0YWlsRGV0YWlscyk7XG4gICAgICAgICAgbWFza2VkLl92YWx1ZSArPSB0YWlsRGV0YWlscy5pbnNlcnRlZDsgLy8gZ2V0IG5vdCBpbnNlcnRlZCBjaGFyc1xuXG4gICAgICAgICAgdmFyIHJlbWFpbkNoYXJzID0gY2h1bmsudG9TdHJpbmcoKS5zbGljZSh0YWlsRGV0YWlscy5yYXdJbnNlcnRlZC5sZW5ndGgpO1xuICAgICAgICAgIGlmIChyZW1haW5DaGFycykgZGV0YWlscy5hZ2dyZWdhdGUobWFza2VkLmFwcGVuZChyZW1haW5DaGFycywge1xuICAgICAgICAgICAgdGFpbDogdHJ1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZShtYXNrZWQuYXBwZW5kKGNodW5rLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgIHRhaWw6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdEJlZm9yZShwb3MpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gPj0gcG9zIHx8ICF0aGlzLmNodW5rcy5sZW5ndGgpIHJldHVybiAnJztcbiAgICAgIHZhciBjaHVua1NoaWZ0UG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgdmFyIGNpID0gMDtcblxuICAgICAgd2hpbGUgKGNpIDwgdGhpcy5jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHRoaXMuY2h1bmtzW2NpXTtcbiAgICAgICAgdmFyIHNoaWZ0Q2hhciA9IGNodW5rLnNoaWZ0QmVmb3JlKGNodW5rU2hpZnRQb3MpO1xuXG4gICAgICAgIGlmIChjaHVuay50b1N0cmluZygpKSB7XG4gICAgICAgICAgLy8gY2h1bmsgc3RpbGwgY29udGFpbnMgdmFsdWVcbiAgICAgICAgICAvLyBidXQgbm90IHNoaWZ0ZWQgLSBtZWFucyBubyBtb3JlIGF2YWlsYWJsZSBjaGFycyB0byBzaGlmdFxuICAgICAgICAgIGlmICghc2hpZnRDaGFyKSBicmVhaztcbiAgICAgICAgICArK2NpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNsZWFuIGlmIGNodW5rIGhhcyBubyB2YWx1ZVxuICAgICAgICAgIHRoaXMuY2h1bmtzLnNwbGljZShjaSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hpZnRDaGFyKSByZXR1cm4gc2hpZnRDaGFyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjLnN0YXRlO1xuICAgICAgICB9KSxcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICBzdG9wOiB0aGlzLnN0b3AsXG4gICAgICAgIGJsb2NrSW5kZXg6IHRoaXMuYmxvY2tJbmRleFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICB2YXIgY2h1bmtzID0gc3RhdGUuY2h1bmtzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHN0YXRlLCBbXCJjaHVua3NcIl0pO1xuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgIHRoaXMuY2h1bmtzID0gY2h1bmtzLm1hcChmdW5jdGlvbiAoY3N0YXRlKSB7XG4gICAgICAgIHZhciBjaHVuayA9IFwiY2h1bmtzXCIgaW4gY3N0YXRlID8gbmV3IENodW5rc1RhaWxEZXRhaWxzKCkgOiBuZXcgQ29udGludW91c1RhaWxEZXRhaWxzKCk7IC8vICRGbG93Rml4TWUgYWxyZWFkeSBjaGVja2VkIGFib3ZlXG5cbiAgICAgICAgY2h1bmsuc3RhdGUgPSBjc3RhdGU7XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaHVua3NUYWlsRGV0YWlscztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2h1bmtzVGFpbERldGFpbHM7XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKiogTWFza2luZyBieSBSZWdFeHAgKi9cblxudmFyIE1hc2tlZFJlZ0V4cCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hc2tlZCkge1xuICBfaW5oZXJpdHMoTWFza2VkUmVnRXhwLCBfTWFza2VkKTtcblxuICBmdW5jdGlvbiBNYXNrZWRSZWdFeHAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFJlZ0V4cCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZFJlZ0V4cCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkUmVnRXhwLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLm1hc2spIG9wdHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNlYXJjaChvcHRzLm1hc2spID49IDA7XG4gICAgICB9O1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSZWdFeHAucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZFJlZ0V4cDtcbn0oTWFza2VkKTtcbklNYXNrLk1hc2tlZFJlZ0V4cCA9IE1hc2tlZFJlZ0V4cDtcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkUmVnRXhwO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCwgYyBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMsIGggYXMgX3NldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgZm9yY2VEaXJlY3Rpb24sIERJUkVDVElPTiB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IENoYW5nZURldGFpbHMgZnJvbSAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCBNYXNrZWQgZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrIGZyb20gJy4vZmFjdG9yeS5qcyc7XG5pbXBvcnQgUGF0dGVybklucHV0RGVmaW5pdGlvbiwgeyBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TIH0gZnJvbSAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0IFBhdHRlcm5GaXhlZERlZmluaXRpb24gZnJvbSAnLi9wYXR0ZXJuL2ZpeGVkLWRlZmluaXRpb24uanMnO1xuaW1wb3J0IENodW5rc1RhaWxEZXRhaWxzIGZyb20gJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5cbi8qKlxyXG4gIFBhdHRlcm4gbWFza1xyXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgQHBhcmFtIHtPYmplY3R9IG9wdHMuYmxvY2tzXHJcbiAgQHBhcmFtIHtPYmplY3R9IG9wdHMuZGVmaW5pdGlvbnNcclxuICBAcGFyYW0ge3N0cmluZ30gb3B0cy5wbGFjZWhvbGRlckNoYXJcclxuICBAcGFyYW0ge2Jvb2xlYW59IG9wdHMubGF6eVxyXG4qL1xudmFyIE1hc2tlZFBhdHRlcm4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgX2luaGVyaXRzKE1hc2tlZFBhdHRlcm4sIF9NYXNrZWQpO1xuXG4gIC8qKiAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiBTaW5nbGUgY2hhciBmb3IgZW1wdHkgaW5wdXQgKi9cblxuICAvKiogU2hvdyBwbGFjZWhvbGRlciBvbmx5IHdoZW4gbmVlZGVkICovXG4gIGZ1bmN0aW9uIE1hc2tlZFBhdHRlcm4oKSB7XG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFBhdHRlcm4pO1xuXG4gICAgLy8gVE9ETyB0eXBlICRTaGFwZTxNYXNrZWRQYXR0ZXJuT3B0aW9ucz49e30gZG9lcyBub3Qgd29ya1xuICAgIG9wdHMuZGVmaW5pdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0lOUFVUX0RFRklOSVRJT05TLCBvcHRzLmRlZmluaXRpb25zKTtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4pLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkUGF0dGVybi5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICBAb3ZlcnJpZGVcclxuICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhNYXNrZWRQYXR0ZXJuLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBvcHRzLmRlZmluaXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZpbml0aW9ucywgb3B0cy5kZWZpbml0aW9ucyk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgIHRoaXMuX3JlYnVpbGRNYXNrKCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYnVpbGRNYXNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWJ1aWxkTWFzaygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBkZWZzID0gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgIHRoaXMuX2Jsb2NrcyA9IFtdO1xuICAgICAgdGhpcy5fc3RvcHMgPSBbXTtcbiAgICAgIHRoaXMuX21hc2tlZEJsb2NrcyA9IHt9O1xuICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLm1hc2s7XG4gICAgICBpZiAoIXBhdHRlcm4gfHwgIWRlZnMpIHJldHVybjtcbiAgICAgIHZhciB1bm1hc2tpbmdCbG9jayA9IGZhbHNlO1xuICAgICAgdmFyIG9wdGlvbmFsQmxvY2sgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2Nrcykge1xuICAgICAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwYXR0ZXJuLnNsaWNlKGkpO1xuICAgICAgICAgICAgdmFyIGJOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzLmJsb2NrcykuZmlsdGVyKGZ1bmN0aW9uIChiTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcC5pbmRleE9mKGJOYW1lKSA9PT0gMDtcbiAgICAgICAgICAgIH0pOyAvLyBvcmRlciBieSBrZXkgbGVuZ3RoXG5cbiAgICAgICAgICAgIGJOYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICAgICAgfSk7IC8vIHVzZSBibG9jayBuYW1lIHdpdGggbWF4IGxlbmd0aFxuXG4gICAgICAgICAgICB2YXIgYk5hbWUgPSBiTmFtZXNbMF07XG5cbiAgICAgICAgICAgIGlmIChiTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgbWFza2VkQmxvY2sgPSBjcmVhdGVNYXNrKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHBhcmVudDogX3RoaXMsXG4gICAgICAgICAgICAgICAgbGF6eTogX3RoaXMubGF6eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlckNoYXI6IF90aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGU6IF90aGlzLm92ZXJ3cml0ZVxuICAgICAgICAgICAgICB9LCBfdGhpcy5ibG9ja3NbYk5hbWVdKSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hc2tlZEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2Jsb2Nrcy5wdXNoKG1hc2tlZEJsb2NrKTsgLy8gc3RvcmUgYmxvY2sgaW5kZXhcblxuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fbWFza2VkQmxvY2tzW2JOYW1lXSkgX3RoaXMuX21hc2tlZEJsb2Nrc1tiTmFtZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgIF90aGlzLl9tYXNrZWRCbG9ja3NbYk5hbWVdLnB1c2goX3RoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGkgKz0gYk5hbWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFyID0gcGF0dGVybltpXTtcblxuICAgICAgICB2YXIgX2lzSW5wdXQgPSBjaGFyIGluIGRlZnM7XG5cbiAgICAgICAgaWYgKGNoYXIgPT09IE1hc2tlZFBhdHRlcm4uU1RPUF9DSEFSKSB7XG4gICAgICAgICAgdGhpcy5fc3RvcHMucHVzaCh0aGlzLl9ibG9ja3MubGVuZ3RoKTtcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7JyB8fCBjaGFyID09PSAnfScpIHtcbiAgICAgICAgICB1bm1hc2tpbmdCbG9jayA9ICF1bm1hc2tpbmdCbG9jaztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyID09PSAnWycgfHwgY2hhciA9PT0gJ10nKSB7XG4gICAgICAgICAgb3B0aW9uYWxCbG9jayA9ICFvcHRpb25hbEJsb2NrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09IE1hc2tlZFBhdHRlcm4uRVNDQVBFX0NIQVIpIHtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgY2hhciA9IHBhdHRlcm5baV07XG4gICAgICAgICAgaWYgKCFjaGFyKSBicmVhaztcbiAgICAgICAgICBfaXNJbnB1dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZiA9IF9pc0lucHV0ID8gbmV3IFBhdHRlcm5JbnB1dERlZmluaXRpb24oe1xuICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICBsYXp5OiB0aGlzLmxhenksXG4gICAgICAgICAgcGxhY2Vob2xkZXJDaGFyOiB0aGlzLnBsYWNlaG9sZGVyQ2hhcixcbiAgICAgICAgICBtYXNrOiBkZWZzW2NoYXJdLFxuICAgICAgICAgIGlzT3B0aW9uYWw6IG9wdGlvbmFsQmxvY2tcbiAgICAgICAgfSkgOiBuZXcgUGF0dGVybkZpeGVkRGVmaW5pdGlvbih7XG4gICAgICAgICAgY2hhcjogY2hhcixcbiAgICAgICAgICBpc1VubWFza2luZzogdW5tYXNraW5nQmxvY2tcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYmxvY2tzLnB1c2goZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJyZXNldFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLl9ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0NvbW1pdFwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Db21taXQoKSB7XG4gICAgICB0aGlzLl9ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5kb0NvbW1pdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJkb0NvbW1pdFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kVGFpbFwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVGFpbCh0YWlsKSB7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcImFwcGVuZFRhaWxcIiwgdGhpcykuY2FsbCh0aGlzLCB0YWlsKS5hZ2dyZWdhdGUodGhpcy5fYXBwZW5kUGxhY2Vob2xkZXIoKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYXBwZW5kQ2hhclJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kQ2hhclJhdyhjaCkge1xuICAgICAgdmFyIGZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIGNoID0gdGhpcy5kb1ByZXBhcmUoY2gsIGZsYWdzKTtcblxuICAgICAgdmFyIGJsb2NrSXRlciA9IHRoaXMuX21hcFBvc1RvQmxvY2sodGhpcy52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAoIWJsb2NrSXRlcikgcmV0dXJuIGRldGFpbHM7XG5cbiAgICAgIGZvciAodmFyIGJpID0gYmxvY2tJdGVyLmluZGV4OzsgKytiaSkge1xuICAgICAgICB2YXIgX2Jsb2NrID0gdGhpcy5fYmxvY2tzW2JpXTtcbiAgICAgICAgaWYgKCFfYmxvY2spIGJyZWFrO1xuXG4gICAgICAgIHZhciBibG9ja0RldGFpbHMgPSBfYmxvY2suX2FwcGVuZENoYXIoY2gsIGZsYWdzKTtcblxuICAgICAgICB2YXIgc2tpcCA9IGJsb2NrRGV0YWlscy5za2lwO1xuICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZShibG9ja0RldGFpbHMpO1xuICAgICAgICBpZiAoc2tpcCB8fCBibG9ja0RldGFpbHMucmF3SW5zZXJ0ZWQpIGJyZWFrOyAvLyBnbyBuZXh0IGNoYXJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0VGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0VGFpbCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgY2h1bmtUYWlsID0gbmV3IENodW5rc1RhaWxEZXRhaWxzKCk7XG4gICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHJldHVybiBjaHVua1RhaWw7XG5cbiAgICAgIHRoaXMuX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MsIHRvUG9zLCBmdW5jdGlvbiAoYiwgYmksIGJGcm9tUG9zLCBiVG9Qb3MpIHtcbiAgICAgICAgdmFyIGJsb2NrQ2h1bmsgPSBiLmV4dHJhY3RUYWlsKGJGcm9tUG9zLCBiVG9Qb3MpO1xuICAgICAgICBibG9ja0NodW5rLnN0b3AgPSBfdGhpczIuX2ZpbmRTdG9wQmVmb3JlKGJpKTtcbiAgICAgICAgYmxvY2tDaHVuay5mcm9tID0gX3RoaXMyLl9ibG9ja1N0YXJ0UG9zKGJpKTtcbiAgICAgICAgaWYgKGJsb2NrQ2h1bmsgaW5zdGFuY2VvZiBDaHVua3NUYWlsRGV0YWlscykgYmxvY2tDaHVuay5ibG9ja0luZGV4ID0gYmk7XG4gICAgICAgIGNodW5rVGFpbC5leHRlbmQoYmxvY2tDaHVuayk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNodW5rVGFpbDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0SW5wdXQoKSB7XG4gICAgICB2YXIgZnJvbVBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgaWYgKGZyb21Qb3MgPT09IHRvUG9zKSByZXR1cm4gJyc7XG4gICAgICB2YXIgaW5wdXQgPSAnJztcblxuICAgICAgdGhpcy5fZm9yRWFjaEJsb2Nrc0luUmFuZ2UoZnJvbVBvcywgdG9Qb3MsIGZ1bmN0aW9uIChiLCBfLCBmcm9tUG9zLCB0b1Bvcykge1xuICAgICAgICBpbnB1dCArPSBiLmV4dHJhY3RJbnB1dChmcm9tUG9zLCB0b1BvcywgZmxhZ3MpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTdG9wQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kU3RvcEJlZm9yZShibG9ja0luZGV4KSB7XG4gICAgICB2YXIgc3RvcEJlZm9yZTtcblxuICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXMuX3N0b3BzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW3NpXTtcbiAgICAgICAgaWYgKHN0b3AgPD0gYmxvY2tJbmRleCkgc3RvcEJlZm9yZSA9IHN0b3A7ZWxzZSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3BCZWZvcmU7XG4gICAgfVxuICAgIC8qKiBBcHBlbmRzIHBsYWNlaG9sZGVyIGRlcGVuZGluZyBvbiBsYXppbmVzcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcih0b0Jsb2NrSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG4gICAgICBpZiAodGhpcy5sYXp5ICYmIHRvQmxvY2tJbmRleCA9PSBudWxsKSByZXR1cm4gZGV0YWlscztcblxuICAgICAgdmFyIHN0YXJ0QmxvY2tJdGVyID0gdGhpcy5fbWFwUG9zVG9CbG9jayh0aGlzLnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgIGlmICghc3RhcnRCbG9ja0l0ZXIpIHJldHVybiBkZXRhaWxzO1xuICAgICAgdmFyIHN0YXJ0QmxvY2tJbmRleCA9IHN0YXJ0QmxvY2tJdGVyLmluZGV4O1xuICAgICAgdmFyIGVuZEJsb2NrSW5kZXggPSB0b0Jsb2NrSW5kZXggIT0gbnVsbCA/IHRvQmxvY2tJbmRleCA6IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX2Jsb2Nrcy5zbGljZShzdGFydEJsb2NrSW5kZXgsIGVuZEJsb2NrSW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKCFiLmxhenkgfHwgdG9CbG9ja0luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIGBfYmxvY2tzYCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICB2YXIgYXJncyA9IGIuX2Jsb2NrcyAhPSBudWxsID8gW2IuX2Jsb2Nrcy5sZW5ndGhdIDogW107XG5cbiAgICAgICAgICB2YXIgYkRldGFpbHMgPSBiLl9hcHBlbmRQbGFjZWhvbGRlci5hcHBseShiLCBhcmdzKTtcblxuICAgICAgICAgIF90aGlzMy5fdmFsdWUgKz0gYkRldGFpbHMuaW5zZXJ0ZWQ7XG4gICAgICAgICAgZGV0YWlscy5hZ2dyZWdhdGUoYkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKiBGaW5kcyBibG9jayBpbiBwb3MgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9tYXBQb3NUb0Jsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXBQb3NUb0Jsb2NrKHBvcykge1xuICAgICAgdmFyIGFjY1ZhbCA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgdGhpcy5fYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICB2YXIgX2Jsb2NrMiA9IHRoaXMuX2Jsb2Nrc1tiaV07XG4gICAgICAgIHZhciBibG9ja1N0YXJ0UG9zID0gYWNjVmFsLmxlbmd0aDtcbiAgICAgICAgYWNjVmFsICs9IF9ibG9jazIudmFsdWU7XG5cbiAgICAgICAgaWYgKHBvcyA8PSBhY2NWYWwubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBiaSxcbiAgICAgICAgICAgIG9mZnNldDogcG9zIC0gYmxvY2tTdGFydFBvc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmxvY2tTdGFydFBvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmxvY2tTdGFydFBvcyhibG9ja0luZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmxvY2tzLnNsaWNlKDAsIGJsb2NrSW5kZXgpLnJlZHVjZShmdW5jdGlvbiAocG9zLCBiKSB7XG4gICAgICAgIHJldHVybiBwb3MgKz0gYi52YWx1ZS5sZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZm9yRWFjaEJsb2Nrc0luUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MpIHtcbiAgICAgIHZhciB0b1BvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGZyb21CbG9ja0l0ZXIgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKGZyb21Qb3MpO1xuXG4gICAgICBpZiAoZnJvbUJsb2NrSXRlcikge1xuICAgICAgICB2YXIgdG9CbG9ja0l0ZXIgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKHRvUG9zKTsgLy8gcHJvY2VzcyBmaXJzdCBibG9ja1xuXG5cbiAgICAgICAgdmFyIGlzU2FtZUJsb2NrID0gdG9CbG9ja0l0ZXIgJiYgZnJvbUJsb2NrSXRlci5pbmRleCA9PT0gdG9CbG9ja0l0ZXIuaW5kZXg7XG4gICAgICAgIHZhciBmcm9tQmxvY2tTdGFydFBvcyA9IGZyb21CbG9ja0l0ZXIub2Zmc2V0O1xuICAgICAgICB2YXIgZnJvbUJsb2NrRW5kUG9zID0gdG9CbG9ja0l0ZXIgJiYgaXNTYW1lQmxvY2sgPyB0b0Jsb2NrSXRlci5vZmZzZXQgOiB0aGlzLl9ibG9ja3NbZnJvbUJsb2NrSXRlci5pbmRleF0udmFsdWUubGVuZ3RoO1xuICAgICAgICBmbih0aGlzLl9ibG9ja3NbZnJvbUJsb2NrSXRlci5pbmRleF0sIGZyb21CbG9ja0l0ZXIuaW5kZXgsIGZyb21CbG9ja1N0YXJ0UG9zLCBmcm9tQmxvY2tFbmRQb3MpO1xuXG4gICAgICAgIGlmICh0b0Jsb2NrSXRlciAmJiAhaXNTYW1lQmxvY2spIHtcbiAgICAgICAgICAvLyBwcm9jZXNzIGludGVybWVkaWF0ZSBibG9ja3NcbiAgICAgICAgICBmb3IgKHZhciBiaSA9IGZyb21CbG9ja0l0ZXIuaW5kZXggKyAxOyBiaSA8IHRvQmxvY2tJdGVyLmluZGV4OyArK2JpKSB7XG4gICAgICAgICAgICBmbih0aGlzLl9ibG9ja3NbYmldLCBiaSwgMCwgdGhpcy5fYmxvY2tzW2JpXS52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gLy8gcHJvY2VzcyBsYXN0IGJsb2NrXG5cblxuICAgICAgICAgIGZuKHRoaXMuX2Jsb2Nrc1t0b0Jsb2NrSXRlci5pbmRleF0sIHRvQmxvY2tJdGVyLmluZGV4LCAwLCB0b0Jsb2NrSXRlci5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGZyb21Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgdG9Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMudmFsdWUubGVuZ3RoO1xuXG4gICAgICB2YXIgcmVtb3ZlRGV0YWlscyA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJyZW1vdmVcIiwgdGhpcykuY2FsbCh0aGlzLCBmcm9tUG9zLCB0b1Bvcyk7XG5cbiAgICAgIHRoaXMuX2ZvckVhY2hCbG9ja3NJblJhbmdlKGZyb21Qb3MsIHRvUG9zLCBmdW5jdGlvbiAoYiwgXywgYkZyb21Qb3MsIGJUb1Bvcykge1xuICAgICAgICByZW1vdmVEZXRhaWxzLmFnZ3JlZ2F0ZShiLnJlbW92ZShiRnJvbVBvcywgYlRvUG9zKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlbW92ZURldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKGN1cnNvclBvcykge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRElSRUNUSU9OLk5PTkU7XG4gICAgICAvLyBUT0RPIHJlZmFjdG9yIC0gZXh0cmFjdCBhbGlnbmJsb2NrXG4gICAgICB2YXIgYmVnaW5CbG9ja0RhdGEgPSB0aGlzLl9tYXBQb3NUb0Jsb2NrKGN1cnNvclBvcykgfHwge1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGJlZ2luQmxvY2tPZmZzZXQgPSBiZWdpbkJsb2NrRGF0YS5vZmZzZXQsXG4gICAgICAgICAgYmVnaW5CbG9ja0luZGV4ID0gYmVnaW5CbG9ja0RhdGEuaW5kZXg7XG4gICAgICB2YXIgYmVnaW5CbG9jayA9IHRoaXMuX2Jsb2Nrc1tiZWdpbkJsb2NrSW5kZXhdO1xuICAgICAgaWYgKCFiZWdpbkJsb2NrKSByZXR1cm4gY3Vyc29yUG9zO1xuICAgICAgdmFyIGJlZ2luQmxvY2tDdXJzb3JQb3MgPSBiZWdpbkJsb2NrT2Zmc2V0OyAvLyBpZiBwb3NpdGlvbiBpbnNpZGUgYmxvY2sgLSB0cnkgdG8gYWRqdXN0IGl0XG5cbiAgICAgIGlmIChiZWdpbkJsb2NrQ3Vyc29yUG9zICE9PSAwICYmIGJlZ2luQmxvY2tDdXJzb3JQb3MgPCBiZWdpbkJsb2NrLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBiZWdpbkJsb2NrQ3Vyc29yUG9zID0gYmVnaW5CbG9jay5uZWFyZXN0SW5wdXRQb3MoYmVnaW5CbG9ja09mZnNldCwgZm9yY2VEaXJlY3Rpb24oZGlyZWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJzb3JBdFJpZ2h0ID0gYmVnaW5CbG9ja0N1cnNvclBvcyA9PT0gYmVnaW5CbG9jay52YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgY3Vyc29yQXRMZWZ0ID0gYmVnaW5CbG9ja0N1cnNvclBvcyA9PT0gMDsgLy8gIGN1cnNvciBpcyBJTlNJREUgZmlyc3QgYmxvY2sgKG5vdCBhdCBib3VuZHMpXG5cbiAgICAgIGlmICghY3Vyc29yQXRMZWZ0ICYmICFjdXJzb3JBdFJpZ2h0KSByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhiZWdpbkJsb2NrSW5kZXgpICsgYmVnaW5CbG9ja0N1cnNvclBvcztcbiAgICAgIHZhciBzZWFyY2hCbG9ja0luZGV4ID0gY3Vyc29yQXRSaWdodCA/IGJlZ2luQmxvY2tJbmRleCArIDEgOiBiZWdpbkJsb2NrSW5kZXg7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5OT05FKSB7XG4gICAgICAgIC8vIE5PTkUgZGlyZWN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHN0YXJ0IGlucHV0IHBvc2l0aW9uIGlmIG5vIGNoYXJzIHdlcmUgcmVtb3ZlZFxuICAgICAgICAvLyBGT1IgTk9ORTpcbiAgICAgICAgLy8gLVxuICAgICAgICAvLyBpbnB1dHxhbnlcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gIGFueXxpbnB1dFxuICAgICAgICAvLyA8LVxuICAgICAgICAvLyAgZmlsbGVkLWlucHV0fGFueVxuICAgICAgICAvLyBjaGVjayBpZiBmaXJzdCBibG9jayBhdCBsZWZ0IGlzIGlucHV0XG4gICAgICAgIGlmIChzZWFyY2hCbG9ja0luZGV4ID4gMCkge1xuICAgICAgICAgIHZhciBibG9ja0luZGV4QXRMZWZ0ID0gc2VhcmNoQmxvY2tJbmRleCAtIDE7XG4gICAgICAgICAgdmFyIGJsb2NrQXRMZWZ0ID0gdGhpcy5fYmxvY2tzW2Jsb2NrSW5kZXhBdExlZnRdO1xuICAgICAgICAgIHZhciBibG9ja0lucHV0UG9zID0gYmxvY2tBdExlZnQubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTsgLy8gaXMgaW5wdXRcblxuICAgICAgICAgIGlmICghYmxvY2tBdExlZnQudmFsdWUubGVuZ3RoIHx8IGJsb2NrSW5wdXRQb3MgIT09IGJsb2NrQXRMZWZ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3Moc2VhcmNoQmxvY2tJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIC0+XG5cblxuICAgICAgICB2YXIgZmlyc3RJbnB1dEF0UmlnaHQgPSBzZWFyY2hCbG9ja0luZGV4O1xuXG4gICAgICAgIGZvciAodmFyIGJpID0gZmlyc3RJbnB1dEF0UmlnaHQ7IGJpIDwgdGhpcy5fYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgIHZhciBibG9ja0F0UmlnaHQgPSB0aGlzLl9ibG9ja3NbYmldO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zID0gYmxvY2tBdFJpZ2h0Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSk7XG5cbiAgICAgICAgICBpZiAoIWJsb2NrQXRSaWdodC52YWx1ZS5sZW5ndGggfHwgX2Jsb2NrSW5wdXRQb3MgIT09IGJsb2NrQXRSaWdodC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja1N0YXJ0UG9zKGJpKSArIF9ibG9ja0lucHV0UG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyA8LVxuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi1maXhlZCBzeW1ib2xcblxuXG4gICAgICAgIGZvciAodmFyIF9iaSA9IHNlYXJjaEJsb2NrSW5kZXggLSAxOyBfYmkgPj0gMDsgLS1fYmkpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrMyA9IHRoaXMuX2Jsb2Nrc1tfYmldO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zMiA9IF9ibG9jazMubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTsgLy8gaXMgaW5wdXRcblxuXG4gICAgICAgICAgaWYgKCFfYmxvY2szLnZhbHVlLmxlbmd0aCB8fCBfYmxvY2tJbnB1dFBvczIgIT09IF9ibG9jazMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmkpICsgX2Jsb2NrMy52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLkxFRlQgfHwgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfTEVGVCkge1xuICAgICAgICAvLyAtXG4gICAgICAgIC8vICBhbnl8ZmlsbGVkLWlucHV0XG4gICAgICAgIC8vIDwtXG4gICAgICAgIC8vICBhbnl8Zmlyc3Qgbm90IGVtcHR5IGlzIG5vdC1sZW4tYWxpZ25lZFxuICAgICAgICAvLyAgbm90LTAtYWxpZ25lZHxhbnlcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gIGFueXxub3QtbGVuLWFsaWduZWQgb3IgZW5kXG4gICAgICAgIC8vIGNoZWNrIGlmIGZpcnN0IGJsb2NrIGF0IHJpZ2h0IGlzIGZpbGxlZCBpbnB1dFxuICAgICAgICB2YXIgZmlyc3RGaWxsZWRCbG9ja0luZGV4QXRSaWdodDtcblxuICAgICAgICBmb3IgKHZhciBfYmkyID0gc2VhcmNoQmxvY2tJbmRleDsgX2JpMiA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpMikge1xuICAgICAgICAgIGlmICh0aGlzLl9ibG9ja3NbX2JpMl0udmFsdWUpIHtcbiAgICAgICAgICAgIGZpcnN0RmlsbGVkQmxvY2tJbmRleEF0UmlnaHQgPSBfYmkyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0RmlsbGVkQmxvY2tJbmRleEF0UmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmaWxsZWRCbG9jayA9IHRoaXMuX2Jsb2Nrc1tmaXJzdEZpbGxlZEJsb2NrSW5kZXhBdFJpZ2h0XTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczMgPSBmaWxsZWRCbG9jay5uZWFyZXN0SW5wdXRQb3MoMCwgRElSRUNUSU9OLlJJR0hUKTtcblxuICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczMgPT09IDAgJiYgZmlsbGVkQmxvY2sudW5tYXNrZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpbGxlZCBibG9jayBpcyBpbnB1dFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoZmlyc3RGaWxsZWRCbG9ja0luZGV4QXRSaWdodCkgKyBfYmxvY2tJbnB1dFBvczM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIDwtXG4gICAgICAgIC8vIGZpbmQgdGhpcyB2YXJzXG5cblxuICAgICAgICB2YXIgZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGZpcnN0RW1wdHlJbnB1dEJsb2NrSW5kZXg7IC8vIFRPRE8gY29uc2lkZXIgbmVzdGVkIGVtcHR5IGlucHV0c1xuXG4gICAgICAgIGZvciAodmFyIF9iaTMgPSBzZWFyY2hCbG9ja0luZGV4IC0gMTsgX2JpMyA+PSAwOyAtLV9iaTMpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrNCA9IHRoaXMuX2Jsb2Nrc1tfYmkzXTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczQgPSBfYmxvY2s0Lm5lYXJlc3RJbnB1dFBvcyhfYmxvY2s0LnZhbHVlLmxlbmd0aCwgRElSRUNUSU9OLkZPUkNFX0xFRlQpO1xuXG4gICAgICAgICAgaWYgKCFfYmxvY2s0LnZhbHVlIHx8IF9ibG9ja0lucHV0UG9zNCAhPT0gMCkgZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCA9IF9iaTM7XG5cbiAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M0ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M0ICE9PSBfYmxvY2s0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBhbGlnbmVkIGluc2lkZSBibG9jayAtIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmkzKSArIF9ibG9ja0lucHV0UG9zNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvdW5kIGZpbGxlZFxuICAgICAgICAgICAgICBmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleCA9IF9iaTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5MRUZUKSB7XG4gICAgICAgICAgLy8gdHJ5IGZpbmQgZmlyc3QgZW1wdHkgaW5wdXQgYmVmb3JlIHN0YXJ0IHNlYXJjaGluZyBwb3NpdGlvbiBvbmx5IHdoZW4gbm90IGZvcmNlZFxuICAgICAgICAgIGZvciAodmFyIF9iaTQgPSBmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleCArIDE7IF9iaTQgPD0gTWF0aC5taW4oc2VhcmNoQmxvY2tJbmRleCwgdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpOyArK19iaTQpIHtcbiAgICAgICAgICAgIHZhciBfYmxvY2s1ID0gdGhpcy5fYmxvY2tzW19iaTRdO1xuXG4gICAgICAgICAgICB2YXIgX2Jsb2NrSW5wdXRQb3M1ID0gX2Jsb2NrNS5uZWFyZXN0SW5wdXRQb3MoMCwgRElSRUNUSU9OLk5PTkUpO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tBbGlnbmVkUG9zID0gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk0KSArIF9ibG9ja0lucHV0UG9zNTtcblxuICAgICAgICAgICAgaWYgKGJsb2NrQWxpZ25lZFBvcyA+IGN1cnNvclBvcykgYnJlYWs7IC8vIGlmIGJsb2NrIGlzIG5vdCBsYXp5IGlucHV0XG5cbiAgICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczUgIT09IF9ibG9jazUudmFsdWUubGVuZ3RoKSByZXR1cm4gYmxvY2tBbGlnbmVkUG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9jZXNzIG92ZXJmbG93XG5cblxuICAgICAgICBpZiAoZmlyc3RGaWxsZWRJbnB1dEJsb2NrSW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja1N0YXJ0UG9zKGZpcnN0RmlsbGVkSW5wdXRCbG9ja0luZGV4KSArIHRoaXMuX2Jsb2Nrc1tmaXJzdEZpbGxlZElucHV0QmxvY2tJbmRleF0udmFsdWUubGVuZ3RoO1xuICAgICAgICB9IC8vIGZvciBsYXp5IGlmIGhhcyBhbGlnbmVkIGxlZnQgaW5zaWRlIGZpeGVkIGFuZCBoYXMgY2FtZSB0byB0aGUgc3RhcnQgLSB1c2Ugc3RhcnQgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5GT1JDRV9MRUZUIHx8IHRoaXMubGF6eSAmJiAhdGhpcy5leHRyYWN0SW5wdXQoKSAmJiAhaXNJbnB1dCh0aGlzLl9ibG9ja3Nbc2VhcmNoQmxvY2tJbmRleF0pKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoZmlyc3RFbXB0eUlucHV0QmxvY2tJbmRleCk7XG4gICAgICAgIH0gLy8gZmluZCBmaXJzdCBpbnB1dFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2JpNSA9IHNlYXJjaEJsb2NrSW5kZXg7IF9iaTUgPCB0aGlzLl9ibG9ja3MubGVuZ3RoOyArK19iaTUpIHtcbiAgICAgICAgICB2YXIgX2Jsb2NrNiA9IHRoaXMuX2Jsb2Nrc1tfYmk1XTtcblxuICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczYgPSBfYmxvY2s2Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSk7IC8vIGlzIGlucHV0XG5cblxuICAgICAgICAgIGlmICghX2Jsb2NrNi52YWx1ZS5sZW5ndGggfHwgX2Jsb2NrSW5wdXRQb3M2ICE9PSBfYmxvY2s2LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrU3RhcnRQb3MoX2JpNSkgKyBfYmxvY2tJbnB1dFBvczY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5SSUdIVCB8fCBkaXJlY3Rpb24gPT09IERJUkVDVElPTi5GT1JDRV9SSUdIVCkge1xuICAgICAgICAvLyAtPlxuICAgICAgICAvLyAgYW55fG5vdC1sZW4tYWxpZ25lZCBhbmQgZmlsbGVkXG4gICAgICAgIC8vICBhbnl8bm90LWxlbi1hbGlnbmVkXG4gICAgICAgIC8vIDwtXG4gICAgICAgIC8vICBub3QtMC1hbGlnbmVkIG9yIHN0YXJ0fGFueVxuICAgICAgICB2YXIgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZEluZGV4O1xuICAgICAgICB2YXIgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZFBvcztcblxuICAgICAgICBmb3IgKHZhciBfYmk2ID0gc2VhcmNoQmxvY2tJbmRleDsgX2JpNiA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpNikge1xuICAgICAgICAgIHZhciBfYmxvY2s3ID0gdGhpcy5fYmxvY2tzW19iaTZdO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zNyA9IF9ibG9jazcubmVhcmVzdElucHV0UG9zKDAsIERJUkVDVElPTi5OT05FKTtcblxuICAgICAgICAgIGlmIChfYmxvY2tJbnB1dFBvczcgIT09IF9ibG9jazcudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaXJzdElucHV0QmxvY2tBbGlnbmVkUG9zID0gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk2KSArIF9ibG9ja0lucHV0UG9zNztcbiAgICAgICAgICAgIGZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleCA9IF9iaTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RJbnB1dEJsb2NrQWxpZ25lZEluZGV4ICE9IG51bGwgJiYgZmlyc3RJbnB1dEJsb2NrQWxpZ25lZFBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2JpNyA9IGZpcnN0SW5wdXRCbG9ja0FsaWduZWRJbmRleDsgX2JpNyA8IHRoaXMuX2Jsb2Nrcy5sZW5ndGg7ICsrX2JpNykge1xuICAgICAgICAgICAgdmFyIF9ibG9jazggPSB0aGlzLl9ibG9ja3NbX2JpN107XG5cbiAgICAgICAgICAgIHZhciBfYmxvY2tJbnB1dFBvczggPSBfYmxvY2s4Lm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uRk9SQ0VfUklHSFQpO1xuXG4gICAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M4ICE9PSBfYmxvY2s4LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2tTdGFydFBvcyhfYmk3KSArIF9ibG9ja0lucHV0UG9zODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfUklHSFQgPyB0aGlzLnZhbHVlLmxlbmd0aCA6IGZpcnN0SW5wdXRCbG9ja0FsaWduZWRQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfYmk4ID0gTWF0aC5taW4oc2VhcmNoQmxvY2tJbmRleCwgdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpOyBfYmk4ID49IDA7IC0tX2JpOCkge1xuICAgICAgICAgIHZhciBfYmxvY2s5ID0gdGhpcy5fYmxvY2tzW19iaThdO1xuXG4gICAgICAgICAgdmFyIF9ibG9ja0lucHV0UG9zOSA9IF9ibG9jazkubmVhcmVzdElucHV0UG9zKF9ibG9jazkudmFsdWUubGVuZ3RoLCBESVJFQ1RJT04uTEVGVCk7XG5cbiAgICAgICAgICBpZiAoX2Jsb2NrSW5wdXRQb3M5ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgYWxpZ25lZFBvcyA9IHRoaXMuX2Jsb2NrU3RhcnRQb3MoX2JpOCkgKyBfYmxvY2tJbnB1dFBvczk7XG5cbiAgICAgICAgICAgIGlmIChhbGlnbmVkUG9zID49IGN1cnNvclBvcykgcmV0dXJuIGFsaWduZWRQb3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnNvclBvcztcbiAgICB9XG4gICAgLyoqIEdldCBibG9jayBieSBuYW1lICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXNrZWRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrZWRCbG9jayhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWRCbG9ja3MobmFtZSlbMF07XG4gICAgfVxuICAgIC8qKiBHZXQgYWxsIGJsb2NrcyBieSBuYW1lICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXNrZWRCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFza2VkQmxvY2tzKG5hbWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuX21hc2tlZEJsb2Nrc1tuYW1lXTtcbiAgICAgIGlmICghaW5kaWNlcykgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIGluZGljZXMubWFwKGZ1bmN0aW9uIChnaSkge1xuICAgICAgICByZXR1cm4gX3RoaXM0Ll9ibG9ja3NbZ2ldO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcInN0YXRlXCIsIHRoaXMpLCB7XG4gICAgICAgIF9ibG9ja3M6IHRoaXMuX2Jsb2Nrcy5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5zdGF0ZTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHZhciBfYmxvY2tzID0gc3RhdGUuX2Jsb2NrcyxcbiAgICAgICAgICBtYXNrZWRTdGF0ZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzdGF0ZSwgW1wiX2Jsb2Nrc1wiXSk7XG5cbiAgICAgIHRoaXMuX2Jsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBiaSkge1xuICAgICAgICByZXR1cm4gYi5zdGF0ZSA9IF9ibG9ja3NbYmldO1xuICAgICAgfSk7XG5cbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJzdGF0ZVwiLCBtYXNrZWRTdGF0ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQ29tcGxldGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ibG9ja3MuZXZlcnkoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaXNDb21wbGV0ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bm1hc2tlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmxvY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBiKSB7XG4gICAgICAgIHJldHVybiBzdHIgKz0gYi51bm1hc2tlZFZhbHVlO1xuICAgICAgfSwgJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodW5tYXNrZWRWYWx1ZSkge1xuICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUGF0dGVybi5wcm90b3R5cGUpLCBcInVubWFza2VkVmFsdWVcIiwgdW5tYXNrZWRWYWx1ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gVE9ETyByZXR1cm4gX3ZhbHVlIHdoZW4gbm90IGluIGNoYW5nZT9cbiAgICAgIHJldHVybiB0aGlzLl9ibG9ja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0ciArPSBiLnZhbHVlO1xuICAgICAgfSwgJycpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFBhdHRlcm4ucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZFBhdHRlcm47XG59KE1hc2tlZCk7XG5NYXNrZWRQYXR0ZXJuLkRFRkFVTFRTID0ge1xuICBsYXp5OiB0cnVlLFxuICBwbGFjZWhvbGRlckNoYXI6ICdfJ1xufTtcbk1hc2tlZFBhdHRlcm4uU1RPUF9DSEFSID0gJ2AnO1xuTWFza2VkUGF0dGVybi5FU0NBUEVfQ0hBUiA9ICdcXFxcJztcbk1hc2tlZFBhdHRlcm4uSW5wdXREZWZpbml0aW9uID0gUGF0dGVybklucHV0RGVmaW5pdGlvbjtcbk1hc2tlZFBhdHRlcm4uRml4ZWREZWZpbml0aW9uID0gUGF0dGVybkZpeGVkRGVmaW5pdGlvbjtcblxuZnVuY3Rpb24gaXNJbnB1dChibG9jaykge1xuICBpZiAoIWJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIHZhciB2YWx1ZSA9IGJsb2NrLnZhbHVlO1xuICByZXR1cm4gIXZhbHVlIHx8IGJsb2NrLm5lYXJlc3RJbnB1dFBvcygwLCBESVJFQ1RJT04uTk9ORSkgIT09IHZhbHVlLmxlbmd0aDtcbn1cblxuSU1hc2suTWFza2VkUGF0dGVybiA9IE1hc2tlZFBhdHRlcm47XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZFBhdHRlcm47XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0LCBpIGFzIF9zbGljZWRUb0FycmF5IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0ICcuL2Jhc2UuanMnO1xuaW1wb3J0ICcuL2ZhY3RvcnkuanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vaW5wdXQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vcmVnZXhwLmpzJztcbmltcG9ydCBNYXNrZWRQYXR0ZXJuIGZyb20gJy4vcGF0dGVybi5qcyc7XG5cbi8qKiBQYXR0ZXJuIHdoaWNoIGFjY2VwdHMgcmFuZ2VzICovXG5cbnZhciBNYXNrZWRSYW5nZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX01hc2tlZFBhdHRlcm4pIHtcbiAgX2luaGVyaXRzKE1hc2tlZFJhbmdlLCBfTWFza2VkUGF0dGVybik7XG5cbiAgZnVuY3Rpb24gTWFza2VkUmFuZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZFJhbmdlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFza2VkUmFuZ2UpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZFJhbmdlLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIC8vIFRPRE8gdHlwZVxuICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0bzogdGhpcy50byB8fCAwLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20gfHwgMFxuICAgICAgfSwgb3B0cyk7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gU3RyaW5nKG9wdHMudG8pLmxlbmd0aDtcbiAgICAgIGlmIChvcHRzLm1heExlbmd0aCAhPSBudWxsKSBtYXhMZW5ndGggPSBNYXRoLm1heChtYXhMZW5ndGgsIG9wdHMubWF4TGVuZ3RoKTtcbiAgICAgIG9wdHMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgICAgdmFyIGZyb21TdHIgPSBTdHJpbmcob3B0cy5mcm9tKS5wYWRTdGFydChtYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdG9TdHIgPSBTdHJpbmcob3B0cy50bykucGFkU3RhcnQobWF4TGVuZ3RoLCAnMCcpO1xuICAgICAgdmFyIHNhbWVDaGFyc0NvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKHNhbWVDaGFyc0NvdW50IDwgdG9TdHIubGVuZ3RoICYmIHRvU3RyW3NhbWVDaGFyc0NvdW50XSA9PT0gZnJvbVN0cltzYW1lQ2hhcnNDb3VudF0pIHtcbiAgICAgICAgKytzYW1lQ2hhcnNDb3VudDtcbiAgICAgIH1cblxuICAgICAgb3B0cy5tYXNrID0gdG9TdHIuc2xpY2UoMCwgc2FtZUNoYXJzQ291bnQpLnJlcGxhY2UoLzAvZywgJ1xcXFwwJykgKyAnMCcucmVwZWF0KG1heExlbmd0aCAtIHNhbWVDaGFyc0NvdW50KTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkUmFuZ2UucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJib3VuZGFyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvdW5kYXJpZXMoc3RyKSB7XG4gICAgICB2YXIgbWluc3RyID0gJyc7XG4gICAgICB2YXIgbWF4c3RyID0gJyc7XG5cbiAgICAgIHZhciBfcmVmID0gc3RyLm1hdGNoKC9eKFxcRCopKFxcZCopKFxcRCopLykgfHwgW10sXG4gICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAzKSxcbiAgICAgICAgICBwbGFjZWhvbGRlciA9IF9yZWYyWzFdLFxuICAgICAgICAgIG51bSA9IF9yZWYyWzJdO1xuXG4gICAgICBpZiAobnVtKSB7XG4gICAgICAgIG1pbnN0ciA9ICcwJy5yZXBlYXQocGxhY2Vob2xkZXIubGVuZ3RoKSArIG51bTtcbiAgICAgICAgbWF4c3RyID0gJzknLnJlcGVhdChwbGFjZWhvbGRlci5sZW5ndGgpICsgbnVtO1xuICAgICAgfVxuXG4gICAgICBtaW5zdHIgPSBtaW5zdHIucGFkRW5kKHRoaXMubWF4TGVuZ3RoLCAnMCcpO1xuICAgICAgbWF4c3RyID0gbWF4c3RyLnBhZEVuZCh0aGlzLm1heExlbmd0aCwgJzknKTtcbiAgICAgIHJldHVybiBbbWluc3RyLCBtYXhzdHJdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9QcmVwYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvUHJlcGFyZShzdHIpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBzdHIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSYW5nZS5wcm90b3R5cGUpLCBcImRvUHJlcGFyZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHN0ciwgZmxhZ3MpLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICBpZiAoIXRoaXMuYXV0b2ZpeCkgcmV0dXJuIHN0cjtcbiAgICAgIHZhciBmcm9tU3RyID0gU3RyaW5nKHRoaXMuZnJvbSkucGFkU3RhcnQodGhpcy5tYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdG9TdHIgPSBTdHJpbmcodGhpcy50bykucGFkU3RhcnQodGhpcy5tYXhMZW5ndGgsICcwJyk7XG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciBwcmVwU3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBzdHIubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgIHZhciBuZXh0VmFsID0gdmFsICsgcHJlcFN0ciArIHN0cltjaV07XG5cbiAgICAgICAgdmFyIF90aGlzJGJvdW5kYXJpZXMgPSB0aGlzLmJvdW5kYXJpZXMobmV4dFZhbCksXG4gICAgICAgICAgICBfdGhpcyRib3VuZGFyaWVzMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGJvdW5kYXJpZXMsIDIpLFxuICAgICAgICAgICAgbWluc3RyID0gX3RoaXMkYm91bmRhcmllczJbMF0sXG4gICAgICAgICAgICBtYXhzdHIgPSBfdGhpcyRib3VuZGFyaWVzMlsxXTtcblxuICAgICAgICBpZiAoTnVtYmVyKG1heHN0cikgPCB0aGlzLmZyb20pIHByZXBTdHIgKz0gZnJvbVN0cltuZXh0VmFsLmxlbmd0aCAtIDFdO2Vsc2UgaWYgKE51bWJlcihtaW5zdHIpID4gdGhpcy50bykgcHJlcFN0ciArPSB0b1N0cltuZXh0VmFsLmxlbmd0aCAtIDFdO2Vsc2UgcHJlcFN0ciArPSBzdHJbY2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlcFN0cjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvVmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9WYWxpZGF0ZSgpIHtcbiAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgdmFyIHN0ciA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgZmlyc3ROb25aZXJvID0gc3RyLnNlYXJjaCgvW14wXS8pO1xuICAgICAgaWYgKGZpcnN0Tm9uWmVybyA9PT0gLTEgJiYgc3RyLmxlbmd0aCA8PSB0aGlzLl9tYXRjaEZyb20pIHJldHVybiB0cnVlO1xuXG4gICAgICB2YXIgX3RoaXMkYm91bmRhcmllczMgPSB0aGlzLmJvdW5kYXJpZXMoc3RyKSxcbiAgICAgICAgICBfdGhpcyRib3VuZGFyaWVzNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJGJvdW5kYXJpZXMzLCAyKSxcbiAgICAgICAgICBtaW5zdHIgPSBfdGhpcyRib3VuZGFyaWVzNFswXSxcbiAgICAgICAgICBtYXhzdHIgPSBfdGhpcyRib3VuZGFyaWVzNFsxXTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZyb20gPD0gTnVtYmVyKG1heHN0cikgJiYgTnVtYmVyKG1pbnN0cikgPD0gdGhpcy50byAmJiAoX2dldDIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRSYW5nZS5wcm90b3R5cGUpLCBcImRvVmFsaWRhdGVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWF0Y2hGcm9tXCIsXG5cbiAgICAvKipcclxuICAgICAgT3B0aW9uYWxseSBzZXRzIG1heCBsZW5ndGggb2YgcGF0dGVybi5cclxuICAgICAgVXNlZCB3aGVuIHBhdHRlcm4gbGVuZ3RoIGlzIGxvbmdlciB0aGVuIGB0b2AgcGFyYW0gbGVuZ3RoLiBQYWRzIHplcm9zIGF0IHN0YXJ0IGluIHRoaXMgY2FzZS5cclxuICAgICovXG5cbiAgICAvKiogTWluIGJvdW5kICovXG5cbiAgICAvKiogTWF4IGJvdW5kICovXG5cbiAgICAvKiogKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1heExlbmd0aCAtIFN0cmluZyh0aGlzLmZyb20pLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb21wbGV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZFJhbmdlLnByb3RvdHlwZSksIFwiaXNDb21wbGV0ZVwiLCB0aGlzKSAmJiBCb29sZWFuKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWRSYW5nZTtcbn0oTWFza2VkUGF0dGVybik7XG5JTWFzay5NYXNrZWRSYW5nZSA9IE1hc2tlZFJhbmdlO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWRSYW5nZTtcbiIsImltcG9ydCB7IGQgYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgaSBhcyBfc2xpY2VkVG9BcnJheSwgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGUgYXMgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIGYgYXMgX2dldFByb3RvdHlwZU9mLCBnIGFzIF9nZXQsIGggYXMgX3NldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCAnLi9iYXNlLmpzJztcbmltcG9ydCAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5pbXBvcnQgTWFza2VkUGF0dGVybiBmcm9tICcuL3BhdHRlcm4uanMnO1xuaW1wb3J0IE1hc2tlZFJhbmdlIGZyb20gJy4vcmFuZ2UuanMnO1xuXG4vKiogRGF0ZSBtYXNrICovXG5cbnZhciBNYXNrZWREYXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkUGF0dGVybikge1xuICBfaW5oZXJpdHMoTWFza2VkRGF0ZSwgX01hc2tlZFBhdHRlcm4pO1xuXG4gIC8qKiBQYXR0ZXJuIG1hc2sgZm9yIGRhdGUgYWNjb3JkaW5nIHRvIHtAbGluayBNYXNrZWREYXRlI2Zvcm1hdH0gKi9cblxuICAvKiogU3RhcnQgZGF0ZSAqL1xuXG4gIC8qKiBFbmQgZGF0ZSAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAqL1xuICBmdW5jdGlvbiBNYXNrZWREYXRlKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza2VkRGF0ZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkRGF0ZS5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gIH1cbiAgLyoqXHJcbiAgICBAb3ZlcnJpZGVcclxuICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZERhdGUsIFt7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZShvcHRzKSB7XG4gICAgICBpZiAob3B0cy5tYXNrID09PSBEYXRlKSBkZWxldGUgb3B0cy5tYXNrO1xuICAgICAgaWYgKG9wdHMucGF0dGVybikgb3B0cy5tYXNrID0gb3B0cy5wYXR0ZXJuO1xuICAgICAgdmFyIGJsb2NrcyA9IG9wdHMuYmxvY2tzO1xuICAgICAgb3B0cy5ibG9ja3MgPSBPYmplY3QuYXNzaWduKHt9LCBNYXNrZWREYXRlLkdFVF9ERUZBVUxUX0JMT0NLUygpKTsgLy8gYWRqdXN0IHllYXIgYmxvY2tcblxuICAgICAgaWYgKG9wdHMubWluKSBvcHRzLmJsb2Nrcy5ZLmZyb20gPSBvcHRzLm1pbi5nZXRGdWxsWWVhcigpO1xuICAgICAgaWYgKG9wdHMubWF4KSBvcHRzLmJsb2Nrcy5ZLnRvID0gb3B0cy5tYXguZ2V0RnVsbFllYXIoKTtcblxuICAgICAgaWYgKG9wdHMubWluICYmIG9wdHMubWF4ICYmIG9wdHMuYmxvY2tzLlkuZnJvbSA9PT0gb3B0cy5ibG9ja3MuWS50bykge1xuICAgICAgICBvcHRzLmJsb2Nrcy5tLmZyb20gPSBvcHRzLm1pbi5nZXRNb250aCgpICsgMTtcbiAgICAgICAgb3B0cy5ibG9ja3MubS50byA9IG9wdHMubWF4LmdldE1vbnRoKCkgKyAxO1xuXG4gICAgICAgIGlmIChvcHRzLmJsb2Nrcy5tLmZyb20gPT09IG9wdHMuYmxvY2tzLm0udG8pIHtcbiAgICAgICAgICBvcHRzLmJsb2Nrcy5kLmZyb20gPSBvcHRzLm1pbi5nZXREYXRlKCk7XG4gICAgICAgICAgb3B0cy5ibG9ja3MuZC50byA9IG9wdHMubWF4LmdldERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKG9wdHMuYmxvY2tzLCBibG9ja3MpOyAvLyBhZGQgYXV0b2ZpeFxuXG4gICAgICBPYmplY3Qua2V5cyhvcHRzLmJsb2NrcykuZm9yRWFjaChmdW5jdGlvbiAoYmspIHtcbiAgICAgICAgdmFyIGIgPSBvcHRzLmJsb2Nrc1tia107XG4gICAgICAgIGlmICghKCdhdXRvZml4JyBpbiBiKSkgYi5hdXRvZml4ID0gb3B0cy5hdXRvZml4O1xuICAgICAgfSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoKSB7XG4gICAgICB2YXIgX2dldDI7XG5cbiAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJkb1ZhbGlkYXRlXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSAmJiAoIXRoaXMuaXNDb21wbGV0ZSB8fCB0aGlzLmlzRGF0ZUV4aXN0KHRoaXMudmFsdWUpICYmIGRhdGUgIT0gbnVsbCAmJiAodGhpcy5taW4gPT0gbnVsbCB8fCB0aGlzLm1pbiA8PSBkYXRlKSAmJiAodGhpcy5tYXggPT0gbnVsbCB8fCBkYXRlIDw9IHRoaXMubWF4KSk7XG4gICAgfVxuICAgIC8qKiBDaGVja3MgaWYgZGF0ZSBpcyBleGlzdHMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzRGF0ZUV4aXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGF0ZUV4aXN0KHN0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHRoaXMucGFyc2Uoc3RyLCB0aGlzKSwgdGhpcykuaW5kZXhPZihzdHIpID49IDA7XG4gICAgfVxuICAgIC8qKiBQYXJzZWQgRGF0ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZWRWYWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRhdGUpIHtcbiAgICAgIHRoaXMudHlwZWRWYWx1ZSA9IGRhdGU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlID8gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRGF0ZS5wcm90b3R5cGUpLCBcInR5cGVkVmFsdWVcIiwgdGhpcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZERhdGUucHJvdG90eXBlKSwgXCJ0eXBlZFZhbHVlXCIsIHZhbHVlLCB0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFza2VkRGF0ZTtcbn0oTWFza2VkUGF0dGVybik7XG5NYXNrZWREYXRlLkRFRkFVTFRTID0ge1xuICBwYXR0ZXJuOiAnZHsufWBtey59YFknLFxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgdmFyIGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB2YXIgbW9udGggPSBTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICByZXR1cm4gW2RheSwgbW9udGgsIHllYXJdLmpvaW4oJy4nKTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBfc3RyJHNwbGl0ID0gc3RyLnNwbGl0KCcuJyksXG4gICAgICAgIF9zdHIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3N0ciRzcGxpdCwgMyksXG4gICAgICAgIGRheSA9IF9zdHIkc3BsaXQyWzBdLFxuICAgICAgICBtb250aCA9IF9zdHIkc3BsaXQyWzFdLFxuICAgICAgICB5ZWFyID0gX3N0ciRzcGxpdDJbMl07XG5cbiAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xuICB9XG59O1xuXG5NYXNrZWREYXRlLkdFVF9ERUZBVUxUX0JMT0NLUyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkOiB7XG4gICAgICBtYXNrOiBNYXNrZWRSYW5nZSxcbiAgICAgIGZyb206IDEsXG4gICAgICB0bzogMzEsXG4gICAgICBtYXhMZW5ndGg6IDJcbiAgICB9LFxuICAgIG06IHtcbiAgICAgIG1hc2s6IE1hc2tlZFJhbmdlLFxuICAgICAgZnJvbTogMSxcbiAgICAgIHRvOiAxMixcbiAgICAgIG1heExlbmd0aDogMlxuICAgIH0sXG4gICAgWToge1xuICAgICAgbWFzazogTWFza2VkUmFuZ2UsXG4gICAgICBmcm9tOiAxOTAwLFxuICAgICAgdG86IDk5OTlcbiAgICB9XG4gIH07XG59O1xuXG5JTWFzay5NYXNrZWREYXRlID0gTWFza2VkRGF0ZTtcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkRGF0ZTtcbiIsImltcG9ydCB7IGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjayB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcblxuLyoqXHJcbiAgR2VuZXJpYyBlbGVtZW50IEFQSSB0byB1c2Ugd2l0aCBtYXNrXHJcbiAgQGludGVyZmFjZVxyXG4qL1xudmFyIE1hc2tFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFza0VsZW1lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tFbGVtZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXNrRWxlbWVudCwgW3tcbiAgICBrZXk6IFwic2VsZWN0XCIsXG5cbiAgICAvKiogU2FmZWx5IHNldHMgZWxlbWVudCBzZWxlY3Rpb24gKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIGVuZCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Vuc2FmZVNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpIHt9XG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50c1wiLFxuXG4gICAgLyoqIFNob3VsZCBiZSBvdmVycmlkZW4gaW4gc3ViY2xhc3NlcyAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKGhhbmRsZXJzKSB7fVxuICAgIC8qKiBTaG91bGQgYmUgb3ZlcnJpZGVuIGluIHN1YmNsYXNzZXMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRFdmVudHMoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdGlvblN0YXJ0XCIsXG5cbiAgICAvKiogKi9cblxuICAgIC8qKiAqL1xuXG4gICAgLyoqICovXG5cbiAgICAvKiogU2FmZWx5IHJldHVybnMgc2VsZWN0aW9uIHN0YXJ0ICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3RhcnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fdW5zYWZlU2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gc3RhcnQgIT0gbnVsbCA/IHN0YXJ0IDogdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKiBTYWZlbHkgcmV0dXJucyBzZWxlY3Rpb24gZW5kICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25FbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbmQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVuZCA9IHRoaXMuX3Vuc2FmZVNlbGVjdGlvbkVuZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiBlbmQgIT0gbnVsbCA/IGVuZCA6IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0FjdGl2ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrRWxlbWVudDtcbn0oKTtcbklNYXNrLk1hc2tFbGVtZW50ID0gTWFza0VsZW1lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tFbGVtZW50O1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YgfSBmcm9tICcuLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgTWFza0VsZW1lbnQgZnJvbSAnLi9tYXNrLWVsZW1lbnQuanMnO1xuXG4vKiogQnJpZGdlIGJldHdlZW4gSFRNTEVsZW1lbnQgYW5kIHtAbGluayBNYXNrZWR9ICovXG5cbnZhciBIVE1MTWFza0VsZW1lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrRWxlbWVudCkge1xuICBfaW5oZXJpdHMoSFRNTE1hc2tFbGVtZW50LCBfTWFza0VsZW1lbnQpO1xuXG4gIC8qKiBNYXBwaW5nIGJldHdlZW4gSFRNTEVsZW1lbnQgZXZlbnRzIGFuZCBtYXNrIGludGVybmFsIGV2ZW50cyAqL1xuXG4gIC8qKiBIVE1MRWxlbWVudCB0byB1c2UgbWFzayBvbiAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XHJcbiAgKi9cbiAgZnVuY3Rpb24gSFRNTE1hc2tFbGVtZW50KGlucHV0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxNYXNrRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihIVE1MTWFza0VsZW1lbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgX3RoaXMuX2hhbmRsZXJzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiAqL1xuICAvLyAkRmxvd0ZpeE1lIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODM5XG5cblxuICBfY3JlYXRlQ2xhc3MoSFRNTE1hc2tFbGVtZW50LCBbe1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0XCIsXG5cbiAgICAvKipcclxuICAgICAgU2V0cyBIVE1MRWxlbWVudCBzZWxlY3Rpb25cclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zYWZlU2VsZWN0KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBIVE1MRWxlbWVudCB2YWx1ZVxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRXZlbnRzXCIsXG5cbiAgICAvKipcclxuICAgICAgQmluZHMgSFRNTEVsZW1lbnQgZXZlbnRzIHRvIG1hc2sgaW50ZXJuYWwgZXZlbnRzXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50cyhoYW5kbGVycykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKGhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl90b2dnbGVFdmVudEhhbmRsZXIoSFRNTE1hc2tFbGVtZW50LkVWRU5UU19NQVBbZXZlbnRdLCBoYW5kbGVyc1tldmVudF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBVbmJpbmRzIEhUTUxFbGVtZW50IGV2ZW50cyB0byBtYXNrIGludGVybmFsIGV2ZW50c1xyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2hhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl90b2dnbGVFdmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RvZ2dsZUV2ZW50SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5faGFuZGxlcnNbZXZlbnRdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm9vdEVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LmdldFJvb3ROb2RlID8gdGhpcy5pbnB1dC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBJcyBlbGVtZW50IGluIGZvY3VzXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQWN0aXZlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyRGbG93Rml4TWVcbiAgICAgIHJldHVybiB0aGlzLmlucHV0ID09PSB0aGlzLnJvb3RFbGVtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBSZXR1cm5zIEhUTUxFbGVtZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uU3RhcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICAvKipcclxuICAgICAgUmV0dXJucyBIVE1MRWxlbWVudCBzZWxlY3Rpb24gZW5kXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91bnNhZmVTZWxlY3Rpb25FbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSFRNTE1hc2tFbGVtZW50O1xufShNYXNrRWxlbWVudCk7XG5IVE1MTWFza0VsZW1lbnQuRVZFTlRTX01BUCA9IHtcbiAgc2VsZWN0aW9uQ2hhbmdlOiAna2V5ZG93bicsXG4gIGlucHV0OiAnaW5wdXQnLFxuICBkcm9wOiAnZHJvcCcsXG4gIGNsaWNrOiAnY2xpY2snLFxuICBmb2N1czogJ2ZvY3VzJyxcbiAgY29tbWl0OiAnYmx1cidcbn07XG5JTWFzay5IVE1MTWFza0VsZW1lbnQgPSBIVE1MTWFza0VsZW1lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhUTUxNYXNrRWxlbWVudDtcbiIsImltcG9ydCB7IGQgYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGUgYXMgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIGYgYXMgX2dldFByb3RvdHlwZU9mIH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0ICcuL21hc2stZWxlbWVudC5qcyc7XG5pbXBvcnQgSFRNTE1hc2tFbGVtZW50IGZyb20gJy4vaHRtbC1tYXNrLWVsZW1lbnQuanMnO1xuXG52YXIgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSFRNTE1hc2tFbGVtZW50KSB7XG4gIF9pbmhlcml0cyhIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQsIF9IVE1MTWFza0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQsIFt7XG4gICAga2V5OiBcIl91bnNhZmVTZWxlY3RcIixcblxuICAgIC8qKlxyXG4gICAgICBTZXRzIEhUTUxFbGVtZW50IHNlbGVjdGlvblxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnNhZmVTZWxlY3Qoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCF0aGlzLnJvb3RFbGVtZW50LmNyZWF0ZVJhbmdlKSByZXR1cm47XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJvb3RFbGVtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZXRTdGFydCh0aGlzLmlucHV0LmZpcnN0Q2hpbGQgfHwgdGhpcy5pbnB1dCwgc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHRoaXMuaW5wdXQubGFzdENoaWxkIHx8IHRoaXMuaW5wdXQsIGVuZCk7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBIVE1MRWxlbWVudCB2YWx1ZVxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uU3RhcnRcIixcblxuICAgIC8qKlxyXG4gICAgICBSZXR1cm5zIEhUTUxFbGVtZW50IHNlbGVjdGlvbiBzdGFydFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIFJldHVybnMgSFRNTEVsZW1lbnQgc2VsZWN0aW9uIGVuZFxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdW5zYWZlU2VsZWN0aW9uRW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdEVsZW1lbnQ7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gcm9vdC5nZXRTZWxlY3Rpb24gJiYgcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgdGhpcy5fdW5zYWZlU2VsZWN0aW9uU3RhcnQgKyBTdHJpbmcoc2VsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gdGhpcy5pbnB1dC50ZXh0Q29udGVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmlucHV0LnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudDtcbn0oSFRNTE1hc2tFbGVtZW50KTtcbklNYXNrLkhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudCA9IEhUTUxDb250ZW50ZWRpdGFibGVNYXNrRWxlbWVudDtcblxuZXhwb3J0IGRlZmF1bHQgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50O1xuIiwiaW1wb3J0IHsgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0IHsgb2JqZWN0SW5jbHVkZXMsIERJUkVDVElPTiB9IGZyb20gJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IEFjdGlvbkRldGFpbHMgZnJvbSAnLi4vY29yZS9hY3Rpb24tZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9iYXNlLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrLCB7IG1hc2tlZENsYXNzIH0gZnJvbSAnLi4vbWFza2VkL2ZhY3RvcnkuanMnO1xuaW1wb3J0ICcuLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi4vbWFza2VkL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9wYXR0ZXJuL2NodW5rLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9yZWdleHAuanMnO1xuaW1wb3J0ICcuLi9tYXNrZWQvcGF0dGVybi5qcyc7XG5pbXBvcnQgJy4uL21hc2tlZC9yYW5nZS5qcyc7XG5pbXBvcnQgTWFza2VkRGF0ZSBmcm9tICcuLi9tYXNrZWQvZGF0ZS5qcyc7XG5pbXBvcnQgTWFza0VsZW1lbnQgZnJvbSAnLi9tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0IEhUTUxNYXNrRWxlbWVudCBmcm9tICcuL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmltcG9ydCBIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQgZnJvbSAnLi9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuXG4vKiogTGlzdGVucyB0byBlbGVtZW50IGV2ZW50cyBhbmQgY29udHJvbHMgY2hhbmdlcyBiZXR3ZWVuIGVsZW1lbnQgYW5kIHtAbGluayBNYXNrZWR9ICovXG5cbnZhciBJbnB1dE1hc2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgIFZpZXcgZWxlbWVudFxyXG4gICAgQHJlYWRvbmx5XHJcbiAgKi9cblxuICAvKipcclxuICAgIEludGVybmFsIHtAbGluayBNYXNrZWR9IG1vZGVsXHJcbiAgICBAcmVhZG9ubHlcclxuICAqL1xuXG4gIC8qKlxyXG4gICAgQHBhcmFtIHtNYXNrRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsXHJcbiAgICBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICovXG4gIGZ1bmN0aW9uIElucHV0TWFzayhlbCwgb3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dE1hc2spO1xuXG4gICAgdGhpcy5lbCA9IGVsIGluc3RhbmNlb2YgTWFza0VsZW1lbnQgPyBlbCA6IGVsLmlzQ29udGVudEVkaXRhYmxlICYmIGVsLnRhZ05hbWUgIT09ICdJTlBVVCcgJiYgZWwudGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyA/IG5ldyBIVE1MQ29udGVudGVkaXRhYmxlTWFza0VsZW1lbnQoZWwpIDogbmV3IEhUTUxNYXNrRWxlbWVudChlbCk7XG4gICAgdGhpcy5tYXNrZWQgPSBjcmVhdGVNYXNrKG9wdHMpO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgdGhpcy5fdW5tYXNrZWRWYWx1ZSA9ICcnO1xuICAgIHRoaXMuX3NhdmVTZWxlY3Rpb24gPSB0aGlzLl9zYXZlU2VsZWN0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ecm9wID0gdGhpcy5fb25Ecm9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb2N1cyA9IHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWxpZ25DdXJzb3IgPSB0aGlzLmFsaWduQ3Vyc29yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5ID0gdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7IC8vIHJlZnJlc2hcblxuXG4gICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuICAvKiogUmVhZCBvciB1cGRhdGUgbWFzayAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKElucHV0TWFzaywgW3tcbiAgICBrZXk6IFwibWFza0VxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrRXF1YWxzKG1hc2spIHtcbiAgICAgIHJldHVybiBtYXNrID09IG51bGwgfHwgbWFzayA9PT0gdGhpcy5tYXNrZWQubWFzayB8fCBtYXNrID09PSBEYXRlICYmIHRoaXMubWFza2VkIGluc3RhbmNlb2YgTWFza2VkRGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRFdmVudHNcIixcblxuICAgIC8qKlxyXG4gICAgICBTdGFydHMgbGlzdGVuaW5nIHRvIGVsZW1lbnQgZXZlbnRzXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgICAgdGhpcy5lbC5iaW5kRXZlbnRzKHtcbiAgICAgICAgc2VsZWN0aW9uQ2hhbmdlOiB0aGlzLl9zYXZlU2VsZWN0aW9uLFxuICAgICAgICBpbnB1dDogdGhpcy5fb25JbnB1dCxcbiAgICAgICAgZHJvcDogdGhpcy5fb25Ecm9wLFxuICAgICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgICAgZm9jdXM6IHRoaXMuX29uRm9jdXMsXG4gICAgICAgIGNvbW1pdDogdGhpcy5fb25DaGFuZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgU3RvcHMgbGlzdGVuaW5nIHRvIGVsZW1lbnQgZXZlbnRzXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuYmluZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5iaW5kRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMuZWwpIHRoaXMuZWwudW5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBGaXJlcyBjdXN0b20gZXZlbnRcclxuICAgICAgQHByb3RlY3RlZFxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmlyZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maXJlRXZlbnQoZXYpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZdO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBsLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEN1cnJlbnQgc2VsZWN0aW9uIHN0YXJ0XHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zYXZlU2VsZWN0aW9uXCIsXG5cbiAgICAvKipcclxuICAgICAgU3RvcmVzIGN1cnJlbnQgc2VsZWN0aW9uXHJcbiAgICAgIEBwcm90ZWN0ZWRcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlU2VsZWN0aW9uKClcbiAgICAvKiBldiAqL1xuICAgIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRWxlbWVudCB2YWx1ZSB3YXMgY2hhbmdlZCBvdXRzaWRlIG9mIG1hc2suIFN5bmNyb25pemUgbWFzayB1c2luZyBgbWFzay51cGRhdGVWYWx1ZSgpYCB0byB3b3JrIHByb3Blcmx5LicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiB0aGlzLmN1cnNvclBvc1xuICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFN5bmNyb25pemVzIG1vZGVsIHZhbHVlIGZyb20gdmlldyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVmFsdWUoKSB7XG4gICAgICB0aGlzLm1hc2tlZC52YWx1ZSA9IHRoaXMuZWwudmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMubWFza2VkLnZhbHVlO1xuICAgIH1cbiAgICAvKiogU3luY3Jvbml6ZXMgdmlldyBmcm9tIG1vZGVsIHZhbHVlLCBmaXJlcyBjaGFuZ2UgZXZlbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDb250cm9sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2woKSB7XG4gICAgICB2YXIgbmV3VW5tYXNrZWRWYWx1ZSA9IHRoaXMubWFza2VkLnVubWFza2VkVmFsdWU7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hc2tlZC52YWx1ZTtcbiAgICAgIHZhciBpc0NoYW5nZWQgPSB0aGlzLnVubWFza2VkVmFsdWUgIT09IG5ld1VubWFza2VkVmFsdWUgfHwgdGhpcy52YWx1ZSAhPT0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl91bm1hc2tlZFZhbHVlID0gbmV3VW5tYXNrZWRWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBpZiAodGhpcy5lbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHRoaXMuZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGlmIChpc0NoYW5nZWQpIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudHMoKTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZXMgb3B0aW9ucyB3aXRoIGRlZXAgZXF1YWwgY2hlY2ssIHJlY3JlYXRlcyBAe2xpbmsgTWFza2VkfSBtb2RlbCBpZiBtYXNrIHR5cGUgY2hhbmdlcyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdHMpIHtcbiAgICAgIHZhciBtYXNrID0gb3B0cy5tYXNrLFxuICAgICAgICAgIHJlc3RPcHRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdHMsIFtcIm1hc2tcIl0pO1xuXG4gICAgICB2YXIgdXBkYXRlTWFzayA9ICF0aGlzLm1hc2tFcXVhbHMobWFzayk7XG4gICAgICB2YXIgdXBkYXRlT3B0cyA9ICFvYmplY3RJbmNsdWRlcyh0aGlzLm1hc2tlZCwgcmVzdE9wdHMpO1xuICAgICAgaWYgKHVwZGF0ZU1hc2spIHRoaXMubWFzayA9IG1hc2s7XG4gICAgICBpZiAodXBkYXRlT3B0cykgdGhpcy5tYXNrZWQudXBkYXRlT3B0aW9ucyhyZXN0T3B0cyk7XG4gICAgICBpZiAodXBkYXRlTWFzayB8fCB1cGRhdGVPcHRzKSB0aGlzLnVwZGF0ZUNvbnRyb2woKTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZXMgY3Vyc29yICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvclBvcykge1xuICAgICAgaWYgKGN1cnNvclBvcyA9PSBudWxsKSByZXR1cm47XG4gICAgICB0aGlzLmN1cnNvclBvcyA9IGN1cnNvclBvczsgLy8gYWxzbyBxdWV1ZSBjaGFuZ2UgY3Vyc29yIGZvciBtb2JpbGUgYnJvd3NlcnNcblxuICAgICAgdGhpcy5fZGVsYXlVcGRhdGVDdXJzb3IoY3Vyc29yUG9zKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIERlbGF5cyBjdXJzb3IgdXBkYXRlIHRvIHN1cHBvcnQgbW9iaWxlIGJyb3dzZXJzXHJcbiAgICAgIEBwcml2YXRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlbGF5VXBkYXRlQ3Vyc29yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxheVVwZGF0ZUN1cnNvcihjdXJzb3JQb3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7XG5cbiAgICAgIHRoaXMuX2NoYW5naW5nQ3Vyc29yUG9zID0gY3Vyc29yUG9zO1xuICAgICAgdGhpcy5fY3Vyc29yQ2hhbmdpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5lbCkgcmV0dXJuOyAvLyBpZiB3YXMgZGVzdHJveWVkXG5cbiAgICAgICAgX3RoaXMuY3Vyc29yUG9zID0gX3RoaXMuX2NoYW5naW5nQ3Vyc29yUG9zO1xuXG4gICAgICAgIF90aGlzLl9hYm9ydFVwZGF0ZUN1cnNvcigpO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgRmlyZXMgY3VzdG9tIGV2ZW50c1xyXG4gICAgICBAcHJvdGVjdGVkXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpcmVDaGFuZ2VFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpcmVDaGFuZ2VFdmVudHMoKSB7XG4gICAgICB0aGlzLl9maXJlRXZlbnQoJ2FjY2VwdCcsIHRoaXMuX2lucHV0RXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5tYXNrZWQuaXNDb21wbGV0ZSkgdGhpcy5fZmlyZUV2ZW50KCdjb21wbGV0ZScsIHRoaXMuX2lucHV0RXZlbnQpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQWJvcnRzIGRlbGF5ZWQgY3Vyc29yIHVwZGF0ZVxyXG4gICAgICBAcHJpdmF0ZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hYm9ydFVwZGF0ZUN1cnNvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWJvcnRVcGRhdGVDdXJzb3IoKSB7XG4gICAgICBpZiAodGhpcy5fY3Vyc29yQ2hhbmdpbmcpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvckNoYW5naW5nKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnNvckNoYW5naW5nO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQWxpZ25zIGN1cnNvciB0byBuZWFyZXN0IGF2YWlsYWJsZSBwb3NpdGlvbiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWxpZ25DdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25DdXJzb3IoKSB7XG4gICAgICB0aGlzLmN1cnNvclBvcyA9IHRoaXMubWFza2VkLm5lYXJlc3RJbnB1dFBvcyh0aGlzLmN1cnNvclBvcywgRElSRUNUSU9OLkxFRlQpO1xuICAgIH1cbiAgICAvKiogQWxpZ25zIGN1cnNvciBvbmx5IGlmIHNlbGVjdGlvbiBpcyBlbXB0eSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWxpZ25DdXJzb3JGcmllbmRseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbkN1cnNvckZyaWVuZGx5KCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuY3Vyc29yUG9zKSByZXR1cm47IC8vIHNraXAgaWYgcmFuZ2UgaXMgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5hbGlnbkN1cnNvcigpO1xuICAgIH1cbiAgICAvKiogQWRkcyBsaXN0ZW5lciBvbiBjdXN0b20gZXZlbnQgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldl0pIHRoaXMuX2xpc3RlbmVyc1tldl0gPSBbXTtcblxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2XS5wdXNoKGhhbmRsZXIpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgY3VzdG9tIGV2ZW50IGxpc3RlbmVyICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyc1tldl0pIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldl07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaEluZGV4ID0gdGhpcy5fbGlzdGVuZXJzW2V2XS5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgICBpZiAoaEluZGV4ID49IDApIHRoaXMuX2xpc3RlbmVyc1tldl0uc3BsaWNlKGhJbmRleCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEhhbmRsZXMgdmlldyBpbnB1dCBldmVudCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uSW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uSW5wdXQoZSkge1xuICAgICAgdGhpcy5faW5wdXRFdmVudCA9IGU7XG5cbiAgICAgIHRoaXMuX2Fib3J0VXBkYXRlQ3Vyc29yKCk7IC8vIGZpeCBzdHJhbmdlIElFIGJlaGF2aW9yXG5cblxuICAgICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24pIHJldHVybiB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICB2YXIgZGV0YWlscyA9IG5ldyBBY3Rpb25EZXRhaWxzKCAvLyBuZXcgc3RhdGVcbiAgICAgIHRoaXMuZWwudmFsdWUsIHRoaXMuY3Vyc29yUG9zLCAvLyBvbGQgc3RhdGVcbiAgICAgIHRoaXMudmFsdWUsIHRoaXMuX3NlbGVjdGlvbik7XG4gICAgICB2YXIgb2xkUmF3VmFsdWUgPSB0aGlzLm1hc2tlZC5yYXdJbnB1dFZhbHVlO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMubWFza2VkLnNwbGljZShkZXRhaWxzLnN0YXJ0Q2hhbmdlUG9zLCBkZXRhaWxzLnJlbW92ZWQubGVuZ3RoLCBkZXRhaWxzLmluc2VydGVkLCBkZXRhaWxzLnJlbW92ZURpcmVjdGlvbikub2Zmc2V0OyAvLyBmb3JjZSBhbGlnbiBpbiByZW1vdmUgZGlyZWN0aW9uIG9ubHkgaWYgbm8gaW5wdXQgY2hhcnMgd2VyZSByZW1vdmVkXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugc3RpbGwgbmVlZCB0byBhbGlnbiB3aXRoIE5PTkUgKHRvIGdldCBvdXQgZnJvbSBmaXhlZCBzeW1ib2xzIGZvciBpbnN0YW5jZSlcblxuICAgICAgdmFyIHJlbW92ZURpcmVjdGlvbiA9IG9sZFJhd1ZhbHVlID09PSB0aGlzLm1hc2tlZC5yYXdJbnB1dFZhbHVlID8gZGV0YWlscy5yZW1vdmVEaXJlY3Rpb24gOiBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHZhciBjdXJzb3JQb3MgPSB0aGlzLm1hc2tlZC5uZWFyZXN0SW5wdXRQb3MoZGV0YWlscy5zdGFydENoYW5nZVBvcyArIG9mZnNldCwgcmVtb3ZlRGlyZWN0aW9uKTtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgdGhpcy51cGRhdGVDdXJzb3IoY3Vyc29yUG9zKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pbnB1dEV2ZW50O1xuICAgIH1cbiAgICAvKiogSGFuZGxlcyB2aWV3IGNoYW5nZSBldmVudCBhbmQgY29tbWl0cyBtb2RlbCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLmVsLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXNrZWQuZG9Db21taXQoKTtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuXG4gICAgICB0aGlzLl9zYXZlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKiBIYW5kbGVzIHZpZXcgZHJvcCBldmVudCwgcHJldmVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29uRHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Ecm9wKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIC8qKiBSZXN0b3JlIGxhc3Qgc2VsZWN0aW9uIG9uIGZvY3VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25Gb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Gb2N1cyhldikge1xuICAgICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5KCk7XG4gICAgfVxuICAgIC8qKiBSZXN0b3JlIGxhc3Qgc2VsZWN0aW9uIG9uIGZvY3VzICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25DbGljayhldikge1xuICAgICAgdGhpcy5hbGlnbkN1cnNvckZyaWVuZGx5KCk7XG4gICAgfVxuICAgIC8qKiBVbmJpbmQgdmlldyBldmVudHMgYW5kIHJlbW92ZXMgZWxlbWVudCByZWZlcmVuY2UgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3VuYmluZEV2ZW50cygpOyAvLyAkRmxvd0ZpeE1lIHdoeSBub3QgZG8gc28/XG5cblxuICAgICAgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCA9IDA7IC8vICRGbG93Rml4TWVcblxuICAgICAgZGVsZXRlIHRoaXMuZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hc2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hc2tlZC5tYXNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobWFzaykge1xuICAgICAgaWYgKHRoaXMubWFza0VxdWFscyhtYXNrKSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIShtYXNrIGluc3RhbmNlb2YgSU1hc2suTWFza2VkKSAmJiB0aGlzLm1hc2tlZC5jb25zdHJ1Y3RvciA9PT0gbWFza2VkQ2xhc3MobWFzaykpIHtcbiAgICAgICAgdGhpcy5tYXNrZWQudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgbWFzazogbWFza1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFza2VkID0gY3JlYXRlTWFzayh7XG4gICAgICAgIG1hc2s6IG1hc2tcbiAgICAgIH0pO1xuICAgICAgbWFza2VkLnVubWFza2VkVmFsdWUgPSB0aGlzLm1hc2tlZC51bm1hc2tlZFZhbHVlO1xuICAgICAgdGhpcy5tYXNrZWQgPSBtYXNrZWQ7XG4gICAgfVxuICAgIC8qKiBSYXcgdmFsdWUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHIpIHtcbiAgICAgIHRoaXMubWFza2VkLnZhbHVlID0gc3RyO1xuICAgICAgdGhpcy51cGRhdGVDb250cm9sKCk7XG4gICAgICB0aGlzLmFsaWduQ3Vyc29yKCk7XG4gICAgfVxuICAgIC8qKiBVbm1hc2tlZCB2YWx1ZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VubWFza2VkVmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHIpIHtcbiAgICAgIHRoaXMubWFza2VkLnVubWFza2VkVmFsdWUgPSBzdHI7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRyb2woKTtcbiAgICAgIHRoaXMuYWxpZ25DdXJzb3IoKTtcbiAgICB9XG4gICAgLyoqIFR5cGVkIHVubWFza2VkIHZhbHVlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlZFZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXNrZWQudHlwZWRWYWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgdGhpcy5tYXNrZWQudHlwZWRWYWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbCgpO1xuICAgICAgdGhpcy5hbGlnbkN1cnNvcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3Rpb25TdGFydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvckNoYW5naW5nID8gdGhpcy5fY2hhbmdpbmdDdXJzb3JQb3MgOiB0aGlzLmVsLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICAvKiogQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1cnNvclBvc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvckNoYW5naW5nID8gdGhpcy5fY2hhbmdpbmdDdXJzb3JQb3MgOiB0aGlzLmVsLnNlbGVjdGlvbkVuZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBvcykge1xuICAgICAgaWYgKCF0aGlzLmVsIHx8ICF0aGlzLmVsLmlzQWN0aXZlKSByZXR1cm47XG4gICAgICB0aGlzLmVsLnNlbGVjdChwb3MsIHBvcyk7XG5cbiAgICAgIHRoaXMuX3NhdmVTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5wdXRNYXNrO1xufSgpO1xuSU1hc2suSW5wdXRNYXNrID0gSW5wdXRNYXNrO1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE1hc2s7XG4iLCJpbXBvcnQgJy4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9hY3Rpb24tZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgJy4vbWFza2VkL2Jhc2UuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9yZWdleHAuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9wYXR0ZXJuLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcmFuZ2UuanMnO1xuaW1wb3J0ICcuL21hc2tlZC9kYXRlLmpzJztcbmltcG9ydCAnLi9jb250cm9scy9tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0ICcuL2NvbnRyb2xzL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmltcG9ydCAnLi9jb250cm9scy9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuaW1wb3J0ICcuL2NvbnRyb2xzL2lucHV0LmpzJztcblxuXG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jaGFuZ2UtZGV0YWlscy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCAnLi9iYXNlLmpzJztcbmltcG9ydCAnLi9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9wYXR0ZXJuL2lucHV0LWRlZmluaXRpb24uanMnO1xuaW1wb3J0ICcuL3BhdHRlcm4vZml4ZWQtZGVmaW5pdGlvbi5qcyc7XG5pbXBvcnQgJy4vcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL3JlZ2V4cC5qcyc7XG5pbXBvcnQgTWFza2VkUGF0dGVybiBmcm9tICcuL3BhdHRlcm4uanMnO1xuXG4vKiogUGF0dGVybiB3aGljaCB2YWxpZGF0ZXMgZW51bSB2YWx1ZXMgKi9cblxudmFyIE1hc2tlZEVudW0gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWRQYXR0ZXJuKSB7XG4gIF9pbmhlcml0cyhNYXNrZWRFbnVtLCBfTWFza2VkUGF0dGVybik7XG5cbiAgZnVuY3Rpb24gTWFza2VkRW51bSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFza2VkRW51bSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZEVudW0pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZEVudW0sIFt7XG4gICAga2V5OiBcIl91cGRhdGVcIixcblxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgLy8gVE9ETyB0eXBlXG4gICAgICBpZiAob3B0cy5lbnVtKSBvcHRzLm1hc2sgPSAnKicucmVwZWF0KG9wdHMuZW51bVswXS5sZW5ndGgpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRFbnVtLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBfZ2V0MjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVudW0uc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5pbmRleE9mKF90aGlzLnVubWFza2VkVmFsdWUpID49IDA7XG4gICAgICB9KSAmJiAoX2dldDIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWRFbnVtLnByb3RvdHlwZSksIFwiZG9WYWxpZGF0ZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hc2tlZEVudW07XG59KE1hc2tlZFBhdHRlcm4pO1xuSU1hc2suTWFza2VkRW51bSA9IE1hc2tlZEVudW07XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZEVudW07XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0LCBpIGFzIF9zbGljZWRUb0FycmF5LCBoIGFzIF9zZXQgfSBmcm9tICcuLi9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLTNjNThmMGUzLmpzJztcbmltcG9ydCB7IGVzY2FwZVJlZ0V4cCwgRElSRUNUSU9OIH0gZnJvbSAnLi4vY29yZS91dGlscy5qcyc7XG5pbXBvcnQgQ2hhbmdlRGV0YWlscyBmcm9tICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcclxuICBOdW1iZXIgbWFza1xyXG4gIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgQHBhcmFtIHtzdHJpbmd9IG9wdHMucmFkaXggLSBTaW5nbGUgY2hhclxyXG4gIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRob3VzYW5kc1NlcGFyYXRvciAtIFNpbmdsZSBjaGFyXHJcbiAgQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBvcHRzLm1hcFRvUmFkaXggLSBBcnJheSBvZiBzaW5nbGUgY2hhcnNcclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5taW5cclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5tYXhcclxuICBAcGFyYW0ge251bWJlcn0gb3B0cy5zY2FsZSAtIERpZ2l0cyBhZnRlciBwb2ludFxyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5zaWduZWQgLSBBbGxvdyBuZWdhdGl2ZVxyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5ub3JtYWxpemVaZXJvcyAtIEZsYWcgdG8gcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHplcm9zIGluIHRoZSBlbmQgb2YgZWRpdGluZ1xyXG4gIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5wYWRGcmFjdGlvbmFsWmVyb3MgLSBGbGFnIHRvIHBhZCB0cmFpbGluZyB6ZXJvcyBhZnRlciBwb2ludCBpbiB0aGUgZW5kIG9mIGVkaXRpbmdcclxuKi9cbnZhciBNYXNrZWROdW1iZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9NYXNrZWQpIHtcbiAgX2luaGVyaXRzKE1hc2tlZE51bWJlciwgX01hc2tlZCk7XG5cbiAgLyoqIFNpbmdsZSBjaGFyICovXG5cbiAgLyoqIFNpbmdsZSBjaGFyICovXG5cbiAgLyoqIEFycmF5IG9mIHNpbmdsZSBjaGFycyAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiAqL1xuXG4gIC8qKiBEaWdpdHMgYWZ0ZXIgcG9pbnQgKi9cblxuICAvKiogKi9cblxuICAvKiogRmxhZyB0byByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGVuZCBvZiBlZGl0aW5nICovXG5cbiAgLyoqIEZsYWcgdG8gcGFkIHRyYWlsaW5nIHplcm9zIGFmdGVyIHBvaW50IGluIHRoZSBlbmQgb2YgZWRpdGluZyAqL1xuICBmdW5jdGlvbiBNYXNrZWROdW1iZXIob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWROdW1iZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkTnVtYmVyLkRFRkFVTFRTLCB7fSwgb3B0cykpKTtcbiAgfVxuICAvKipcclxuICAgIEBvdmVycmlkZVxyXG4gICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkTnVtYmVyLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUob3B0cykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICB0aGlzLl91cGRhdGVSZWdFeHBzKCk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVJlZ0V4cHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJlZ0V4cHMoKSB7XG4gICAgICAvLyB1c2UgZGlmZmVyZW50IHJlZ2V4cCB0byBwcm9jZXNzIHVzZXIgaW5wdXQgKG1vcmUgc3RyaWN0LCBpbnB1dCBzdWZmaXgpIGFuZCB0YWlsIHNoaWZ0aW5nXG4gICAgICB2YXIgc3RhcnQgPSAnXicgKyAodGhpcy5hbGxvd05lZ2F0aXZlID8gJ1srfFxcXFwtXT8nIDogJycpO1xuICAgICAgdmFyIG1pZElucHV0ID0gJygwfChbMS05XStcXFxcZCopKT8nO1xuICAgICAgdmFyIG1pZCA9ICdcXFxcZConO1xuICAgICAgdmFyIGVuZCA9ICh0aGlzLnNjYWxlID8gJygnICsgZXNjYXBlUmVnRXhwKHRoaXMucmFkaXgpICsgJ1xcXFxkezAsJyArIHRoaXMuc2NhbGUgKyAnfSk/JyA6ICcnKSArICckJztcbiAgICAgIHRoaXMuX251bWJlclJlZ0V4cElucHV0ID0gbmV3IFJlZ0V4cChzdGFydCArIG1pZElucHV0ICsgZW5kKTtcbiAgICAgIHRoaXMuX251bWJlclJlZ0V4cCA9IG5ldyBSZWdFeHAoc3RhcnQgKyBtaWQgKyBlbmQpO1xuICAgICAgdGhpcy5fbWFwVG9SYWRpeFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1snICsgdGhpcy5tYXBUb1JhZGl4Lm1hcChlc2NhcGVSZWdFeHApLmpvaW4oJycpICsgJ10nLCAnZycpO1xuICAgICAgdGhpcy5fdGhvdXNhbmRzU2VwYXJhdG9yUmVnRXhwID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGhpcy50aG91c2FuZHNTZXBhcmF0b3IpLCAnZycpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSh0aGlzLl90aG91c2FuZHNTZXBhcmF0b3JSZWdFeHAsICcnKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkge1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkwMTEwMi9ob3ctdG8tcHJpbnQtYS1udW1iZXItd2l0aC1jb21tYXMtYXMtdGhvdXNhbmRzLXNlcGFyYXRvcnMtaW4tamF2YXNjcmlwdFxuICAgICAgdmFyIHBhcnRzID0gdmFsdWUuc3BsaXQodGhpcy5yYWRpeCk7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yKTtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMucmFkaXgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9QcmVwYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvUHJlcGFyZShzdHIpIHtcbiAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcImRvUHJlcGFyZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXMsIHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnMoc3RyLnJlcGxhY2UodGhpcy5fbWFwVG9SYWRpeFJlZ0V4cCwgdGhpcy5yYWRpeCkpXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICAvKiogKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXBhcmF0b3JzQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NlcGFyYXRvcnNDb3VudCh0bykge1xuICAgICAgdmFyIGV4dGVuZE9uU2VwYXJhdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCB0bzsgKytwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlLmluZGV4T2YodGhpcy50aG91c2FuZHNTZXBhcmF0b3IsIHBvcykgPT09IHBvcykge1xuICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgaWYgKGV4dGVuZE9uU2VwYXJhdG9ycykgdG8gKz0gdGhpcy50aG91c2FuZHNTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXBhcmF0b3JzQ291bnRGcm9tU2xpY2UoKSB7XG4gICAgICB2YXIgc2xpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuX3ZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcGFyYXRvcnNDb3VudCh0aGlzLl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHNsaWNlKS5sZW5ndGgsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RJbnB1dCgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgX3RoaXMkX2FkanVzdFJhbmdlV2l0ID0gdGhpcy5fYWRqdXN0UmFuZ2VXaXRoU2VwYXJhdG9ycyhmcm9tUG9zLCB0b1Bvcyk7XG5cbiAgICAgIHZhciBfdGhpcyRfYWRqdXN0UmFuZ2VXaXQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2FkanVzdFJhbmdlV2l0LCAyKTtcblxuICAgICAgZnJvbVBvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDJbMF07XG4gICAgICB0b1BvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDJbMV07XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyhfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgXCJleHRyYWN0SW5wdXRcIiwgdGhpcykuY2FsbCh0aGlzLCBmcm9tUG9zLCB0b1BvcywgZmxhZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBlbmRDaGFyUmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRDaGFyUmF3KGNoKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgaWYgKCF0aGlzLnRob3VzYW5kc1NlcGFyYXRvcikgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcIl9hcHBlbmRDaGFyUmF3XCIsIHRoaXMpLmNhbGwodGhpcywgY2gsIGZsYWdzKTtcbiAgICAgIHZhciBwcmV2QmVmb3JlVGFpbFZhbHVlID0gZmxhZ3MudGFpbCAmJiBmbGFncy5fYmVmb3JlVGFpbFN0YXRlID8gZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZS5fdmFsdWUgOiB0aGlzLl92YWx1ZTtcblxuICAgICAgdmFyIHByZXZCZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlKHByZXZCZWZvcmVUYWlsVmFsdWUpO1xuXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnModGhpcy52YWx1ZSk7XG5cbiAgICAgIHZhciBhcHBlbmREZXRhaWxzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwiX2FwcGVuZENoYXJSYXdcIiwgdGhpcykuY2FsbCh0aGlzLCBjaCwgZmxhZ3MpO1xuXG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2luc2VydFRob3VzYW5kc1NlcGFyYXRvcnModGhpcy5fdmFsdWUpO1xuICAgICAgdmFyIGJlZm9yZVRhaWxWYWx1ZSA9IGZsYWdzLnRhaWwgJiYgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSA/IGZsYWdzLl9iZWZvcmVUYWlsU3RhdGUuX3ZhbHVlIDogdGhpcy5fdmFsdWU7XG5cbiAgICAgIHZhciBiZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50RnJvbVNsaWNlKGJlZm9yZVRhaWxWYWx1ZSk7XG5cbiAgICAgIGFwcGVuZERldGFpbHMudGFpbFNoaWZ0ICs9IChiZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50IC0gcHJldkJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQpICogdGhpcy50aG91c2FuZHNTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgYXBwZW5kRGV0YWlscy5za2lwID0gIWFwcGVuZERldGFpbHMucmF3SW5zZXJ0ZWQgJiYgY2ggPT09IHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yO1xuICAgICAgcmV0dXJuIGFwcGVuZERldGFpbHM7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRTZXBhcmF0b3JBcm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRTZXBhcmF0b3JBcm91bmQocG9zKSB7XG4gICAgICBpZiAodGhpcy50aG91c2FuZHNTZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIHNlYXJjaEZyb20gPSBwb3MgLSB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgc2VwYXJhdG9yUG9zID0gdGhpcy52YWx1ZS5pbmRleE9mKHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLCBzZWFyY2hGcm9tKTtcbiAgICAgICAgaWYgKHNlcGFyYXRvclBvcyA8PSBwb3MpIHJldHVybiBzZXBhcmF0b3JQb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkanVzdFJhbmdlV2l0aFNlcGFyYXRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkanVzdFJhbmdlV2l0aFNlcGFyYXRvcnMoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBzZXBhcmF0b3JBcm91bmRGcm9tUG9zID0gdGhpcy5fZmluZFNlcGFyYXRvckFyb3VuZChmcm9tKTtcblxuICAgICAgaWYgKHNlcGFyYXRvckFyb3VuZEZyb21Qb3MgPj0gMCkgZnJvbSA9IHNlcGFyYXRvckFyb3VuZEZyb21Qb3M7XG5cbiAgICAgIHZhciBzZXBhcmF0b3JBcm91bmRUb1BvcyA9IHRoaXMuX2ZpbmRTZXBhcmF0b3JBcm91bmQodG8pO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yQXJvdW5kVG9Qb3MgPj0gMCkgdG8gPSBzZXBhcmF0b3JBcm91bmRUb1BvcyArIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgIHJldHVybiBbZnJvbSwgdG9dO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBmcm9tUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZhbHVlLmxlbmd0aDtcblxuICAgICAgdmFyIF90aGlzJF9hZGp1c3RSYW5nZVdpdDMgPSB0aGlzLl9hZGp1c3RSYW5nZVdpdGhTZXBhcmF0b3JzKGZyb21Qb3MsIHRvUG9zKTtcblxuICAgICAgdmFyIF90aGlzJF9hZGp1c3RSYW5nZVdpdDQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfYWRqdXN0UmFuZ2VXaXQzLCAyKTtcblxuICAgICAgZnJvbVBvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDRbMF07XG4gICAgICB0b1BvcyA9IF90aGlzJF9hZGp1c3RSYW5nZVdpdDRbMV07XG4gICAgICB2YXIgdmFsdWVCZWZvcmVQb3MgPSB0aGlzLnZhbHVlLnNsaWNlKDAsIGZyb21Qb3MpO1xuICAgICAgdmFyIHZhbHVlQWZ0ZXJQb3MgPSB0aGlzLnZhbHVlLnNsaWNlKHRvUG9zKTtcblxuICAgICAgdmFyIHByZXZCZWZvcmVUYWlsU2VwYXJhdG9yc0NvdW50ID0gdGhpcy5fc2VwYXJhdG9yc0NvdW50KHZhbHVlQmVmb3JlUG9zLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5faW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLl9yZW1vdmVUaG91c2FuZHNTZXBhcmF0b3JzKHZhbHVlQmVmb3JlUG9zICsgdmFsdWVBZnRlclBvcykpO1xuXG4gICAgICB2YXIgYmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCA9IHRoaXMuX3NlcGFyYXRvcnNDb3VudEZyb21TbGljZSh2YWx1ZUJlZm9yZVBvcyk7XG5cbiAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGV0YWlscyh7XG4gICAgICAgIHRhaWxTaGlmdDogKGJlZm9yZVRhaWxTZXBhcmF0b3JzQ291bnQgLSBwcmV2QmVmb3JlVGFpbFNlcGFyYXRvcnNDb3VudCkgKiB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmVhcmVzdElucHV0UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lYXJlc3RJbnB1dFBvcyhjdXJzb3JQb3MsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKCF0aGlzLnRob3VzYW5kc1NlcGFyYXRvcikgcmV0dXJuIGN1cnNvclBvcztcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTk9ORTpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uTEVGVDpcbiAgICAgICAgY2FzZSBESVJFQ1RJT04uRk9SQ0VfTEVGVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQXRMZWZ0UG9zID0gdGhpcy5fZmluZFNlcGFyYXRvckFyb3VuZChjdXJzb3JQb3MgLSAxKTtcblxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvckF0TGVmdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JBdExlZnRFbmRQb3MgPSBzZXBhcmF0b3JBdExlZnRQb3MgKyB0aGlzLnRob3VzYW5kc1NlcGFyYXRvci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnNvclBvcyA8IHNlcGFyYXRvckF0TGVmdEVuZFBvcyB8fCB0aGlzLnZhbHVlLmxlbmd0aCA8PSBzZXBhcmF0b3JBdExlZnRFbmRQb3MgfHwgZGlyZWN0aW9uID09PSBESVJFQ1RJT04uRk9SQ0VfTEVGVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXBhcmF0b3JBdExlZnRQb3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgRElSRUNUSU9OLlJJR0hUOlxuICAgICAgICBjYXNlIERJUkVDVElPTi5GT1JDRV9SSUdIVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQXRSaWdodFBvcyA9IHRoaXMuX2ZpbmRTZXBhcmF0b3JBcm91bmQoY3Vyc29yUG9zKTtcblxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvckF0UmlnaHRQb3MgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdG9yQXRSaWdodFBvcyArIHRoaXMudGhvdXNhbmRzU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJzb3JQb3M7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb1ZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvVmFsaWRhdGUoZmxhZ3MpIHtcbiAgICAgIHZhciByZWdleHAgPSBmbGFncy5pbnB1dCA/IHRoaXMuX251bWJlclJlZ0V4cElucHV0IDogdGhpcy5fbnVtYmVyUmVnRXhwOyAvLyB2YWxpZGF0ZSBhcyBzdHJpbmdcblxuICAgICAgdmFyIHZhbGlkID0gcmVnZXhwLnRlc3QodGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh0aGlzLnZhbHVlKSk7XG5cbiAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAvLyB2YWxpZGF0ZSBhcyBudW1iZXJcbiAgICAgICAgdmFyIG51bWJlciA9IHRoaXMubnVtYmVyO1xuICAgICAgICB2YWxpZCA9IHZhbGlkICYmICFpc05hTihudW1iZXIpICYmICggLy8gY2hlY2sgbWluIGJvdW5kIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgdGhpcy5taW4gPT0gbnVsbCB8fCB0aGlzLm1pbiA+PSAwIHx8IHRoaXMubWluIDw9IHRoaXMubnVtYmVyKSAmJiAoIC8vIGNoZWNrIG1heCBib3VuZCBmb3IgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgIHRoaXMubWF4ID09IG51bGwgfHwgdGhpcy5tYXggPD0gMCB8fCB0aGlzLm51bWJlciA8PSB0aGlzLm1heCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWxpZCAmJiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWROdW1iZXIucHJvdG90eXBlKSwgXCJkb1ZhbGlkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9Db21taXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9Db21taXQoKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB2YXIgbnVtYmVyID0gdGhpcy5udW1iZXI7XG4gICAgICAgIHZhciB2YWxpZG51bSA9IG51bWJlcjsgLy8gY2hlY2sgYm91bmRzXG5cbiAgICAgICAgaWYgKHRoaXMubWluICE9IG51bGwpIHZhbGlkbnVtID0gTWF0aC5tYXgodmFsaWRudW0sIHRoaXMubWluKTtcbiAgICAgICAgaWYgKHRoaXMubWF4ICE9IG51bGwpIHZhbGlkbnVtID0gTWF0aC5taW4odmFsaWRudW0sIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKHZhbGlkbnVtICE9PSBudW1iZXIpIHRoaXMudW5tYXNrZWRWYWx1ZSA9IFN0cmluZyh2YWxpZG51bSk7XG4gICAgICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemVaZXJvcykgZm9ybWF0dGVkID0gdGhpcy5fbm9ybWFsaXplWmVyb3MoZm9ybWF0dGVkKTtcbiAgICAgICAgaWYgKHRoaXMucGFkRnJhY3Rpb25hbFplcm9zKSBmb3JtYXR0ZWQgPSB0aGlzLl9wYWRGcmFjdGlvbmFsWmVyb3MoZm9ybWF0dGVkKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtYXR0ZWQ7XG4gICAgICB9XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcImRvQ29tbWl0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKiAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX25vcm1hbGl6ZVplcm9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3JtYWxpemVaZXJvcyh2YWx1ZSkge1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5fcmVtb3ZlVGhvdXNhbmRzU2VwYXJhdG9ycyh2YWx1ZSkuc3BsaXQodGhpcy5yYWRpeCk7IC8vIHJlbW92ZSBsZWFkaW5nIHplcm9zXG5cblxuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKC9eKFxcRCopKDAqKShcXGQqKS8sIGZ1bmN0aW9uIChtYXRjaCwgc2lnbiwgemVyb3MsIG51bSkge1xuICAgICAgICByZXR1cm4gc2lnbiArIG51bTtcbiAgICAgIH0pOyAvLyBhZGQgbGVhZGluZyB6ZXJvXG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggJiYgIS9cXGQkLy50ZXN0KHBhcnRzWzBdKSkgcGFydHNbMF0gPSBwYXJ0c1swXSArICcwJztcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS5yZXBsYWNlKC8wKiQvLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvc1xuXG4gICAgICAgIGlmICghcGFydHNbMV0ubGVuZ3RoKSBwYXJ0cy5sZW5ndGggPSAxOyAvLyByZW1vdmUgZnJhY3Rpb25hbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faW5zZXJ0VGhvdXNhbmRzU2VwYXJhdG9ycyhwYXJ0cy5qb2luKHRoaXMucmFkaXgpKTtcbiAgICB9XG4gICAgLyoqICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFkRnJhY3Rpb25hbFplcm9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWRGcmFjdGlvbmFsWmVyb3ModmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLnNwbGl0KHRoaXMucmFkaXgpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHBhcnRzLnB1c2goJycpO1xuICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS5wYWRFbmQodGhpcy5zY2FsZSwgJzAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMucmFkaXgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVRob3VzYW5kc1NlcGFyYXRvcnModGhpcy5fbm9ybWFsaXplWmVyb3ModGhpcy52YWx1ZSkpLnJlcGxhY2UodGhpcy5yYWRpeCwgJy4nKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHVubWFza2VkVmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZE51bWJlci5wcm90b3R5cGUpLCBcInVubWFza2VkVmFsdWVcIiwgdW5tYXNrZWRWYWx1ZS5yZXBsYWNlKCcuJywgdGhpcy5yYWRpeCksIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnVubWFza2VkVmFsdWUpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobikge1xuICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkTnVtYmVyLnByb3RvdHlwZSksIFwidW5tYXNrZWRWYWx1ZVwiLCBTdHJpbmcobiksIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKiogUGFyc2VkIE51bWJlciAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtYmVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlZFZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobnVtYmVyKSB7XG4gICAgICB0aGlzLnR5cGVkVmFsdWUgPSBudW1iZXI7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBJcyBuZWdhdGl2ZSBhbGxvd2VkXHJcbiAgICAgIEByZWFkb25seVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFsbG93TmVnYXRpdmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25lZCB8fCB0aGlzLm1pbiAhPSBudWxsICYmIHRoaXMubWluIDwgMCB8fCB0aGlzLm1heCAhPSBudWxsICYmIHRoaXMubWF4IDwgMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFza2VkTnVtYmVyO1xufShNYXNrZWQpO1xuTWFza2VkTnVtYmVyLkRFRkFVTFRTID0ge1xuICByYWRpeDogJywnLFxuICB0aG91c2FuZHNTZXBhcmF0b3I6ICcnLFxuICBtYXBUb1JhZGl4OiBbJy4nXSxcbiAgc2NhbGU6IDIsXG4gIHNpZ25lZDogZmFsc2UsXG4gIG5vcm1hbGl6ZVplcm9zOiB0cnVlLFxuICBwYWRGcmFjdGlvbmFsWmVyb3M6IGZhbHNlXG59O1xuSU1hc2suTWFza2VkTnVtYmVyID0gTWFza2VkTnVtYmVyO1xuXG5leHBvcnQgZGVmYXVsdCBNYXNrZWROdW1iZXI7XG4iLCJpbXBvcnQgeyBkIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBlIGFzIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBmIGFzIF9nZXRQcm90b3R5cGVPZiwgZyBhcyBfZ2V0IH0gZnJvbSAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NoYW5nZS1kZXRhaWxzLmpzJztcbmltcG9ydCAnLi4vY29yZS9jb250aW51b3VzLXRhaWwtZGV0YWlscy5qcyc7XG5pbXBvcnQgSU1hc2sgZnJvbSAnLi4vY29yZS9ob2xkZXIuanMnO1xuaW1wb3J0IE1hc2tlZCBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKiogTWFza2luZyBieSBjdXN0b20gRnVuY3Rpb24gKi9cblxudmFyIE1hc2tlZEZ1bmN0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkKSB7XG4gIF9pbmhlcml0cyhNYXNrZWRGdW5jdGlvbiwgX01hc2tlZCk7XG5cbiAgZnVuY3Rpb24gTWFza2VkRnVuY3Rpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hc2tlZEZ1bmN0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFza2VkRnVuY3Rpb24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hc2tlZEZ1bmN0aW9uLCBbe1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLm1hc2spIG9wdHMudmFsaWRhdGUgPSBvcHRzLm1hc2s7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZEZ1bmN0aW9uLnByb3RvdHlwZSksIFwiX3VwZGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWRGdW5jdGlvbjtcbn0oTWFza2VkKTtcbklNYXNrLk1hc2tlZEZ1bmN0aW9uID0gTWFza2VkRnVuY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IE1hc2tlZEZ1bmN0aW9uO1xuIiwiaW1wb3J0IHsgZCBhcyBfaW5oZXJpdHMsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgZSBhcyBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgZiBhcyBfZ2V0UHJvdG90eXBlT2YsIGcgYXMgX2dldCwgaCBhcyBfc2V0LCBjIGFzIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyB9IGZyb20gJy4uL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL3V0aWxzLmpzJztcbmltcG9ydCBDaGFuZ2VEZXRhaWxzIGZyb20gJy4uL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuLi9jb3JlL2NvbnRpbnVvdXMtdGFpbC1kZXRhaWxzLmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuLi9jb3JlL2hvbGRlci5qcyc7XG5pbXBvcnQgTWFza2VkIGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgY3JlYXRlTWFzayBmcm9tICcuL2ZhY3RvcnkuanMnO1xuXG4vKiogRHluYW1pYyBtYXNrIGZvciBjaG9vc2luZyBhcHJvcHJpYXRlIG1hc2sgaW4gcnVuLXRpbWUgKi9cbnZhciBNYXNrZWREeW5hbWljID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfTWFza2VkKSB7XG4gIF9pbmhlcml0cyhNYXNrZWREeW5hbWljLCBfTWFza2VkKTtcblxuICAvKiogQ3VycmVudGx5IGNob3NlbiBtYXNrICovXG5cbiAgLyoqIENvbXBsaWxlZCB7QGxpbmsgTWFza2VkfSBvcHRpb25zICovXG5cbiAgLyoqIENob29zZXMge0BsaW5rIE1hc2tlZH0gZGVwZW5kaW5nIG9uIGlucHV0IHZhbHVlICovXG5cbiAgLyoqXHJcbiAgICBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICovXG4gIGZ1bmN0aW9uIE1hc2tlZER5bmFtaWMob3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXNrZWREeW5hbWljKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMpLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbih7fSwgTWFza2VkRHluYW1pYy5ERUZBVUxUUywge30sIG9wdHMpKSk7XG4gICAgX3RoaXMuY3VycmVudE1hc2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgIEBvdmVycmlkZVxyXG4gICovXG5cblxuICBfY3JlYXRlQ2xhc3MoTWFza2VkRHluYW1pYywgW3tcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKG9wdHMpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJfdXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgIGlmICgnbWFzaycgaW4gb3B0cykge1xuICAgICAgICAvLyBtYXNrIGNvdWxkIGJlIHRvdGFsbHkgZHluYW1pYyB3aXRoIG9ubHkgYGRpc3BhdGNoYCBvcHRpb25cbiAgICAgICAgdGhpcy5jb21waWxlZE1hc2tzID0gQXJyYXkuaXNBcnJheShvcHRzLm1hc2spID8gb3B0cy5tYXNrLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVNYXNrKG0pO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZENoYXJSYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGVuZENoYXJSYXcoKSB7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuX2FwcGx5RGlzcGF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHtcbiAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRNYXNrO1xuXG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKChfdGhpcyRjdXJyZW50TWFzayA9IHRoaXMuY3VycmVudE1hc2spLl9hcHBlbmRDaGFyLmFwcGx5KF90aGlzJGN1cnJlbnRNYXNrLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseURpc3BhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseURpc3BhdGNoKCkge1xuICAgICAgdmFyIGFwcGVuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcHJldlZhbHVlQmVmb3JlVGFpbCA9IGZsYWdzLnRhaWwgJiYgZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZSAhPSBudWxsID8gZmxhZ3MuX2JlZm9yZVRhaWxTdGF0ZS5fdmFsdWUgOiB0aGlzLnZhbHVlO1xuICAgICAgdmFyIGlucHV0VmFsdWUgPSB0aGlzLnJhd0lucHV0VmFsdWU7XG4gICAgICB2YXIgaW5zZXJ0VmFsdWUgPSBmbGFncy50YWlsICYmIGZsYWdzLl9iZWZvcmVUYWlsU3RhdGUgIT0gbnVsbCA/IC8vICRGbG93Rml4TWUgLSB0aXJlZCB0byBmaWdodCB3aXRoIHR5cGUgc3lzdGVtXG4gICAgICBmbGFncy5fYmVmb3JlVGFpbFN0YXRlLl9yYXdJbnB1dFZhbHVlIDogaW5wdXRWYWx1ZTtcbiAgICAgIHZhciB0YWlsVmFsdWUgPSBpbnB1dFZhbHVlLnNsaWNlKGluc2VydFZhbHVlLmxlbmd0aCk7XG4gICAgICB2YXIgcHJldk1hc2sgPSB0aGlzLmN1cnJlbnRNYXNrO1xuICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQ2hhbmdlRGV0YWlscygpO1xuICAgICAgdmFyIHByZXZNYXNrU3RhdGUgPSBwcmV2TWFzayAmJiBwcmV2TWFzay5zdGF0ZTsgLy8gY2xvbmUgZmxhZ3MgdG8gcHJldmVudCBvdmVyd3JpdGluZyBgX2JlZm9yZVRhaWxTdGF0ZWBcblxuICAgICAgdGhpcy5jdXJyZW50TWFzayA9IHRoaXMuZG9EaXNwYXRjaChhcHBlbmRlZCwgT2JqZWN0LmFzc2lnbih7fSwgZmxhZ3MpKTsgLy8gcmVzdG9yZSBzdGF0ZSBhZnRlciBkaXNwYXRjaFxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWFzayAhPT0gcHJldk1hc2spIHtcbiAgICAgICAgICAvLyBpZiBtYXNrIGNoYW5nZWQgcmVhcHBseSBpbnB1dFxuICAgICAgICAgIHRoaXMuY3VycmVudE1hc2sucmVzZXQoKTsgLy8gJEZsb3dGaXhNZSAtIGl0J3Mgb2ssIHdlIGRvbid0IGNoYW5nZSBjdXJyZW50IG1hc2sgYWJvdmVcblxuICAgICAgICAgIHZhciBkID0gdGhpcy5jdXJyZW50TWFzay5hcHBlbmQoaW5zZXJ0VmFsdWUsIHtcbiAgICAgICAgICAgIHJhdzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRldGFpbHMudGFpbFNoaWZ0ID0gZC5pbnNlcnRlZC5sZW5ndGggLSBwcmV2VmFsdWVCZWZvcmVUYWlsLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0YWlsVmFsdWUpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBpdCdzIG9rLCB3ZSBkb24ndCBjaGFuZ2UgY3VycmVudCBtYXNrIGFib3ZlXG4gICAgICAgICAgICBkZXRhaWxzLnRhaWxTaGlmdCArPSB0aGlzLmN1cnJlbnRNYXNrLmFwcGVuZCh0YWlsVmFsdWUsIHtcbiAgICAgICAgICAgICAgcmF3OiB0cnVlLFxuICAgICAgICAgICAgICB0YWlsOiB0cnVlXG4gICAgICAgICAgICB9KS50YWlsU2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERpc3BhdGNoIGNhbiBkbyBzb21ldGhpbmcgYmFkIHdpdGggc3RhdGUsIHNvXG4gICAgICAgICAgLy8gcmVzdG9yZSBwcmV2IG1hc2sgc3RhdGVcbiAgICAgICAgICB0aGlzLmN1cnJlbnRNYXNrLnN0YXRlID0gcHJldk1hc2tTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRQbGFjZWhvbGRlcigpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gdGhpcy5fYXBwbHlEaXNwYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICBkZXRhaWxzLmFnZ3JlZ2F0ZSh0aGlzLmN1cnJlbnRNYXNrLl9hcHBlbmRQbGFjZWhvbGRlcigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb0Rpc3BhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvRGlzcGF0Y2goYXBwZW5kZWQpIHtcbiAgICAgIHZhciBmbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChhcHBlbmRlZCwgdGhpcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG9WYWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb1ZhbGlkYXRlKCkge1xuICAgICAgdmFyIF9nZXQyLCBfdGhpcyRjdXJyZW50TWFzazI7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImRvVmFsaWRhdGVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpICYmICghdGhpcy5jdXJyZW50TWFzayB8fCAoX3RoaXMkY3VycmVudE1hc2syID0gdGhpcy5jdXJyZW50TWFzaykuZG9WYWxpZGF0ZS5hcHBseShfdGhpcyRjdXJyZW50TWFzazIsIGFyZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHRoaXMuY3VycmVudE1hc2sucmVzZXQoKTtcbiAgICAgIHRoaXMuY29tcGlsZWRNYXNrcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuXG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGRldGFpbHMgPSBuZXcgQ2hhbmdlRGV0YWlscygpO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWFzaykge1xuICAgICAgICB2YXIgX3RoaXMkY3VycmVudE1hc2szO1xuXG4gICAgICAgIGRldGFpbHMuYWdncmVnYXRlKChfdGhpcyRjdXJyZW50TWFzazMgPSB0aGlzLmN1cnJlbnRNYXNrKS5yZW1vdmUuYXBwbHkoX3RoaXMkY3VycmVudE1hc2szLCBhcmd1bWVudHMpKSAvLyB1cGRhdGUgd2l0aCBkaXNwYXRjaFxuICAgICAgICAuYWdncmVnYXRlKHRoaXMuX2FwcGx5RGlzcGF0Y2goKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdElucHV0XCIsXG5cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0SW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXMkY3VycmVudE1hc2s0O1xuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IChfdGhpcyRjdXJyZW50TWFzazQgPSB0aGlzLmN1cnJlbnRNYXNrKS5leHRyYWN0SW5wdXQuYXBwbHkoX3RoaXMkY3VycmVudE1hc2s0LCBhcmd1bWVudHMpIDogJyc7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0VGFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0VGFpbCgpIHtcbiAgICAgIHZhciBfdGhpcyRjdXJyZW50TWFzazUsIF9nZXQzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IChfdGhpcyRjdXJyZW50TWFzazUgPSB0aGlzLmN1cnJlbnRNYXNrKS5leHRyYWN0VGFpbC5hcHBseShfdGhpcyRjdXJyZW50TWFzazUsIGFyZ3MpIDogKF9nZXQzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImV4dHJhY3RUYWlsXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQzLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgIEBvdmVycmlkZVxyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRvQ29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ29tbWl0KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHRoaXMuY3VycmVudE1hc2suZG9Db21taXQoKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcImRvQ29tbWl0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZWFyZXN0SW5wdXRQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVhcmVzdElucHV0UG9zKCkge1xuICAgICAgdmFyIF90aGlzJGN1cnJlbnRNYXNrNiwgX2dldDQ7XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNYXNrID8gKF90aGlzJGN1cnJlbnRNYXNrNiA9IHRoaXMuY3VycmVudE1hc2spLm5lYXJlc3RJbnB1dFBvcy5hcHBseShfdGhpcyRjdXJyZW50TWFzazYsIGFyZ3MpIDogKF9nZXQ0ID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTWFza2VkRHluYW1pYy5wcm90b3R5cGUpLCBcIm5lYXJlc3RJbnB1dFBvc1wiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0NCwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TWFzayA/IHRoaXMuY3VycmVudE1hc2sudmFsdWUgOiAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBfc2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5tYXNrZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLnVubWFza2VkVmFsdWUgOiAnJztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHVubWFza2VkVmFsdWUpIHtcbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJ1bm1hc2tlZFZhbHVlXCIsIHVubWFza2VkVmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgQG92ZXJyaWRlXHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZWRWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLnR5cGVkVmFsdWUgOiAnJztcbiAgICB9IC8vIHByb2JhYmx5IHR5cGVkVmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggZHluYW1pY1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIHVubWFza2VkVmFsdWUgPSBTdHJpbmcodmFsdWUpOyAvLyBkb3VibGUgY2hlY2sgaXRcblxuICAgICAgaWYgKHRoaXMuY3VycmVudE1hc2spIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWFzay50eXBlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHVubWFza2VkVmFsdWUgPSB0aGlzLmN1cnJlbnRNYXNrLnVubWFza2VkVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5tYXNrZWRWYWx1ZSA9IHVubWFza2VkVmFsdWU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICBAb3ZlcnJpZGVcclxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0NvbXBsZXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmN1cnJlbnRNYXNrICYmIHRoaXMuY3VycmVudE1hc2suaXNDb21wbGV0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBfZ2V0KF9nZXRQcm90b3R5cGVPZihNYXNrZWREeW5hbWljLnByb3RvdHlwZSksIFwic3RhdGVcIiwgdGhpcyksIHtcbiAgICAgICAgX3Jhd0lucHV0VmFsdWU6IHRoaXMucmF3SW5wdXRWYWx1ZSxcbiAgICAgICAgY29tcGlsZWRNYXNrczogdGhpcy5jb21waWxlZE1hc2tzLm1hcChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLnN0YXRlO1xuICAgICAgICB9KSxcbiAgICAgICAgY3VycmVudE1hc2tSZWY6IHRoaXMuY3VycmVudE1hc2ssXG4gICAgICAgIGN1cnJlbnRNYXNrOiB0aGlzLmN1cnJlbnRNYXNrICYmIHRoaXMuY3VycmVudE1hc2suc3RhdGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIHZhciBjb21waWxlZE1hc2tzID0gc3RhdGUuY29tcGlsZWRNYXNrcyxcbiAgICAgICAgICBjdXJyZW50TWFza1JlZiA9IHN0YXRlLmN1cnJlbnRNYXNrUmVmLFxuICAgICAgICAgIGN1cnJlbnRNYXNrID0gc3RhdGUuY3VycmVudE1hc2ssXG4gICAgICAgICAgbWFza2VkU3RhdGUgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3RhdGUsIFtcImNvbXBpbGVkTWFza3NcIiwgXCJjdXJyZW50TWFza1JlZlwiLCBcImN1cnJlbnRNYXNrXCJdKTtcblxuICAgICAgdGhpcy5jb21waWxlZE1hc2tzLmZvckVhY2goZnVuY3Rpb24gKG0sIG1pKSB7XG4gICAgICAgIHJldHVybiBtLnN0YXRlID0gY29tcGlsZWRNYXNrc1ttaV07XG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnRNYXNrUmVmICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWFzayA9IGN1cnJlbnRNYXNrUmVmO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXNrLnN0YXRlID0gY3VycmVudE1hc2s7XG4gICAgICB9XG5cbiAgICAgIF9zZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJzdGF0ZVwiLCBtYXNrZWRTdGF0ZSwgdGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJ3cml0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hc2sgPyB0aGlzLmN1cnJlbnRNYXNrLm92ZXJ3cml0ZSA6IF9nZXQoX2dldFByb3RvdHlwZU9mKE1hc2tlZER5bmFtaWMucHJvdG90eXBlKSwgXCJvdmVyd3JpdGVcIiwgdGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvdmVyd3JpdGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignXCJvdmVyd3JpdGVcIiBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiBkeW5hbWljIG1hc2ssIHVzZSB0aGlzIG9wdGlvbiBpbiBzaWJsaW5ncycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrZWREeW5hbWljO1xufShNYXNrZWQpO1xuTWFza2VkRHluYW1pYy5ERUZBVUxUUyA9IHtcbiAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFwcGVuZGVkLCBtYXNrZWQsIGZsYWdzKSB7XG4gICAgaWYgKCFtYXNrZWQuY29tcGlsZWRNYXNrcy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IG1hc2tlZC5yYXdJbnB1dFZhbHVlOyAvLyBzaW11bGF0ZSBpbnB1dFxuXG4gICAgdmFyIGlucHV0cyA9IG1hc2tlZC5jb21waWxlZE1hc2tzLm1hcChmdW5jdGlvbiAobSwgaW5kZXgpIHtcbiAgICAgIG0ucmVzZXQoKTtcbiAgICAgIG0uYXBwZW5kKGlucHV0VmFsdWUsIHtcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG0uYXBwZW5kKGFwcGVuZGVkLCBmbGFncyk7XG4gICAgICB2YXIgd2VpZ2h0ID0gbS5yYXdJbnB1dFZhbHVlLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfSk7IC8vIHBvcCBtYXNrcyB3aXRoIGxvbmdlciB2YWx1ZXMgZmlyc3RcblxuICAgIGlucHV0cy5zb3J0KGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgIHJldHVybiBpMi53ZWlnaHQgLSBpMS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hc2tlZC5jb21waWxlZE1hc2tzW2lucHV0c1swXS5pbmRleF07XG4gIH1cbn07XG5JTWFzay5NYXNrZWREeW5hbWljID0gTWFza2VkRHluYW1pYztcblxuZXhwb3J0IGRlZmF1bHQgTWFza2VkRHluYW1pYztcbiIsImltcG9ydCAnLi4vX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy0zYzU4ZjBlMy5qcyc7XG5pbXBvcnQgJy4uL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0IElNYXNrIGZyb20gJy4uL2NvcmUvaG9sZGVyLmpzJztcbmltcG9ydCBjcmVhdGVNYXNrIGZyb20gJy4vZmFjdG9yeS5qcyc7XG5cbi8qKiBNYXNrIHBpcGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyAqL1xuXG52YXIgUElQRV9UWVBFID0ge1xuICBNQVNLRUQ6ICd2YWx1ZScsXG4gIFVOTUFTS0VEOiAndW5tYXNrZWRWYWx1ZScsXG4gIFRZUEVEOiAndHlwZWRWYWx1ZSdcbn07XG4vKiogQ3JlYXRlcyBuZXcgcGlwZSBmdW5jdGlvbiBkZXBlbmRpbmcgb24gbWFzayB0eXBlLCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG9wdGlvbnMgKi9cblxuZnVuY3Rpb24gY3JlYXRlUGlwZShtYXNrKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBQSVBFX1RZUEUuTUFTS0VEO1xuICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFBJUEVfVFlQRS5NQVNLRUQ7XG4gIHZhciBtYXNrZWQgPSBjcmVhdGVNYXNrKG1hc2spO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG1hc2tlZC5ydW5Jc29sYXRlZChmdW5jdGlvbiAobSkge1xuICAgICAgbVtmcm9tXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1bdG9dO1xuICAgIH0pO1xuICB9O1xufVxuLyoqIFBpcGVzIHZhbHVlIHRocm91Z2ggbWFzayBkZXBlbmRpbmcgb24gbWFzayB0eXBlLCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG9wdGlvbnMgKi9cblxuZnVuY3Rpb24gcGlwZSh2YWx1ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGlwZUFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBpcGVBcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVQaXBlLmFwcGx5KHZvaWQgMCwgcGlwZUFyZ3MpKHZhbHVlKTtcbn1cbklNYXNrLlBJUEVfVFlQRSA9IFBJUEVfVFlQRTtcbklNYXNrLmNyZWF0ZVBpcGUgPSBjcmVhdGVQaXBlO1xuSU1hc2sucGlwZSA9IHBpcGU7XG5cbmV4cG9ydCB7IFBJUEVfVFlQRSwgY3JlYXRlUGlwZSwgcGlwZSB9O1xuIiwiaW1wb3J0ICcuL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMtM2M1OGYwZTMuanMnO1xuaW1wb3J0ICcuL2NvcmUvdXRpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvYWN0aW9uLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvY2hhbmdlLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvY29udGludW91cy10YWlsLWRldGFpbHMuanMnO1xuaW1wb3J0ICcuL2NvcmUvaG9sZGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkIH0gZnJvbSAnLi9tYXNrZWQvYmFzZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZU1hc2sgfSBmcm9tICcuL21hc2tlZC9mYWN0b3J5LmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9pbnB1dC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9maXhlZC1kZWZpbml0aW9uLmpzJztcbmltcG9ydCAnLi9tYXNrZWQvcGF0dGVybi9jaHVuay10YWlsLWRldGFpbHMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRSZWdFeHAgfSBmcm9tICcuL21hc2tlZC9yZWdleHAuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRQYXR0ZXJuIH0gZnJvbSAnLi9tYXNrZWQvcGF0dGVybi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hc2tlZFJhbmdlIH0gZnJvbSAnLi9tYXNrZWQvcmFuZ2UuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWREYXRlIH0gZnJvbSAnLi9tYXNrZWQvZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hc2tFbGVtZW50IH0gZnJvbSAnLi9jb250cm9scy9tYXNrLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIVE1MTWFza0VsZW1lbnQgfSBmcm9tICcuL2NvbnRyb2xzL2h0bWwtbWFzay1lbGVtZW50LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSFRNTENvbnRlbnRlZGl0YWJsZU1hc2tFbGVtZW50IH0gZnJvbSAnLi9jb250cm9scy9odG1sLWNvbnRlbnRlZGl0YWJsZS1tYXNrLWVsZW1lbnQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dE1hc2sgfSBmcm9tICcuL2NvbnRyb2xzL2lucHV0LmpzJztcbmltcG9ydCBJTWFzayBmcm9tICcuL2ltYXNrLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkRW51bSB9IGZyb20gJy4vbWFza2VkL2VudW0uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWROdW1iZXIgfSBmcm9tICcuL21hc2tlZC9udW1iZXIuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXNrZWRGdW5jdGlvbiB9IGZyb20gJy4vbWFza2VkL2Z1bmN0aW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFza2VkRHluYW1pYyB9IGZyb20gJy4vbWFza2VkL2R5bmFtaWMuanMnO1xuZXhwb3J0IHsgUElQRV9UWVBFLCBjcmVhdGVQaXBlLCBwaXBlIH0gZnJvbSAnLi9tYXNrZWQvcGlwZS5qcyc7XG5cbnRyeSB7XG4gIGdsb2JhbFRoaXMuSU1hc2sgPSBJTWFzaztcbn0gY2F0Y2ggKGUpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IElNYXNrO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 14.6.0 - 6/27/2020 */\n(function (factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function () {\n  "use strict";\n\n  var VERSION = "14.6.0"; //region Helper Methods\n\n  function isValidFormatter(entry) {\n    return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";\n  }\n\n  function removeElement(el) {\n    el.parentElement.removeChild(el);\n  }\n\n  function isSet(value) {\n    return value !== null && value !== undefined;\n  } // Bindable version\n\n\n  function preventDefault(e) {\n    e.preventDefault();\n  } // Removes duplicates from an array.\n\n\n  function unique(array) {\n    return array.filter(function (a) {\n      return !this[a] ? this[a] = true : false;\n    }, {});\n  } // Round a value to the closest \'to\'.\n\n\n  function closest(value, to) {\n    return Math.round(value / to) * to;\n  } // Current position of an element relative to the document.\n\n\n  function offset(elem, orientation) {\n    var rect = elem.getBoundingClientRect();\n    var doc = elem.ownerDocument;\n    var docElem = doc.documentElement;\n    var pageOffset = getPageOffset(doc); // getBoundingClientRect contains left scroll in Chrome on Android.\n    // I haven\'t found a feature detection that proves this. Worst case\n    // scenario on mis-match: the \'tap\' feature on horizontal sliders breaks.\n\n    if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\n      pageOffset.x = 0;\n    }\n\n    return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;\n  } // Checks whether a value is numerical.\n\n\n  function isNumeric(a) {\n    return typeof a === "number" && !isNaN(a) && isFinite(a);\n  } // Sets a class and removes it after [duration] ms.\n\n\n  function addClassFor(element, className, duration) {\n    if (duration > 0) {\n      addClass(element, className);\n      setTimeout(function () {\n        removeClass(element, className);\n      }, duration);\n    }\n  } // Limits a value to 0 - 100\n\n\n  function limit(a) {\n    return Math.max(Math.min(a, 100), 0);\n  } // Wraps a variable as an array, if it isn\'t one yet.\n  // Note that an input array is returned by reference!\n\n\n  function asArray(a) {\n    return Array.isArray(a) ? a : [a];\n  } // Counts decimals\n\n\n  function countDecimals(numStr) {\n    numStr = String(numStr);\n    var pieces = numStr.split(".");\n    return pieces.length > 1 ? pieces[1].length : 0;\n  } // http://youmightnotneedjquery.com/#add_class\n\n\n  function addClass(el, className) {\n    if (el.classList && !/\\s/.test(className)) {\n      el.classList.add(className);\n    } else {\n      el.className += " " + className;\n    }\n  } // http://youmightnotneedjquery.com/#remove_class\n\n\n  function removeClass(el, className) {\n    if (el.classList && !/\\s/.test(className)) {\n      el.classList.remove(className);\n    } else {\n      el.className = el.className.replace(new RegExp("(^|\\\\b)" + className.split(" ").join("|") + "(\\\\b|$)", "gi"), " ");\n    }\n  } // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\n\n\n  function hasClass(el, className) {\n    return el.classList ? el.classList.contains(className) : new RegExp("\\\\b" + className + "\\\\b").test(el.className);\n  } // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\n\n\n  function getPageOffset(doc) {\n    var supportPageOffset = window.pageXOffset !== undefined;\n    var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";\n    var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;\n    var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;\n    return {\n      x: x,\n      y: y\n    };\n  } // we provide a function to compute constants instead\n  // of accessing window.* as soon as the module needs it\n  // so that we do not compute anything if not needed\n\n\n  function getActions() {\n    // Determine the events to bind. IE11 implements pointerEvents without\n    // a prefix, which breaks compatibility with the IE10 implementation.\n    return window.navigator.pointerEnabled ? {\n      start: "pointerdown",\n      move: "pointermove",\n      end: "pointerup"\n    } : window.navigator.msPointerEnabled ? {\n      start: "MSPointerDown",\n      move: "MSPointerMove",\n      end: "MSPointerUp"\n    } : {\n      start: "mousedown touchstart",\n      move: "mousemove touchmove",\n      end: "mouseup touchend"\n    };\n  } // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n  // Issue #785\n\n\n  function getSupportsPassive() {\n    var supportsPassive = false;\n    /* eslint-disable */\n\n    try {\n      var opts = Object.defineProperty({}, "passive", {\n        get: function () {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener("test", null, opts);\n    } catch (e) {}\n    /* eslint-enable */\n\n\n    return supportsPassive;\n  }\n\n  function getSupportsTouchActionNone() {\n    return window.CSS && CSS.supports && CSS.supports("touch-action", "none");\n  } //endregion\n  //region Range Calculation\n  // Determine the size of a sub-range in relation to a full range.\n\n\n  function subRangeRatio(pa, pb) {\n    return 100 / (pb - pa);\n  } // (percentage) How many percent is this value of this range?\n\n\n  function fromPercentage(range, value, startRange) {\n    return value * 100 / (range[startRange + 1] - range[startRange]);\n  } // (percentage) Where is this value on this range?\n\n\n  function toPercentage(range, value) {\n    return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);\n  } // (value) How much is this percentage on this range?\n\n\n  function isPercentage(range, value) {\n    return value * (range[1] - range[0]) / 100 + range[0];\n  }\n\n  function getJ(value, arr) {\n    var j = 1;\n\n    while (value >= arr[j]) {\n      j += 1;\n    }\n\n    return j;\n  } // (percentage) Input a value, find where, on a scale of 0-100, it applies.\n\n\n  function toStepping(xVal, xPct, value) {\n    if (value >= xVal.slice(-1)[0]) {\n      return 100;\n    }\n\n    var j = getJ(value, xVal);\n    var va = xVal[j - 1];\n    var vb = xVal[j];\n    var pa = xPct[j - 1];\n    var pb = xPct[j];\n    return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\n  } // (value) Input a percentage, find where it is on the specified range.\n\n\n  function fromStepping(xVal, xPct, value) {\n    // There is no range group that fits 100\n    if (value >= 100) {\n      return xVal.slice(-1)[0];\n    }\n\n    var j = getJ(value, xPct);\n    var va = xVal[j - 1];\n    var vb = xVal[j];\n    var pa = xPct[j - 1];\n    var pb = xPct[j];\n    return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\n  } // (percentage) Get the step that applies at a certain value.\n\n\n  function getStep(xPct, xSteps, snap, value) {\n    if (value === 100) {\n      return value;\n    }\n\n    var j = getJ(value, xPct);\n    var a = xPct[j - 1];\n    var b = xPct[j]; // If \'snap\' is set, steps are used as fixed points on the slider.\n\n    if (snap) {\n      // Find the closest position, a or b.\n      if (value - a > (b - a) / 2) {\n        return b;\n      }\n\n      return a;\n    }\n\n    if (!xSteps[j - 1]) {\n      return value;\n    }\n\n    return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\n  }\n\n  function handleEntryPoint(index, value, that) {\n    var percentage; // Wrap numerical input in an array.\n\n    if (typeof value === "number") {\n      value = [value];\n    } // Reject any invalid input, by testing whether value is an array.\n\n\n    if (!Array.isArray(value)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'range\' contains invalid value.");\n    } // Covert min/max syntax to 0 and 100.\n\n\n    if (index === "min") {\n      percentage = 0;\n    } else if (index === "max") {\n      percentage = 100;\n    } else {\n      percentage = parseFloat(index);\n    } // Check for correct input.\n\n\n    if (!isNumeric(percentage) || !isNumeric(value[0])) {\n      throw new Error("noUiSlider (" + VERSION + "): \'range\' value isn\'t numeric.");\n    } // Store values.\n\n\n    that.xPct.push(percentage);\n    that.xVal.push(value[0]); // NaN will evaluate to false too, but to keep\n    // logging clear, set step explicitly. Make sure\n    // not to override the \'step\' setting with false.\n\n    if (!percentage) {\n      if (!isNaN(value[1])) {\n        that.xSteps[0] = value[1];\n      }\n    } else {\n      that.xSteps.push(isNaN(value[1]) ? false : value[1]);\n    }\n\n    that.xHighestCompleteStep.push(0);\n  }\n\n  function handleStepPoint(i, n, that) {\n    // Ignore \'false\' stepping.\n    if (!n) {\n      return;\n    } // Step over zero-length ranges (#948);\n\n\n    if (that.xVal[i] === that.xVal[i + 1]) {\n      that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];\n      return;\n    } // Factor to range ratio\n\n\n    that.xSteps[i] = fromPercentage([that.xVal[i], that.xVal[i + 1]], n, 0) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);\n    var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];\n    var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\n    var step = that.xVal[i] + that.xNumSteps[i] * highestStep;\n    that.xHighestCompleteStep[i] = step;\n  } //endregion\n  //region Spectrum\n\n\n  function Spectrum(entry, snap, singleStep) {\n    this.xPct = [];\n    this.xVal = [];\n    this.xSteps = [singleStep || false];\n    this.xNumSteps = [false];\n    this.xHighestCompleteStep = [];\n    this.snap = snap;\n    var index;\n    var ordered = []; // [0, \'min\'], [1, \'50%\'], [2, \'max\']\n    // Map the object keys to an array.\n\n    for (index in entry) {\n      if (entry.hasOwnProperty(index)) {\n        ordered.push([entry[index], index]);\n      }\n    } // Sort all entries by value (numeric sort).\n\n\n    if (ordered.length && typeof ordered[0][0] === "object") {\n      ordered.sort(function (a, b) {\n        return a[0][0] - b[0][0];\n      });\n    } else {\n      ordered.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n    } // Convert all entries to subranges.\n\n\n    for (index = 0; index < ordered.length; index++) {\n      handleEntryPoint(ordered[index][1], ordered[index][0], this);\n    } // Store the actual step values.\n    // xSteps is sorted in the same order as xPct and xVal.\n\n\n    this.xNumSteps = this.xSteps.slice(0); // Convert all numeric steps to the percentage of the subrange they represent.\n\n    for (index = 0; index < this.xNumSteps.length; index++) {\n      handleStepPoint(index, this.xNumSteps[index], this);\n    }\n  }\n\n  Spectrum.prototype.getDistance = function (value) {\n    var index;\n    var distances = [];\n\n    for (index = 0; index < this.xNumSteps.length - 1; index++) {\n      // last "range" can\'t contain step size as it is purely an endpoint.\n      var step = this.xNumSteps[index];\n\n      if (step && value / step % 1 !== 0) {\n        throw new Error("noUiSlider (" + VERSION + "): \'limit\', \'margin\' and \'padding\' of " + this.xPct[index] + "% range must be divisible by step.");\n      } // Calculate percentual distance in current range of limit, margin or padding\n\n\n      distances[index] = fromPercentage(this.xVal, value, index);\n    }\n\n    return distances;\n  }; // Calculate the percentual distance over the whole scale of ranges.\n  // direction: 0 = backwards / 1 = forwards\n\n\n  Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {\n    var xPct_index = 0; // Calculate range where to start calculation\n\n    if (value < this.xPct[this.xPct.length - 1]) {\n      while (value > this.xPct[xPct_index + 1]) {\n        xPct_index++;\n      }\n    } else if (value === this.xPct[this.xPct.length - 1]) {\n      xPct_index = this.xPct.length - 2;\n    } // If looking backwards and the value is exactly at a range separator then look one range further\n\n\n    if (!direction && value === this.xPct[xPct_index + 1]) {\n      xPct_index++;\n    }\n\n    var start_factor;\n    var rest_factor = 1;\n    var rest_rel_distance = distances[xPct_index];\n    var range_pct = 0;\n    var rel_range_distance = 0;\n    var abs_distance_counter = 0;\n    var range_counter = 0; // Calculate what part of the start range the value is\n\n    if (direction) {\n      start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n    } else {\n      start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n    } // Do until the complete distance across ranges is calculated\n\n\n    while (rest_rel_distance > 0) {\n      // Calculate the percentage of total range\n      range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter]; // Detect if the margin, padding or limit is larger then the current range and calculate\n\n      if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {\n        // If larger then take the percentual distance of the whole range\n        rel_range_distance = range_pct * start_factor; // Rest factor of relative percentual distance still to be calculated\n\n        rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter]; // Set start factor to 1 as for next range it does not apply.\n\n        start_factor = 1;\n      } else {\n        // If smaller or equal then take the percentual distance of the calculate percentual part of that range\n        rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor; // No rest left as the rest fits in current range\n\n        rest_factor = 0;\n      }\n\n      if (direction) {\n        abs_distance_counter = abs_distance_counter - rel_range_distance; // Limit range to first range when distance becomes outside of minimum range\n\n        if (this.xPct.length + range_counter >= 1) {\n          range_counter--;\n        }\n      } else {\n        abs_distance_counter = abs_distance_counter + rel_range_distance; // Limit range to last range when distance becomes outside of maximum range\n\n        if (this.xPct.length - range_counter >= 1) {\n          range_counter++;\n        }\n      } // Rest of relative percentual distance still to be calculated\n\n\n      rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;\n    }\n\n    return value + abs_distance_counter;\n  };\n\n  Spectrum.prototype.toStepping = function (value) {\n    value = toStepping(this.xVal, this.xPct, value);\n    return value;\n  };\n\n  Spectrum.prototype.fromStepping = function (value) {\n    return fromStepping(this.xVal, this.xPct, value);\n  };\n\n  Spectrum.prototype.getStep = function (value) {\n    value = getStep(this.xPct, this.xSteps, this.snap, value);\n    return value;\n  };\n\n  Spectrum.prototype.getDefaultStep = function (value, isDown, size) {\n    var j = getJ(value, this.xPct); // When at the top or stepping down, look at the previous sub-range\n\n    if (value === 100 || isDown && value === this.xPct[j - 1]) {\n      j = Math.max(j - 1, 1);\n    }\n\n    return (this.xVal[j] - this.xVal[j - 1]) / size;\n  };\n\n  Spectrum.prototype.getNearbySteps = function (value) {\n    var j = getJ(value, this.xPct);\n    return {\n      stepBefore: {\n        startValue: this.xVal[j - 2],\n        step: this.xNumSteps[j - 2],\n        highestStep: this.xHighestCompleteStep[j - 2]\n      },\n      thisStep: {\n        startValue: this.xVal[j - 1],\n        step: this.xNumSteps[j - 1],\n        highestStep: this.xHighestCompleteStep[j - 1]\n      },\n      stepAfter: {\n        startValue: this.xVal[j],\n        step: this.xNumSteps[j],\n        highestStep: this.xHighestCompleteStep[j]\n      }\n    };\n  };\n\n  Spectrum.prototype.countStepDecimals = function () {\n    var stepDecimals = this.xNumSteps.map(countDecimals);\n    return Math.max.apply(null, stepDecimals);\n  }; // Outside testing\n\n\n  Spectrum.prototype.convert = function (value) {\n    return this.getStep(this.toStepping(value));\n  }; //endregion\n  //region Options\n\n  /*\tEvery input option is tested and parsed. This\'ll prevent\n      endless validation in internal methods. These tests are\n      structured with an item for every option available. An\n      option can be marked as required by setting the \'r\' flag.\n      The testing function is provided with three arguments:\n          - The provided value for the option;\n          - A reference to the options object;\n          - The name for the option;\n       The testing function returns false when an error is detected,\n      or true when everything is OK. It can also modify the option\n      object, to make sure all values can be correctly looped elsewhere. */\n  //region Defaults\n\n\n  var defaultFormatter = {\n    to: function (value) {\n      return value !== undefined && value.toFixed(2);\n    },\n    from: Number\n  };\n  var cssClasses = {\n    target: "target",\n    base: "base",\n    origin: "origin",\n    handle: "handle",\n    handleLower: "handle-lower",\n    handleUpper: "handle-upper",\n    touchArea: "touch-area",\n    horizontal: "horizontal",\n    vertical: "vertical",\n    background: "background",\n    connect: "connect",\n    connects: "connects",\n    ltr: "ltr",\n    rtl: "rtl",\n    textDirectionLtr: "txt-dir-ltr",\n    textDirectionRtl: "txt-dir-rtl",\n    draggable: "draggable",\n    drag: "state-drag",\n    tap: "state-tap",\n    active: "active",\n    tooltip: "tooltip",\n    pips: "pips",\n    pipsHorizontal: "pips-horizontal",\n    pipsVertical: "pips-vertical",\n    marker: "marker",\n    markerHorizontal: "marker-horizontal",\n    markerVertical: "marker-vertical",\n    markerNormal: "marker-normal",\n    markerLarge: "marker-large",\n    markerSub: "marker-sub",\n    value: "value",\n    valueHorizontal: "value-horizontal",\n    valueVertical: "value-vertical",\n    valueNormal: "value-normal",\n    valueLarge: "value-large",\n    valueSub: "value-sub"\n  }; //endregion\n\n  function validateFormat(entry) {\n    // Any object with a to and from method is supported.\n    if (isValidFormatter(entry)) {\n      return true;\n    }\n\n    throw new Error("noUiSlider (" + VERSION + "): \'format\' requires \'to\' and \'from\' methods.");\n  }\n\n  function testStep(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'step\' is not numeric.");\n    } // The step option can still be used to set stepping\n    // for linear sliders. Overwritten if set in \'range\'.\n\n\n    parsed.singleStep = entry;\n  }\n\n  function testKeyboardPageMultiplier(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'keyboardPageMultiplier\' is not numeric.");\n    }\n\n    parsed.keyboardPageMultiplier = entry;\n  }\n\n  function testKeyboardDefaultStep(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'keyboardDefaultStep\' is not numeric.");\n    }\n\n    parsed.keyboardDefaultStep = entry;\n  }\n\n  function testRange(parsed, entry) {\n    // Filter incorrect input.\n    if (typeof entry !== "object" || Array.isArray(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'range\' is not an object.");\n    } // Catch missing start or end.\n\n\n    if (entry.min === undefined || entry.max === undefined) {\n      throw new Error("noUiSlider (" + VERSION + "): Missing \'min\' or \'max\' in \'range\'.");\n    } // Catch equal start or end.\n\n\n    if (entry.min === entry.max) {\n      throw new Error("noUiSlider (" + VERSION + "): \'range\' \'min\' and \'max\' cannot be equal.");\n    }\n\n    parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\n  }\n\n  function testStart(parsed, entry) {\n    entry = asArray(entry); // Validate input. Values aren\'t tested, as the public .val method\n    // will always provide a valid location.\n\n    if (!Array.isArray(entry) || !entry.length) {\n      throw new Error("noUiSlider (" + VERSION + "): \'start\' option is incorrect.");\n    } // Store the number of handles.\n\n\n    parsed.handles = entry.length; // When the slider is initialized, the .val method will\n    // be called with the start options.\n\n    parsed.start = entry;\n  }\n\n  function testSnap(parsed, entry) {\n    // Enforce 100% stepping within subranges.\n    parsed.snap = entry;\n\n    if (typeof entry !== "boolean") {\n      throw new Error("noUiSlider (" + VERSION + "): \'snap\' option must be a boolean.");\n    }\n  }\n\n  function testAnimate(parsed, entry) {\n    // Enforce 100% stepping within subranges.\n    parsed.animate = entry;\n\n    if (typeof entry !== "boolean") {\n      throw new Error("noUiSlider (" + VERSION + "): \'animate\' option must be a boolean.");\n    }\n  }\n\n  function testAnimationDuration(parsed, entry) {\n    parsed.animationDuration = entry;\n\n    if (typeof entry !== "number") {\n      throw new Error("noUiSlider (" + VERSION + "): \'animationDuration\' option must be a number.");\n    }\n  }\n\n  function testConnect(parsed, entry) {\n    var connect = [false];\n    var i; // Map legacy options\n\n    if (entry === "lower") {\n      entry = [true, false];\n    } else if (entry === "upper") {\n      entry = [false, true];\n    } // Handle boolean options\n\n\n    if (entry === true || entry === false) {\n      for (i = 1; i < parsed.handles; i++) {\n        connect.push(entry);\n      }\n\n      connect.push(false);\n    } // Reject invalid input\n    else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\n        throw new Error("noUiSlider (" + VERSION + "): \'connect\' option doesn\'t match handle count.");\n      } else {\n        connect = entry;\n      }\n\n    parsed.connect = connect;\n  }\n\n  function testOrientation(parsed, entry) {\n    // Set orientation to an a numerical value for easy\n    // array selection.\n    switch (entry) {\n      case "horizontal":\n        parsed.ort = 0;\n        break;\n\n      case "vertical":\n        parsed.ort = 1;\n        break;\n\n      default:\n        throw new Error("noUiSlider (" + VERSION + "): \'orientation\' option is invalid.");\n    }\n  }\n\n  function testMargin(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'margin\' option must be numeric.");\n    } // Issue #582\n\n\n    if (entry === 0) {\n      return;\n    }\n\n    parsed.margin = parsed.spectrum.getDistance(entry);\n  }\n\n  function testLimit(parsed, entry) {\n    if (!isNumeric(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'limit\' option must be numeric.");\n    }\n\n    parsed.limit = parsed.spectrum.getDistance(entry);\n\n    if (!parsed.limit || parsed.handles < 2) {\n      throw new Error("noUiSlider (" + VERSION + "): \'limit\' option is only supported on linear sliders with 2 or more handles.");\n    }\n  }\n\n  function testPadding(parsed, entry) {\n    var index;\n\n    if (!isNumeric(entry) && !Array.isArray(entry)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers.");\n    }\n\n    if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\n      throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers.");\n    }\n\n    if (entry === 0) {\n      return;\n    }\n\n    if (!Array.isArray(entry)) {\n      entry = [entry, entry];\n    } // \'getDistance\' returns false for invalid values.\n\n\n    parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];\n\n    for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {\n      // last "range" can\'t contain step size as it is purely an endpoint.\n      if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {\n        throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must be a positive number(s).");\n      }\n    }\n\n    var totalPadding = entry[0] + entry[1];\n    var firstValue = parsed.spectrum.xVal[0];\n    var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];\n\n    if (totalPadding / (lastValue - firstValue) > 1) {\n      throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must not exceed 100% of the range.");\n    }\n  }\n\n  function testDirection(parsed, entry) {\n    // Set direction as a numerical value for easy parsing.\n    // Invert connection for RTL sliders, so that the proper\n    // handles get the connect/background classes.\n    switch (entry) {\n      case "ltr":\n        parsed.dir = 0;\n        break;\n\n      case "rtl":\n        parsed.dir = 1;\n        break;\n\n      default:\n        throw new Error("noUiSlider (" + VERSION + "): \'direction\' option was not recognized.");\n    }\n  }\n\n  function testBehaviour(parsed, entry) {\n    // Make sure the input is a string.\n    if (typeof entry !== "string") {\n      throw new Error("noUiSlider (" + VERSION + "): \'behaviour\' must be a string containing options.");\n    } // Check if the string contains any keywords.\n    // None are required.\n\n\n    var tap = entry.indexOf("tap") >= 0;\n    var drag = entry.indexOf("drag") >= 0;\n    var fixed = entry.indexOf("fixed") >= 0;\n    var snap = entry.indexOf("snap") >= 0;\n    var hover = entry.indexOf("hover") >= 0;\n    var unconstrained = entry.indexOf("unconstrained") >= 0;\n\n    if (fixed) {\n      if (parsed.handles !== 2) {\n        throw new Error("noUiSlider (" + VERSION + "): \'fixed\' behaviour must be used with 2 handles");\n      } // Use margin to enforce fixed state\n\n\n      testMargin(parsed, parsed.start[1] - parsed.start[0]);\n    }\n\n    if (unconstrained && (parsed.margin || parsed.limit)) {\n      throw new Error("noUiSlider (" + VERSION + "): \'unconstrained\' behaviour cannot be used with margin or limit");\n    }\n\n    parsed.events = {\n      tap: tap || snap,\n      drag: drag,\n      fixed: fixed,\n      snap: snap,\n      hover: hover,\n      unconstrained: unconstrained\n    };\n  }\n\n  function testTooltips(parsed, entry) {\n    if (entry === false) {\n      return;\n    }\n\n    if (entry === true) {\n      parsed.tooltips = [];\n\n      for (var i = 0; i < parsed.handles; i++) {\n        parsed.tooltips.push(true);\n      }\n    } else {\n      parsed.tooltips = asArray(entry);\n\n      if (parsed.tooltips.length !== parsed.handles) {\n        throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");\n      }\n\n      parsed.tooltips.forEach(function (formatter) {\n        if (typeof formatter !== "boolean" && (typeof formatter !== "object" || typeof formatter.to !== "function")) {\n          throw new Error("noUiSlider (" + VERSION + "): \'tooltips\' must be passed a formatter or \'false\'.");\n        }\n      });\n    }\n  }\n\n  function testAriaFormat(parsed, entry) {\n    parsed.ariaFormat = entry;\n    validateFormat(entry);\n  }\n\n  function testFormat(parsed, entry) {\n    parsed.format = entry;\n    validateFormat(entry);\n  }\n\n  function testKeyboardSupport(parsed, entry) {\n    parsed.keyboardSupport = entry;\n\n    if (typeof entry !== "boolean") {\n      throw new Error("noUiSlider (" + VERSION + "): \'keyboardSupport\' option must be a boolean.");\n    }\n  }\n\n  function testDocumentElement(parsed, entry) {\n    // This is an advanced option. Passed values are used without validation.\n    parsed.documentElement = entry;\n  }\n\n  function testCssPrefix(parsed, entry) {\n    if (typeof entry !== "string" && entry !== false) {\n      throw new Error("noUiSlider (" + VERSION + "): \'cssPrefix\' must be a string or `false`.");\n    }\n\n    parsed.cssPrefix = entry;\n  }\n\n  function testCssClasses(parsed, entry) {\n    if (typeof entry !== "object") {\n      throw new Error("noUiSlider (" + VERSION + "): \'cssClasses\' must be an object.");\n    }\n\n    if (typeof parsed.cssPrefix === "string") {\n      parsed.cssClasses = {};\n\n      for (var key in entry) {\n        if (!entry.hasOwnProperty(key)) {\n          continue;\n        }\n\n        parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\n      }\n    } else {\n      parsed.cssClasses = entry;\n    }\n  } // Test all developer settings and parse to assumption-safe values.\n\n\n  function testOptions(options) {\n    // To prove a fix for #537, freeze options here.\n    // If the object is modified, an error will be thrown.\n    // Object.freeze(options);\n    var parsed = {\n      margin: 0,\n      limit: 0,\n      padding: 0,\n      animate: true,\n      animationDuration: 300,\n      ariaFormat: defaultFormatter,\n      format: defaultFormatter\n    }; // Tests are executed in the order they are presented here.\n\n    var tests = {\n      step: {\n        r: false,\n        t: testStep\n      },\n      keyboardPageMultiplier: {\n        r: false,\n        t: testKeyboardPageMultiplier\n      },\n      keyboardDefaultStep: {\n        r: false,\n        t: testKeyboardDefaultStep\n      },\n      start: {\n        r: true,\n        t: testStart\n      },\n      connect: {\n        r: true,\n        t: testConnect\n      },\n      direction: {\n        r: true,\n        t: testDirection\n      },\n      snap: {\n        r: false,\n        t: testSnap\n      },\n      animate: {\n        r: false,\n        t: testAnimate\n      },\n      animationDuration: {\n        r: false,\n        t: testAnimationDuration\n      },\n      range: {\n        r: true,\n        t: testRange\n      },\n      orientation: {\n        r: false,\n        t: testOrientation\n      },\n      margin: {\n        r: false,\n        t: testMargin\n      },\n      limit: {\n        r: false,\n        t: testLimit\n      },\n      padding: {\n        r: false,\n        t: testPadding\n      },\n      behaviour: {\n        r: true,\n        t: testBehaviour\n      },\n      ariaFormat: {\n        r: false,\n        t: testAriaFormat\n      },\n      format: {\n        r: false,\n        t: testFormat\n      },\n      tooltips: {\n        r: false,\n        t: testTooltips\n      },\n      keyboardSupport: {\n        r: true,\n        t: testKeyboardSupport\n      },\n      documentElement: {\n        r: false,\n        t: testDocumentElement\n      },\n      cssPrefix: {\n        r: true,\n        t: testCssPrefix\n      },\n      cssClasses: {\n        r: true,\n        t: testCssClasses\n      }\n    };\n    var defaults = {\n      connect: false,\n      direction: "ltr",\n      behaviour: "tap",\n      orientation: "horizontal",\n      keyboardSupport: true,\n      cssPrefix: "noUi-",\n      cssClasses: cssClasses,\n      keyboardPageMultiplier: 5,\n      keyboardDefaultStep: 10\n    }; // AriaFormat defaults to regular format, if any.\n\n    if (options.format && !options.ariaFormat) {\n      options.ariaFormat = options.format;\n    } // Run all options through a testing mechanism to ensure correct\n    // input. It should be noted that options might get modified to\n    // be handled properly. E.g. wrapping integers in arrays.\n\n\n    Object.keys(tests).forEach(function (name) {\n      // If the option isn\'t set, but it is required, throw an error.\n      if (!isSet(options[name]) && defaults[name] === undefined) {\n        if (tests[name].r) {\n          throw new Error("noUiSlider (" + VERSION + "): \'" + name + "\' is required.");\n        }\n\n        return true;\n      }\n\n      tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\n    }); // Forward pips options\n\n    parsed.pips = options.pips; // All recent browsers accept unprefixed transform.\n    // We need -ms- for IE9 and -webkit- for older Android;\n    // Assume use of -webkit- if unprefixed and -ms- are not supported.\n    // https://caniuse.com/#feat=transforms2d\n\n    var d = document.createElement("div");\n    var msPrefix = d.style.msTransform !== undefined;\n    var noPrefix = d.style.transform !== undefined;\n    parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform"; // Pips don\'t move, so we can place them using left/top.\n\n    var styles = [["left", "top"], ["right", "bottom"]];\n    parsed.style = styles[parsed.dir][parsed.ort];\n    return parsed;\n  } //endregion\n\n\n  function scope(target, options, originalOptions) {\n    var actions = getActions();\n    var supportsTouchActionNone = getSupportsTouchActionNone();\n    var supportsPassive = supportsTouchActionNone && getSupportsPassive(); // All variables local to \'scope\' are prefixed with \'scope_\'\n    // Slider DOM Nodes\n\n    var scope_Target = target;\n    var scope_Base;\n    var scope_Handles;\n    var scope_Connects;\n    var scope_Pips;\n    var scope_Tooltips; // Slider state values\n\n    var scope_Spectrum = options.spectrum;\n    var scope_Values = [];\n    var scope_Locations = [];\n    var scope_HandleNumbers = [];\n    var scope_ActiveHandlesCount = 0;\n    var scope_Events = {}; // Exposed API\n\n    var scope_Self; // Document Nodes\n\n    var scope_Document = target.ownerDocument;\n    var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\n    var scope_Body = scope_Document.body; // Pips constants\n\n    var PIPS_NONE = -1;\n    var PIPS_NO_VALUE = 0;\n    var PIPS_LARGE_VALUE = 1;\n    var PIPS_SMALL_VALUE = 2; // For horizontal sliders in standard ltr documents,\n    // make .noUi-origin overflow to the left so the document doesn\'t scroll.\n\n    var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100; // Creates a node, adds it to target, returns the new node.\n\n    function addNodeTo(addTarget, className) {\n      var div = scope_Document.createElement("div");\n\n      if (className) {\n        addClass(div, className);\n      }\n\n      addTarget.appendChild(div);\n      return div;\n    } // Append a origin to the base\n\n\n    function addOrigin(base, handleNumber) {\n      var origin = addNodeTo(base, options.cssClasses.origin);\n      var handle = addNodeTo(origin, options.cssClasses.handle);\n      addNodeTo(handle, options.cssClasses.touchArea);\n      handle.setAttribute("data-handle", handleNumber);\n\n      if (options.keyboardSupport) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\n        // 0 = focusable and reachable\n        handle.setAttribute("tabindex", "0");\n        handle.addEventListener("keydown", function (event) {\n          return eventKeydown(event, handleNumber);\n        });\n      }\n\n      handle.setAttribute("role", "slider");\n      handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");\n\n      if (handleNumber === 0) {\n        addClass(handle, options.cssClasses.handleLower);\n      } else if (handleNumber === options.handles - 1) {\n        addClass(handle, options.cssClasses.handleUpper);\n      }\n\n      return origin;\n    } // Insert nodes for connect elements\n\n\n    function addConnect(base, add) {\n      if (!add) {\n        return false;\n      }\n\n      return addNodeTo(base, options.cssClasses.connect);\n    } // Add handles to the slider base.\n\n\n    function addElements(connectOptions, base) {\n      var connectBase = addNodeTo(base, options.cssClasses.connects);\n      scope_Handles = [];\n      scope_Connects = [];\n      scope_Connects.push(addConnect(connectBase, connectOptions[0])); // [::::O====O====O====]\n      // connectOptions = [0, 1, 1, 1]\n\n      for (var i = 0; i < options.handles; i++) {\n        // Keep a list of all added handles.\n        scope_Handles.push(addOrigin(base, i));\n        scope_HandleNumbers[i] = i;\n        scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\n      }\n    } // Initialize a single slider.\n\n\n    function addSlider(addTarget) {\n      // Apply classes and data to the target.\n      addClass(addTarget, options.cssClasses.target);\n\n      if (options.dir === 0) {\n        addClass(addTarget, options.cssClasses.ltr);\n      } else {\n        addClass(addTarget, options.cssClasses.rtl);\n      }\n\n      if (options.ort === 0) {\n        addClass(addTarget, options.cssClasses.horizontal);\n      } else {\n        addClass(addTarget, options.cssClasses.vertical);\n      }\n\n      var textDirection = getComputedStyle(addTarget).direction;\n\n      if (textDirection === "rtl") {\n        addClass(addTarget, options.cssClasses.textDirectionRtl);\n      } else {\n        addClass(addTarget, options.cssClasses.textDirectionLtr);\n      }\n\n      return addNodeTo(addTarget, options.cssClasses.base);\n    }\n\n    function addTooltip(handle, handleNumber) {\n      if (!options.tooltips[handleNumber]) {\n        return false;\n      }\n\n      return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\n    }\n\n    function isSliderDisabled() {\n      return scope_Target.hasAttribute("disabled");\n    } // Disable the slider dragging if any handle is disabled\n\n\n    function isHandleDisabled(handleNumber) {\n      var handleOrigin = scope_Handles[handleNumber];\n      return handleOrigin.hasAttribute("disabled");\n    }\n\n    function removeTooltips() {\n      if (scope_Tooltips) {\n        removeEvent("update.tooltips");\n        scope_Tooltips.forEach(function (tooltip) {\n          if (tooltip) {\n            removeElement(tooltip);\n          }\n        });\n        scope_Tooltips = null;\n      }\n    } // The tooltips option is a shorthand for using the \'update\' event.\n\n\n    function tooltips() {\n      removeTooltips(); // Tooltips are added with options.tooltips in original order.\n\n      scope_Tooltips = scope_Handles.map(addTooltip);\n      bindEvent("update.tooltips", function (values, handleNumber, unencoded) {\n        if (!scope_Tooltips[handleNumber]) {\n          return;\n        }\n\n        var formattedValue = values[handleNumber];\n\n        if (options.tooltips[handleNumber] !== true) {\n          formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\n        }\n\n        scope_Tooltips[handleNumber].innerHTML = formattedValue;\n      });\n    }\n\n    function aria() {\n      bindEvent("update", function (values, handleNumber, unencoded, tap, positions) {\n        // Update Aria Values for all handles, as a change in one changes min and max values for the next.\n        scope_HandleNumbers.forEach(function (index) {\n          var handle = scope_Handles[index];\n          var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\n          var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\n          var now = positions[index]; // Formatted value for display\n\n          var text = options.ariaFormat.to(unencoded[index]); // Map to slider range values\n\n          min = scope_Spectrum.fromStepping(min).toFixed(1);\n          max = scope_Spectrum.fromStepping(max).toFixed(1);\n          now = scope_Spectrum.fromStepping(now).toFixed(1);\n          handle.children[0].setAttribute("aria-valuemin", min);\n          handle.children[0].setAttribute("aria-valuemax", max);\n          handle.children[0].setAttribute("aria-valuenow", now);\n          handle.children[0].setAttribute("aria-valuetext", text);\n        });\n      });\n    }\n\n    function getGroup(mode, values, stepped) {\n      // Use the range.\n      if (mode === "range" || mode === "steps") {\n        return scope_Spectrum.xVal;\n      }\n\n      if (mode === "count") {\n        if (values < 2) {\n          throw new Error("noUiSlider (" + VERSION + "): \'values\' (>= 2) required for mode \'count\'.");\n        } // Divide 0 - 100 in \'count\' parts.\n\n\n        var interval = values - 1;\n        var spread = 100 / interval;\n        values = []; // List these parts and have them handled as \'positions\'.\n\n        while (interval--) {\n          values[interval] = interval * spread;\n        }\n\n        values.push(100);\n        mode = "positions";\n      }\n\n      if (mode === "positions") {\n        // Map all percentages to on-range values.\n        return values.map(function (value) {\n          return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\n        });\n      }\n\n      if (mode === "values") {\n        // If the value must be stepped, it needs to be converted to a percentage first.\n        if (stepped) {\n          return values.map(function (value) {\n            // Convert to percentage, apply step, return to value.\n            return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\n          });\n        } // Otherwise, we can simply use the values.\n\n\n        return values;\n      }\n    }\n\n    function generateSpread(density, mode, group) {\n      function safeIncrement(value, increment) {\n        // Avoid floating point variance by dropping the smallest decimal places.\n        return (value + increment).toFixed(7) / 1;\n      }\n\n      var indexes = {};\n      var firstInRange = scope_Spectrum.xVal[0];\n      var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\n      var ignoreFirst = false;\n      var ignoreLast = false;\n      var prevPct = 0; // Create a copy of the group, sort it and filter away all duplicates.\n\n      group = unique(group.slice().sort(function (a, b) {\n        return a - b;\n      })); // Make sure the range starts with the first element.\n\n      if (group[0] !== firstInRange) {\n        group.unshift(firstInRange);\n        ignoreFirst = true;\n      } // Likewise for the last one.\n\n\n      if (group[group.length - 1] !== lastInRange) {\n        group.push(lastInRange);\n        ignoreLast = true;\n      }\n\n      group.forEach(function (current, index) {\n        // Get the current step and the lower + upper positions.\n        var step;\n        var i;\n        var q;\n        var low = current;\n        var high = group[index + 1];\n        var newPct;\n        var pctDifference;\n        var pctPos;\n        var type;\n        var steps;\n        var realSteps;\n        var stepSize;\n        var isSteps = mode === "steps"; // When using \'steps\' mode, use the provided steps.\n        // Otherwise, we\'ll step on to the next subrange.\n\n        if (isSteps) {\n          step = scope_Spectrum.xNumSteps[index];\n        } // Default to a \'full\' step.\n\n\n        if (!step) {\n          step = high - low;\n        } // Low can be 0, so test for false. If high is undefined,\n        // we are at the last subrange. Index 0 is already handled.\n\n\n        if (low === false || high === undefined) {\n          return;\n        } // Make sure step isn\'t 0, which would cause an infinite loop (#654)\n\n\n        step = Math.max(step, 0.0000001); // Find all steps in the subrange.\n\n        for (i = low; i <= high; i = safeIncrement(i, step)) {\n          // Get the percentage value for the current step,\n          // calculate the size for the subrange.\n          newPct = scope_Spectrum.toStepping(i);\n          pctDifference = newPct - prevPct;\n          steps = pctDifference / density;\n          realSteps = Math.round(steps); // This ratio represents the amount of percentage-space a point indicates.\n          // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\n          // Round the percentage offset to an even number, then divide by two\n          // to spread the offset on both sides of the range.\n\n          stepSize = pctDifference / realSteps; // Divide all points evenly, adding the correct number to this subrange.\n          // Run up to <= so that 100% gets a point, event if ignoreLast is set.\n\n          for (q = 1; q <= realSteps; q += 1) {\n            // The ratio between the rounded value and the actual size might be ~1% off.\n            // Correct the percentage offset by the number of points\n            // per subrange. density = 1 will result in 100 points on the\n            // full range, 2 for 50, 4 for 25, etc.\n            pctPos = prevPct + q * stepSize;\n            indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\n          } // Determine the point type.\n\n\n          type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE; // Enforce the \'ignoreFirst\' option by overwriting the type for 0.\n\n          if (!index && ignoreFirst && i !== high) {\n            type = 0;\n          }\n\n          if (!(i === high && ignoreLast)) {\n            // Mark the \'type\' of this point. 0 = plain, 1 = real value, 2 = step value.\n            indexes[newPct.toFixed(5)] = [i, type];\n          } // Update the percentage count.\n\n\n          prevPct = newPct;\n        }\n      });\n      return indexes;\n    }\n\n    function addMarking(spread, filterFunc, formatter) {\n      var element = scope_Document.createElement("div");\n      var valueSizeClasses = [];\n      valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;\n      valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;\n      valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;\n      var markerSizeClasses = [];\n      markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;\n      markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;\n      markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;\n      var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\n      var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\n      addClass(element, options.cssClasses.pips);\n      addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\n\n      function getClasses(type, source) {\n        var a = source === options.cssClasses.value;\n        var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\n        var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\n        return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];\n      }\n\n      function addSpread(offset, value, type) {\n        // Apply the filter function, if it is set.\n        type = filterFunc ? filterFunc(value, type) : type;\n\n        if (type === PIPS_NONE) {\n          return;\n        } // Add a marker for every point\n\n\n        var node = addNodeTo(element, false);\n        node.className = getClasses(type, options.cssClasses.marker);\n        node.style[options.style] = offset + "%"; // Values are only appended for points marked \'1\' or \'2\'.\n\n        if (type > PIPS_NO_VALUE) {\n          node = addNodeTo(element, false);\n          node.className = getClasses(type, options.cssClasses.value);\n          node.setAttribute("data-value", value);\n          node.style[options.style] = offset + "%";\n          node.innerHTML = formatter.to(value);\n        }\n      } // Append all points.\n\n\n      Object.keys(spread).forEach(function (offset) {\n        addSpread(offset, spread[offset][0], spread[offset][1]);\n      });\n      return element;\n    }\n\n    function removePips() {\n      if (scope_Pips) {\n        removeElement(scope_Pips);\n        scope_Pips = null;\n      }\n    }\n\n    function pips(grid) {\n      // Fix #669\n      removePips();\n      var mode = grid.mode;\n      var density = grid.density || 1;\n      var filter = grid.filter || false;\n      var values = grid.values || false;\n      var stepped = grid.stepped || false;\n      var group = getGroup(mode, values, stepped);\n      var spread = generateSpread(density, mode, group);\n      var format = grid.format || {\n        to: Math.round\n      };\n      scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\n      return scope_Pips;\n    } // Shorthand for base dimensions.\n\n\n    function baseSize() {\n      var rect = scope_Base.getBoundingClientRect();\n      var alt = "offset" + ["Width", "Height"][options.ort];\n      return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\n    } // Handler for attaching events trough a proxy.\n\n\n    function attachEvent(events, element, callback, data) {\n      // This function can be used to \'filter\' events to the slider.\n      // element is a node, not a nodeList\n      var method = function (e) {\n        e = fixEvent(e, data.pageOffset, data.target || element); // fixEvent returns false if this event has a different target\n        // when handling (multi-) touch events;\n\n        if (!e) {\n          return false;\n        } // doNotReject is passed by all end events to make sure released touches\n        // are not rejected, leaving the slider "stuck" to the cursor;\n\n\n        if (isSliderDisabled() && !data.doNotReject) {\n          return false;\n        } // Stop if an active \'tap\' transition is taking place.\n\n\n        if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\n          return false;\n        } // Ignore right or middle clicks on start #454\n\n\n        if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\n          return false;\n        } // Ignore right or middle clicks on start #454\n\n\n        if (data.hover && e.buttons) {\n          return false;\n        } // \'supportsPassive\' is only true if a browser also supports touch-action: none in CSS.\n        // iOS safari does not, so it doesn\'t get to benefit from passive scrolling. iOS does support\n        // touch-action: manipulation, but that allows panning, which breaks\n        // sliders after zooming/on non-responsive pages.\n        // See: https://bugs.webkit.org/show_bug.cgi?id=133112\n\n\n        if (!supportsPassive) {\n          e.preventDefault();\n        }\n\n        e.calcPoint = e.points[options.ort]; // Call the event handler with the event [ and additional data ].\n\n        callback(e, data);\n      };\n\n      var methods = []; // Bind a closure on the target for every event type.\n\n      events.split(" ").forEach(function (eventName) {\n        element.addEventListener(eventName, method, supportsPassive ? {\n          passive: true\n        } : false);\n        methods.push([eventName, method]);\n      });\n      return methods;\n    } // Provide a clean event with standardized offset values.\n\n\n    function fixEvent(e, pageOffset, eventTarget) {\n      // Filter the event to register the type, which can be\n      // touch, mouse or pointer. Offset changes need to be\n      // made on an event specific basis.\n      var touch = e.type.indexOf("touch") === 0;\n      var mouse = e.type.indexOf("mouse") === 0;\n      var pointer = e.type.indexOf("pointer") === 0;\n      var x;\n      var y; // IE10 implemented pointer events with a prefix;\n\n      if (e.type.indexOf("MSPointer") === 0) {\n        pointer = true;\n      } // The only thing one handle should be concerned about is the touches that originated on top of it.\n\n\n      if (touch) {\n        // Returns true if a touch originated on the target.\n        var isTouchOnTarget = function (checkTouch) {\n          return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target) || checkTouch.target.shadowRoot && checkTouch.target.shadowRoot.contains(eventTarget);\n        }; // In the case of touchstart events, we need to make sure there is still no more than one\n        // touch on the target so we look amongst all touches.\n\n\n        if (e.type === "touchstart") {\n          var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget); // Do not support more than one touch per handle.\n\n          if (targetTouches.length > 1) {\n            return false;\n          }\n\n          x = targetTouches[0].pageX;\n          y = targetTouches[0].pageY;\n        } else {\n          // In the other cases, find on changedTouches is enough.\n          var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget); // Cancel if the target touch has not moved.\n\n          if (!targetTouch) {\n            return false;\n          }\n\n          x = targetTouch.pageX;\n          y = targetTouch.pageY;\n        }\n      }\n\n      pageOffset = pageOffset || getPageOffset(scope_Document);\n\n      if (mouse || pointer) {\n        x = e.clientX + pageOffset.x;\n        y = e.clientY + pageOffset.y;\n      }\n\n      e.pageOffset = pageOffset;\n      e.points = [x, y];\n      e.cursor = mouse || pointer; // Fix #435\n\n      return e;\n    } // Translate a coordinate in the document to a percentage on the slider\n\n\n    function calcPointToPercentage(calcPoint) {\n      var location = calcPoint - offset(scope_Base, options.ort);\n      var proposal = location * 100 / baseSize(); // Clamp proposal between 0% and 100%\n      // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\n      // are used (e.g. contained handles feature)\n\n      proposal = limit(proposal);\n      return options.dir ? 100 - proposal : proposal;\n    } // Find handle closest to a certain percentage on the slider\n\n\n    function getClosestHandle(clickedPosition) {\n      var smallestDifference = 100;\n      var handleNumber = false;\n      scope_Handles.forEach(function (handle, index) {\n        // Disabled handles are ignored\n        if (isHandleDisabled(index)) {\n          return;\n        }\n\n        var handlePosition = scope_Locations[index];\n        var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition); // Initial state\n\n        var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100; // Difference with this handle is smaller than the previously checked handle\n\n        var isCloser = differenceWithThisHandle < smallestDifference;\n        var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;\n\n        if (isCloser || isCloserAfter || clickAtEdge) {\n          handleNumber = index;\n          smallestDifference = differenceWithThisHandle;\n        }\n      });\n      return handleNumber;\n    } // Fire \'end\' when a mouse or pen leaves the document.\n\n\n    function documentLeave(event, data) {\n      if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {\n        eventEnd(event, data);\n      }\n    } // Handle movement on document for handle and range drag.\n\n\n    function eventMove(event, data) {\n      // Fix #498\n      // Check value of .buttons in \'start\' to work around a bug in IE10 mobile (data.buttonsProperty).\n      // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\n      // IE9 has .buttons and .which zero on mousemove.\n      // Firefox breaks the spec MDN defines.\n      if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\n        return eventEnd(event, data);\n      } // Check if we are moving up or down\n\n\n      var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint); // Convert the movement into a percentage of the slider width/height\n\n      var proposal = movement * 100 / data.baseSize;\n      moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\n    } // Unbind move events on document, call callbacks.\n\n\n    function eventEnd(event, data) {\n      // The handle is no longer active, so remove the class.\n      if (data.handle) {\n        removeClass(data.handle, options.cssClasses.active);\n        scope_ActiveHandlesCount -= 1;\n      } // Unbind the move and end events, which are added on \'start\'.\n\n\n      data.listeners.forEach(function (c) {\n        scope_DocumentElement.removeEventListener(c[0], c[1]);\n      });\n\n      if (scope_ActiveHandlesCount === 0) {\n        // Remove dragging class.\n        removeClass(scope_Target, options.cssClasses.drag);\n        setZindex(); // Remove cursor styles and text-selection events bound to the body.\n\n        if (event.cursor) {\n          scope_Body.style.cursor = "";\n          scope_Body.removeEventListener("selectstart", preventDefault);\n        }\n      }\n\n      data.handleNumbers.forEach(function (handleNumber) {\n        fireEvent("change", handleNumber);\n        fireEvent("set", handleNumber);\n        fireEvent("end", handleNumber);\n      });\n    } // Bind move events on document.\n\n\n    function eventStart(event, data) {\n      console.log(\'Event start\'); // Ignore event if any handle is disabled\n\n      if (data.handleNumbers.some(isHandleDisabled)) {\n        return false;\n      }\n\n      var handle;\n\n      if (data.handleNumbers.length === 1) {\n        var handleOrigin = scope_Handles[data.handleNumbers[0]];\n        handle = handleOrigin.children[0];\n        scope_ActiveHandlesCount += 1; // Mark the handle as \'active\' so it can be styled.\n\n        addClass(handle, options.cssClasses.active);\n      } // A drag should never propagate up to the \'tap\' event.\n\n\n      event.stopPropagation(); // Record the event listeners.\n\n      var listeners = []; // Attach the move and end events.\n\n      var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\n        // The event target has changed so we need to propagate the original one so that we keep\n        // relying on it to extract target touches.\n        target: event.target,\n        handle: handle,\n        listeners: listeners,\n        startCalcPoint: event.calcPoint,\n        baseSize: baseSize(),\n        pageOffset: event.pageOffset,\n        handleNumbers: data.handleNumbers,\n        buttonsProperty: event.buttons,\n        locations: scope_Locations.slice()\n      });\n      var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\n        target: event.target,\n        handle: handle,\n        listeners: listeners,\n        doNotReject: true,\n        handleNumbers: data.handleNumbers\n      });\n      var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {\n        target: event.target,\n        handle: handle,\n        listeners: listeners,\n        doNotReject: true,\n        handleNumbers: data.handleNumbers\n      }); // We want to make sure we pushed the listeners in the listener list rather than creating\n      // a new one as it has already been passed to the event handlers.\n\n      listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)); // Text selection isn\'t an issue on touch devices,\n      // so adding cursor styles can be skipped.\n\n      if (event.cursor) {\n        // Prevent the \'I\' cursor and extend the range-drag cursor.\n        scope_Body.style.cursor = getComputedStyle(event.target).cursor; // Mark the target with a dragging state.\n\n        if (scope_Handles.length > 1) {\n          addClass(scope_Target, options.cssClasses.drag);\n        } // Prevent text selection when dragging the handles.\n        // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\n        // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\n        // meaning the only holdout is iOS Safari. This doesn\'t matter: text selection isn\'t triggered there.\n        // The \'cursor\' flag is false.\n        // See: http://caniuse.com/#search=selectstart\n\n\n        scope_Body.addEventListener("selectstart", preventDefault, false);\n      }\n\n      data.handleNumbers.forEach(function (handleNumber) {\n        fireEvent("start", handleNumber);\n      });\n    } // Move closest handle to tapped location.\n\n\n    function eventTap(event) {\n      // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with\n      // the slider. They appear to be of type MouseEvent, yet they don\'t have usual properties set. Ignore tap\n      // events that have no touches or buttons associated with them.\n      if (!event.buttons && !event.touches) {\n        return false;\n      } // The tap event shouldn\'t propagate up\n\n\n      event.stopPropagation();\n      var proposal = calcPointToPercentage(event.calcPoint);\n      var handleNumber = getClosestHandle(proposal); // Tackle the case that all handles are \'disabled\'.\n\n      if (handleNumber === false) {\n        return false;\n      } // Flag the slider as it is now in a transitional state.\n      // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\n\n\n      if (!options.events.snap) {\n        addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n      }\n\n      setHandle(handleNumber, proposal, true, true);\n      setZindex();\n      fireEvent("slide", handleNumber, true);\n      fireEvent("update", handleNumber, true);\n      fireEvent("change", handleNumber, true);\n      fireEvent("set", handleNumber, true);\n\n      if (options.events.snap) {\n        eventStart(event, {\n          handleNumbers: [handleNumber]\n        });\n      }\n    } // Fires a \'hover\' event for a hovered mouse/pen position.\n\n\n    function eventHover(event) {\n      var proposal = calcPointToPercentage(event.calcPoint);\n      var to = scope_Spectrum.getStep(proposal);\n      var value = scope_Spectrum.fromStepping(to);\n      Object.keys(scope_Events).forEach(function (targetEvent) {\n        if ("hover" === targetEvent.split(".")[0]) {\n          scope_Events[targetEvent].forEach(function (callback) {\n            callback.call(scope_Self, value);\n          });\n        }\n      });\n    } // Handles keydown on focused handles\n    // Don\'t move the document when pressing arrow keys on focused handles\n\n\n    function eventKeydown(event, handleNumber) {\n      if (isSliderDisabled() || isHandleDisabled(handleNumber)) {\n        return false;\n      }\n\n      var horizontalKeys = ["Left", "Right"];\n      var verticalKeys = ["Down", "Up"];\n      var largeStepKeys = ["PageDown", "PageUp"];\n      var edgeKeys = ["Home", "End"];\n\n      if (options.dir && !options.ort) {\n        // On an right-to-left slider, the left and right keys act inverted\n        horizontalKeys.reverse();\n      } else if (options.ort && !options.dir) {\n        // On a top-to-bottom slider, the up and down keys act inverted\n        verticalKeys.reverse();\n        largeStepKeys.reverse();\n      } // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\n\n      var key = event.key.replace("Arrow", "");\n      var isLargeDown = key === largeStepKeys[0];\n      var isLargeUp = key === largeStepKeys[1];\n      var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;\n      var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;\n      var isMin = key === edgeKeys[0];\n      var isMax = key === edgeKeys[1];\n\n      if (!isDown && !isUp && !isMin && !isMax) {\n        return true;\n      }\n\n      event.preventDefault();\n      var to;\n\n      if (isUp || isDown) {\n        var multiplier = options.keyboardPageMultiplier;\n        var direction = isDown ? 0 : 1;\n        var steps = getNextStepsForHandle(handleNumber);\n        var step = steps[direction]; // At the edge of a slider, do nothing\n\n        if (step === null) {\n          return false;\n        } // No step set, use the default of 10% of the sub-range\n\n\n        if (step === false) {\n          step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);\n        }\n\n        if (isLargeUp || isLargeDown) {\n          step *= multiplier;\n        } // Step over zero-length ranges (#948);\n\n\n        step = Math.max(step, 0.0000001); // Decrement for down steps\n\n        step = (isDown ? -1 : 1) * step;\n        to = scope_Values[handleNumber] + step;\n      } else if (isMax) {\n        // End key\n        to = options.spectrum.xVal[options.spectrum.xVal.length - 1];\n      } else {\n        // Home key\n        to = options.spectrum.xVal[0];\n      }\n\n      setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);\n      fireEvent("slide", handleNumber);\n      fireEvent("update", handleNumber);\n      fireEvent("change", handleNumber);\n      fireEvent("set", handleNumber);\n      return false;\n    } // Attach events to several slider parts.\n\n\n    function bindSliderEvents(behaviour) {\n      // Attach the standard drag event to the handles.\n      if (!behaviour.fixed) {\n        scope_Handles.forEach(function (handle, index) {\n          // These events are only bound to the visual handle\n          // element, not the \'real\' origin element.\n          attachEvent(actions.start, handle.children[0], eventStart, {\n            handleNumbers: [index]\n          });\n        });\n      } // Attach the tap event to the slider base.\n\n\n      if (behaviour.tap) {\n        attachEvent(actions.start, scope_Base, eventTap, {});\n      } // Fire hover events\n\n\n      if (behaviour.hover) {\n        attachEvent(actions.move, scope_Base, eventHover, {\n          hover: true\n        });\n      } // Make the range draggable.\n\n\n      if (behaviour.drag) {\n        scope_Connects.forEach(function (connect, index) {\n          if (connect === false || index === 0 || index === scope_Connects.length - 1) {\n            return;\n          }\n\n          var handleBefore = scope_Handles[index - 1];\n          var handleAfter = scope_Handles[index];\n          var eventHolders = [connect];\n          addClass(connect, options.cssClasses.draggable); // When the range is fixed, the entire range can\n          // be dragged by the handles. The handle in the first\n          // origin will propagate the start event upward,\n          // but it needs to be bound manually on the other.\n\n          if (behaviour.fixed) {\n            eventHolders.push(handleBefore.children[0]);\n            eventHolders.push(handleAfter.children[0]);\n          }\n\n          eventHolders.forEach(function (eventHolder) {\n            attachEvent(actions.start, eventHolder, eventStart, {\n              handles: [handleBefore, handleAfter],\n              handleNumbers: [index - 1, index]\n            });\n          });\n        });\n      }\n    } // Attach an event to this slider, possibly including a namespace\n\n\n    function bindEvent(namespacedEvent, callback) {\n      scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\n      scope_Events[namespacedEvent].push(callback); // If the event bound is \'update,\' fire it immediately for all handles.\n\n      if (namespacedEvent.split(".")[0] === "update") {\n        scope_Handles.forEach(function (a, index) {\n          fireEvent("update", index);\n        });\n      }\n    } // Undo attachment of event\n\n\n    function removeEvent(namespacedEvent) {\n      var event = namespacedEvent && namespacedEvent.split(".")[0];\n      var namespace = event && namespacedEvent.substring(event.length);\n      Object.keys(scope_Events).forEach(function (bind) {\n        var tEvent = bind.split(".")[0];\n        var tNamespace = bind.substring(tEvent.length);\n\n        if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\n          delete scope_Events[bind];\n        }\n      });\n    } // External event handling\n\n\n    function fireEvent(eventName, handleNumber, tap) {\n      Object.keys(scope_Events).forEach(function (targetEvent) {\n        var eventType = targetEvent.split(".")[0];\n\n        if (eventName === eventType) {\n          scope_Events[targetEvent].forEach(function (callback) {\n            callback.call( // Use the slider public API as the scope (\'this\')\n            scope_Self, // Return values as array, so arg_1[arg_2] is always valid.\n            scope_Values.map(options.format.to), // Handle index, 0 or 1\n            handleNumber, // Un-formatted slider values\n            scope_Values.slice(), // Event is fired by tap, true or false\n            tap || false, // Left offset of the handle, in relation to the slider\n            scope_Locations.slice(), // add the slider public API to an accessible parameter when this is unavailable\n            scope_Self);\n          });\n        }\n      });\n    } // Split out the handle positioning logic so the Move event can use it, too\n\n\n    function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {\n      var distance; // For sliders with multiple handles, limit movement to the other handle.\n      // Apply the margin option by adding it to the handle positions.\n\n      if (scope_Handles.length > 1 && !options.events.unconstrained) {\n        if (lookBackward && handleNumber > 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, 0);\n          to = Math.max(to, distance);\n        }\n\n        if (lookForward && handleNumber < scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, 1);\n          to = Math.min(to, distance);\n        }\n      } // The limit option has the opposite effect, limiting handles to a\n      // maximum distance from another. Limit must be > 0, as otherwise\n      // handles would be unmovable.\n\n\n      if (scope_Handles.length > 1 && options.limit) {\n        if (lookBackward && handleNumber > 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, 0);\n          to = Math.min(to, distance);\n        }\n\n        if (lookForward && handleNumber < scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, 1);\n          to = Math.max(to, distance);\n        }\n      } // The padding option keeps the handles a certain distance from the\n      // edges of the slider. Padding must be > 0.\n\n\n      if (options.padding) {\n        if (handleNumber === 0) {\n          distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], 0);\n          to = Math.max(to, distance);\n        }\n\n        if (handleNumber === scope_Handles.length - 1) {\n          distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], 1);\n          to = Math.min(to, distance);\n        }\n      }\n\n      to = scope_Spectrum.getStep(to); // Limit percentage to the 0 - 100 range\n\n      to = limit(to); // Return false if handle can\'t move\n\n      if (to === reference[handleNumber] && !getValue) {\n        return false;\n      }\n\n      return to;\n    } // Uses slider orientation to create CSS rules. a = base value;\n\n\n    function inRuleOrder(v, a) {\n      var o = options.ort;\n      return (o ? a : v) + ", " + (o ? v : a);\n    } // Moves handle(s) by a percentage\n    // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\n\n\n    function moveHandles(upward, proposal, locations, handleNumbers) {\n      var proposals = locations.slice();\n      var b = [!upward, upward];\n      var f = [upward, !upward]; // Copy handleNumbers so we don\'t change the dataset\n\n      handleNumbers = handleNumbers.slice(); // Check to see which handle is \'leading\'.\n      // If that one can\'t move the second can\'t either.\n\n      if (upward) {\n        handleNumbers.reverse();\n      } // Step 1: get the maximum percentage that any of the handles can move\n\n\n      if (handleNumbers.length > 1) {\n        handleNumbers.forEach(function (handleNumber, o) {\n          var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false); // Stop if one of the handles can\'t move.\n\n          if (to === false) {\n            proposal = 0;\n          } else {\n            proposal = to - proposals[handleNumber];\n            proposals[handleNumber] = to;\n          }\n        });\n      } // If using one handle, check backward AND forward\n      else {\n          b = f = [true];\n        }\n\n      var state = false; // Step 2: Try to set the handles with the found percentage\n\n      handleNumbers.forEach(function (handleNumber, o) {\n        state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\n      }); // Step 3: If a handle moved, fire events\n\n      if (state) {\n        handleNumbers.forEach(function (handleNumber) {\n          fireEvent("update", handleNumber);\n          fireEvent("slide", handleNumber);\n        });\n      }\n    } // Takes a base value and an offset. This offset is used for the connect bar size.\n    // In the initial design for this feature, the origin element was 1% wide.\n    // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\n    // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\n\n\n    function transformDirection(a, b) {\n      return options.dir ? 100 - a - b : a;\n    } // Updates scope_Locations and scope_Values, updates visual state\n\n\n    function updateHandlePosition(handleNumber, to) {\n      // Update locations.\n      scope_Locations[handleNumber] = to; // Convert the value to the slider stepping/range.\n\n      scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\n      var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);\n      var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";\n      scope_Handles[handleNumber].style[options.transformRule] = translateRule;\n      updateConnect(handleNumber);\n      updateConnect(handleNumber + 1);\n    } // Handles before the slider middle are stacked later = higher,\n    // Handles after the middle later is lower\n    // [[7] [8] .......... | .......... [5] [4]\n\n\n    function setZindex() {\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\n        var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\n        scope_Handles[handleNumber].style.zIndex = zIndex;\n      });\n    } // Test suggested values and apply margin, step.\n\n\n    function setHandle(handleNumber, to, lookBackward, lookForward) {\n      to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\n\n      if (to === false) {\n        return false;\n      }\n\n      updateHandlePosition(handleNumber, to);\n      return true;\n    } // Updates style attribute for connect nodes\n\n\n    function updateConnect(index) {\n      // Skip connects set to false\n      if (!scope_Connects[index]) {\n        return;\n      }\n\n      var l = 0;\n      var h = 100;\n\n      if (index !== 0) {\n        l = scope_Locations[index - 1];\n      }\n\n      if (index !== scope_Connects.length - 1) {\n        h = scope_Locations[index];\n      } // We use two rules:\n      // \'translate\' to change the left/top offset;\n      // \'scale\' to change the width of the element;\n      // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\n\n\n      var connectWidth = h - l;\n      var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";\n      var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";\n      scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;\n    } // Parses value passed to .set method. Returns current value if not parse-able.\n\n\n    function resolveToValue(to, handleNumber) {\n      // Setting with null indicates an \'ignore\'.\n      // Inputting \'false\' is invalid.\n      if (to === null || to === false || to === undefined) {\n        return scope_Locations[handleNumber];\n      } // If a formatted number was passed, attempt to decode it.\n\n\n      if (typeof to === "number") {\n        to = String(to);\n      }\n\n      to = options.format.from(to);\n      to = scope_Spectrum.toStepping(to); // If parsing the number failed, use the current value.\n\n      if (to === false || isNaN(to)) {\n        return scope_Locations[handleNumber];\n      }\n\n      return to;\n    } // Set the slider value.\n\n\n    function valueSet(input, fireSetEvent) {\n      var values = asArray(input);\n      var isInit = scope_Locations[0] === undefined; // Event fires by default\n\n      fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent; // Animation is optional.\n      // Make sure the initial values were set before using animated placement.\n\n      if (options.animate && !isInit) {\n        addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n      } // First pass, without lookAhead but with lookBackward. Values are set from left to right.\n\n\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false);\n      });\n      var i = scope_HandleNumbers.length === 1 ? 0 : 1; // Secondary passes. Now that all base values are set, apply constraints.\n      // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)\n\n      for (; i < scope_HandleNumbers.length; ++i) {\n        scope_HandleNumbers.forEach(function (handleNumber) {\n          setHandle(handleNumber, scope_Locations[handleNumber], true, true);\n        });\n      }\n\n      setZindex();\n      scope_HandleNumbers.forEach(function (handleNumber) {\n        fireEvent("update", handleNumber); // Fire the event only for handles that received a new value, as per #579\n\n        if (values[handleNumber] !== null && fireSetEvent) {\n          fireEvent("set", handleNumber);\n        }\n      });\n    } // Reset slider to initial values\n\n\n    function valueReset(fireSetEvent) {\n      valueSet(options.start, fireSetEvent);\n    } // Set value for a single handle\n\n\n    function valueSetHandle(handleNumber, value, fireSetEvent) {\n      // Ensure numeric input\n      handleNumber = Number(handleNumber);\n\n      if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\n        throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);\n      } // Look both backward and forward, since we don\'t want this handle to "push" other handles (#960);\n\n\n      setHandle(handleNumber, resolveToValue(value, handleNumber), true, true);\n      fireEvent("update", handleNumber);\n\n      if (fireSetEvent) {\n        fireEvent("set", handleNumber);\n      }\n    } // Get the slider value.\n\n\n    function valueGet() {\n      var values = scope_Values.map(options.format.to); // If only one handle is used, return a single value.\n\n      if (values.length === 1) {\n        return values[0];\n      }\n\n      return values;\n    } // Removes classes from the root and empties it.\n\n\n    function destroy() {\n      for (var key in options.cssClasses) {\n        if (!options.cssClasses.hasOwnProperty(key)) {\n          continue;\n        }\n\n        removeClass(scope_Target, options.cssClasses[key]);\n      }\n\n      while (scope_Target.firstChild) {\n        scope_Target.removeChild(scope_Target.firstChild);\n      }\n\n      delete scope_Target.noUiSlider;\n    }\n\n    function getNextStepsForHandle(handleNumber) {\n      var location = scope_Locations[handleNumber];\n      var nearbySteps = scope_Spectrum.getNearbySteps(location);\n      var value = scope_Values[handleNumber];\n      var increment = nearbySteps.thisStep.step;\n      var decrement = null; // If snapped, directly use defined step value\n\n      if (options.snap) {\n        return [value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null];\n      } // If the next value in this step moves into the next step,\n      // the increment is the start of the next step - the current value\n\n\n      if (increment !== false) {\n        if (value + increment > nearbySteps.stepAfter.startValue) {\n          increment = nearbySteps.stepAfter.startValue - value;\n        }\n      } // If the value is beyond the starting point\n\n\n      if (value > nearbySteps.thisStep.startValue) {\n        decrement = nearbySteps.thisStep.step;\n      } else if (nearbySteps.stepBefore.step === false) {\n        decrement = false;\n      } // If a handle is at the start of a step, it always steps back into the previous step first\n      else {\n          decrement = value - nearbySteps.stepBefore.highestStep;\n        } // Now, if at the slider edges, there is no in/decrement\n\n\n      if (location === 100) {\n        increment = null;\n      } else if (location === 0) {\n        decrement = null;\n      } // As per #391, the comparison for the decrement step can have some rounding issues.\n\n\n      var stepDecimals = scope_Spectrum.countStepDecimals(); // Round per #391\n\n      if (increment !== null && increment !== false) {\n        increment = Number(increment.toFixed(stepDecimals));\n      }\n\n      if (decrement !== null && decrement !== false) {\n        decrement = Number(decrement.toFixed(stepDecimals));\n      }\n\n      return [decrement, increment];\n    } // Get the current step size for the slider.\n\n\n    function getNextSteps() {\n      return scope_HandleNumbers.map(getNextStepsForHandle);\n    } // Updateable: margin, limit, padding, step, range, animate, snap\n\n\n    function updateOptions(optionsToUpdate, fireSetEvent) {\n      // Spectrum is created using the range, snap, direction and step options.\n      // \'snap\' and \'step\' can be updated.\n      // If \'snap\' and \'step\' are not passed, they should remain unchanged.\n      var v = valueGet();\n      var updateAble = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"]; // Only change options that we\'re actually passed to update.\n\n      updateAble.forEach(function (name) {\n        // Check for undefined. null removes the value.\n        if (optionsToUpdate[name] !== undefined) {\n          originalOptions[name] = optionsToUpdate[name];\n        }\n      });\n      var newOptions = testOptions(originalOptions); // Load new options into the slider state\n\n      updateAble.forEach(function (name) {\n        if (optionsToUpdate[name] !== undefined) {\n          options[name] = newOptions[name];\n        }\n      });\n      scope_Spectrum = newOptions.spectrum; // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\n\n      options.margin = newOptions.margin;\n      options.limit = newOptions.limit;\n      options.padding = newOptions.padding; // Update pips, removes existing.\n\n      if (options.pips) {\n        pips(options.pips);\n      } else {\n        removePips();\n      } // Update tooltips, removes existing.\n\n\n      if (options.tooltips) {\n        tooltips();\n      } else {\n        removeTooltips();\n      } // Invalidate the current positioning so valueSet forces an update.\n\n\n      scope_Locations = [];\n      valueSet(optionsToUpdate.start || v, fireSetEvent);\n    } // Initialization steps\n\n\n    function setupSlider() {\n      // Create the base element, initialize HTML and set classes.\n      // Add handles and connect elements.\n      scope_Base = addSlider(scope_Target);\n      addElements(options.connect, scope_Base); // Attach user events.\n\n      bindSliderEvents(options.events); // Use the public value method to set the start values.\n\n      valueSet(options.start);\n\n      if (options.pips) {\n        pips(options.pips);\n      }\n\n      if (options.tooltips) {\n        tooltips();\n      }\n\n      aria();\n    }\n\n    setupSlider(); // noinspection JSUnusedGlobalSymbols\n\n    scope_Self = {\n      destroy: destroy,\n      steps: getNextSteps,\n      on: bindEvent,\n      off: removeEvent,\n      get: valueGet,\n      set: valueSet,\n      setHandle: valueSetHandle,\n      reset: valueReset,\n      // Exposed for unit testing, don\'t use this in your application.\n      __moveHandles: function (a, b, c) {\n        moveHandles(a, b, scope_Locations, c);\n      },\n      options: originalOptions,\n      // Issue #600, #678\n      updateOptions: updateOptions,\n      target: scope_Target,\n      // Issue #597\n      removePips: removePips,\n      removeTooltips: removeTooltips,\n      getTooltips: function () {\n        return scope_Tooltips;\n      },\n      getOrigins: function () {\n        return scope_Handles;\n      },\n      pips: pips // Issue #594\n\n    };\n    return scope_Self;\n  } // Run the standard initializer\n\n\n  function initialize(target, originalOptions) {\n    if (!target || !target.nodeName) {\n      throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);\n    } // Throw an error if the slider was already initialized.\n\n\n    if (target.noUiSlider) {\n      throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");\n    } // Test the options and create the slider environment;\n\n\n    var options = testOptions(originalOptions, target);\n    var api = scope(target, options, originalOptions);\n    target.noUiSlider = api;\n    return api;\n  } // Use an object instead of a function for future expandability;\n\n\n  return {\n    // Exposed for unit testing, don\'t use this in your application.\n    __spectrum: Spectrum,\n    version: VERSION,\n    // A reference to the default classes, allows global changes.\n    // Use the cssClasses option for changes to one slider.\n    cssClasses: cssClasses,\n    create: initialize\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanM/ZTlmYSJdLCJuYW1lcyI6WyJmYWN0b3J5IiwiZGVmaW5lIiwiVkVSU0lPTiIsImlzVmFsaWRGb3JtYXR0ZXIiLCJlbnRyeSIsInRvIiwiZnJvbSIsInJlbW92ZUVsZW1lbnQiLCJlbCIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsImlzU2V0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJwcmV2ZW50RGVmYXVsdCIsImUiLCJ1bmlxdWUiLCJhcnJheSIsImZpbHRlciIsImEiLCJjbG9zZXN0IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0IiwiZWxlbSIsIm9yaWVudGF0aW9uIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRFbGVtZW50IiwicGFnZU9mZnNldCIsImdldFBhZ2VPZmZzZXQiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwieCIsInRvcCIsInkiLCJjbGllbnRUb3AiLCJsZWZ0IiwiY2xpZW50TGVmdCIsImlzTnVtZXJpYyIsImlzTmFOIiwiaXNGaW5pdGUiLCJhZGRDbGFzc0ZvciIsImVsZW1lbnQiLCJjbGFzc05hbWUiLCJkdXJhdGlvbiIsImFkZENsYXNzIiwic2V0VGltZW91dCIsInJlbW92ZUNsYXNzIiwibGltaXQiLCJtYXgiLCJtaW4iLCJhc0FycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiY291bnREZWNpbWFscyIsIm51bVN0ciIsIlN0cmluZyIsInBpZWNlcyIsInNwbGl0IiwibGVuZ3RoIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwicmVwbGFjZSIsIlJlZ0V4cCIsImpvaW4iLCJoYXNDbGFzcyIsImNvbnRhaW5zIiwic3VwcG9ydFBhZ2VPZmZzZXQiLCJ3aW5kb3ciLCJwYWdlWE9mZnNldCIsImlzQ1NTMUNvbXBhdCIsImNvbXBhdE1vZGUiLCJzY3JvbGxMZWZ0IiwiYm9keSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiZ2V0QWN0aW9ucyIsInBvaW50ZXJFbmFibGVkIiwic3RhcnQiLCJtb3ZlIiwiZW5kIiwibXNQb2ludGVyRW5hYmxlZCIsImdldFN1cHBvcnRzUGFzc2l2ZSIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSIsIkNTUyIsInN1cHBvcnRzIiwic3ViUmFuZ2VSYXRpbyIsInBhIiwicGIiLCJmcm9tUGVyY2VudGFnZSIsInJhbmdlIiwic3RhcnRSYW5nZSIsInRvUGVyY2VudGFnZSIsImFicyIsImlzUGVyY2VudGFnZSIsImdldEoiLCJhcnIiLCJqIiwidG9TdGVwcGluZyIsInhWYWwiLCJ4UGN0Iiwic2xpY2UiLCJ2YSIsInZiIiwiZnJvbVN0ZXBwaW5nIiwiZ2V0U3RlcCIsInhTdGVwcyIsInNuYXAiLCJiIiwiaGFuZGxlRW50cnlQb2ludCIsImluZGV4IiwidGhhdCIsInBlcmNlbnRhZ2UiLCJFcnJvciIsInBhcnNlRmxvYXQiLCJwdXNoIiwieEhpZ2hlc3RDb21wbGV0ZVN0ZXAiLCJoYW5kbGVTdGVwUG9pbnQiLCJpIiwibiIsInRvdGFsU3RlcHMiLCJ4TnVtU3RlcHMiLCJoaWdoZXN0U3RlcCIsImNlaWwiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwic3RlcCIsIlNwZWN0cnVtIiwic2luZ2xlU3RlcCIsIm9yZGVyZWQiLCJoYXNPd25Qcm9wZXJ0eSIsInNvcnQiLCJwcm90b3R5cGUiLCJnZXREaXN0YW5jZSIsImRpc3RhbmNlcyIsImdldEFic29sdXRlRGlzdGFuY2UiLCJkaXJlY3Rpb24iLCJ4UGN0X2luZGV4Iiwic3RhcnRfZmFjdG9yIiwicmVzdF9mYWN0b3IiLCJyZXN0X3JlbF9kaXN0YW5jZSIsInJhbmdlX3BjdCIsInJlbF9yYW5nZV9kaXN0YW5jZSIsImFic19kaXN0YW5jZV9jb3VudGVyIiwicmFuZ2VfY291bnRlciIsImdldERlZmF1bHRTdGVwIiwiaXNEb3duIiwic2l6ZSIsImdldE5lYXJieVN0ZXBzIiwic3RlcEJlZm9yZSIsInN0YXJ0VmFsdWUiLCJ0aGlzU3RlcCIsInN0ZXBBZnRlciIsImNvdW50U3RlcERlY2ltYWxzIiwic3RlcERlY2ltYWxzIiwibWFwIiwiYXBwbHkiLCJjb252ZXJ0IiwiZGVmYXVsdEZvcm1hdHRlciIsImNzc0NsYXNzZXMiLCJ0YXJnZXQiLCJiYXNlIiwib3JpZ2luIiwiaGFuZGxlIiwiaGFuZGxlTG93ZXIiLCJoYW5kbGVVcHBlciIsInRvdWNoQXJlYSIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImJhY2tncm91bmQiLCJjb25uZWN0IiwiY29ubmVjdHMiLCJsdHIiLCJydGwiLCJ0ZXh0RGlyZWN0aW9uTHRyIiwidGV4dERpcmVjdGlvblJ0bCIsImRyYWdnYWJsZSIsImRyYWciLCJ0YXAiLCJhY3RpdmUiLCJ0b29sdGlwIiwicGlwcyIsInBpcHNIb3Jpem9udGFsIiwicGlwc1ZlcnRpY2FsIiwibWFya2VyIiwibWFya2VySG9yaXpvbnRhbCIsIm1hcmtlclZlcnRpY2FsIiwibWFya2VyTm9ybWFsIiwibWFya2VyTGFyZ2UiLCJtYXJrZXJTdWIiLCJ2YWx1ZUhvcml6b250YWwiLCJ2YWx1ZVZlcnRpY2FsIiwidmFsdWVOb3JtYWwiLCJ2YWx1ZUxhcmdlIiwidmFsdWVTdWIiLCJ2YWxpZGF0ZUZvcm1hdCIsInRlc3RTdGVwIiwicGFyc2VkIiwidGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIiLCJrZXlib2FyZFBhZ2VNdWx0aXBsaWVyIiwidGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAiLCJrZXlib2FyZERlZmF1bHRTdGVwIiwidGVzdFJhbmdlIiwic3BlY3RydW0iLCJ0ZXN0U3RhcnQiLCJoYW5kbGVzIiwidGVzdFNuYXAiLCJ0ZXN0QW5pbWF0ZSIsImFuaW1hdGUiLCJ0ZXN0QW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25EdXJhdGlvbiIsInRlc3RDb25uZWN0IiwidGVzdE9yaWVudGF0aW9uIiwib3J0IiwidGVzdE1hcmdpbiIsIm1hcmdpbiIsInRlc3RMaW1pdCIsInRlc3RQYWRkaW5nIiwicGFkZGluZyIsInRvdGFsUGFkZGluZyIsImZpcnN0VmFsdWUiLCJsYXN0VmFsdWUiLCJ0ZXN0RGlyZWN0aW9uIiwiZGlyIiwidGVzdEJlaGF2aW91ciIsImluZGV4T2YiLCJmaXhlZCIsImhvdmVyIiwidW5jb25zdHJhaW5lZCIsImV2ZW50cyIsInRlc3RUb29sdGlwcyIsInRvb2x0aXBzIiwiZm9yRWFjaCIsImZvcm1hdHRlciIsInRlc3RBcmlhRm9ybWF0IiwiYXJpYUZvcm1hdCIsInRlc3RGb3JtYXQiLCJmb3JtYXQiLCJ0ZXN0S2V5Ym9hcmRTdXBwb3J0Iiwia2V5Ym9hcmRTdXBwb3J0IiwidGVzdERvY3VtZW50RWxlbWVudCIsInRlc3RDc3NQcmVmaXgiLCJjc3NQcmVmaXgiLCJ0ZXN0Q3NzQ2xhc3NlcyIsImtleSIsInRlc3RPcHRpb25zIiwib3B0aW9ucyIsInRlc3RzIiwiciIsInQiLCJiZWhhdmlvdXIiLCJkZWZhdWx0cyIsImtleXMiLCJuYW1lIiwiZCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm1zUHJlZml4Iiwic3R5bGUiLCJtc1RyYW5zZm9ybSIsIm5vUHJlZml4IiwidHJhbnNmb3JtIiwidHJhbnNmb3JtUnVsZSIsInN0eWxlcyIsInNjb3BlIiwib3JpZ2luYWxPcHRpb25zIiwiYWN0aW9ucyIsInN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lIiwic2NvcGVfVGFyZ2V0Iiwic2NvcGVfQmFzZSIsInNjb3BlX0hhbmRsZXMiLCJzY29wZV9Db25uZWN0cyIsInNjb3BlX1BpcHMiLCJzY29wZV9Ub29sdGlwcyIsInNjb3BlX1NwZWN0cnVtIiwic2NvcGVfVmFsdWVzIiwic2NvcGVfTG9jYXRpb25zIiwic2NvcGVfSGFuZGxlTnVtYmVycyIsInNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCIsInNjb3BlX0V2ZW50cyIsInNjb3BlX1NlbGYiLCJzY29wZV9Eb2N1bWVudCIsInNjb3BlX0RvY3VtZW50RWxlbWVudCIsInNjb3BlX0JvZHkiLCJQSVBTX05PTkUiLCJQSVBTX05PX1ZBTFVFIiwiUElQU19MQVJHRV9WQUxVRSIsIlBJUFNfU01BTExfVkFMVUUiLCJzY29wZV9EaXJPZmZzZXQiLCJhZGROb2RlVG8iLCJhZGRUYXJnZXQiLCJkaXYiLCJhcHBlbmRDaGlsZCIsImFkZE9yaWdpbiIsImhhbmRsZU51bWJlciIsInNldEF0dHJpYnV0ZSIsImV2ZW50IiwiZXZlbnRLZXlkb3duIiwiYWRkQ29ubmVjdCIsImFkZEVsZW1lbnRzIiwiY29ubmVjdE9wdGlvbnMiLCJjb25uZWN0QmFzZSIsImFkZFNsaWRlciIsInRleHREaXJlY3Rpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwiYWRkVG9vbHRpcCIsImZpcnN0Q2hpbGQiLCJpc1NsaWRlckRpc2FibGVkIiwiaGFzQXR0cmlidXRlIiwiaXNIYW5kbGVEaXNhYmxlZCIsImhhbmRsZU9yaWdpbiIsInJlbW92ZVRvb2x0aXBzIiwicmVtb3ZlRXZlbnQiLCJiaW5kRXZlbnQiLCJ2YWx1ZXMiLCJ1bmVuY29kZWQiLCJmb3JtYXR0ZWRWYWx1ZSIsImlubmVySFRNTCIsImFyaWEiLCJwb3NpdGlvbnMiLCJjaGVja0hhbmRsZVBvc2l0aW9uIiwibm93IiwidGV4dCIsImNoaWxkcmVuIiwiZ2V0R3JvdXAiLCJtb2RlIiwic3RlcHBlZCIsImludGVydmFsIiwic3ByZWFkIiwiZ2VuZXJhdGVTcHJlYWQiLCJkZW5zaXR5IiwiZ3JvdXAiLCJzYWZlSW5jcmVtZW50IiwiaW5jcmVtZW50IiwiaW5kZXhlcyIsImZpcnN0SW5SYW5nZSIsImxhc3RJblJhbmdlIiwiaWdub3JlRmlyc3QiLCJpZ25vcmVMYXN0IiwicHJldlBjdCIsInVuc2hpZnQiLCJjdXJyZW50IiwicSIsImxvdyIsImhpZ2giLCJuZXdQY3QiLCJwY3REaWZmZXJlbmNlIiwicGN0UG9zIiwidHlwZSIsInN0ZXBzIiwicmVhbFN0ZXBzIiwic3RlcFNpemUiLCJpc1N0ZXBzIiwiYWRkTWFya2luZyIsImZpbHRlckZ1bmMiLCJ2YWx1ZVNpemVDbGFzc2VzIiwibWFya2VyU2l6ZUNsYXNzZXMiLCJ2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyIsIm1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcyIsImdldENsYXNzZXMiLCJzb3VyY2UiLCJvcmllbnRhdGlvbkNsYXNzZXMiLCJzaXplQ2xhc3NlcyIsImFkZFNwcmVhZCIsIm5vZGUiLCJyZW1vdmVQaXBzIiwiZ3JpZCIsImJhc2VTaXplIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJhdHRhY2hFdmVudCIsImNhbGxiYWNrIiwiZGF0YSIsIm1ldGhvZCIsImZpeEV2ZW50IiwiZG9Ob3RSZWplY3QiLCJidXR0b25zIiwiY2FsY1BvaW50IiwicG9pbnRzIiwibWV0aG9kcyIsImV2ZW50TmFtZSIsInBhc3NpdmUiLCJldmVudFRhcmdldCIsInRvdWNoIiwibW91c2UiLCJwb2ludGVyIiwiaXNUb3VjaE9uVGFyZ2V0IiwiY2hlY2tUb3VjaCIsInNoYWRvd1Jvb3QiLCJ0YXJnZXRUb3VjaGVzIiwiY2FsbCIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwidGFyZ2V0VG91Y2giLCJmaW5kIiwiY2hhbmdlZFRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsImN1cnNvciIsImNhbGNQb2ludFRvUGVyY2VudGFnZSIsImxvY2F0aW9uIiwicHJvcG9zYWwiLCJnZXRDbG9zZXN0SGFuZGxlIiwiY2xpY2tlZFBvc2l0aW9uIiwic21hbGxlc3REaWZmZXJlbmNlIiwiaGFuZGxlUG9zaXRpb24iLCJkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUiLCJjbGlja0F0RWRnZSIsImlzQ2xvc2VyIiwiaXNDbG9zZXJBZnRlciIsImRvY3VtZW50TGVhdmUiLCJub2RlTmFtZSIsInJlbGF0ZWRUYXJnZXQiLCJldmVudEVuZCIsImV2ZW50TW92ZSIsImFwcFZlcnNpb24iLCJidXR0b25zUHJvcGVydHkiLCJtb3ZlbWVudCIsInN0YXJ0Q2FsY1BvaW50IiwibW92ZUhhbmRsZXMiLCJsb2NhdGlvbnMiLCJoYW5kbGVOdW1iZXJzIiwibGlzdGVuZXJzIiwiYyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRaaW5kZXgiLCJmaXJlRXZlbnQiLCJldmVudFN0YXJ0IiwiY29uc29sZSIsImxvZyIsInNvbWUiLCJzdG9wUHJvcGFnYXRpb24iLCJtb3ZlRXZlbnQiLCJlbmRFdmVudCIsIm91dEV2ZW50IiwiY29uY2F0IiwiZXZlbnRUYXAiLCJzZXRIYW5kbGUiLCJldmVudEhvdmVyIiwidGFyZ2V0RXZlbnQiLCJob3Jpem9udGFsS2V5cyIsInZlcnRpY2FsS2V5cyIsImxhcmdlU3RlcEtleXMiLCJlZGdlS2V5cyIsInJldmVyc2UiLCJpc0xhcmdlRG93biIsImlzTGFyZ2VVcCIsImlzVXAiLCJpc01pbiIsImlzTWF4IiwibXVsdGlwbGllciIsImdldE5leHRTdGVwc0ZvckhhbmRsZSIsImJpbmRTbGlkZXJFdmVudHMiLCJoYW5kbGVCZWZvcmUiLCJoYW5kbGVBZnRlciIsImV2ZW50SG9sZGVycyIsImV2ZW50SG9sZGVyIiwibmFtZXNwYWNlZEV2ZW50IiwibmFtZXNwYWNlIiwic3Vic3RyaW5nIiwiYmluZCIsInRFdmVudCIsInROYW1lc3BhY2UiLCJldmVudFR5cGUiLCJyZWZlcmVuY2UiLCJsb29rQmFja3dhcmQiLCJsb29rRm9yd2FyZCIsImdldFZhbHVlIiwiZGlzdGFuY2UiLCJpblJ1bGVPcmRlciIsInYiLCJvIiwidXB3YXJkIiwicHJvcG9zYWxzIiwiZiIsInN0YXRlIiwidHJhbnNmb3JtRGlyZWN0aW9uIiwidXBkYXRlSGFuZGxlUG9zaXRpb24iLCJ0cmFuc2xhdGlvbiIsInRyYW5zbGF0ZVJ1bGUiLCJ1cGRhdGVDb25uZWN0IiwiekluZGV4IiwibCIsImgiLCJjb25uZWN0V2lkdGgiLCJzY2FsZVJ1bGUiLCJyZXNvbHZlVG9WYWx1ZSIsInZhbHVlU2V0IiwiaW5wdXQiLCJmaXJlU2V0RXZlbnQiLCJpc0luaXQiLCJ2YWx1ZVJlc2V0IiwidmFsdWVTZXRIYW5kbGUiLCJ2YWx1ZUdldCIsImRlc3Ryb3kiLCJub1VpU2xpZGVyIiwibmVhcmJ5U3RlcHMiLCJkZWNyZW1lbnQiLCJnZXROZXh0U3RlcHMiLCJ1cGRhdGVPcHRpb25zIiwib3B0aW9uc1RvVXBkYXRlIiwidXBkYXRlQWJsZSIsIm5ld09wdGlvbnMiLCJzZXR1cFNsaWRlciIsIm9uIiwib2ZmIiwic2V0IiwicmVzZXQiLCJfX21vdmVIYW5kbGVzIiwiZ2V0VG9vbHRpcHMiLCJnZXRPcmlnaW5zIiwiaW5pdGlhbGl6ZSIsImFwaSIsIl9fc3BlY3RydW0iLCJ2ZXJzaW9uIiwiY3JlYXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsVUFBU0EsT0FBVCxFQUFrQjtBQUNmLE1BQUksSUFBSixFQUFnRDtBQUM1QztBQUNBQyxxQ0FBTyxFQUFELG9DQUFLRCxPQUFMO0FBQUE7QUFBQTtBQUFBLG9HQUFOO0FBQ0gsR0FIRCxNQUdPLEVBTU47QUFDSixDQVhELEVBV0csWUFBVztBQUNWOztBQUVBLE1BQUlFLE9BQU8sR0FBRyxRQUFkLENBSFUsQ0FLVjs7QUFFQSxXQUFTQyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7QUFDN0IsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQUssQ0FBQ0MsRUFBYixLQUFvQixVQUFqRCxJQUErRCxPQUFPRCxLQUFLLENBQUNFLElBQWIsS0FBc0IsVUFBNUY7QUFDSDs7QUFFRCxXQUFTQyxhQUFULENBQXVCQyxFQUF2QixFQUEyQjtBQUN2QkEsTUFBRSxDQUFDQyxhQUFILENBQWlCQyxXQUFqQixDQUE2QkYsRUFBN0I7QUFDSDs7QUFFRCxXQUFTRyxLQUFULENBQWVDLEtBQWYsRUFBc0I7QUFDbEIsV0FBT0EsS0FBSyxLQUFLLElBQVYsSUFBa0JBLEtBQUssS0FBS0MsU0FBbkM7QUFDSCxHQWpCUyxDQW1CVjs7O0FBQ0EsV0FBU0MsY0FBVCxDQUF3QkMsQ0FBeEIsRUFBMkI7QUFDdkJBLEtBQUMsQ0FBQ0QsY0FBRjtBQUNILEdBdEJTLENBd0JWOzs7QUFDQSxXQUFTRSxNQUFULENBQWdCQyxLQUFoQixFQUF1QjtBQUNuQixXQUFPQSxLQUFLLENBQUNDLE1BQU4sQ0FBYSxVQUFTQyxDQUFULEVBQVk7QUFDNUIsYUFBTyxDQUFDLEtBQUtBLENBQUwsQ0FBRCxHQUFZLEtBQUtBLENBQUwsSUFBVSxJQUF0QixHQUE4QixLQUFyQztBQUNILEtBRk0sRUFFSixFQUZJLENBQVA7QUFHSCxHQTdCUyxDQStCVjs7O0FBQ0EsV0FBU0MsT0FBVCxDQUFpQlIsS0FBakIsRUFBd0JQLEVBQXhCLEVBQTRCO0FBQ3hCLFdBQU9nQixJQUFJLENBQUNDLEtBQUwsQ0FBV1YsS0FBSyxHQUFHUCxFQUFuQixJQUF5QkEsRUFBaEM7QUFDSCxHQWxDUyxDQW9DVjs7O0FBQ0EsV0FBU2tCLE1BQVQsQ0FBZ0JDLElBQWhCLEVBQXNCQyxXQUF0QixFQUFtQztBQUMvQixRQUFJQyxJQUFJLEdBQUdGLElBQUksQ0FBQ0cscUJBQUwsRUFBWDtBQUNBLFFBQUlDLEdBQUcsR0FBR0osSUFBSSxDQUFDSyxhQUFmO0FBQ0EsUUFBSUMsT0FBTyxHQUFHRixHQUFHLENBQUNHLGVBQWxCO0FBQ0EsUUFBSUMsVUFBVSxHQUFHQyxhQUFhLENBQUNMLEdBQUQsQ0FBOUIsQ0FKK0IsQ0FNL0I7QUFDQTtBQUNBOztBQUNBLFFBQUksMEJBQTBCTSxJQUExQixDQUErQkMsU0FBUyxDQUFDQyxTQUF6QyxDQUFKLEVBQXlEO0FBQ3JESixnQkFBVSxDQUFDSyxDQUFYLEdBQWUsQ0FBZjtBQUNIOztBQUVELFdBQU9aLFdBQVcsR0FDWkMsSUFBSSxDQUFDWSxHQUFMLEdBQVdOLFVBQVUsQ0FBQ08sQ0FBdEIsR0FBMEJULE9BQU8sQ0FBQ1UsU0FEdEIsR0FFWmQsSUFBSSxDQUFDZSxJQUFMLEdBQVlULFVBQVUsQ0FBQ0ssQ0FBdkIsR0FBMkJQLE9BQU8sQ0FBQ1ksVUFGekM7QUFHSCxHQXJEUyxDQXVEVjs7O0FBQ0EsV0FBU0MsU0FBVCxDQUFtQnhCLENBQW5CLEVBQXNCO0FBQ2xCLFdBQU8sT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUIsQ0FBQ3lCLEtBQUssQ0FBQ3pCLENBQUQsQ0FBL0IsSUFBc0MwQixRQUFRLENBQUMxQixDQUFELENBQXJEO0FBQ0gsR0ExRFMsQ0E0RFY7OztBQUNBLFdBQVMyQixXQUFULENBQXFCQyxPQUFyQixFQUE4QkMsU0FBOUIsRUFBeUNDLFFBQXpDLEVBQW1EO0FBQy9DLFFBQUlBLFFBQVEsR0FBRyxDQUFmLEVBQWtCO0FBQ2RDLGNBQVEsQ0FBQ0gsT0FBRCxFQUFVQyxTQUFWLENBQVI7QUFDQUcsZ0JBQVUsQ0FBQyxZQUFXO0FBQ2xCQyxtQkFBVyxDQUFDTCxPQUFELEVBQVVDLFNBQVYsQ0FBWDtBQUNILE9BRlMsRUFFUEMsUUFGTyxDQUFWO0FBR0g7QUFDSixHQXBFUyxDQXNFVjs7O0FBQ0EsV0FBU0ksS0FBVCxDQUFlbEMsQ0FBZixFQUFrQjtBQUNkLFdBQU9FLElBQUksQ0FBQ2lDLEdBQUwsQ0FBU2pDLElBQUksQ0FBQ2tDLEdBQUwsQ0FBU3BDLENBQVQsRUFBWSxHQUFaLENBQVQsRUFBMkIsQ0FBM0IsQ0FBUDtBQUNILEdBekVTLENBMkVWO0FBQ0E7OztBQUNBLFdBQVNxQyxPQUFULENBQWlCckMsQ0FBakIsRUFBb0I7QUFDaEIsV0FBT3NDLEtBQUssQ0FBQ0MsT0FBTixDQUFjdkMsQ0FBZCxJQUFtQkEsQ0FBbkIsR0FBdUIsQ0FBQ0EsQ0FBRCxDQUE5QjtBQUNILEdBL0VTLENBaUZWOzs7QUFDQSxXQUFTd0MsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I7QUFDM0JBLFVBQU0sR0FBR0MsTUFBTSxDQUFDRCxNQUFELENBQWY7QUFDQSxRQUFJRSxNQUFNLEdBQUdGLE1BQU0sQ0FBQ0csS0FBUCxDQUFhLEdBQWIsQ0FBYjtBQUNBLFdBQU9ELE1BQU0sQ0FBQ0UsTUFBUCxHQUFnQixDQUFoQixHQUFvQkYsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVRSxNQUE5QixHQUF1QyxDQUE5QztBQUNILEdBdEZTLENBd0ZWOzs7QUFDQSxXQUFTZCxRQUFULENBQWtCMUMsRUFBbEIsRUFBc0J3QyxTQUF0QixFQUFpQztBQUM3QixRQUFJeEMsRUFBRSxDQUFDeUQsU0FBSCxJQUFnQixDQUFDLEtBQUsvQixJQUFMLENBQVVjLFNBQVYsQ0FBckIsRUFBMkM7QUFDdkN4QyxRQUFFLENBQUN5RCxTQUFILENBQWFDLEdBQWIsQ0FBaUJsQixTQUFqQjtBQUNILEtBRkQsTUFFTztBQUNIeEMsUUFBRSxDQUFDd0MsU0FBSCxJQUFnQixNQUFNQSxTQUF0QjtBQUNIO0FBQ0osR0EvRlMsQ0FpR1Y7OztBQUNBLFdBQVNJLFdBQVQsQ0FBcUI1QyxFQUFyQixFQUF5QndDLFNBQXpCLEVBQW9DO0FBQ2hDLFFBQUl4QyxFQUFFLENBQUN5RCxTQUFILElBQWdCLENBQUMsS0FBSy9CLElBQUwsQ0FBVWMsU0FBVixDQUFyQixFQUEyQztBQUN2Q3hDLFFBQUUsQ0FBQ3lELFNBQUgsQ0FBYUUsTUFBYixDQUFvQm5CLFNBQXBCO0FBQ0gsS0FGRCxNQUVPO0FBQ0h4QyxRQUFFLENBQUN3QyxTQUFILEdBQWV4QyxFQUFFLENBQUN3QyxTQUFILENBQWFvQixPQUFiLENBQ1gsSUFBSUMsTUFBSixDQUFXLFlBQVlyQixTQUFTLENBQUNlLEtBQVYsQ0FBZ0IsR0FBaEIsRUFBcUJPLElBQXJCLENBQTBCLEdBQTFCLENBQVosR0FBNkMsU0FBeEQsRUFBbUUsSUFBbkUsQ0FEVyxFQUVYLEdBRlcsQ0FBZjtBQUlIO0FBQ0osR0EzR1MsQ0E2R1Y7OztBQUNBLFdBQVNDLFFBQVQsQ0FBa0IvRCxFQUFsQixFQUFzQndDLFNBQXRCLEVBQWlDO0FBQzdCLFdBQU94QyxFQUFFLENBQUN5RCxTQUFILEdBQ0R6RCxFQUFFLENBQUN5RCxTQUFILENBQWFPLFFBQWIsQ0FBc0J4QixTQUF0QixDQURDLEdBRUQsSUFBSXFCLE1BQUosQ0FBVyxRQUFRckIsU0FBUixHQUFvQixLQUEvQixFQUFzQ2QsSUFBdEMsQ0FBMkMxQixFQUFFLENBQUN3QyxTQUE5QyxDQUZOO0FBR0gsR0FsSFMsQ0FvSFY7OztBQUNBLFdBQVNmLGFBQVQsQ0FBdUJMLEdBQXZCLEVBQTRCO0FBQ3hCLFFBQUk2QyxpQkFBaUIsR0FBR0MsTUFBTSxDQUFDQyxXQUFQLEtBQXVCOUQsU0FBL0M7QUFDQSxRQUFJK0QsWUFBWSxHQUFHLENBQUNoRCxHQUFHLENBQUNpRCxVQUFKLElBQWtCLEVBQW5CLE1BQTJCLFlBQTlDO0FBQ0EsUUFBSXhDLENBQUMsR0FBR29DLGlCQUFpQixHQUNuQkMsTUFBTSxDQUFDQyxXQURZLEdBRW5CQyxZQUFZLEdBQ1JoRCxHQUFHLENBQUNHLGVBQUosQ0FBb0IrQyxVQURaLEdBRVJsRCxHQUFHLENBQUNtRCxJQUFKLENBQVNELFVBSm5CO0FBS0EsUUFBSXZDLENBQUMsR0FBR2tDLGlCQUFpQixHQUNuQkMsTUFBTSxDQUFDTSxXQURZLEdBRW5CSixZQUFZLEdBQ1JoRCxHQUFHLENBQUNHLGVBQUosQ0FBb0JrRCxTQURaLEdBRVJyRCxHQUFHLENBQUNtRCxJQUFKLENBQVNFLFNBSm5CO0FBTUEsV0FBTztBQUNINUMsT0FBQyxFQUFFQSxDQURBO0FBRUhFLE9BQUMsRUFBRUE7QUFGQSxLQUFQO0FBSUgsR0F2SVMsQ0F5SVY7QUFDQTtBQUNBOzs7QUFDQSxXQUFTMkMsVUFBVCxHQUFzQjtBQUNsQjtBQUNBO0FBQ0EsV0FBT1IsTUFBTSxDQUFDdkMsU0FBUCxDQUFpQmdELGNBQWpCLEdBQ0Q7QUFDSUMsV0FBSyxFQUFFLGFBRFg7QUFFSUMsVUFBSSxFQUFFLGFBRlY7QUFHSUMsU0FBRyxFQUFFO0FBSFQsS0FEQyxHQU1EWixNQUFNLENBQUN2QyxTQUFQLENBQWlCb0QsZ0JBQWpCLEdBQ0k7QUFDSUgsV0FBSyxFQUFFLGVBRFg7QUFFSUMsVUFBSSxFQUFFLGVBRlY7QUFHSUMsU0FBRyxFQUFFO0FBSFQsS0FESixHQU1JO0FBQ0lGLFdBQUssRUFBRSxzQkFEWDtBQUVJQyxVQUFJLEVBQUUscUJBRlY7QUFHSUMsU0FBRyxFQUFFO0FBSFQsS0FaVjtBQWlCSCxHQWhLUyxDQWtLVjtBQUNBOzs7QUFDQSxXQUFTRSxrQkFBVCxHQUE4QjtBQUMxQixRQUFJQyxlQUFlLEdBQUcsS0FBdEI7QUFFQTs7QUFDQSxRQUFJO0FBQ0EsVUFBSUMsSUFBSSxHQUFHQyxNQUFNLENBQUNDLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsU0FBMUIsRUFBcUM7QUFDNUNDLFdBQUcsRUFBRSxZQUFXO0FBQ1pKLHlCQUFlLEdBQUcsSUFBbEI7QUFDSDtBQUgyQyxPQUFyQyxDQUFYO0FBTUFmLFlBQU0sQ0FBQ29CLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDLElBQWhDLEVBQXNDSixJQUF0QztBQUNILEtBUkQsQ0FRRSxPQUFPM0UsQ0FBUCxFQUFVLENBQUU7QUFDZDs7O0FBRUEsV0FBTzBFLGVBQVA7QUFDSDs7QUFFRCxXQUFTTSwwQkFBVCxHQUFzQztBQUNsQyxXQUFPckIsTUFBTSxDQUFDc0IsR0FBUCxJQUFjQSxHQUFHLENBQUNDLFFBQWxCLElBQThCRCxHQUFHLENBQUNDLFFBQUosQ0FBYSxjQUFiLEVBQTZCLE1BQTdCLENBQXJDO0FBQ0gsR0F4TFMsQ0EwTFY7QUFFQTtBQUVBOzs7QUFDQSxXQUFTQyxhQUFULENBQXVCQyxFQUF2QixFQUEyQkMsRUFBM0IsRUFBK0I7QUFDM0IsV0FBTyxPQUFPQSxFQUFFLEdBQUdELEVBQVosQ0FBUDtBQUNILEdBak1TLENBbU1WOzs7QUFDQSxXQUFTRSxjQUFULENBQXdCQyxLQUF4QixFQUErQjFGLEtBQS9CLEVBQXNDMkYsVUFBdEMsRUFBa0Q7QUFDOUMsV0FBUTNGLEtBQUssR0FBRyxHQUFULElBQWlCMEYsS0FBSyxDQUFDQyxVQUFVLEdBQUcsQ0FBZCxDQUFMLEdBQXdCRCxLQUFLLENBQUNDLFVBQUQsQ0FBOUMsQ0FBUDtBQUNILEdBdE1TLENBd01WOzs7QUFDQSxXQUFTQyxZQUFULENBQXNCRixLQUF0QixFQUE2QjFGLEtBQTdCLEVBQW9DO0FBQ2hDLFdBQU95RixjQUFjLENBQUNDLEtBQUQsRUFBUUEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLENBQVgsR0FBZTFGLEtBQUssR0FBR1MsSUFBSSxDQUFDb0YsR0FBTCxDQUFTSCxLQUFLLENBQUMsQ0FBRCxDQUFkLENBQXZCLEdBQTRDMUYsS0FBSyxHQUFHMEYsS0FBSyxDQUFDLENBQUQsQ0FBakUsRUFBc0UsQ0FBdEUsQ0FBckI7QUFDSCxHQTNNUyxDQTZNVjs7O0FBQ0EsV0FBU0ksWUFBVCxDQUFzQkosS0FBdEIsRUFBNkIxRixLQUE3QixFQUFvQztBQUNoQyxXQUFRQSxLQUFLLElBQUkwRixLQUFLLENBQUMsQ0FBRCxDQUFMLEdBQVdBLEtBQUssQ0FBQyxDQUFELENBQXBCLENBQU4sR0FBa0MsR0FBbEMsR0FBd0NBLEtBQUssQ0FBQyxDQUFELENBQXBEO0FBQ0g7O0FBRUQsV0FBU0ssSUFBVCxDQUFjL0YsS0FBZCxFQUFxQmdHLEdBQXJCLEVBQTBCO0FBQ3RCLFFBQUlDLENBQUMsR0FBRyxDQUFSOztBQUVBLFdBQU9qRyxLQUFLLElBQUlnRyxHQUFHLENBQUNDLENBQUQsQ0FBbkIsRUFBd0I7QUFDcEJBLE9BQUMsSUFBSSxDQUFMO0FBQ0g7O0FBRUQsV0FBT0EsQ0FBUDtBQUNILEdBMU5TLENBNE5WOzs7QUFDQSxXQUFTQyxVQUFULENBQW9CQyxJQUFwQixFQUEwQkMsSUFBMUIsRUFBZ0NwRyxLQUFoQyxFQUF1QztBQUNuQyxRQUFJQSxLQUFLLElBQUltRyxJQUFJLENBQUNFLEtBQUwsQ0FBVyxDQUFDLENBQVosRUFBZSxDQUFmLENBQWIsRUFBZ0M7QUFDNUIsYUFBTyxHQUFQO0FBQ0g7O0FBRUQsUUFBSUosQ0FBQyxHQUFHRixJQUFJLENBQUMvRixLQUFELEVBQVFtRyxJQUFSLENBQVo7QUFDQSxRQUFJRyxFQUFFLEdBQUdILElBQUksQ0FBQ0YsQ0FBQyxHQUFHLENBQUwsQ0FBYjtBQUNBLFFBQUlNLEVBQUUsR0FBR0osSUFBSSxDQUFDRixDQUFELENBQWI7QUFDQSxRQUFJVixFQUFFLEdBQUdhLElBQUksQ0FBQ0gsQ0FBQyxHQUFHLENBQUwsQ0FBYjtBQUNBLFFBQUlULEVBQUUsR0FBR1ksSUFBSSxDQUFDSCxDQUFELENBQWI7QUFFQSxXQUFPVixFQUFFLEdBQUdLLFlBQVksQ0FBQyxDQUFDVSxFQUFELEVBQUtDLEVBQUwsQ0FBRCxFQUFXdkcsS0FBWCxDQUFaLEdBQWdDc0YsYUFBYSxDQUFDQyxFQUFELEVBQUtDLEVBQUwsQ0FBekQ7QUFDSCxHQXpPUyxDQTJPVjs7O0FBQ0EsV0FBU2dCLFlBQVQsQ0FBc0JMLElBQXRCLEVBQTRCQyxJQUE1QixFQUFrQ3BHLEtBQWxDLEVBQXlDO0FBQ3JDO0FBQ0EsUUFBSUEsS0FBSyxJQUFJLEdBQWIsRUFBa0I7QUFDZCxhQUFPbUcsSUFBSSxDQUFDRSxLQUFMLENBQVcsQ0FBQyxDQUFaLEVBQWUsQ0FBZixDQUFQO0FBQ0g7O0FBRUQsUUFBSUosQ0FBQyxHQUFHRixJQUFJLENBQUMvRixLQUFELEVBQVFvRyxJQUFSLENBQVo7QUFDQSxRQUFJRSxFQUFFLEdBQUdILElBQUksQ0FBQ0YsQ0FBQyxHQUFHLENBQUwsQ0FBYjtBQUNBLFFBQUlNLEVBQUUsR0FBR0osSUFBSSxDQUFDRixDQUFELENBQWI7QUFDQSxRQUFJVixFQUFFLEdBQUdhLElBQUksQ0FBQ0gsQ0FBQyxHQUFHLENBQUwsQ0FBYjtBQUNBLFFBQUlULEVBQUUsR0FBR1ksSUFBSSxDQUFDSCxDQUFELENBQWI7QUFFQSxXQUFPSCxZQUFZLENBQUMsQ0FBQ1EsRUFBRCxFQUFLQyxFQUFMLENBQUQsRUFBVyxDQUFDdkcsS0FBSyxHQUFHdUYsRUFBVCxJQUFlRCxhQUFhLENBQUNDLEVBQUQsRUFBS0MsRUFBTCxDQUF2QyxDQUFuQjtBQUNILEdBelBTLENBMlBWOzs7QUFDQSxXQUFTaUIsT0FBVCxDQUFpQkwsSUFBakIsRUFBdUJNLE1BQXZCLEVBQStCQyxJQUEvQixFQUFxQzNHLEtBQXJDLEVBQTRDO0FBQ3hDLFFBQUlBLEtBQUssS0FBSyxHQUFkLEVBQW1CO0FBQ2YsYUFBT0EsS0FBUDtBQUNIOztBQUVELFFBQUlpRyxDQUFDLEdBQUdGLElBQUksQ0FBQy9GLEtBQUQsRUFBUW9HLElBQVIsQ0FBWjtBQUNBLFFBQUk3RixDQUFDLEdBQUc2RixJQUFJLENBQUNILENBQUMsR0FBRyxDQUFMLENBQVo7QUFDQSxRQUFJVyxDQUFDLEdBQUdSLElBQUksQ0FBQ0gsQ0FBRCxDQUFaLENBUHdDLENBU3hDOztBQUNBLFFBQUlVLElBQUosRUFBVTtBQUNOO0FBQ0EsVUFBSTNHLEtBQUssR0FBR08sQ0FBUixHQUFZLENBQUNxRyxDQUFDLEdBQUdyRyxDQUFMLElBQVUsQ0FBMUIsRUFBNkI7QUFDekIsZUFBT3FHLENBQVA7QUFDSDs7QUFFRCxhQUFPckcsQ0FBUDtBQUNIOztBQUVELFFBQUksQ0FBQ21HLE1BQU0sQ0FBQ1QsQ0FBQyxHQUFHLENBQUwsQ0FBWCxFQUFvQjtBQUNoQixhQUFPakcsS0FBUDtBQUNIOztBQUVELFdBQU9vRyxJQUFJLENBQUNILENBQUMsR0FBRyxDQUFMLENBQUosR0FBY3pGLE9BQU8sQ0FBQ1IsS0FBSyxHQUFHb0csSUFBSSxDQUFDSCxDQUFDLEdBQUcsQ0FBTCxDQUFiLEVBQXNCUyxNQUFNLENBQUNULENBQUMsR0FBRyxDQUFMLENBQTVCLENBQTVCO0FBQ0g7O0FBRUQsV0FBU1ksZ0JBQVQsQ0FBMEJDLEtBQTFCLEVBQWlDOUcsS0FBakMsRUFBd0MrRyxJQUF4QyxFQUE4QztBQUMxQyxRQUFJQyxVQUFKLENBRDBDLENBRzFDOztBQUNBLFFBQUksT0FBT2hILEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0JBLFdBQUssR0FBRyxDQUFDQSxLQUFELENBQVI7QUFDSCxLQU55QyxDQVExQzs7O0FBQ0EsUUFBSSxDQUFDNkMsS0FBSyxDQUFDQyxPQUFOLENBQWM5QyxLQUFkLENBQUwsRUFBMkI7QUFDdkIsWUFBTSxJQUFJaUgsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLG9DQUFyQyxDQUFOO0FBQ0gsS0FYeUMsQ0FhMUM7OztBQUNBLFFBQUl3SCxLQUFLLEtBQUssS0FBZCxFQUFxQjtBQUNqQkUsZ0JBQVUsR0FBRyxDQUFiO0FBQ0gsS0FGRCxNQUVPLElBQUlGLEtBQUssS0FBSyxLQUFkLEVBQXFCO0FBQ3hCRSxnQkFBVSxHQUFHLEdBQWI7QUFDSCxLQUZNLE1BRUE7QUFDSEEsZ0JBQVUsR0FBR0UsVUFBVSxDQUFDSixLQUFELENBQXZCO0FBQ0gsS0FwQnlDLENBc0IxQzs7O0FBQ0EsUUFBSSxDQUFDL0UsU0FBUyxDQUFDaUYsVUFBRCxDQUFWLElBQTBCLENBQUNqRixTQUFTLENBQUMvQixLQUFLLENBQUMsQ0FBRCxDQUFOLENBQXhDLEVBQW9EO0FBQ2hELFlBQU0sSUFBSWlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQixpQ0FBckMsQ0FBTjtBQUNILEtBekJ5QyxDQTJCMUM7OztBQUNBeUgsUUFBSSxDQUFDWCxJQUFMLENBQVVlLElBQVYsQ0FBZUgsVUFBZjtBQUNBRCxRQUFJLENBQUNaLElBQUwsQ0FBVWdCLElBQVYsQ0FBZW5ILEtBQUssQ0FBQyxDQUFELENBQXBCLEVBN0IwQyxDQStCMUM7QUFDQTtBQUNBOztBQUNBLFFBQUksQ0FBQ2dILFVBQUwsRUFBaUI7QUFDYixVQUFJLENBQUNoRixLQUFLLENBQUNoQyxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQVYsRUFBc0I7QUFDbEIrRyxZQUFJLENBQUNMLE1BQUwsQ0FBWSxDQUFaLElBQWlCMUcsS0FBSyxDQUFDLENBQUQsQ0FBdEI7QUFDSDtBQUNKLEtBSkQsTUFJTztBQUNIK0csVUFBSSxDQUFDTCxNQUFMLENBQVlTLElBQVosQ0FBaUJuRixLQUFLLENBQUNoQyxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQUwsR0FBa0IsS0FBbEIsR0FBMEJBLEtBQUssQ0FBQyxDQUFELENBQWhEO0FBQ0g7O0FBRUQrRyxRQUFJLENBQUNLLG9CQUFMLENBQTBCRCxJQUExQixDQUErQixDQUEvQjtBQUNIOztBQUVELFdBQVNFLGVBQVQsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQlIsSUFBL0IsRUFBcUM7QUFDakM7QUFDQSxRQUFJLENBQUNRLENBQUwsRUFBUTtBQUNKO0FBQ0gsS0FKZ0MsQ0FNakM7OztBQUNBLFFBQUlSLElBQUksQ0FBQ1osSUFBTCxDQUFVbUIsQ0FBVixNQUFpQlAsSUFBSSxDQUFDWixJQUFMLENBQVVtQixDQUFDLEdBQUcsQ0FBZCxDQUFyQixFQUF1QztBQUNuQ1AsVUFBSSxDQUFDTCxNQUFMLENBQVlZLENBQVosSUFBaUJQLElBQUksQ0FBQ0ssb0JBQUwsQ0FBMEJFLENBQTFCLElBQStCUCxJQUFJLENBQUNaLElBQUwsQ0FBVW1CLENBQVYsQ0FBaEQ7QUFFQTtBQUNILEtBWGdDLENBYWpDOzs7QUFDQVAsUUFBSSxDQUFDTCxNQUFMLENBQVlZLENBQVosSUFDSTdCLGNBQWMsQ0FBQyxDQUFDc0IsSUFBSSxDQUFDWixJQUFMLENBQVVtQixDQUFWLENBQUQsRUFBZVAsSUFBSSxDQUFDWixJQUFMLENBQVVtQixDQUFDLEdBQUcsQ0FBZCxDQUFmLENBQUQsRUFBbUNDLENBQW5DLEVBQXNDLENBQXRDLENBQWQsR0FBeURqQyxhQUFhLENBQUN5QixJQUFJLENBQUNYLElBQUwsQ0FBVWtCLENBQVYsQ0FBRCxFQUFlUCxJQUFJLENBQUNYLElBQUwsQ0FBVWtCLENBQUMsR0FBRyxDQUFkLENBQWYsQ0FEMUU7QUFHQSxRQUFJRSxVQUFVLEdBQUcsQ0FBQ1QsSUFBSSxDQUFDWixJQUFMLENBQVVtQixDQUFDLEdBQUcsQ0FBZCxJQUFtQlAsSUFBSSxDQUFDWixJQUFMLENBQVVtQixDQUFWLENBQXBCLElBQW9DUCxJQUFJLENBQUNVLFNBQUwsQ0FBZUgsQ0FBZixDQUFyRDtBQUNBLFFBQUlJLFdBQVcsR0FBR2pILElBQUksQ0FBQ2tILElBQUwsQ0FBVUMsTUFBTSxDQUFDSixVQUFVLENBQUNLLE9BQVgsQ0FBbUIsQ0FBbkIsQ0FBRCxDQUFOLEdBQWdDLENBQTFDLENBQWxCO0FBQ0EsUUFBSUMsSUFBSSxHQUFHZixJQUFJLENBQUNaLElBQUwsQ0FBVW1CLENBQVYsSUFBZVAsSUFBSSxDQUFDVSxTQUFMLENBQWVILENBQWYsSUFBb0JJLFdBQTlDO0FBRUFYLFFBQUksQ0FBQ0ssb0JBQUwsQ0FBMEJFLENBQTFCLElBQStCUSxJQUEvQjtBQUNILEdBelZTLENBMlZWO0FBRUE7OztBQUVBLFdBQVNDLFFBQVQsQ0FBa0J2SSxLQUFsQixFQUF5Qm1ILElBQXpCLEVBQStCcUIsVUFBL0IsRUFBMkM7QUFDdkMsU0FBSzVCLElBQUwsR0FBWSxFQUFaO0FBQ0EsU0FBS0QsSUFBTCxHQUFZLEVBQVo7QUFDQSxTQUFLTyxNQUFMLEdBQWMsQ0FBQ3NCLFVBQVUsSUFBSSxLQUFmLENBQWQ7QUFDQSxTQUFLUCxTQUFMLEdBQWlCLENBQUMsS0FBRCxDQUFqQjtBQUNBLFNBQUtMLG9CQUFMLEdBQTRCLEVBQTVCO0FBRUEsU0FBS1QsSUFBTCxHQUFZQSxJQUFaO0FBRUEsUUFBSUcsS0FBSjtBQUNBLFFBQUltQixPQUFPLEdBQUcsRUFBZCxDQVZ1QyxDQVVyQjtBQUVsQjs7QUFDQSxTQUFLbkIsS0FBTCxJQUFjdEgsS0FBZCxFQUFxQjtBQUNqQixVQUFJQSxLQUFLLENBQUMwSSxjQUFOLENBQXFCcEIsS0FBckIsQ0FBSixFQUFpQztBQUM3Qm1CLGVBQU8sQ0FBQ2QsSUFBUixDQUFhLENBQUMzSCxLQUFLLENBQUNzSCxLQUFELENBQU4sRUFBZUEsS0FBZixDQUFiO0FBQ0g7QUFDSixLQWpCc0MsQ0FtQnZDOzs7QUFDQSxRQUFJbUIsT0FBTyxDQUFDN0UsTUFBUixJQUFrQixPQUFPNkUsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXLENBQVgsQ0FBUCxLQUF5QixRQUEvQyxFQUF5RDtBQUNyREEsYUFBTyxDQUFDRSxJQUFSLENBQWEsVUFBUzVILENBQVQsRUFBWXFHLENBQVosRUFBZTtBQUN4QixlQUFPckcsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFLLENBQUwsSUFBVXFHLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSyxDQUFMLENBQWpCO0FBQ0gsT0FGRDtBQUdILEtBSkQsTUFJTztBQUNIcUIsYUFBTyxDQUFDRSxJQUFSLENBQWEsVUFBUzVILENBQVQsRUFBWXFHLENBQVosRUFBZTtBQUN4QixlQUFPckcsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPcUcsQ0FBQyxDQUFDLENBQUQsQ0FBZjtBQUNILE9BRkQ7QUFHSCxLQTVCc0MsQ0E4QnZDOzs7QUFDQSxTQUFLRSxLQUFLLEdBQUcsQ0FBYixFQUFnQkEsS0FBSyxHQUFHbUIsT0FBTyxDQUFDN0UsTUFBaEMsRUFBd0MwRCxLQUFLLEVBQTdDLEVBQWlEO0FBQzdDRCxzQkFBZ0IsQ0FBQ29CLE9BQU8sQ0FBQ25CLEtBQUQsQ0FBUCxDQUFlLENBQWYsQ0FBRCxFQUFvQm1CLE9BQU8sQ0FBQ25CLEtBQUQsQ0FBUCxDQUFlLENBQWYsQ0FBcEIsRUFBdUMsSUFBdkMsQ0FBaEI7QUFDSCxLQWpDc0MsQ0FtQ3ZDO0FBQ0E7OztBQUNBLFNBQUtXLFNBQUwsR0FBaUIsS0FBS2YsTUFBTCxDQUFZTCxLQUFaLENBQWtCLENBQWxCLENBQWpCLENBckN1QyxDQXVDdkM7O0FBQ0EsU0FBS1MsS0FBSyxHQUFHLENBQWIsRUFBZ0JBLEtBQUssR0FBRyxLQUFLVyxTQUFMLENBQWVyRSxNQUF2QyxFQUErQzBELEtBQUssRUFBcEQsRUFBd0Q7QUFDcERPLHFCQUFlLENBQUNQLEtBQUQsRUFBUSxLQUFLVyxTQUFMLENBQWVYLEtBQWYsQ0FBUixFQUErQixJQUEvQixDQUFmO0FBQ0g7QUFDSjs7QUFFRGlCLFVBQVEsQ0FBQ0ssU0FBVCxDQUFtQkMsV0FBbkIsR0FBaUMsVUFBU3JJLEtBQVQsRUFBZ0I7QUFDN0MsUUFBSThHLEtBQUo7QUFDQSxRQUFJd0IsU0FBUyxHQUFHLEVBQWhCOztBQUVBLFNBQUt4QixLQUFLLEdBQUcsQ0FBYixFQUFnQkEsS0FBSyxHQUFHLEtBQUtXLFNBQUwsQ0FBZXJFLE1BQWYsR0FBd0IsQ0FBaEQsRUFBbUQwRCxLQUFLLEVBQXhELEVBQTREO0FBQ3hEO0FBQ0EsVUFBSWdCLElBQUksR0FBRyxLQUFLTCxTQUFMLENBQWVYLEtBQWYsQ0FBWDs7QUFFQSxVQUFJZ0IsSUFBSSxJQUFLOUgsS0FBSyxHQUFHOEgsSUFBVCxHQUFpQixDQUFqQixLQUF1QixDQUFuQyxFQUFzQztBQUNsQyxjQUFNLElBQUliLEtBQUosQ0FDRixpQkFDSTNILE9BREosR0FFSSx3Q0FGSixHQUdJLEtBQUs4RyxJQUFMLENBQVVVLEtBQVYsQ0FISixHQUlJLG9DQUxGLENBQU47QUFPSCxPQVp1RCxDQWN4RDs7O0FBQ0F3QixlQUFTLENBQUN4QixLQUFELENBQVQsR0FBbUJyQixjQUFjLENBQUMsS0FBS1UsSUFBTixFQUFZbkcsS0FBWixFQUFtQjhHLEtBQW5CLENBQWpDO0FBQ0g7O0FBRUQsV0FBT3dCLFNBQVA7QUFDSCxHQXZCRCxDQTVZVSxDQXFhVjtBQUNBOzs7QUFDQVAsVUFBUSxDQUFDSyxTQUFULENBQW1CRyxtQkFBbkIsR0FBeUMsVUFBU3ZJLEtBQVQsRUFBZ0JzSSxTQUFoQixFQUEyQkUsU0FBM0IsRUFBc0M7QUFDM0UsUUFBSUMsVUFBVSxHQUFHLENBQWpCLENBRDJFLENBRzNFOztBQUNBLFFBQUl6SSxLQUFLLEdBQUcsS0FBS29HLElBQUwsQ0FBVSxLQUFLQSxJQUFMLENBQVVoRCxNQUFWLEdBQW1CLENBQTdCLENBQVosRUFBNkM7QUFDekMsYUFBT3BELEtBQUssR0FBRyxLQUFLb0csSUFBTCxDQUFVcUMsVUFBVSxHQUFHLENBQXZCLENBQWYsRUFBMEM7QUFDdENBLGtCQUFVO0FBQ2I7QUFDSixLQUpELE1BSU8sSUFBSXpJLEtBQUssS0FBSyxLQUFLb0csSUFBTCxDQUFVLEtBQUtBLElBQUwsQ0FBVWhELE1BQVYsR0FBbUIsQ0FBN0IsQ0FBZCxFQUErQztBQUNsRHFGLGdCQUFVLEdBQUcsS0FBS3JDLElBQUwsQ0FBVWhELE1BQVYsR0FBbUIsQ0FBaEM7QUFDSCxLQVYwRSxDQVkzRTs7O0FBQ0EsUUFBSSxDQUFDb0YsU0FBRCxJQUFjeEksS0FBSyxLQUFLLEtBQUtvRyxJQUFMLENBQVVxQyxVQUFVLEdBQUcsQ0FBdkIsQ0FBNUIsRUFBdUQ7QUFDbkRBLGdCQUFVO0FBQ2I7O0FBRUQsUUFBSUMsWUFBSjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxDQUFsQjtBQUVBLFFBQUlDLGlCQUFpQixHQUFHTixTQUFTLENBQUNHLFVBQUQsQ0FBakM7QUFFQSxRQUFJSSxTQUFTLEdBQUcsQ0FBaEI7QUFFQSxRQUFJQyxrQkFBa0IsR0FBRyxDQUF6QjtBQUNBLFFBQUlDLG9CQUFvQixHQUFHLENBQTNCO0FBQ0EsUUFBSUMsYUFBYSxHQUFHLENBQXBCLENBMUIyRSxDQTRCM0U7O0FBQ0EsUUFBSVIsU0FBSixFQUFlO0FBQ1hFLGtCQUFZLEdBQUcsQ0FBQzFJLEtBQUssR0FBRyxLQUFLb0csSUFBTCxDQUFVcUMsVUFBVixDQUFULEtBQW1DLEtBQUtyQyxJQUFMLENBQVVxQyxVQUFVLEdBQUcsQ0FBdkIsSUFBNEIsS0FBS3JDLElBQUwsQ0FBVXFDLFVBQVYsQ0FBL0QsQ0FBZjtBQUNILEtBRkQsTUFFTztBQUNIQyxrQkFBWSxHQUFHLENBQUMsS0FBS3RDLElBQUwsQ0FBVXFDLFVBQVUsR0FBRyxDQUF2QixJQUE0QnpJLEtBQTdCLEtBQXVDLEtBQUtvRyxJQUFMLENBQVVxQyxVQUFVLEdBQUcsQ0FBdkIsSUFBNEIsS0FBS3JDLElBQUwsQ0FBVXFDLFVBQVYsQ0FBbkUsQ0FBZjtBQUNILEtBakMwRSxDQW1DM0U7OztBQUNBLFdBQU9HLGlCQUFpQixHQUFHLENBQTNCLEVBQThCO0FBQzFCO0FBQ0FDLGVBQVMsR0FBRyxLQUFLekMsSUFBTCxDQUFVcUMsVUFBVSxHQUFHLENBQWIsR0FBaUJPLGFBQTNCLElBQTRDLEtBQUs1QyxJQUFMLENBQVVxQyxVQUFVLEdBQUdPLGFBQXZCLENBQXhELENBRjBCLENBSTFCOztBQUNBLFVBQUlWLFNBQVMsQ0FBQ0csVUFBVSxHQUFHTyxhQUFkLENBQVQsR0FBd0NMLFdBQXhDLEdBQXNELEdBQXRELEdBQTRERCxZQUFZLEdBQUcsR0FBM0UsR0FBaUYsR0FBckYsRUFBMEY7QUFDdEY7QUFDQUksMEJBQWtCLEdBQUdELFNBQVMsR0FBR0gsWUFBakMsQ0FGc0YsQ0FHdEY7O0FBQ0FDLG1CQUFXLEdBQUcsQ0FBQ0MsaUJBQWlCLEdBQUcsTUFBTUYsWUFBM0IsSUFBMkNKLFNBQVMsQ0FBQ0csVUFBVSxHQUFHTyxhQUFkLENBQWxFLENBSnNGLENBS3RGOztBQUNBTixvQkFBWSxHQUFHLENBQWY7QUFDSCxPQVBELE1BT087QUFDSDtBQUNBSSwwQkFBa0IsR0FBS1IsU0FBUyxDQUFDRyxVQUFVLEdBQUdPLGFBQWQsQ0FBVCxHQUF3Q0gsU0FBekMsR0FBc0QsR0FBdkQsR0FBOERGLFdBQW5GLENBRkcsQ0FHSDs7QUFDQUEsbUJBQVcsR0FBRyxDQUFkO0FBQ0g7O0FBRUQsVUFBSUgsU0FBSixFQUFlO0FBQ1hPLDRCQUFvQixHQUFHQSxvQkFBb0IsR0FBR0Qsa0JBQTlDLENBRFcsQ0FFWDs7QUFDQSxZQUFJLEtBQUsxQyxJQUFMLENBQVVoRCxNQUFWLEdBQW1CNEYsYUFBbkIsSUFBb0MsQ0FBeEMsRUFBMkM7QUFDdkNBLHVCQUFhO0FBQ2hCO0FBQ0osT0FORCxNQU1PO0FBQ0hELDRCQUFvQixHQUFHQSxvQkFBb0IsR0FBR0Qsa0JBQTlDLENBREcsQ0FFSDs7QUFDQSxZQUFJLEtBQUsxQyxJQUFMLENBQVVoRCxNQUFWLEdBQW1CNEYsYUFBbkIsSUFBb0MsQ0FBeEMsRUFBMkM7QUFDdkNBLHVCQUFhO0FBQ2hCO0FBQ0osT0EvQnlCLENBaUMxQjs7O0FBQ0FKLHVCQUFpQixHQUFHTixTQUFTLENBQUNHLFVBQVUsR0FBR08sYUFBZCxDQUFULEdBQXdDTCxXQUE1RDtBQUNIOztBQUVELFdBQU8zSSxLQUFLLEdBQUcrSSxvQkFBZjtBQUNILEdBMUVEOztBQTRFQWhCLFVBQVEsQ0FBQ0ssU0FBVCxDQUFtQmxDLFVBQW5CLEdBQWdDLFVBQVNsRyxLQUFULEVBQWdCO0FBQzVDQSxTQUFLLEdBQUdrRyxVQUFVLENBQUMsS0FBS0MsSUFBTixFQUFZLEtBQUtDLElBQWpCLEVBQXVCcEcsS0FBdkIsQ0FBbEI7QUFFQSxXQUFPQSxLQUFQO0FBQ0gsR0FKRDs7QUFNQStILFVBQVEsQ0FBQ0ssU0FBVCxDQUFtQjVCLFlBQW5CLEdBQWtDLFVBQVN4RyxLQUFULEVBQWdCO0FBQzlDLFdBQU93RyxZQUFZLENBQUMsS0FBS0wsSUFBTixFQUFZLEtBQUtDLElBQWpCLEVBQXVCcEcsS0FBdkIsQ0FBbkI7QUFDSCxHQUZEOztBQUlBK0gsVUFBUSxDQUFDSyxTQUFULENBQW1CM0IsT0FBbkIsR0FBNkIsVUFBU3pHLEtBQVQsRUFBZ0I7QUFDekNBLFNBQUssR0FBR3lHLE9BQU8sQ0FBQyxLQUFLTCxJQUFOLEVBQVksS0FBS00sTUFBakIsRUFBeUIsS0FBS0MsSUFBOUIsRUFBb0MzRyxLQUFwQyxDQUFmO0FBRUEsV0FBT0EsS0FBUDtBQUNILEdBSkQ7O0FBTUErSCxVQUFRLENBQUNLLFNBQVQsQ0FBbUJhLGNBQW5CLEdBQW9DLFVBQVNqSixLQUFULEVBQWdCa0osTUFBaEIsRUFBd0JDLElBQXhCLEVBQThCO0FBQzlELFFBQUlsRCxDQUFDLEdBQUdGLElBQUksQ0FBQy9GLEtBQUQsRUFBUSxLQUFLb0csSUFBYixDQUFaLENBRDhELENBRzlEOztBQUNBLFFBQUlwRyxLQUFLLEtBQUssR0FBVixJQUFrQmtKLE1BQU0sSUFBSWxKLEtBQUssS0FBSyxLQUFLb0csSUFBTCxDQUFVSCxDQUFDLEdBQUcsQ0FBZCxDQUExQyxFQUE2RDtBQUN6REEsT0FBQyxHQUFHeEYsSUFBSSxDQUFDaUMsR0FBTCxDQUFTdUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBSjtBQUNIOztBQUVELFdBQU8sQ0FBQyxLQUFLRSxJQUFMLENBQVVGLENBQVYsSUFBZSxLQUFLRSxJQUFMLENBQVVGLENBQUMsR0FBRyxDQUFkLENBQWhCLElBQW9Da0QsSUFBM0M7QUFDSCxHQVREOztBQVdBcEIsVUFBUSxDQUFDSyxTQUFULENBQW1CZ0IsY0FBbkIsR0FBb0MsVUFBU3BKLEtBQVQsRUFBZ0I7QUFDaEQsUUFBSWlHLENBQUMsR0FBR0YsSUFBSSxDQUFDL0YsS0FBRCxFQUFRLEtBQUtvRyxJQUFiLENBQVo7QUFFQSxXQUFPO0FBQ0hpRCxnQkFBVSxFQUFFO0FBQ1JDLGtCQUFVLEVBQUUsS0FBS25ELElBQUwsQ0FBVUYsQ0FBQyxHQUFHLENBQWQsQ0FESjtBQUVSNkIsWUFBSSxFQUFFLEtBQUtMLFNBQUwsQ0FBZXhCLENBQUMsR0FBRyxDQUFuQixDQUZFO0FBR1J5QixtQkFBVyxFQUFFLEtBQUtOLG9CQUFMLENBQTBCbkIsQ0FBQyxHQUFHLENBQTlCO0FBSEwsT0FEVDtBQU1Ic0QsY0FBUSxFQUFFO0FBQ05ELGtCQUFVLEVBQUUsS0FBS25ELElBQUwsQ0FBVUYsQ0FBQyxHQUFHLENBQWQsQ0FETjtBQUVONkIsWUFBSSxFQUFFLEtBQUtMLFNBQUwsQ0FBZXhCLENBQUMsR0FBRyxDQUFuQixDQUZBO0FBR055QixtQkFBVyxFQUFFLEtBQUtOLG9CQUFMLENBQTBCbkIsQ0FBQyxHQUFHLENBQTlCO0FBSFAsT0FOUDtBQVdIdUQsZUFBUyxFQUFFO0FBQ1BGLGtCQUFVLEVBQUUsS0FBS25ELElBQUwsQ0FBVUYsQ0FBVixDQURMO0FBRVA2QixZQUFJLEVBQUUsS0FBS0wsU0FBTCxDQUFleEIsQ0FBZixDQUZDO0FBR1B5QixtQkFBVyxFQUFFLEtBQUtOLG9CQUFMLENBQTBCbkIsQ0FBMUI7QUFITjtBQVhSLEtBQVA7QUFpQkgsR0FwQkQ7O0FBc0JBOEIsVUFBUSxDQUFDSyxTQUFULENBQW1CcUIsaUJBQW5CLEdBQXVDLFlBQVc7QUFDOUMsUUFBSUMsWUFBWSxHQUFHLEtBQUtqQyxTQUFMLENBQWVrQyxHQUFmLENBQW1CNUcsYUFBbkIsQ0FBbkI7QUFDQSxXQUFPdEMsSUFBSSxDQUFDaUMsR0FBTCxDQUFTa0gsS0FBVCxDQUFlLElBQWYsRUFBcUJGLFlBQXJCLENBQVA7QUFDSCxHQUhELENBcGlCVSxDQXlpQlY7OztBQUNBM0IsVUFBUSxDQUFDSyxTQUFULENBQW1CeUIsT0FBbkIsR0FBNkIsVUFBUzdKLEtBQVQsRUFBZ0I7QUFDekMsV0FBTyxLQUFLeUcsT0FBTCxDQUFhLEtBQUtQLFVBQUwsQ0FBZ0JsRyxLQUFoQixDQUFiLENBQVA7QUFDSCxHQUZELENBMWlCVSxDQThpQlY7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFhQTs7O0FBRUEsTUFBSThKLGdCQUFnQixHQUFHO0FBQ25CckssTUFBRSxFQUFFLFVBQVNPLEtBQVQsRUFBZ0I7QUFDaEIsYUFBT0EsS0FBSyxLQUFLQyxTQUFWLElBQXVCRCxLQUFLLENBQUM2SCxPQUFOLENBQWMsQ0FBZCxDQUE5QjtBQUNILEtBSGtCO0FBSW5CbkksUUFBSSxFQUFFa0k7QUFKYSxHQUF2QjtBQU9BLE1BQUltQyxVQUFVLEdBQUc7QUFDYkMsVUFBTSxFQUFFLFFBREs7QUFFYkMsUUFBSSxFQUFFLE1BRk87QUFHYkMsVUFBTSxFQUFFLFFBSEs7QUFJYkMsVUFBTSxFQUFFLFFBSks7QUFLYkMsZUFBVyxFQUFFLGNBTEE7QUFNYkMsZUFBVyxFQUFFLGNBTkE7QUFPYkMsYUFBUyxFQUFFLFlBUEU7QUFRYkMsY0FBVSxFQUFFLFlBUkM7QUFTYkMsWUFBUSxFQUFFLFVBVEc7QUFVYkMsY0FBVSxFQUFFLFlBVkM7QUFXYkMsV0FBTyxFQUFFLFNBWEk7QUFZYkMsWUFBUSxFQUFFLFVBWkc7QUFhYkMsT0FBRyxFQUFFLEtBYlE7QUFjYkMsT0FBRyxFQUFFLEtBZFE7QUFlYkMsb0JBQWdCLEVBQUUsYUFmTDtBQWdCYkMsb0JBQWdCLEVBQUUsYUFoQkw7QUFpQmJDLGFBQVMsRUFBRSxXQWpCRTtBQWtCYkMsUUFBSSxFQUFFLFlBbEJPO0FBbUJiQyxPQUFHLEVBQUUsV0FuQlE7QUFvQmJDLFVBQU0sRUFBRSxRQXBCSztBQXFCYkMsV0FBTyxFQUFFLFNBckJJO0FBc0JiQyxRQUFJLEVBQUUsTUF0Qk87QUF1QmJDLGtCQUFjLEVBQUUsaUJBdkJIO0FBd0JiQyxnQkFBWSxFQUFFLGVBeEJEO0FBeUJiQyxVQUFNLEVBQUUsUUF6Qks7QUEwQmJDLG9CQUFnQixFQUFFLG1CQTFCTDtBQTJCYkMsa0JBQWMsRUFBRSxpQkEzQkg7QUE0QmJDLGdCQUFZLEVBQUUsZUE1QkQ7QUE2QmJDLGVBQVcsRUFBRSxjQTdCQTtBQThCYkMsYUFBUyxFQUFFLFlBOUJFO0FBK0JiN0wsU0FBSyxFQUFFLE9BL0JNO0FBZ0NiOEwsbUJBQWUsRUFBRSxrQkFoQ0o7QUFpQ2JDLGlCQUFhLEVBQUUsZ0JBakNGO0FBa0NiQyxlQUFXLEVBQUUsY0FsQ0E7QUFtQ2JDLGNBQVUsRUFBRSxhQW5DQztBQW9DYkMsWUFBUSxFQUFFO0FBcENHLEdBQWpCLENBeGtCVSxDQSttQlY7O0FBRUEsV0FBU0MsY0FBVCxDQUF3QjNNLEtBQXhCLEVBQStCO0FBQzNCO0FBQ0EsUUFBSUQsZ0JBQWdCLENBQUNDLEtBQUQsQ0FBcEIsRUFBNkI7QUFDekIsYUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBTSxJQUFJeUgsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLCtDQUFyQyxDQUFOO0FBQ0g7O0FBRUQsV0FBUzhNLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCN00sS0FBMUIsRUFBaUM7QUFDN0IsUUFBSSxDQUFDdUMsU0FBUyxDQUFDdkMsS0FBRCxDQUFkLEVBQXVCO0FBQ25CLFlBQU0sSUFBSXlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQiwyQkFBckMsQ0FBTjtBQUNILEtBSDRCLENBSzdCO0FBQ0E7OztBQUNBK00sVUFBTSxDQUFDckUsVUFBUCxHQUFvQnhJLEtBQXBCO0FBQ0g7O0FBRUQsV0FBUzhNLDBCQUFULENBQW9DRCxNQUFwQyxFQUE0QzdNLEtBQTVDLEVBQW1EO0FBQy9DLFFBQUksQ0FBQ3VDLFNBQVMsQ0FBQ3ZDLEtBQUQsQ0FBZCxFQUF1QjtBQUNuQixZQUFNLElBQUl5SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsNkNBQXJDLENBQU47QUFDSDs7QUFFRCtNLFVBQU0sQ0FBQ0Usc0JBQVAsR0FBZ0MvTSxLQUFoQztBQUNIOztBQUVELFdBQVNnTix1QkFBVCxDQUFpQ0gsTUFBakMsRUFBeUM3TSxLQUF6QyxFQUFnRDtBQUM1QyxRQUFJLENBQUN1QyxTQUFTLENBQUN2QyxLQUFELENBQWQsRUFBdUI7QUFDbkIsWUFBTSxJQUFJeUgsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLDBDQUFyQyxDQUFOO0FBQ0g7O0FBRUQrTSxVQUFNLENBQUNJLG1CQUFQLEdBQTZCak4sS0FBN0I7QUFDSDs7QUFFRCxXQUFTa04sU0FBVCxDQUFtQkwsTUFBbkIsRUFBMkI3TSxLQUEzQixFQUFrQztBQUM5QjtBQUNBLFFBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QnFELEtBQUssQ0FBQ0MsT0FBTixDQUFjdEQsS0FBZCxDQUFqQyxFQUF1RDtBQUNuRCxZQUFNLElBQUl5SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsOEJBQXJDLENBQU47QUFDSCxLQUo2QixDQU05Qjs7O0FBQ0EsUUFBSUUsS0FBSyxDQUFDbUQsR0FBTixLQUFjMUMsU0FBZCxJQUEyQlQsS0FBSyxDQUFDa0QsR0FBTixLQUFjekMsU0FBN0MsRUFBd0Q7QUFDcEQsWUFBTSxJQUFJZ0gsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLHVDQUFyQyxDQUFOO0FBQ0gsS0FUNkIsQ0FXOUI7OztBQUNBLFFBQUlFLEtBQUssQ0FBQ21ELEdBQU4sS0FBY25ELEtBQUssQ0FBQ2tELEdBQXhCLEVBQTZCO0FBQ3pCLFlBQU0sSUFBSXVFLEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQiw2Q0FBckMsQ0FBTjtBQUNIOztBQUVEK00sVUFBTSxDQUFDTSxRQUFQLEdBQWtCLElBQUk1RSxRQUFKLENBQWF2SSxLQUFiLEVBQW9CNk0sTUFBTSxDQUFDMUYsSUFBM0IsRUFBaUMwRixNQUFNLENBQUNyRSxVQUF4QyxDQUFsQjtBQUNIOztBQUVELFdBQVM0RSxTQUFULENBQW1CUCxNQUFuQixFQUEyQjdNLEtBQTNCLEVBQWtDO0FBQzlCQSxTQUFLLEdBQUdvRCxPQUFPLENBQUNwRCxLQUFELENBQWYsQ0FEOEIsQ0FHOUI7QUFDQTs7QUFDQSxRQUFJLENBQUNxRCxLQUFLLENBQUNDLE9BQU4sQ0FBY3RELEtBQWQsQ0FBRCxJQUF5QixDQUFDQSxLQUFLLENBQUM0RCxNQUFwQyxFQUE0QztBQUN4QyxZQUFNLElBQUk2RCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsaUNBQXJDLENBQU47QUFDSCxLQVA2QixDQVM5Qjs7O0FBQ0ErTSxVQUFNLENBQUNRLE9BQVAsR0FBaUJyTixLQUFLLENBQUM0RCxNQUF2QixDQVY4QixDQVk5QjtBQUNBOztBQUNBaUosVUFBTSxDQUFDN0gsS0FBUCxHQUFlaEYsS0FBZjtBQUNIOztBQUVELFdBQVNzTixRQUFULENBQWtCVCxNQUFsQixFQUEwQjdNLEtBQTFCLEVBQWlDO0FBQzdCO0FBQ0E2TSxVQUFNLENBQUMxRixJQUFQLEdBQWNuSCxLQUFkOztBQUVBLFFBQUksT0FBT0EsS0FBUCxLQUFpQixTQUFyQixFQUFnQztBQUM1QixZQUFNLElBQUl5SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIscUNBQXJDLENBQU47QUFDSDtBQUNKOztBQUVELFdBQVN5TixXQUFULENBQXFCVixNQUFyQixFQUE2QjdNLEtBQTdCLEVBQW9DO0FBQ2hDO0FBQ0E2TSxVQUFNLENBQUNXLE9BQVAsR0FBaUJ4TixLQUFqQjs7QUFFQSxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDNUIsWUFBTSxJQUFJeUgsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLHdDQUFyQyxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxXQUFTMk4scUJBQVQsQ0FBK0JaLE1BQS9CLEVBQXVDN00sS0FBdkMsRUFBOEM7QUFDMUM2TSxVQUFNLENBQUNhLGlCQUFQLEdBQTJCMU4sS0FBM0I7O0FBRUEsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzNCLFlBQU0sSUFBSXlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQixpREFBckMsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQsV0FBUzZOLFdBQVQsQ0FBcUJkLE1BQXJCLEVBQTZCN00sS0FBN0IsRUFBb0M7QUFDaEMsUUFBSWtMLE9BQU8sR0FBRyxDQUFDLEtBQUQsQ0FBZDtBQUNBLFFBQUlwRCxDQUFKLENBRmdDLENBSWhDOztBQUNBLFFBQUk5SCxLQUFLLEtBQUssT0FBZCxFQUF1QjtBQUNuQkEsV0FBSyxHQUFHLENBQUMsSUFBRCxFQUFPLEtBQVAsQ0FBUjtBQUNILEtBRkQsTUFFTyxJQUFJQSxLQUFLLEtBQUssT0FBZCxFQUF1QjtBQUMxQkEsV0FBSyxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsQ0FBUjtBQUNILEtBVCtCLENBV2hDOzs7QUFDQSxRQUFJQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLLEtBQWhDLEVBQXVDO0FBQ25DLFdBQUs4SCxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUcrRSxNQUFNLENBQUNRLE9BQXZCLEVBQWdDdkYsQ0FBQyxFQUFqQyxFQUFxQztBQUNqQ29ELGVBQU8sQ0FBQ3ZELElBQVIsQ0FBYTNILEtBQWI7QUFDSDs7QUFFRGtMLGFBQU8sQ0FBQ3ZELElBQVIsQ0FBYSxLQUFiO0FBQ0gsS0FORCxDQVFBO0FBUkEsU0FTSyxJQUFJLENBQUN0RSxLQUFLLENBQUNDLE9BQU4sQ0FBY3RELEtBQWQsQ0FBRCxJQUF5QixDQUFDQSxLQUFLLENBQUM0RCxNQUFoQyxJQUEwQzVELEtBQUssQ0FBQzRELE1BQU4sS0FBaUJpSixNQUFNLENBQUNRLE9BQVAsR0FBaUIsQ0FBaEYsRUFBbUY7QUFDcEYsY0FBTSxJQUFJNUYsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLGlEQUFyQyxDQUFOO0FBQ0gsT0FGSSxNQUVFO0FBQ0hvTCxlQUFPLEdBQUdsTCxLQUFWO0FBQ0g7O0FBRUQ2TSxVQUFNLENBQUMzQixPQUFQLEdBQWlCQSxPQUFqQjtBQUNIOztBQUVELFdBQVMwQyxlQUFULENBQXlCZixNQUF6QixFQUFpQzdNLEtBQWpDLEVBQXdDO0FBQ3BDO0FBQ0E7QUFDQSxZQUFRQSxLQUFSO0FBQ0ksV0FBSyxZQUFMO0FBQ0k2TSxjQUFNLENBQUNnQixHQUFQLEdBQWEsQ0FBYjtBQUNBOztBQUNKLFdBQUssVUFBTDtBQUNJaEIsY0FBTSxDQUFDZ0IsR0FBUCxHQUFhLENBQWI7QUFDQTs7QUFDSjtBQUNJLGNBQU0sSUFBSXBHLEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQixxQ0FBckMsQ0FBTjtBQVJSO0FBVUg7O0FBRUQsV0FBU2dPLFVBQVQsQ0FBb0JqQixNQUFwQixFQUE0QjdNLEtBQTVCLEVBQW1DO0FBQy9CLFFBQUksQ0FBQ3VDLFNBQVMsQ0FBQ3ZDLEtBQUQsQ0FBZCxFQUF1QjtBQUNuQixZQUFNLElBQUl5SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIscUNBQXJDLENBQU47QUFDSCxLQUg4QixDQUsvQjs7O0FBQ0EsUUFBSUUsS0FBSyxLQUFLLENBQWQsRUFBaUI7QUFDYjtBQUNIOztBQUVENk0sVUFBTSxDQUFDa0IsTUFBUCxHQUFnQmxCLE1BQU0sQ0FBQ00sUUFBUCxDQUFnQnRFLFdBQWhCLENBQTRCN0ksS0FBNUIsQ0FBaEI7QUFDSDs7QUFFRCxXQUFTZ08sU0FBVCxDQUFtQm5CLE1BQW5CLEVBQTJCN00sS0FBM0IsRUFBa0M7QUFDOUIsUUFBSSxDQUFDdUMsU0FBUyxDQUFDdkMsS0FBRCxDQUFkLEVBQXVCO0FBQ25CLFlBQU0sSUFBSXlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQixvQ0FBckMsQ0FBTjtBQUNIOztBQUVEK00sVUFBTSxDQUFDNUosS0FBUCxHQUFlNEosTUFBTSxDQUFDTSxRQUFQLENBQWdCdEUsV0FBaEIsQ0FBNEI3SSxLQUE1QixDQUFmOztBQUVBLFFBQUksQ0FBQzZNLE1BQU0sQ0FBQzVKLEtBQVIsSUFBaUI0SixNQUFNLENBQUNRLE9BQVAsR0FBaUIsQ0FBdEMsRUFBeUM7QUFDckMsWUFBTSxJQUFJNUYsS0FBSixDQUNGLGlCQUNJM0gsT0FESixHQUVJLCtFQUhGLENBQU47QUFLSDtBQUNKOztBQUVELFdBQVNtTyxXQUFULENBQXFCcEIsTUFBckIsRUFBNkI3TSxLQUE3QixFQUFvQztBQUNoQyxRQUFJc0gsS0FBSjs7QUFFQSxRQUFJLENBQUMvRSxTQUFTLENBQUN2QyxLQUFELENBQVYsSUFBcUIsQ0FBQ3FELEtBQUssQ0FBQ0MsT0FBTixDQUFjdEQsS0FBZCxDQUExQixFQUFnRDtBQUM1QyxZQUFNLElBQUl5SCxLQUFKLENBQ0YsaUJBQWlCM0gsT0FBakIsR0FBMkIsb0VBRHpCLENBQU47QUFHSDs7QUFFRCxRQUFJdUQsS0FBSyxDQUFDQyxPQUFOLENBQWN0RCxLQUFkLEtBQXdCLEVBQUVBLEtBQUssQ0FBQzRELE1BQU4sS0FBaUIsQ0FBakIsSUFBc0JyQixTQUFTLENBQUN2QyxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQS9CLElBQTZDdUMsU0FBUyxDQUFDdkMsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUF4RCxDQUE1QixFQUFpRztBQUM3RixZQUFNLElBQUl5SCxLQUFKLENBQ0YsaUJBQWlCM0gsT0FBakIsR0FBMkIsb0VBRHpCLENBQU47QUFHSDs7QUFFRCxRQUFJRSxLQUFLLEtBQUssQ0FBZCxFQUFpQjtBQUNiO0FBQ0g7O0FBRUQsUUFBSSxDQUFDcUQsS0FBSyxDQUFDQyxPQUFOLENBQWN0RCxLQUFkLENBQUwsRUFBMkI7QUFDdkJBLFdBQUssR0FBRyxDQUFDQSxLQUFELEVBQVFBLEtBQVIsQ0FBUjtBQUNILEtBckIrQixDQXVCaEM7OztBQUNBNk0sVUFBTSxDQUFDcUIsT0FBUCxHQUFpQixDQUFDckIsTUFBTSxDQUFDTSxRQUFQLENBQWdCdEUsV0FBaEIsQ0FBNEI3SSxLQUFLLENBQUMsQ0FBRCxDQUFqQyxDQUFELEVBQXdDNk0sTUFBTSxDQUFDTSxRQUFQLENBQWdCdEUsV0FBaEIsQ0FBNEI3SSxLQUFLLENBQUMsQ0FBRCxDQUFqQyxDQUF4QyxDQUFqQjs7QUFFQSxTQUFLc0gsS0FBSyxHQUFHLENBQWIsRUFBZ0JBLEtBQUssR0FBR3VGLE1BQU0sQ0FBQ00sUUFBUCxDQUFnQmxGLFNBQWhCLENBQTBCckUsTUFBMUIsR0FBbUMsQ0FBM0QsRUFBOEQwRCxLQUFLLEVBQW5FLEVBQXVFO0FBQ25FO0FBQ0EsVUFBSXVGLE1BQU0sQ0FBQ3FCLE9BQVAsQ0FBZSxDQUFmLEVBQWtCNUcsS0FBbEIsSUFBMkIsQ0FBM0IsSUFBZ0N1RixNQUFNLENBQUNxQixPQUFQLENBQWUsQ0FBZixFQUFrQjVHLEtBQWxCLElBQTJCLENBQS9ELEVBQWtFO0FBQzlELGNBQU0sSUFBSUcsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLG1EQUFyQyxDQUFOO0FBQ0g7QUFDSjs7QUFFRCxRQUFJcU8sWUFBWSxHQUFHbk8sS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFuQztBQUNBLFFBQUlvTyxVQUFVLEdBQUd2QixNQUFNLENBQUNNLFFBQVAsQ0FBZ0J4RyxJQUFoQixDQUFxQixDQUFyQixDQUFqQjtBQUNBLFFBQUkwSCxTQUFTLEdBQUd4QixNQUFNLENBQUNNLFFBQVAsQ0FBZ0J4RyxJQUFoQixDQUFxQmtHLE1BQU0sQ0FBQ00sUUFBUCxDQUFnQnhHLElBQWhCLENBQXFCL0MsTUFBckIsR0FBOEIsQ0FBbkQsQ0FBaEI7O0FBRUEsUUFBSXVLLFlBQVksSUFBSUUsU0FBUyxHQUFHRCxVQUFoQixDQUFaLEdBQTBDLENBQTlDLEVBQWlEO0FBQzdDLFlBQU0sSUFBSTNHLEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQix3REFBckMsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQsV0FBU3dPLGFBQVQsQ0FBdUJ6QixNQUF2QixFQUErQjdNLEtBQS9CLEVBQXNDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFlBQVFBLEtBQVI7QUFDSSxXQUFLLEtBQUw7QUFDSTZNLGNBQU0sQ0FBQzBCLEdBQVAsR0FBYSxDQUFiO0FBQ0E7O0FBQ0osV0FBSyxLQUFMO0FBQ0kxQixjQUFNLENBQUMwQixHQUFQLEdBQWEsQ0FBYjtBQUNBOztBQUNKO0FBQ0ksY0FBTSxJQUFJOUcsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLDJDQUFyQyxDQUFOO0FBUlI7QUFVSDs7QUFFRCxXQUFTME8sYUFBVCxDQUF1QjNCLE1BQXZCLEVBQStCN00sS0FBL0IsRUFBc0M7QUFDbEM7QUFDQSxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDM0IsWUFBTSxJQUFJeUgsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLHFEQUFyQyxDQUFOO0FBQ0gsS0FKaUMsQ0FNbEM7QUFDQTs7O0FBQ0EsUUFBSTRMLEdBQUcsR0FBRzFMLEtBQUssQ0FBQ3lPLE9BQU4sQ0FBYyxLQUFkLEtBQXdCLENBQWxDO0FBQ0EsUUFBSWhELElBQUksR0FBR3pMLEtBQUssQ0FBQ3lPLE9BQU4sQ0FBYyxNQUFkLEtBQXlCLENBQXBDO0FBQ0EsUUFBSUMsS0FBSyxHQUFHMU8sS0FBSyxDQUFDeU8sT0FBTixDQUFjLE9BQWQsS0FBMEIsQ0FBdEM7QUFDQSxRQUFJdEgsSUFBSSxHQUFHbkgsS0FBSyxDQUFDeU8sT0FBTixDQUFjLE1BQWQsS0FBeUIsQ0FBcEM7QUFDQSxRQUFJRSxLQUFLLEdBQUczTyxLQUFLLENBQUN5TyxPQUFOLENBQWMsT0FBZCxLQUEwQixDQUF0QztBQUNBLFFBQUlHLGFBQWEsR0FBRzVPLEtBQUssQ0FBQ3lPLE9BQU4sQ0FBYyxlQUFkLEtBQWtDLENBQXREOztBQUVBLFFBQUlDLEtBQUosRUFBVztBQUNQLFVBQUk3QixNQUFNLENBQUNRLE9BQVAsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsY0FBTSxJQUFJNUYsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLGtEQUFyQyxDQUFOO0FBQ0gsT0FITSxDQUtQOzs7QUFDQWdPLGdCQUFVLENBQUNqQixNQUFELEVBQVNBLE1BQU0sQ0FBQzdILEtBQVAsQ0FBYSxDQUFiLElBQWtCNkgsTUFBTSxDQUFDN0gsS0FBUCxDQUFhLENBQWIsQ0FBM0IsQ0FBVjtBQUNIOztBQUVELFFBQUk0SixhQUFhLEtBQUsvQixNQUFNLENBQUNrQixNQUFQLElBQWlCbEIsTUFBTSxDQUFDNUosS0FBN0IsQ0FBakIsRUFBc0Q7QUFDbEQsWUFBTSxJQUFJd0UsS0FBSixDQUNGLGlCQUFpQjNILE9BQWpCLEdBQTJCLGtFQUR6QixDQUFOO0FBR0g7O0FBRUQrTSxVQUFNLENBQUNnQyxNQUFQLEdBQWdCO0FBQ1puRCxTQUFHLEVBQUVBLEdBQUcsSUFBSXZFLElBREE7QUFFWnNFLFVBQUksRUFBRUEsSUFGTTtBQUdaaUQsV0FBSyxFQUFFQSxLQUhLO0FBSVp2SCxVQUFJLEVBQUVBLElBSk07QUFLWndILFdBQUssRUFBRUEsS0FMSztBQU1aQyxtQkFBYSxFQUFFQTtBQU5ILEtBQWhCO0FBUUg7O0FBRUQsV0FBU0UsWUFBVCxDQUFzQmpDLE1BQXRCLEVBQThCN00sS0FBOUIsRUFBcUM7QUFDakMsUUFBSUEsS0FBSyxLQUFLLEtBQWQsRUFBcUI7QUFDakI7QUFDSDs7QUFFRCxRQUFJQSxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNoQjZNLFlBQU0sQ0FBQ2tDLFFBQVAsR0FBa0IsRUFBbEI7O0FBRUEsV0FBSyxJQUFJakgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytFLE1BQU0sQ0FBQ1EsT0FBM0IsRUFBb0N2RixDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDK0UsY0FBTSxDQUFDa0MsUUFBUCxDQUFnQnBILElBQWhCLENBQXFCLElBQXJCO0FBQ0g7QUFDSixLQU5ELE1BTU87QUFDSGtGLFlBQU0sQ0FBQ2tDLFFBQVAsR0FBa0IzTCxPQUFPLENBQUNwRCxLQUFELENBQXpCOztBQUVBLFVBQUk2TSxNQUFNLENBQUNrQyxRQUFQLENBQWdCbkwsTUFBaEIsS0FBMkJpSixNQUFNLENBQUNRLE9BQXRDLEVBQStDO0FBQzNDLGNBQU0sSUFBSTVGLEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQiwyQ0FBckMsQ0FBTjtBQUNIOztBQUVEK00sWUFBTSxDQUFDa0MsUUFBUCxDQUFnQkMsT0FBaEIsQ0FBd0IsVUFBU0MsU0FBVCxFQUFvQjtBQUN4QyxZQUNJLE9BQU9BLFNBQVAsS0FBcUIsU0FBckIsS0FDQyxPQUFPQSxTQUFQLEtBQXFCLFFBQXJCLElBQWlDLE9BQU9BLFNBQVMsQ0FBQ2hQLEVBQWpCLEtBQXdCLFVBRDFELENBREosRUFHRTtBQUNFLGdCQUFNLElBQUl3SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsc0RBQXJDLENBQU47QUFDSDtBQUNKLE9BUEQ7QUFRSDtBQUNKOztBQUVELFdBQVNvUCxjQUFULENBQXdCckMsTUFBeEIsRUFBZ0M3TSxLQUFoQyxFQUF1QztBQUNuQzZNLFVBQU0sQ0FBQ3NDLFVBQVAsR0FBb0JuUCxLQUFwQjtBQUNBMk0sa0JBQWMsQ0FBQzNNLEtBQUQsQ0FBZDtBQUNIOztBQUVELFdBQVNvUCxVQUFULENBQW9CdkMsTUFBcEIsRUFBNEI3TSxLQUE1QixFQUFtQztBQUMvQjZNLFVBQU0sQ0FBQ3dDLE1BQVAsR0FBZ0JyUCxLQUFoQjtBQUNBMk0sa0JBQWMsQ0FBQzNNLEtBQUQsQ0FBZDtBQUNIOztBQUVELFdBQVNzUCxtQkFBVCxDQUE2QnpDLE1BQTdCLEVBQXFDN00sS0FBckMsRUFBNEM7QUFDeEM2TSxVQUFNLENBQUMwQyxlQUFQLEdBQXlCdlAsS0FBekI7O0FBRUEsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFNBQXJCLEVBQWdDO0FBQzVCLFlBQU0sSUFBSXlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQixnREFBckMsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQsV0FBUzBQLG1CQUFULENBQTZCM0MsTUFBN0IsRUFBcUM3TSxLQUFyQyxFQUE0QztBQUN4QztBQUNBNk0sVUFBTSxDQUFDbEwsZUFBUCxHQUF5QjNCLEtBQXpCO0FBQ0g7O0FBRUQsV0FBU3lQLGFBQVQsQ0FBdUI1QyxNQUF2QixFQUErQjdNLEtBQS9CLEVBQXNDO0FBQ2xDLFFBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBSyxLQUFLLEtBQTNDLEVBQWtEO0FBQzlDLFlBQU0sSUFBSXlILEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQiw2Q0FBckMsQ0FBTjtBQUNIOztBQUVEK00sVUFBTSxDQUFDNkMsU0FBUCxHQUFtQjFQLEtBQW5CO0FBQ0g7O0FBRUQsV0FBUzJQLGNBQVQsQ0FBd0I5QyxNQUF4QixFQUFnQzdNLEtBQWhDLEVBQXVDO0FBQ25DLFFBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUMzQixZQUFNLElBQUl5SCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsb0NBQXJDLENBQU47QUFDSDs7QUFFRCxRQUFJLE9BQU8rTSxNQUFNLENBQUM2QyxTQUFkLEtBQTRCLFFBQWhDLEVBQTBDO0FBQ3RDN0MsWUFBTSxDQUFDdEMsVUFBUCxHQUFvQixFQUFwQjs7QUFFQSxXQUFLLElBQUlxRixHQUFULElBQWdCNVAsS0FBaEIsRUFBdUI7QUFDbkIsWUFBSSxDQUFDQSxLQUFLLENBQUMwSSxjQUFOLENBQXFCa0gsR0FBckIsQ0FBTCxFQUFnQztBQUM1QjtBQUNIOztBQUVEL0MsY0FBTSxDQUFDdEMsVUFBUCxDQUFrQnFGLEdBQWxCLElBQXlCL0MsTUFBTSxDQUFDNkMsU0FBUCxHQUFtQjFQLEtBQUssQ0FBQzRQLEdBQUQsQ0FBakQ7QUFDSDtBQUNKLEtBVkQsTUFVTztBQUNIL0MsWUFBTSxDQUFDdEMsVUFBUCxHQUFvQnZLLEtBQXBCO0FBQ0g7QUFDSixHQTU4QlMsQ0E4OEJWOzs7QUFDQSxXQUFTNlAsV0FBVCxDQUFxQkMsT0FBckIsRUFBOEI7QUFDMUI7QUFDQTtBQUNBO0FBRUEsUUFBSWpELE1BQU0sR0FBRztBQUNUa0IsWUFBTSxFQUFFLENBREM7QUFFVDlLLFdBQUssRUFBRSxDQUZFO0FBR1RpTCxhQUFPLEVBQUUsQ0FIQTtBQUlUVixhQUFPLEVBQUUsSUFKQTtBQUtURSx1QkFBaUIsRUFBRSxHQUxWO0FBTVR5QixnQkFBVSxFQUFFN0UsZ0JBTkg7QUFPVCtFLFlBQU0sRUFBRS9FO0FBUEMsS0FBYixDQUwwQixDQWUxQjs7QUFDQSxRQUFJeUYsS0FBSyxHQUFHO0FBQ1J6SCxVQUFJLEVBQUU7QUFBRTBILFNBQUMsRUFBRSxLQUFMO0FBQVlDLFNBQUMsRUFBRXJEO0FBQWYsT0FERTtBQUVSRyw0QkFBc0IsRUFBRTtBQUFFaUQsU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFbkQ7QUFBZixPQUZoQjtBQUdSRyx5QkFBbUIsRUFBRTtBQUFFK0MsU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFakQ7QUFBZixPQUhiO0FBSVJoSSxXQUFLLEVBQUU7QUFBRWdMLFNBQUMsRUFBRSxJQUFMO0FBQVdDLFNBQUMsRUFBRTdDO0FBQWQsT0FKQztBQUtSbEMsYUFBTyxFQUFFO0FBQUU4RSxTQUFDLEVBQUUsSUFBTDtBQUFXQyxTQUFDLEVBQUV0QztBQUFkLE9BTEQ7QUFNUjNFLGVBQVMsRUFBRTtBQUFFZ0gsU0FBQyxFQUFFLElBQUw7QUFBV0MsU0FBQyxFQUFFM0I7QUFBZCxPQU5IO0FBT1JuSCxVQUFJLEVBQUU7QUFBRTZJLFNBQUMsRUFBRSxLQUFMO0FBQVlDLFNBQUMsRUFBRTNDO0FBQWYsT0FQRTtBQVFSRSxhQUFPLEVBQUU7QUFBRXdDLFNBQUMsRUFBRSxLQUFMO0FBQVlDLFNBQUMsRUFBRTFDO0FBQWYsT0FSRDtBQVNSRyx1QkFBaUIsRUFBRTtBQUFFc0MsU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFeEM7QUFBZixPQVRYO0FBVVJ2SCxXQUFLLEVBQUU7QUFBRThKLFNBQUMsRUFBRSxJQUFMO0FBQVdDLFNBQUMsRUFBRS9DO0FBQWQsT0FWQztBQVdSN0wsaUJBQVcsRUFBRTtBQUFFMk8sU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFckM7QUFBZixPQVhMO0FBWVJHLFlBQU0sRUFBRTtBQUFFaUMsU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFbkM7QUFBZixPQVpBO0FBYVI3SyxXQUFLLEVBQUU7QUFBRStNLFNBQUMsRUFBRSxLQUFMO0FBQVlDLFNBQUMsRUFBRWpDO0FBQWYsT0FiQztBQWNSRSxhQUFPLEVBQUU7QUFBRThCLFNBQUMsRUFBRSxLQUFMO0FBQVlDLFNBQUMsRUFBRWhDO0FBQWYsT0FkRDtBQWVSaUMsZUFBUyxFQUFFO0FBQUVGLFNBQUMsRUFBRSxJQUFMO0FBQVdDLFNBQUMsRUFBRXpCO0FBQWQsT0FmSDtBQWdCUlcsZ0JBQVUsRUFBRTtBQUFFYSxTQUFDLEVBQUUsS0FBTDtBQUFZQyxTQUFDLEVBQUVmO0FBQWYsT0FoQko7QUFpQlJHLFlBQU0sRUFBRTtBQUFFVyxTQUFDLEVBQUUsS0FBTDtBQUFZQyxTQUFDLEVBQUViO0FBQWYsT0FqQkE7QUFrQlJMLGNBQVEsRUFBRTtBQUFFaUIsU0FBQyxFQUFFLEtBQUw7QUFBWUMsU0FBQyxFQUFFbkI7QUFBZixPQWxCRjtBQW1CUlMscUJBQWUsRUFBRTtBQUFFUyxTQUFDLEVBQUUsSUFBTDtBQUFXQyxTQUFDLEVBQUVYO0FBQWQsT0FuQlQ7QUFvQlIzTixxQkFBZSxFQUFFO0FBQUVxTyxTQUFDLEVBQUUsS0FBTDtBQUFZQyxTQUFDLEVBQUVUO0FBQWYsT0FwQlQ7QUFxQlJFLGVBQVMsRUFBRTtBQUFFTSxTQUFDLEVBQUUsSUFBTDtBQUFXQyxTQUFDLEVBQUVSO0FBQWQsT0FyQkg7QUFzQlJsRixnQkFBVSxFQUFFO0FBQUV5RixTQUFDLEVBQUUsSUFBTDtBQUFXQyxTQUFDLEVBQUVOO0FBQWQ7QUF0QkosS0FBWjtBQXlCQSxRQUFJUSxRQUFRLEdBQUc7QUFDWGpGLGFBQU8sRUFBRSxLQURFO0FBRVhsQyxlQUFTLEVBQUUsS0FGQTtBQUdYa0gsZUFBUyxFQUFFLEtBSEE7QUFJWDdPLGlCQUFXLEVBQUUsWUFKRjtBQUtYa08scUJBQWUsRUFBRSxJQUxOO0FBTVhHLGVBQVMsRUFBRSxPQU5BO0FBT1huRixnQkFBVSxFQUFFQSxVQVBEO0FBUVh3Qyw0QkFBc0IsRUFBRSxDQVJiO0FBU1hFLHlCQUFtQixFQUFFO0FBVFYsS0FBZixDQXpDMEIsQ0FxRDFCOztBQUNBLFFBQUk2QyxPQUFPLENBQUNULE1BQVIsSUFBa0IsQ0FBQ1MsT0FBTyxDQUFDWCxVQUEvQixFQUEyQztBQUN2Q1csYUFBTyxDQUFDWCxVQUFSLEdBQXFCVyxPQUFPLENBQUNULE1BQTdCO0FBQ0gsS0F4RHlCLENBMEQxQjtBQUNBO0FBQ0E7OztBQUNBOUosVUFBTSxDQUFDNkssSUFBUCxDQUFZTCxLQUFaLEVBQW1CZixPQUFuQixDQUEyQixVQUFTcUIsSUFBVCxFQUFlO0FBQ3RDO0FBQ0EsVUFBSSxDQUFDOVAsS0FBSyxDQUFDdVAsT0FBTyxDQUFDTyxJQUFELENBQVIsQ0FBTixJQUF5QkYsUUFBUSxDQUFDRSxJQUFELENBQVIsS0FBbUI1UCxTQUFoRCxFQUEyRDtBQUN2RCxZQUFJc1AsS0FBSyxDQUFDTSxJQUFELENBQUwsQ0FBWUwsQ0FBaEIsRUFBbUI7QUFDZixnQkFBTSxJQUFJdkksS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLE1BQTNCLEdBQW9DdVEsSUFBcEMsR0FBMkMsZ0JBQXJELENBQU47QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSDs7QUFFRE4sV0FBSyxDQUFDTSxJQUFELENBQUwsQ0FBWUosQ0FBWixDQUFjcEQsTUFBZCxFQUFzQixDQUFDdE0sS0FBSyxDQUFDdVAsT0FBTyxDQUFDTyxJQUFELENBQVIsQ0FBTixHQUF3QkYsUUFBUSxDQUFDRSxJQUFELENBQWhDLEdBQXlDUCxPQUFPLENBQUNPLElBQUQsQ0FBdEU7QUFDSCxLQVhELEVBN0QwQixDQTBFMUI7O0FBQ0F4RCxVQUFNLENBQUNoQixJQUFQLEdBQWNpRSxPQUFPLENBQUNqRSxJQUF0QixDQTNFMEIsQ0E2RTFCO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFFBQUl5RSxDQUFDLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFSO0FBQ0EsUUFBSUMsUUFBUSxHQUFHSCxDQUFDLENBQUNJLEtBQUYsQ0FBUUMsV0FBUixLQUF3QmxRLFNBQXZDO0FBQ0EsUUFBSW1RLFFBQVEsR0FBR04sQ0FBQyxDQUFDSSxLQUFGLENBQVFHLFNBQVIsS0FBc0JwUSxTQUFyQztBQUVBb00sVUFBTSxDQUFDaUUsYUFBUCxHQUF1QkYsUUFBUSxHQUFHLFdBQUgsR0FBaUJILFFBQVEsR0FBRyxhQUFILEdBQW1CLGlCQUEzRSxDQXJGMEIsQ0F1RjFCOztBQUNBLFFBQUlNLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBRCxFQUFTLEtBQVQsQ0FBRCxFQUFrQixDQUFDLE9BQUQsRUFBVSxRQUFWLENBQWxCLENBQWI7QUFFQWxFLFVBQU0sQ0FBQzZELEtBQVAsR0FBZUssTUFBTSxDQUFDbEUsTUFBTSxDQUFDMEIsR0FBUixDQUFOLENBQW1CMUIsTUFBTSxDQUFDZ0IsR0FBMUIsQ0FBZjtBQUVBLFdBQU9oQixNQUFQO0FBQ0gsR0E1aUNTLENBOGlDVjs7O0FBRUEsV0FBU21FLEtBQVQsQ0FBZXhHLE1BQWYsRUFBdUJzRixPQUF2QixFQUFnQ21CLGVBQWhDLEVBQWlEO0FBQzdDLFFBQUlDLE9BQU8sR0FBR3BNLFVBQVUsRUFBeEI7QUFDQSxRQUFJcU0sdUJBQXVCLEdBQUd4TCwwQkFBMEIsRUFBeEQ7QUFDQSxRQUFJTixlQUFlLEdBQUc4TCx1QkFBdUIsSUFBSS9MLGtCQUFrQixFQUFuRSxDQUg2QyxDQUs3QztBQUVBOztBQUNBLFFBQUlnTSxZQUFZLEdBQUc1RyxNQUFuQjtBQUNBLFFBQUk2RyxVQUFKO0FBQ0EsUUFBSUMsYUFBSjtBQUNBLFFBQUlDLGNBQUo7QUFDQSxRQUFJQyxVQUFKO0FBQ0EsUUFBSUMsY0FBSixDQWI2QyxDQWU3Qzs7QUFDQSxRQUFJQyxjQUFjLEdBQUc1QixPQUFPLENBQUMzQyxRQUE3QjtBQUNBLFFBQUl3RSxZQUFZLEdBQUcsRUFBbkI7QUFDQSxRQUFJQyxlQUFlLEdBQUcsRUFBdEI7QUFDQSxRQUFJQyxtQkFBbUIsR0FBRyxFQUExQjtBQUNBLFFBQUlDLHdCQUF3QixHQUFHLENBQS9CO0FBQ0EsUUFBSUMsWUFBWSxHQUFHLEVBQW5CLENBckI2QyxDQXVCN0M7O0FBQ0EsUUFBSUMsVUFBSixDQXhCNkMsQ0EwQjdDOztBQUNBLFFBQUlDLGNBQWMsR0FBR3pILE1BQU0sQ0FBQy9JLGFBQTVCO0FBQ0EsUUFBSXlRLHFCQUFxQixHQUFHcEMsT0FBTyxDQUFDbk8sZUFBUixJQUEyQnNRLGNBQWMsQ0FBQ3RRLGVBQXRFO0FBQ0EsUUFBSXdRLFVBQVUsR0FBR0YsY0FBYyxDQUFDdE4sSUFBaEMsQ0E3QjZDLENBK0I3Qzs7QUFDQSxRQUFJeU4sU0FBUyxHQUFHLENBQUMsQ0FBakI7QUFDQSxRQUFJQyxhQUFhLEdBQUcsQ0FBcEI7QUFDQSxRQUFJQyxnQkFBZ0IsR0FBRyxDQUF2QjtBQUNBLFFBQUlDLGdCQUFnQixHQUFHLENBQXZCLENBbkM2QyxDQXFDN0M7QUFDQTs7QUFDQSxRQUFJQyxlQUFlLEdBQUdQLGNBQWMsQ0FBQzFELEdBQWYsS0FBdUIsS0FBdkIsSUFBZ0N1QixPQUFPLENBQUNqQyxHQUFSLEtBQWdCLENBQWhELEdBQW9ELENBQXBELEdBQXdELEdBQTlFLENBdkM2QyxDQXlDN0M7O0FBQ0EsYUFBUzRFLFNBQVQsQ0FBbUJDLFNBQW5CLEVBQThCOVAsU0FBOUIsRUFBeUM7QUFDckMsVUFBSStQLEdBQUcsR0FBR1YsY0FBYyxDQUFDekIsYUFBZixDQUE2QixLQUE3QixDQUFWOztBQUVBLFVBQUk1TixTQUFKLEVBQWU7QUFDWEUsZ0JBQVEsQ0FBQzZQLEdBQUQsRUFBTS9QLFNBQU4sQ0FBUjtBQUNIOztBQUVEOFAsZUFBUyxDQUFDRSxXQUFWLENBQXNCRCxHQUF0QjtBQUVBLGFBQU9BLEdBQVA7QUFDSCxLQXBENEMsQ0FzRDdDOzs7QUFDQSxhQUFTRSxTQUFULENBQW1CcEksSUFBbkIsRUFBeUJxSSxZQUF6QixFQUF1QztBQUNuQyxVQUFJcEksTUFBTSxHQUFHK0gsU0FBUyxDQUFDaEksSUFBRCxFQUFPcUYsT0FBTyxDQUFDdkYsVUFBUixDQUFtQkcsTUFBMUIsQ0FBdEI7QUFDQSxVQUFJQyxNQUFNLEdBQUc4SCxTQUFTLENBQUMvSCxNQUFELEVBQVNvRixPQUFPLENBQUN2RixVQUFSLENBQW1CSSxNQUE1QixDQUF0QjtBQUVBOEgsZUFBUyxDQUFDOUgsTUFBRCxFQUFTbUYsT0FBTyxDQUFDdkYsVUFBUixDQUFtQk8sU0FBNUIsQ0FBVDtBQUVBSCxZQUFNLENBQUNvSSxZQUFQLENBQW9CLGFBQXBCLEVBQW1DRCxZQUFuQzs7QUFFQSxVQUFJaEQsT0FBTyxDQUFDUCxlQUFaLEVBQTZCO0FBQ3pCO0FBQ0E7QUFDQTVFLGNBQU0sQ0FBQ29JLFlBQVAsQ0FBb0IsVUFBcEIsRUFBZ0MsR0FBaEM7QUFDQXBJLGNBQU0sQ0FBQ2pGLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFVBQVNzTixLQUFULEVBQWdCO0FBQy9DLGlCQUFPQyxZQUFZLENBQUNELEtBQUQsRUFBUUYsWUFBUixDQUFuQjtBQUNILFNBRkQ7QUFHSDs7QUFFRG5JLFlBQU0sQ0FBQ29JLFlBQVAsQ0FBb0IsTUFBcEIsRUFBNEIsUUFBNUI7QUFDQXBJLFlBQU0sQ0FBQ29JLFlBQVAsQ0FBb0Isa0JBQXBCLEVBQXdDakQsT0FBTyxDQUFDakMsR0FBUixHQUFjLFVBQWQsR0FBMkIsWUFBbkU7O0FBRUEsVUFBSWlGLFlBQVksS0FBSyxDQUFyQixFQUF3QjtBQUNwQmhRLGdCQUFRLENBQUM2SCxNQUFELEVBQVNtRixPQUFPLENBQUN2RixVQUFSLENBQW1CSyxXQUE1QixDQUFSO0FBQ0gsT0FGRCxNQUVPLElBQUlrSSxZQUFZLEtBQUtoRCxPQUFPLENBQUN6QyxPQUFSLEdBQWtCLENBQXZDLEVBQTBDO0FBQzdDdkssZ0JBQVEsQ0FBQzZILE1BQUQsRUFBU21GLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJNLFdBQTVCLENBQVI7QUFDSDs7QUFFRCxhQUFPSCxNQUFQO0FBQ0gsS0FsRjRDLENBb0Y3Qzs7O0FBQ0EsYUFBU3dJLFVBQVQsQ0FBb0J6SSxJQUFwQixFQUEwQjNHLEdBQTFCLEVBQStCO0FBQzNCLFVBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ04sZUFBTyxLQUFQO0FBQ0g7O0FBRUQsYUFBTzJPLFNBQVMsQ0FBQ2hJLElBQUQsRUFBT3FGLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJXLE9BQTFCLENBQWhCO0FBQ0gsS0EzRjRDLENBNkY3Qzs7O0FBQ0EsYUFBU2lJLFdBQVQsQ0FBcUJDLGNBQXJCLEVBQXFDM0ksSUFBckMsRUFBMkM7QUFDdkMsVUFBSTRJLFdBQVcsR0FBR1osU0FBUyxDQUFDaEksSUFBRCxFQUFPcUYsT0FBTyxDQUFDdkYsVUFBUixDQUFtQlksUUFBMUIsQ0FBM0I7QUFFQW1HLG1CQUFhLEdBQUcsRUFBaEI7QUFDQUMsb0JBQWMsR0FBRyxFQUFqQjtBQUVBQSxvQkFBYyxDQUFDNUosSUFBZixDQUFvQnVMLFVBQVUsQ0FBQ0csV0FBRCxFQUFjRCxjQUFjLENBQUMsQ0FBRCxDQUE1QixDQUE5QixFQU51QyxDQVF2QztBQUNBOztBQUVBLFdBQUssSUFBSXRMLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnSSxPQUFPLENBQUN6QyxPQUE1QixFQUFxQ3ZGLENBQUMsRUFBdEMsRUFBMEM7QUFDdEM7QUFDQXdKLHFCQUFhLENBQUMzSixJQUFkLENBQW1Ca0wsU0FBUyxDQUFDcEksSUFBRCxFQUFPM0MsQ0FBUCxDQUE1QjtBQUNBK0osMkJBQW1CLENBQUMvSixDQUFELENBQW5CLEdBQXlCQSxDQUF6QjtBQUNBeUosc0JBQWMsQ0FBQzVKLElBQWYsQ0FBb0J1TCxVQUFVLENBQUNHLFdBQUQsRUFBY0QsY0FBYyxDQUFDdEwsQ0FBQyxHQUFHLENBQUwsQ0FBNUIsQ0FBOUI7QUFDSDtBQUNKLEtBL0c0QyxDQWlIN0M7OztBQUNBLGFBQVN3TCxTQUFULENBQW1CWixTQUFuQixFQUE4QjtBQUMxQjtBQUNBNVAsY0FBUSxDQUFDNFAsU0FBRCxFQUFZNUMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQkMsTUFBL0IsQ0FBUjs7QUFFQSxVQUFJc0YsT0FBTyxDQUFDdkIsR0FBUixLQUFnQixDQUFwQixFQUF1QjtBQUNuQnpMLGdCQUFRLENBQUM0UCxTQUFELEVBQVk1QyxPQUFPLENBQUN2RixVQUFSLENBQW1CYSxHQUEvQixDQUFSO0FBQ0gsT0FGRCxNQUVPO0FBQ0h0SSxnQkFBUSxDQUFDNFAsU0FBRCxFQUFZNUMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQmMsR0FBL0IsQ0FBUjtBQUNIOztBQUVELFVBQUl5RSxPQUFPLENBQUNqQyxHQUFSLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CL0ssZ0JBQVEsQ0FBQzRQLFNBQUQsRUFBWTVDLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJRLFVBQS9CLENBQVI7QUFDSCxPQUZELE1BRU87QUFDSGpJLGdCQUFRLENBQUM0UCxTQUFELEVBQVk1QyxPQUFPLENBQUN2RixVQUFSLENBQW1CUyxRQUEvQixDQUFSO0FBQ0g7O0FBRUQsVUFBSXVJLGFBQWEsR0FBR0MsZ0JBQWdCLENBQUNkLFNBQUQsQ0FBaEIsQ0FBNEIxSixTQUFoRDs7QUFFQSxVQUFJdUssYUFBYSxLQUFLLEtBQXRCLEVBQTZCO0FBQ3pCelEsZ0JBQVEsQ0FBQzRQLFNBQUQsRUFBWTVDLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJnQixnQkFBL0IsQ0FBUjtBQUNILE9BRkQsTUFFTztBQUNIekksZ0JBQVEsQ0FBQzRQLFNBQUQsRUFBWTVDLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJlLGdCQUEvQixDQUFSO0FBQ0g7O0FBRUQsYUFBT21ILFNBQVMsQ0FBQ0MsU0FBRCxFQUFZNUMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQkUsSUFBL0IsQ0FBaEI7QUFDSDs7QUFFRCxhQUFTZ0osVUFBVCxDQUFvQjlJLE1BQXBCLEVBQTRCbUksWUFBNUIsRUFBMEM7QUFDdEMsVUFBSSxDQUFDaEQsT0FBTyxDQUFDZixRQUFSLENBQWlCK0QsWUFBakIsQ0FBTCxFQUFxQztBQUNqQyxlQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFPTCxTQUFTLENBQUM5SCxNQUFNLENBQUMrSSxVQUFSLEVBQW9CNUQsT0FBTyxDQUFDdkYsVUFBUixDQUFtQnFCLE9BQXZDLENBQWhCO0FBQ0g7O0FBRUQsYUFBUytILGdCQUFULEdBQTRCO0FBQ3hCLGFBQU92QyxZQUFZLENBQUN3QyxZQUFiLENBQTBCLFVBQTFCLENBQVA7QUFDSCxLQXZKNEMsQ0F5SjdDOzs7QUFDQSxhQUFTQyxnQkFBVCxDQUEwQmYsWUFBMUIsRUFBd0M7QUFDcEMsVUFBSWdCLFlBQVksR0FBR3hDLGFBQWEsQ0FBQ3dCLFlBQUQsQ0FBaEM7QUFDQSxhQUFPZ0IsWUFBWSxDQUFDRixZQUFiLENBQTBCLFVBQTFCLENBQVA7QUFDSDs7QUFFRCxhQUFTRyxjQUFULEdBQTBCO0FBQ3RCLFVBQUl0QyxjQUFKLEVBQW9CO0FBQ2hCdUMsbUJBQVcsQ0FBQyxpQkFBRCxDQUFYO0FBQ0F2QyxzQkFBYyxDQUFDekMsT0FBZixDQUF1QixVQUFTcEQsT0FBVCxFQUFrQjtBQUNyQyxjQUFJQSxPQUFKLEVBQWE7QUFDVHpMLHlCQUFhLENBQUN5TCxPQUFELENBQWI7QUFDSDtBQUNKLFNBSkQ7QUFLQTZGLHNCQUFjLEdBQUcsSUFBakI7QUFDSDtBQUNKLEtBeks0QyxDQTJLN0M7OztBQUNBLGFBQVMxQyxRQUFULEdBQW9CO0FBQ2hCZ0Ysb0JBQWMsR0FERSxDQUdoQjs7QUFDQXRDLG9CQUFjLEdBQUdILGFBQWEsQ0FBQ25ILEdBQWQsQ0FBa0JzSixVQUFsQixDQUFqQjtBQUVBUSxlQUFTLENBQUMsaUJBQUQsRUFBb0IsVUFBU0MsTUFBVCxFQUFpQnBCLFlBQWpCLEVBQStCcUIsU0FBL0IsRUFBMEM7QUFDbkUsWUFBSSxDQUFDMUMsY0FBYyxDQUFDcUIsWUFBRCxDQUFuQixFQUFtQztBQUMvQjtBQUNIOztBQUVELFlBQUlzQixjQUFjLEdBQUdGLE1BQU0sQ0FBQ3BCLFlBQUQsQ0FBM0I7O0FBRUEsWUFBSWhELE9BQU8sQ0FBQ2YsUUFBUixDQUFpQitELFlBQWpCLE1BQW1DLElBQXZDLEVBQTZDO0FBQ3pDc0Isd0JBQWMsR0FBR3RFLE9BQU8sQ0FBQ2YsUUFBUixDQUFpQitELFlBQWpCLEVBQStCN1MsRUFBL0IsQ0FBa0NrVSxTQUFTLENBQUNyQixZQUFELENBQTNDLENBQWpCO0FBQ0g7O0FBRURyQixzQkFBYyxDQUFDcUIsWUFBRCxDQUFkLENBQTZCdUIsU0FBN0IsR0FBeUNELGNBQXpDO0FBQ0gsT0FaUSxDQUFUO0FBYUg7O0FBRUQsYUFBU0UsSUFBVCxHQUFnQjtBQUNaTCxlQUFTLENBQUMsUUFBRCxFQUFXLFVBQVNDLE1BQVQsRUFBaUJwQixZQUFqQixFQUErQnFCLFNBQS9CLEVBQTBDekksR0FBMUMsRUFBK0M2SSxTQUEvQyxFQUEwRDtBQUMxRTtBQUNBMUMsMkJBQW1CLENBQUM3QyxPQUFwQixDQUE0QixVQUFTMUgsS0FBVCxFQUFnQjtBQUN4QyxjQUFJcUQsTUFBTSxHQUFHMkcsYUFBYSxDQUFDaEssS0FBRCxDQUExQjtBQUVBLGNBQUluRSxHQUFHLEdBQUdxUixtQkFBbUIsQ0FBQzVDLGVBQUQsRUFBa0J0SyxLQUFsQixFQUF5QixDQUF6QixFQUE0QixJQUE1QixFQUFrQyxJQUFsQyxFQUF3QyxJQUF4QyxDQUE3QjtBQUNBLGNBQUlwRSxHQUFHLEdBQUdzUixtQkFBbUIsQ0FBQzVDLGVBQUQsRUFBa0J0SyxLQUFsQixFQUF5QixHQUF6QixFQUE4QixJQUE5QixFQUFvQyxJQUFwQyxFQUEwQyxJQUExQyxDQUE3QjtBQUNBLGNBQUltTixHQUFHLEdBQUdGLFNBQVMsQ0FBQ2pOLEtBQUQsQ0FBbkIsQ0FMd0MsQ0FPeEM7O0FBQ0EsY0FBSW9OLElBQUksR0FBRzVFLE9BQU8sQ0FBQ1gsVUFBUixDQUFtQmxQLEVBQW5CLENBQXNCa1UsU0FBUyxDQUFDN00sS0FBRCxDQUEvQixDQUFYLENBUndDLENBVXhDOztBQUNBbkUsYUFBRyxHQUFHdU8sY0FBYyxDQUFDMUssWUFBZixDQUE0QjdELEdBQTVCLEVBQWlDa0YsT0FBakMsQ0FBeUMsQ0FBekMsQ0FBTjtBQUNBbkYsYUFBRyxHQUFHd08sY0FBYyxDQUFDMUssWUFBZixDQUE0QjlELEdBQTVCLEVBQWlDbUYsT0FBakMsQ0FBeUMsQ0FBekMsQ0FBTjtBQUNBb00sYUFBRyxHQUFHL0MsY0FBYyxDQUFDMUssWUFBZixDQUE0QnlOLEdBQTVCLEVBQWlDcE0sT0FBakMsQ0FBeUMsQ0FBekMsQ0FBTjtBQUVBc0MsZ0JBQU0sQ0FBQ2dLLFFBQVAsQ0FBZ0IsQ0FBaEIsRUFBbUI1QixZQUFuQixDQUFnQyxlQUFoQyxFQUFpRDVQLEdBQWpEO0FBQ0F3SCxnQkFBTSxDQUFDZ0ssUUFBUCxDQUFnQixDQUFoQixFQUFtQjVCLFlBQW5CLENBQWdDLGVBQWhDLEVBQWlEN1AsR0FBakQ7QUFDQXlILGdCQUFNLENBQUNnSyxRQUFQLENBQWdCLENBQWhCLEVBQW1CNUIsWUFBbkIsQ0FBZ0MsZUFBaEMsRUFBaUQwQixHQUFqRDtBQUNBOUosZ0JBQU0sQ0FBQ2dLLFFBQVAsQ0FBZ0IsQ0FBaEIsRUFBbUI1QixZQUFuQixDQUFnQyxnQkFBaEMsRUFBa0QyQixJQUFsRDtBQUNILFNBbkJEO0FBb0JILE9BdEJRLENBQVQ7QUF1Qkg7O0FBRUQsYUFBU0UsUUFBVCxDQUFrQkMsSUFBbEIsRUFBd0JYLE1BQXhCLEVBQWdDWSxPQUFoQyxFQUF5QztBQUNyQztBQUNBLFVBQUlELElBQUksS0FBSyxPQUFULElBQW9CQSxJQUFJLEtBQUssT0FBakMsRUFBMEM7QUFDdEMsZUFBT25ELGNBQWMsQ0FBQy9LLElBQXRCO0FBQ0g7O0FBRUQsVUFBSWtPLElBQUksS0FBSyxPQUFiLEVBQXNCO0FBQ2xCLFlBQUlYLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQ1osZ0JBQU0sSUFBSXpNLEtBQUosQ0FBVSxpQkFBaUIzSCxPQUFqQixHQUEyQiwrQ0FBckMsQ0FBTjtBQUNILFNBSGlCLENBS2xCOzs7QUFDQSxZQUFJaVYsUUFBUSxHQUFHYixNQUFNLEdBQUcsQ0FBeEI7QUFDQSxZQUFJYyxNQUFNLEdBQUcsTUFBTUQsUUFBbkI7QUFFQWIsY0FBTSxHQUFHLEVBQVQsQ0FUa0IsQ0FXbEI7O0FBQ0EsZUFBT2EsUUFBUSxFQUFmLEVBQW1CO0FBQ2ZiLGdCQUFNLENBQUNhLFFBQUQsQ0FBTixHQUFtQkEsUUFBUSxHQUFHQyxNQUE5QjtBQUNIOztBQUVEZCxjQUFNLENBQUN2TSxJQUFQLENBQVksR0FBWjtBQUVBa04sWUFBSSxHQUFHLFdBQVA7QUFDSDs7QUFFRCxVQUFJQSxJQUFJLEtBQUssV0FBYixFQUEwQjtBQUN0QjtBQUNBLGVBQU9YLE1BQU0sQ0FBQy9KLEdBQVAsQ0FBVyxVQUFTM0osS0FBVCxFQUFnQjtBQUM5QixpQkFBT2tSLGNBQWMsQ0FBQzFLLFlBQWYsQ0FBNEI4TixPQUFPLEdBQUdwRCxjQUFjLENBQUN6SyxPQUFmLENBQXVCekcsS0FBdkIsQ0FBSCxHQUFtQ0EsS0FBdEUsQ0FBUDtBQUNILFNBRk0sQ0FBUDtBQUdIOztBQUVELFVBQUlxVSxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUNuQjtBQUNBLFlBQUlDLE9BQUosRUFBYTtBQUNULGlCQUFPWixNQUFNLENBQUMvSixHQUFQLENBQVcsVUFBUzNKLEtBQVQsRUFBZ0I7QUFDOUI7QUFDQSxtQkFBT2tSLGNBQWMsQ0FBQzFLLFlBQWYsQ0FBNEIwSyxjQUFjLENBQUN6SyxPQUFmLENBQXVCeUssY0FBYyxDQUFDaEwsVUFBZixDQUEwQmxHLEtBQTFCLENBQXZCLENBQTVCLENBQVA7QUFDSCxXQUhNLENBQVA7QUFJSCxTQVBrQixDQVNuQjs7O0FBQ0EsZUFBTzBULE1BQVA7QUFDSDtBQUNKOztBQUVELGFBQVNlLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDTCxJQUFqQyxFQUF1Q00sS0FBdkMsRUFBOEM7QUFDMUMsZUFBU0MsYUFBVCxDQUF1QjVVLEtBQXZCLEVBQThCNlUsU0FBOUIsRUFBeUM7QUFDckM7QUFDQSxlQUFPLENBQUM3VSxLQUFLLEdBQUc2VSxTQUFULEVBQW9CaE4sT0FBcEIsQ0FBNEIsQ0FBNUIsSUFBaUMsQ0FBeEM7QUFDSDs7QUFFRCxVQUFJaU4sT0FBTyxHQUFHLEVBQWQ7QUFDQSxVQUFJQyxZQUFZLEdBQUc3RCxjQUFjLENBQUMvSyxJQUFmLENBQW9CLENBQXBCLENBQW5CO0FBQ0EsVUFBSTZPLFdBQVcsR0FBRzlELGNBQWMsQ0FBQy9LLElBQWYsQ0FBb0IrSyxjQUFjLENBQUMvSyxJQUFmLENBQW9CL0MsTUFBcEIsR0FBNkIsQ0FBakQsQ0FBbEI7QUFDQSxVQUFJNlIsV0FBVyxHQUFHLEtBQWxCO0FBQ0EsVUFBSUMsVUFBVSxHQUFHLEtBQWpCO0FBQ0EsVUFBSUMsT0FBTyxHQUFHLENBQWQsQ0FYMEMsQ0FhMUM7O0FBQ0FSLFdBQUssR0FBR3ZVLE1BQU0sQ0FDVnVVLEtBQUssQ0FBQ3RPLEtBQU4sR0FBYzhCLElBQWQsQ0FBbUIsVUFBUzVILENBQVQsRUFBWXFHLENBQVosRUFBZTtBQUM5QixlQUFPckcsQ0FBQyxHQUFHcUcsQ0FBWDtBQUNILE9BRkQsQ0FEVSxDQUFkLENBZDBDLENBb0IxQzs7QUFDQSxVQUFJK04sS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhSSxZQUFqQixFQUErQjtBQUMzQkosYUFBSyxDQUFDUyxPQUFOLENBQWNMLFlBQWQ7QUFDQUUsbUJBQVcsR0FBRyxJQUFkO0FBQ0gsT0F4QnlDLENBMEIxQzs7O0FBQ0EsVUFBSU4sS0FBSyxDQUFDQSxLQUFLLENBQUN2UixNQUFOLEdBQWUsQ0FBaEIsQ0FBTCxLQUE0QjRSLFdBQWhDLEVBQTZDO0FBQ3pDTCxhQUFLLENBQUN4TixJQUFOLENBQVc2TixXQUFYO0FBQ0FFLGtCQUFVLEdBQUcsSUFBYjtBQUNIOztBQUVEUCxXQUFLLENBQUNuRyxPQUFOLENBQWMsVUFBUzZHLE9BQVQsRUFBa0J2TyxLQUFsQixFQUF5QjtBQUNuQztBQUNBLFlBQUlnQixJQUFKO0FBQ0EsWUFBSVIsQ0FBSjtBQUNBLFlBQUlnTyxDQUFKO0FBQ0EsWUFBSUMsR0FBRyxHQUFHRixPQUFWO0FBQ0EsWUFBSUcsSUFBSSxHQUFHYixLQUFLLENBQUM3TixLQUFLLEdBQUcsQ0FBVCxDQUFoQjtBQUNBLFlBQUkyTyxNQUFKO0FBQ0EsWUFBSUMsYUFBSjtBQUNBLFlBQUlDLE1BQUo7QUFDQSxZQUFJQyxJQUFKO0FBQ0EsWUFBSUMsS0FBSjtBQUNBLFlBQUlDLFNBQUo7QUFDQSxZQUFJQyxRQUFKO0FBQ0EsWUFBSUMsT0FBTyxHQUFHM0IsSUFBSSxLQUFLLE9BQXZCLENBZG1DLENBZ0JuQztBQUNBOztBQUNBLFlBQUkyQixPQUFKLEVBQWE7QUFDVGxPLGNBQUksR0FBR29KLGNBQWMsQ0FBQ3pKLFNBQWYsQ0FBeUJYLEtBQXpCLENBQVA7QUFDSCxTQXBCa0MsQ0FzQm5DOzs7QUFDQSxZQUFJLENBQUNnQixJQUFMLEVBQVc7QUFDUEEsY0FBSSxHQUFHME4sSUFBSSxHQUFHRCxHQUFkO0FBQ0gsU0F6QmtDLENBMkJuQztBQUNBOzs7QUFDQSxZQUFJQSxHQUFHLEtBQUssS0FBUixJQUFpQkMsSUFBSSxLQUFLdlYsU0FBOUIsRUFBeUM7QUFDckM7QUFDSCxTQS9Ca0MsQ0FpQ25DOzs7QUFDQTZILFlBQUksR0FBR3JILElBQUksQ0FBQ2lDLEdBQUwsQ0FBU29GLElBQVQsRUFBZSxTQUFmLENBQVAsQ0FsQ21DLENBb0NuQzs7QUFDQSxhQUFLUixDQUFDLEdBQUdpTyxHQUFULEVBQWNqTyxDQUFDLElBQUlrTyxJQUFuQixFQUF5QmxPLENBQUMsR0FBR3NOLGFBQWEsQ0FBQ3ROLENBQUQsRUFBSVEsSUFBSixDQUExQyxFQUFxRDtBQUNqRDtBQUNBO0FBQ0EyTixnQkFBTSxHQUFHdkUsY0FBYyxDQUFDaEwsVUFBZixDQUEwQm9CLENBQTFCLENBQVQ7QUFDQW9PLHVCQUFhLEdBQUdELE1BQU0sR0FBR04sT0FBekI7QUFFQVUsZUFBSyxHQUFHSCxhQUFhLEdBQUdoQixPQUF4QjtBQUNBb0IsbUJBQVMsR0FBR3JWLElBQUksQ0FBQ0MsS0FBTCxDQUFXbVYsS0FBWCxDQUFaLENBUGlELENBU2pEO0FBQ0E7QUFDQTtBQUNBOztBQUNBRSxrQkFBUSxHQUFHTCxhQUFhLEdBQUdJLFNBQTNCLENBYmlELENBZWpEO0FBQ0E7O0FBQ0EsZUFBS1IsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxJQUFJUSxTQUFqQixFQUE0QlIsQ0FBQyxJQUFJLENBQWpDLEVBQW9DO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0FLLGtCQUFNLEdBQUdSLE9BQU8sR0FBR0csQ0FBQyxHQUFHUyxRQUF2QjtBQUNBakIsbUJBQU8sQ0FBQ2EsTUFBTSxDQUFDOU4sT0FBUCxDQUFlLENBQWYsQ0FBRCxDQUFQLEdBQTZCLENBQUNxSixjQUFjLENBQUMxSyxZQUFmLENBQTRCbVAsTUFBNUIsQ0FBRCxFQUFzQyxDQUF0QyxDQUE3QjtBQUNILFdBeEJnRCxDQTBCakQ7OztBQUNBQyxjQUFJLEdBQUdqQixLQUFLLENBQUMxRyxPQUFOLENBQWMzRyxDQUFkLElBQW1CLENBQUMsQ0FBcEIsR0FBd0J3SyxnQkFBeEIsR0FBMkNrRSxPQUFPLEdBQUdqRSxnQkFBSCxHQUFzQkYsYUFBL0UsQ0EzQmlELENBNkJqRDs7QUFDQSxjQUFJLENBQUMvSyxLQUFELElBQVVtTyxXQUFWLElBQXlCM04sQ0FBQyxLQUFLa08sSUFBbkMsRUFBeUM7QUFDckNJLGdCQUFJLEdBQUcsQ0FBUDtBQUNIOztBQUVELGNBQUksRUFBRXRPLENBQUMsS0FBS2tPLElBQU4sSUFBY04sVUFBaEIsQ0FBSixFQUFpQztBQUM3QjtBQUNBSixtQkFBTyxDQUFDVyxNQUFNLENBQUM1TixPQUFQLENBQWUsQ0FBZixDQUFELENBQVAsR0FBNkIsQ0FBQ1AsQ0FBRCxFQUFJc08sSUFBSixDQUE3QjtBQUNILFdBckNnRCxDQXVDakQ7OztBQUNBVCxpQkFBTyxHQUFHTSxNQUFWO0FBQ0g7QUFDSixPQS9FRDtBQWlGQSxhQUFPWCxPQUFQO0FBQ0g7O0FBRUQsYUFBU21CLFVBQVQsQ0FBb0J6QixNQUFwQixFQUE0QjBCLFVBQTVCLEVBQXdDekgsU0FBeEMsRUFBbUQ7QUFDL0MsVUFBSXRNLE9BQU8sR0FBR3NQLGNBQWMsQ0FBQ3pCLGFBQWYsQ0FBNkIsS0FBN0IsQ0FBZDtBQUVBLFVBQUltRyxnQkFBZ0IsR0FBRyxFQUF2QjtBQUNBQSxzQkFBZ0IsQ0FBQ3RFLGFBQUQsQ0FBaEIsR0FBa0N2QyxPQUFPLENBQUN2RixVQUFSLENBQW1CaUMsV0FBckQ7QUFDQW1LLHNCQUFnQixDQUFDckUsZ0JBQUQsQ0FBaEIsR0FBcUN4QyxPQUFPLENBQUN2RixVQUFSLENBQW1Ca0MsVUFBeEQ7QUFDQWtLLHNCQUFnQixDQUFDcEUsZ0JBQUQsQ0FBaEIsR0FBcUN6QyxPQUFPLENBQUN2RixVQUFSLENBQW1CbUMsUUFBeEQ7QUFFQSxVQUFJa0ssaUJBQWlCLEdBQUcsRUFBeEI7QUFDQUEsdUJBQWlCLENBQUN2RSxhQUFELENBQWpCLEdBQW1DdkMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQjRCLFlBQXREO0FBQ0F5Syx1QkFBaUIsQ0FBQ3RFLGdCQUFELENBQWpCLEdBQXNDeEMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQjZCLFdBQXpEO0FBQ0F3Syx1QkFBaUIsQ0FBQ3JFLGdCQUFELENBQWpCLEdBQXNDekMsT0FBTyxDQUFDdkYsVUFBUixDQUFtQjhCLFNBQXpEO0FBRUEsVUFBSXdLLHVCQUF1QixHQUFHLENBQUMvRyxPQUFPLENBQUN2RixVQUFSLENBQW1CK0IsZUFBcEIsRUFBcUN3RCxPQUFPLENBQUN2RixVQUFSLENBQW1CZ0MsYUFBeEQsQ0FBOUI7QUFDQSxVQUFJdUssd0JBQXdCLEdBQUcsQ0FBQ2hILE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUIwQixnQkFBcEIsRUFBc0M2RCxPQUFPLENBQUN2RixVQUFSLENBQW1CMkIsY0FBekQsQ0FBL0I7QUFFQXBKLGNBQVEsQ0FBQ0gsT0FBRCxFQUFVbU4sT0FBTyxDQUFDdkYsVUFBUixDQUFtQnNCLElBQTdCLENBQVI7QUFDQS9JLGNBQVEsQ0FBQ0gsT0FBRCxFQUFVbU4sT0FBTyxDQUFDakMsR0FBUixLQUFnQixDQUFoQixHQUFvQmlDLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJ1QixjQUF2QyxHQUF3RGdFLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJ3QixZQUFyRixDQUFSOztBQUVBLGVBQVNnTCxVQUFULENBQW9CWCxJQUFwQixFQUEwQlksTUFBMUIsRUFBa0M7QUFDOUIsWUFBSWpXLENBQUMsR0FBR2lXLE1BQU0sS0FBS2xILE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUIvSixLQUF0QztBQUNBLFlBQUl5VyxrQkFBa0IsR0FBR2xXLENBQUMsR0FBRzhWLHVCQUFILEdBQTZCQyx3QkFBdkQ7QUFDQSxZQUFJSSxXQUFXLEdBQUduVyxDQUFDLEdBQUc0VixnQkFBSCxHQUFzQkMsaUJBQXpDO0FBRUEsZUFBT0ksTUFBTSxHQUFHLEdBQVQsR0FBZUMsa0JBQWtCLENBQUNuSCxPQUFPLENBQUNqQyxHQUFULENBQWpDLEdBQWlELEdBQWpELEdBQXVEcUosV0FBVyxDQUFDZCxJQUFELENBQXpFO0FBQ0g7O0FBRUQsZUFBU2UsU0FBVCxDQUFtQmhXLE1BQW5CLEVBQTJCWCxLQUEzQixFQUFrQzRWLElBQWxDLEVBQXdDO0FBQ3BDO0FBQ0FBLFlBQUksR0FBR00sVUFBVSxHQUFHQSxVQUFVLENBQUNsVyxLQUFELEVBQVE0VixJQUFSLENBQWIsR0FBNkJBLElBQTlDOztBQUVBLFlBQUlBLElBQUksS0FBS2hFLFNBQWIsRUFBd0I7QUFDcEI7QUFDSCxTQU5tQyxDQVFwQzs7O0FBQ0EsWUFBSWdGLElBQUksR0FBRzNFLFNBQVMsQ0FBQzlQLE9BQUQsRUFBVSxLQUFWLENBQXBCO0FBQ0F5VSxZQUFJLENBQUN4VSxTQUFMLEdBQWlCbVUsVUFBVSxDQUFDWCxJQUFELEVBQU90RyxPQUFPLENBQUN2RixVQUFSLENBQW1CeUIsTUFBMUIsQ0FBM0I7QUFDQW9MLFlBQUksQ0FBQzFHLEtBQUwsQ0FBV1osT0FBTyxDQUFDWSxLQUFuQixJQUE0QnZQLE1BQU0sR0FBRyxHQUFyQyxDQVhvQyxDQWFwQzs7QUFDQSxZQUFJaVYsSUFBSSxHQUFHL0QsYUFBWCxFQUEwQjtBQUN0QitFLGNBQUksR0FBRzNFLFNBQVMsQ0FBQzlQLE9BQUQsRUFBVSxLQUFWLENBQWhCO0FBQ0F5VSxjQUFJLENBQUN4VSxTQUFMLEdBQWlCbVUsVUFBVSxDQUFDWCxJQUFELEVBQU90RyxPQUFPLENBQUN2RixVQUFSLENBQW1CL0osS0FBMUIsQ0FBM0I7QUFDQTRXLGNBQUksQ0FBQ3JFLFlBQUwsQ0FBa0IsWUFBbEIsRUFBZ0N2UyxLQUFoQztBQUNBNFcsY0FBSSxDQUFDMUcsS0FBTCxDQUFXWixPQUFPLENBQUNZLEtBQW5CLElBQTRCdlAsTUFBTSxHQUFHLEdBQXJDO0FBQ0FpVyxjQUFJLENBQUMvQyxTQUFMLEdBQWlCcEYsU0FBUyxDQUFDaFAsRUFBVixDQUFhTyxLQUFiLENBQWpCO0FBQ0g7QUFDSixPQWhEOEMsQ0FrRC9DOzs7QUFDQStFLFlBQU0sQ0FBQzZLLElBQVAsQ0FBWTRFLE1BQVosRUFBb0JoRyxPQUFwQixDQUE0QixVQUFTN04sTUFBVCxFQUFpQjtBQUN6Q2dXLGlCQUFTLENBQUNoVyxNQUFELEVBQVM2VCxNQUFNLENBQUM3VCxNQUFELENBQU4sQ0FBZSxDQUFmLENBQVQsRUFBNEI2VCxNQUFNLENBQUM3VCxNQUFELENBQU4sQ0FBZSxDQUFmLENBQTVCLENBQVQ7QUFDSCxPQUZEO0FBSUEsYUFBT3dCLE9BQVA7QUFDSDs7QUFFRCxhQUFTMFUsVUFBVCxHQUFzQjtBQUNsQixVQUFJN0YsVUFBSixFQUFnQjtBQUNaclIscUJBQWEsQ0FBQ3FSLFVBQUQsQ0FBYjtBQUNBQSxrQkFBVSxHQUFHLElBQWI7QUFDSDtBQUNKOztBQUVELGFBQVMzRixJQUFULENBQWN5TCxJQUFkLEVBQW9CO0FBQ2hCO0FBQ0FELGdCQUFVO0FBRVYsVUFBSXhDLElBQUksR0FBR3lDLElBQUksQ0FBQ3pDLElBQWhCO0FBQ0EsVUFBSUssT0FBTyxHQUFHb0MsSUFBSSxDQUFDcEMsT0FBTCxJQUFnQixDQUE5QjtBQUNBLFVBQUlwVSxNQUFNLEdBQUd3VyxJQUFJLENBQUN4VyxNQUFMLElBQWUsS0FBNUI7QUFDQSxVQUFJb1QsTUFBTSxHQUFHb0QsSUFBSSxDQUFDcEQsTUFBTCxJQUFlLEtBQTVCO0FBQ0EsVUFBSVksT0FBTyxHQUFHd0MsSUFBSSxDQUFDeEMsT0FBTCxJQUFnQixLQUE5QjtBQUNBLFVBQUlLLEtBQUssR0FBR1AsUUFBUSxDQUFDQyxJQUFELEVBQU9YLE1BQVAsRUFBZVksT0FBZixDQUFwQjtBQUNBLFVBQUlFLE1BQU0sR0FBR0MsY0FBYyxDQUFDQyxPQUFELEVBQVVMLElBQVYsRUFBZ0JNLEtBQWhCLENBQTNCO0FBQ0EsVUFBSTlGLE1BQU0sR0FBR2lJLElBQUksQ0FBQ2pJLE1BQUwsSUFBZTtBQUN4QnBQLFVBQUUsRUFBRWdCLElBQUksQ0FBQ0M7QUFEZSxPQUE1QjtBQUlBc1EsZ0JBQVUsR0FBR0osWUFBWSxDQUFDd0IsV0FBYixDQUF5QjZELFVBQVUsQ0FBQ3pCLE1BQUQsRUFBU2xVLE1BQVQsRUFBaUJ1TyxNQUFqQixDQUFuQyxDQUFiO0FBRUEsYUFBT21DLFVBQVA7QUFDSCxLQWxkNEMsQ0FvZDdDOzs7QUFDQSxhQUFTK0YsUUFBVCxHQUFvQjtBQUNoQixVQUFJalcsSUFBSSxHQUFHK1AsVUFBVSxDQUFDOVAscUJBQVgsRUFBWDtBQUNBLFVBQUlpVyxHQUFHLEdBQUcsV0FBVyxDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CMUgsT0FBTyxDQUFDakMsR0FBNUIsQ0FBckI7QUFDQSxhQUFPaUMsT0FBTyxDQUFDakMsR0FBUixLQUFnQixDQUFoQixHQUFvQnZNLElBQUksQ0FBQ21XLEtBQUwsSUFBY3BHLFVBQVUsQ0FBQ21HLEdBQUQsQ0FBNUMsR0FBb0RsVyxJQUFJLENBQUNvVyxNQUFMLElBQWVyRyxVQUFVLENBQUNtRyxHQUFELENBQXBGO0FBQ0gsS0F6ZDRDLENBMmQ3Qzs7O0FBQ0EsYUFBU0csV0FBVCxDQUFxQjlJLE1BQXJCLEVBQTZCbE0sT0FBN0IsRUFBc0NpVixRQUF0QyxFQUFnREMsSUFBaEQsRUFBc0Q7QUFDbEQ7QUFDQTtBQUVBLFVBQUlDLE1BQU0sR0FBRyxVQUFTblgsQ0FBVCxFQUFZO0FBQ3JCQSxTQUFDLEdBQUdvWCxRQUFRLENBQUNwWCxDQUFELEVBQUlrWCxJQUFJLENBQUNqVyxVQUFULEVBQXFCaVcsSUFBSSxDQUFDck4sTUFBTCxJQUFlN0gsT0FBcEMsQ0FBWixDQURxQixDQUdyQjtBQUNBOztBQUNBLFlBQUksQ0FBQ2hDLENBQUwsRUFBUTtBQUNKLGlCQUFPLEtBQVA7QUFDSCxTQVBvQixDQVNyQjtBQUNBOzs7QUFDQSxZQUFJZ1QsZ0JBQWdCLE1BQU0sQ0FBQ2tFLElBQUksQ0FBQ0csV0FBaEMsRUFBNkM7QUFDekMsaUJBQU8sS0FBUDtBQUNILFNBYm9CLENBZXJCOzs7QUFDQSxZQUFJN1QsUUFBUSxDQUFDaU4sWUFBRCxFQUFldEIsT0FBTyxDQUFDdkYsVUFBUixDQUFtQm1CLEdBQWxDLENBQVIsSUFBa0QsQ0FBQ21NLElBQUksQ0FBQ0csV0FBNUQsRUFBeUU7QUFDckUsaUJBQU8sS0FBUDtBQUNILFNBbEJvQixDQW9CckI7OztBQUNBLFlBQUluSixNQUFNLEtBQUtxQyxPQUFPLENBQUNsTSxLQUFuQixJQUE0QnJFLENBQUMsQ0FBQ3NYLE9BQUYsS0FBY3hYLFNBQTFDLElBQXVERSxDQUFDLENBQUNzWCxPQUFGLEdBQVksQ0FBdkUsRUFBMEU7QUFDdEUsaUJBQU8sS0FBUDtBQUNILFNBdkJvQixDQXlCckI7OztBQUNBLFlBQUlKLElBQUksQ0FBQ2xKLEtBQUwsSUFBY2hPLENBQUMsQ0FBQ3NYLE9BQXBCLEVBQTZCO0FBQ3pCLGlCQUFPLEtBQVA7QUFDSCxTQTVCb0IsQ0E4QnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFlBQUksQ0FBQzVTLGVBQUwsRUFBc0I7QUFDbEIxRSxXQUFDLENBQUNELGNBQUY7QUFDSDs7QUFFREMsU0FBQyxDQUFDdVgsU0FBRixHQUFjdlgsQ0FBQyxDQUFDd1gsTUFBRixDQUFTckksT0FBTyxDQUFDakMsR0FBakIsQ0FBZCxDQXZDcUIsQ0F5Q3JCOztBQUNBK0osZ0JBQVEsQ0FBQ2pYLENBQUQsRUFBSWtYLElBQUosQ0FBUjtBQUNILE9BM0NEOztBQTZDQSxVQUFJTyxPQUFPLEdBQUcsRUFBZCxDQWpEa0QsQ0FtRGxEOztBQUNBdkosWUFBTSxDQUFDbEwsS0FBUCxDQUFhLEdBQWIsRUFBa0JxTCxPQUFsQixDQUEwQixVQUFTcUosU0FBVCxFQUFvQjtBQUMxQzFWLGVBQU8sQ0FBQytDLGdCQUFSLENBQXlCMlMsU0FBekIsRUFBb0NQLE1BQXBDLEVBQTRDelMsZUFBZSxHQUFHO0FBQUVpVCxpQkFBTyxFQUFFO0FBQVgsU0FBSCxHQUF1QixLQUFsRjtBQUNBRixlQUFPLENBQUN6USxJQUFSLENBQWEsQ0FBQzBRLFNBQUQsRUFBWVAsTUFBWixDQUFiO0FBQ0gsT0FIRDtBQUtBLGFBQU9NLE9BQVA7QUFDSCxLQXRoQjRDLENBd2hCN0M7OztBQUNBLGFBQVNMLFFBQVQsQ0FBa0JwWCxDQUFsQixFQUFxQmlCLFVBQXJCLEVBQWlDMlcsV0FBakMsRUFBOEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBSUMsS0FBSyxHQUFHN1gsQ0FBQyxDQUFDeVYsSUFBRixDQUFPM0gsT0FBUCxDQUFlLE9BQWYsTUFBNEIsQ0FBeEM7QUFDQSxVQUFJZ0ssS0FBSyxHQUFHOVgsQ0FBQyxDQUFDeVYsSUFBRixDQUFPM0gsT0FBUCxDQUFlLE9BQWYsTUFBNEIsQ0FBeEM7QUFDQSxVQUFJaUssT0FBTyxHQUFHL1gsQ0FBQyxDQUFDeVYsSUFBRixDQUFPM0gsT0FBUCxDQUFlLFNBQWYsTUFBOEIsQ0FBNUM7QUFFQSxVQUFJeE0sQ0FBSjtBQUNBLFVBQUlFLENBQUosQ0FUMEMsQ0FXMUM7O0FBQ0EsVUFBSXhCLENBQUMsQ0FBQ3lWLElBQUYsQ0FBTzNILE9BQVAsQ0FBZSxXQUFmLE1BQWdDLENBQXBDLEVBQXVDO0FBQ25DaUssZUFBTyxHQUFHLElBQVY7QUFDSCxPQWR5QyxDQWdCMUM7OztBQUNBLFVBQUlGLEtBQUosRUFBVztBQUNQO0FBQ0EsWUFBSUcsZUFBZSxHQUFHLFVBQVNDLFVBQVQsRUFBcUI7QUFDdkMsaUJBQ0lBLFVBQVUsQ0FBQ3BPLE1BQVgsS0FBc0IrTixXQUF0QixJQUNBQSxXQUFXLENBQUNuVSxRQUFaLENBQXFCd1UsVUFBVSxDQUFDcE8sTUFBaEMsQ0FEQSxJQUVDb08sVUFBVSxDQUFDcE8sTUFBWCxDQUFrQnFPLFVBQWxCLElBQWdDRCxVQUFVLENBQUNwTyxNQUFYLENBQWtCcU8sVUFBbEIsQ0FBNkJ6VSxRQUE3QixDQUFzQ21VLFdBQXRDLENBSHJDO0FBS0gsU0FORCxDQUZPLENBVVA7QUFDQTs7O0FBQ0EsWUFBSTVYLENBQUMsQ0FBQ3lWLElBQUYsS0FBVyxZQUFmLEVBQTZCO0FBQ3pCLGNBQUkwQyxhQUFhLEdBQUd6VixLQUFLLENBQUN1RixTQUFOLENBQWdCOUgsTUFBaEIsQ0FBdUJpWSxJQUF2QixDQUE0QnBZLENBQUMsQ0FBQ3FZLE9BQTlCLEVBQXVDTCxlQUF2QyxDQUFwQixDQUR5QixDQUd6Qjs7QUFDQSxjQUFJRyxhQUFhLENBQUNsVixNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCLG1CQUFPLEtBQVA7QUFDSDs7QUFFRDNCLFdBQUMsR0FBRzZXLGFBQWEsQ0FBQyxDQUFELENBQWIsQ0FBaUJHLEtBQXJCO0FBQ0E5VyxXQUFDLEdBQUcyVyxhQUFhLENBQUMsQ0FBRCxDQUFiLENBQWlCSSxLQUFyQjtBQUNILFNBVkQsTUFVTztBQUNIO0FBQ0EsY0FBSUMsV0FBVyxHQUFHOVYsS0FBSyxDQUFDdUYsU0FBTixDQUFnQndRLElBQWhCLENBQXFCTCxJQUFyQixDQUEwQnBZLENBQUMsQ0FBQzBZLGNBQTVCLEVBQTRDVixlQUE1QyxDQUFsQixDQUZHLENBSUg7O0FBQ0EsY0FBSSxDQUFDUSxXQUFMLEVBQWtCO0FBQ2QsbUJBQU8sS0FBUDtBQUNIOztBQUVEbFgsV0FBQyxHQUFHa1gsV0FBVyxDQUFDRixLQUFoQjtBQUNBOVcsV0FBQyxHQUFHZ1gsV0FBVyxDQUFDRCxLQUFoQjtBQUNIO0FBQ0o7O0FBRUR0WCxnQkFBVSxHQUFHQSxVQUFVLElBQUlDLGFBQWEsQ0FBQ29RLGNBQUQsQ0FBeEM7O0FBRUEsVUFBSXdHLEtBQUssSUFBSUMsT0FBYixFQUFzQjtBQUNsQnpXLFNBQUMsR0FBR3RCLENBQUMsQ0FBQzJZLE9BQUYsR0FBWTFYLFVBQVUsQ0FBQ0ssQ0FBM0I7QUFDQUUsU0FBQyxHQUFHeEIsQ0FBQyxDQUFDNFksT0FBRixHQUFZM1gsVUFBVSxDQUFDTyxDQUEzQjtBQUNIOztBQUVEeEIsT0FBQyxDQUFDaUIsVUFBRixHQUFlQSxVQUFmO0FBQ0FqQixPQUFDLENBQUN3WCxNQUFGLEdBQVcsQ0FBQ2xXLENBQUQsRUFBSUUsQ0FBSixDQUFYO0FBQ0F4QixPQUFDLENBQUM2WSxNQUFGLEdBQVdmLEtBQUssSUFBSUMsT0FBcEIsQ0E5RDBDLENBOERiOztBQUU3QixhQUFPL1gsQ0FBUDtBQUNILEtBMWxCNEMsQ0E0bEI3Qzs7O0FBQ0EsYUFBUzhZLHFCQUFULENBQStCdkIsU0FBL0IsRUFBMEM7QUFDdEMsVUFBSXdCLFFBQVEsR0FBR3hCLFNBQVMsR0FBRy9XLE1BQU0sQ0FBQ2tRLFVBQUQsRUFBYXZCLE9BQU8sQ0FBQ2pDLEdBQXJCLENBQWpDO0FBQ0EsVUFBSThMLFFBQVEsR0FBSUQsUUFBUSxHQUFHLEdBQVosR0FBbUJuQyxRQUFRLEVBQTFDLENBRnNDLENBSXRDO0FBQ0E7QUFDQTs7QUFDQW9DLGNBQVEsR0FBRzFXLEtBQUssQ0FBQzBXLFFBQUQsQ0FBaEI7QUFFQSxhQUFPN0osT0FBTyxDQUFDdkIsR0FBUixHQUFjLE1BQU1vTCxRQUFwQixHQUErQkEsUUFBdEM7QUFDSCxLQXZtQjRDLENBeW1CN0M7OztBQUNBLGFBQVNDLGdCQUFULENBQTBCQyxlQUExQixFQUEyQztBQUN2QyxVQUFJQyxrQkFBa0IsR0FBRyxHQUF6QjtBQUNBLFVBQUloSCxZQUFZLEdBQUcsS0FBbkI7QUFFQXhCLG1CQUFhLENBQUN0QyxPQUFkLENBQXNCLFVBQVNyRSxNQUFULEVBQWlCckQsS0FBakIsRUFBd0I7QUFDMUM7QUFDQSxZQUFJdU0sZ0JBQWdCLENBQUN2TSxLQUFELENBQXBCLEVBQTZCO0FBQ3pCO0FBQ0g7O0FBRUQsWUFBSXlTLGNBQWMsR0FBR25JLGVBQWUsQ0FBQ3RLLEtBQUQsQ0FBcEM7QUFDQSxZQUFJMFMsd0JBQXdCLEdBQUcvWSxJQUFJLENBQUNvRixHQUFMLENBQVMwVCxjQUFjLEdBQUdGLGVBQTFCLENBQS9CLENBUDBDLENBUzFDOztBQUNBLFlBQUlJLFdBQVcsR0FBR0Qsd0JBQXdCLEtBQUssR0FBN0IsSUFBb0NGLGtCQUFrQixLQUFLLEdBQTdFLENBVjBDLENBWTFDOztBQUNBLFlBQUlJLFFBQVEsR0FBR0Ysd0JBQXdCLEdBQUdGLGtCQUExQztBQUNBLFlBQUlLLGFBQWEsR0FBR0gsd0JBQXdCLElBQUlGLGtCQUE1QixJQUFrREQsZUFBZSxHQUFHRSxjQUF4Rjs7QUFFQSxZQUFJRyxRQUFRLElBQUlDLGFBQVosSUFBNkJGLFdBQWpDLEVBQThDO0FBQzFDbkgsc0JBQVksR0FBR3hMLEtBQWY7QUFDQXdTLDRCQUFrQixHQUFHRSx3QkFBckI7QUFDSDtBQUNKLE9BcEJEO0FBc0JBLGFBQU9sSCxZQUFQO0FBQ0gsS0Fyb0I0QyxDQXVvQjdDOzs7QUFDQSxhQUFTc0gsYUFBVCxDQUF1QnBILEtBQXZCLEVBQThCNkUsSUFBOUIsRUFBb0M7QUFDaEMsVUFBSTdFLEtBQUssQ0FBQ29ELElBQU4sS0FBZSxVQUFmLElBQTZCcEQsS0FBSyxDQUFDeEksTUFBTixDQUFhNlAsUUFBYixLQUEwQixNQUF2RCxJQUFpRXJILEtBQUssQ0FBQ3NILGFBQU4sS0FBd0IsSUFBN0YsRUFBbUc7QUFDL0ZDLGdCQUFRLENBQUN2SCxLQUFELEVBQVE2RSxJQUFSLENBQVI7QUFDSDtBQUNKLEtBNW9CNEMsQ0E4b0I3Qzs7O0FBQ0EsYUFBUzJDLFNBQVQsQ0FBbUJ4SCxLQUFuQixFQUEwQjZFLElBQTFCLEVBQWdDO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJOVYsU0FBUyxDQUFDMFksVUFBVixDQUFxQmhNLE9BQXJCLENBQTZCLFFBQTdCLE1BQTJDLENBQUMsQ0FBNUMsSUFBaUR1RSxLQUFLLENBQUNpRixPQUFOLEtBQWtCLENBQW5FLElBQXdFSixJQUFJLENBQUM2QyxlQUFMLEtBQXlCLENBQXJHLEVBQXdHO0FBQ3BHLGVBQU9ILFFBQVEsQ0FBQ3ZILEtBQUQsRUFBUTZFLElBQVIsQ0FBZjtBQUNILE9BUjJCLENBVTVCOzs7QUFDQSxVQUFJOEMsUUFBUSxHQUFHLENBQUM3SyxPQUFPLENBQUN2QixHQUFSLEdBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQXBCLEtBQTBCeUUsS0FBSyxDQUFDa0YsU0FBTixHQUFrQkwsSUFBSSxDQUFDK0MsY0FBakQsQ0FBZixDQVg0QixDQWE1Qjs7QUFDQSxVQUFJakIsUUFBUSxHQUFJZ0IsUUFBUSxHQUFHLEdBQVosR0FBbUI5QyxJQUFJLENBQUNOLFFBQXZDO0FBRUFzRCxpQkFBVyxDQUFDRixRQUFRLEdBQUcsQ0FBWixFQUFlaEIsUUFBZixFQUF5QjlCLElBQUksQ0FBQ2lELFNBQTlCLEVBQXlDakQsSUFBSSxDQUFDa0QsYUFBOUMsQ0FBWDtBQUNILEtBaHFCNEMsQ0FrcUI3Qzs7O0FBQ0EsYUFBU1IsUUFBVCxDQUFrQnZILEtBQWxCLEVBQXlCNkUsSUFBekIsRUFBK0I7QUFDM0I7QUFDQSxVQUFJQSxJQUFJLENBQUNsTixNQUFULEVBQWlCO0FBQ2IzSCxtQkFBVyxDQUFDNlUsSUFBSSxDQUFDbE4sTUFBTixFQUFjbUYsT0FBTyxDQUFDdkYsVUFBUixDQUFtQm9CLE1BQWpDLENBQVg7QUFDQW1HLGdDQUF3QixJQUFJLENBQTVCO0FBQ0gsT0FMMEIsQ0FPM0I7OztBQUNBK0YsVUFBSSxDQUFDbUQsU0FBTCxDQUFlaE0sT0FBZixDQUF1QixVQUFTaU0sQ0FBVCxFQUFZO0FBQy9CL0ksNkJBQXFCLENBQUNnSixtQkFBdEIsQ0FBMENELENBQUMsQ0FBQyxDQUFELENBQTNDLEVBQWdEQSxDQUFDLENBQUMsQ0FBRCxDQUFqRDtBQUNILE9BRkQ7O0FBSUEsVUFBSW5KLHdCQUF3QixLQUFLLENBQWpDLEVBQW9DO0FBQ2hDO0FBQ0E5TyxtQkFBVyxDQUFDb08sWUFBRCxFQUFldEIsT0FBTyxDQUFDdkYsVUFBUixDQUFtQmtCLElBQWxDLENBQVg7QUFDQTBQLGlCQUFTLEdBSHVCLENBS2hDOztBQUNBLFlBQUluSSxLQUFLLENBQUN3RyxNQUFWLEVBQWtCO0FBQ2RySCxvQkFBVSxDQUFDekIsS0FBWCxDQUFpQjhJLE1BQWpCLEdBQTBCLEVBQTFCO0FBQ0FySCxvQkFBVSxDQUFDK0ksbUJBQVgsQ0FBK0IsYUFBL0IsRUFBOEN4YSxjQUE5QztBQUNIO0FBQ0o7O0FBRURtWCxVQUFJLENBQUNrRCxhQUFMLENBQW1CL0wsT0FBbkIsQ0FBMkIsVUFBUzhELFlBQVQsRUFBdUI7QUFDOUNzSSxpQkFBUyxDQUFDLFFBQUQsRUFBV3RJLFlBQVgsQ0FBVDtBQUNBc0ksaUJBQVMsQ0FBQyxLQUFELEVBQVF0SSxZQUFSLENBQVQ7QUFDQXNJLGlCQUFTLENBQUMsS0FBRCxFQUFRdEksWUFBUixDQUFUO0FBQ0gsT0FKRDtBQUtILEtBaHNCNEMsQ0Frc0I3Qzs7O0FBQ0EsYUFBU3VJLFVBQVQsQ0FBb0JySSxLQUFwQixFQUEyQjZFLElBQTNCLEVBQWlDO0FBQzdCeUQsYUFBTyxDQUFDQyxHQUFSLENBQVksYUFBWixFQUQ2QixDQUU3Qjs7QUFDQSxVQUFJMUQsSUFBSSxDQUFDa0QsYUFBTCxDQUFtQlMsSUFBbkIsQ0FBd0IzSCxnQkFBeEIsQ0FBSixFQUErQztBQUMzQyxlQUFPLEtBQVA7QUFDSDs7QUFFRCxVQUFJbEosTUFBSjs7QUFFQSxVQUFJa04sSUFBSSxDQUFDa0QsYUFBTCxDQUFtQm5YLE1BQW5CLEtBQThCLENBQWxDLEVBQXFDO0FBQ2pDLFlBQUlrUSxZQUFZLEdBQUd4QyxhQUFhLENBQUN1RyxJQUFJLENBQUNrRCxhQUFMLENBQW1CLENBQW5CLENBQUQsQ0FBaEM7QUFFQXBRLGNBQU0sR0FBR21KLFlBQVksQ0FBQ2EsUUFBYixDQUFzQixDQUF0QixDQUFUO0FBQ0E3QyxnQ0FBd0IsSUFBSSxDQUE1QixDQUppQyxDQU1qQzs7QUFDQWhQLGdCQUFRLENBQUM2SCxNQUFELEVBQVNtRixPQUFPLENBQUN2RixVQUFSLENBQW1Cb0IsTUFBNUIsQ0FBUjtBQUNILE9BakI0QixDQW1CN0I7OztBQUNBcUgsV0FBSyxDQUFDeUksZUFBTixHQXBCNkIsQ0FzQjdCOztBQUNBLFVBQUlULFNBQVMsR0FBRyxFQUFoQixDQXZCNkIsQ0F5QjdCOztBQUNBLFVBQUlVLFNBQVMsR0FBRy9ELFdBQVcsQ0FBQ3pHLE9BQU8sQ0FBQ2pNLElBQVQsRUFBZWlOLHFCQUFmLEVBQXNDc0ksU0FBdEMsRUFBaUQ7QUFDeEU7QUFDQTtBQUNBaFEsY0FBTSxFQUFFd0ksS0FBSyxDQUFDeEksTUFIMEQ7QUFJeEVHLGNBQU0sRUFBRUEsTUFKZ0U7QUFLeEVxUSxpQkFBUyxFQUFFQSxTQUw2RDtBQU14RUosc0JBQWMsRUFBRTVILEtBQUssQ0FBQ2tGLFNBTmtEO0FBT3hFWCxnQkFBUSxFQUFFQSxRQUFRLEVBUHNEO0FBUXhFM1Ysa0JBQVUsRUFBRW9SLEtBQUssQ0FBQ3BSLFVBUnNEO0FBU3hFbVoscUJBQWEsRUFBRWxELElBQUksQ0FBQ2tELGFBVG9EO0FBVXhFTCx1QkFBZSxFQUFFMUgsS0FBSyxDQUFDaUYsT0FWaUQ7QUFXeEU2QyxpQkFBUyxFQUFFbEosZUFBZSxDQUFDL0ssS0FBaEI7QUFYNkQsT0FBakQsQ0FBM0I7QUFjQSxVQUFJOFUsUUFBUSxHQUFHaEUsV0FBVyxDQUFDekcsT0FBTyxDQUFDaE0sR0FBVCxFQUFjZ04scUJBQWQsRUFBcUNxSSxRQUFyQyxFQUErQztBQUNyRS9QLGNBQU0sRUFBRXdJLEtBQUssQ0FBQ3hJLE1BRHVEO0FBRXJFRyxjQUFNLEVBQUVBLE1BRjZEO0FBR3JFcVEsaUJBQVMsRUFBRUEsU0FIMEQ7QUFJckVoRCxtQkFBVyxFQUFFLElBSndEO0FBS3JFK0MscUJBQWEsRUFBRWxELElBQUksQ0FBQ2tEO0FBTGlELE9BQS9DLENBQTFCO0FBUUEsVUFBSWEsUUFBUSxHQUFHakUsV0FBVyxDQUFDLFVBQUQsRUFBYXpGLHFCQUFiLEVBQW9Da0ksYUFBcEMsRUFBbUQ7QUFDekU1UCxjQUFNLEVBQUV3SSxLQUFLLENBQUN4SSxNQUQyRDtBQUV6RUcsY0FBTSxFQUFFQSxNQUZpRTtBQUd6RXFRLGlCQUFTLEVBQUVBLFNBSDhEO0FBSXpFaEQsbUJBQVcsRUFBRSxJQUo0RDtBQUt6RStDLHFCQUFhLEVBQUVsRCxJQUFJLENBQUNrRDtBQUxxRCxPQUFuRCxDQUExQixDQWhENkIsQ0F3RDdCO0FBQ0E7O0FBQ0FDLGVBQVMsQ0FBQ3JULElBQVYsQ0FBZXlDLEtBQWYsQ0FBcUI0USxTQUFyQixFQUFnQ1UsU0FBUyxDQUFDRyxNQUFWLENBQWlCRixRQUFqQixFQUEyQkMsUUFBM0IsQ0FBaEMsRUExRDZCLENBNEQ3QjtBQUNBOztBQUNBLFVBQUk1SSxLQUFLLENBQUN3RyxNQUFWLEVBQWtCO0FBQ2Q7QUFDQXJILGtCQUFVLENBQUN6QixLQUFYLENBQWlCOEksTUFBakIsR0FBMEJoRyxnQkFBZ0IsQ0FBQ1IsS0FBSyxDQUFDeEksTUFBUCxDQUFoQixDQUErQmdQLE1BQXpELENBRmMsQ0FJZDs7QUFDQSxZQUFJbEksYUFBYSxDQUFDMU4sTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUMxQmQsa0JBQVEsQ0FBQ3NPLFlBQUQsRUFBZXRCLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUJrQixJQUFsQyxDQUFSO0FBQ0gsU0FQYSxDQVNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EwRyxrQkFBVSxDQUFDek0sZ0JBQVgsQ0FBNEIsYUFBNUIsRUFBMkNoRixjQUEzQyxFQUEyRCxLQUEzRDtBQUNIOztBQUVEbVgsVUFBSSxDQUFDa0QsYUFBTCxDQUFtQi9MLE9BQW5CLENBQTJCLFVBQVM4RCxZQUFULEVBQXVCO0FBQzlDc0ksaUJBQVMsQ0FBQyxPQUFELEVBQVV0SSxZQUFWLENBQVQ7QUFDSCxPQUZEO0FBR0gsS0F0eEI0QyxDQXd4QjdDOzs7QUFDQSxhQUFTZ0osUUFBVCxDQUFrQjlJLEtBQWxCLEVBQXlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQUksQ0FBQ0EsS0FBSyxDQUFDaUYsT0FBUCxJQUFrQixDQUFDakYsS0FBSyxDQUFDZ0csT0FBN0IsRUFBc0M7QUFDbEMsZUFBTyxLQUFQO0FBQ0gsT0FOb0IsQ0FRckI7OztBQUNBaEcsV0FBSyxDQUFDeUksZUFBTjtBQUVBLFVBQUk5QixRQUFRLEdBQUdGLHFCQUFxQixDQUFDekcsS0FBSyxDQUFDa0YsU0FBUCxDQUFwQztBQUNBLFVBQUlwRixZQUFZLEdBQUc4RyxnQkFBZ0IsQ0FBQ0QsUUFBRCxDQUFuQyxDQVpxQixDQWNyQjs7QUFDQSxVQUFJN0csWUFBWSxLQUFLLEtBQXJCLEVBQTRCO0FBQ3hCLGVBQU8sS0FBUDtBQUNILE9BakJvQixDQW1CckI7QUFDQTs7O0FBQ0EsVUFBSSxDQUFDaEQsT0FBTyxDQUFDakIsTUFBUixDQUFlMUgsSUFBcEIsRUFBMEI7QUFDdEJ6RSxtQkFBVyxDQUFDME8sWUFBRCxFQUFldEIsT0FBTyxDQUFDdkYsVUFBUixDQUFtQm1CLEdBQWxDLEVBQXVDb0UsT0FBTyxDQUFDcEMsaUJBQS9DLENBQVg7QUFDSDs7QUFFRHFPLGVBQVMsQ0FBQ2pKLFlBQUQsRUFBZTZHLFFBQWYsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsQ0FBVDtBQUVBd0IsZUFBUztBQUVUQyxlQUFTLENBQUMsT0FBRCxFQUFVdEksWUFBVixFQUF3QixJQUF4QixDQUFUO0FBQ0FzSSxlQUFTLENBQUMsUUFBRCxFQUFXdEksWUFBWCxFQUF5QixJQUF6QixDQUFUO0FBQ0FzSSxlQUFTLENBQUMsUUFBRCxFQUFXdEksWUFBWCxFQUF5QixJQUF6QixDQUFUO0FBQ0FzSSxlQUFTLENBQUMsS0FBRCxFQUFRdEksWUFBUixFQUFzQixJQUF0QixDQUFUOztBQUVBLFVBQUloRCxPQUFPLENBQUNqQixNQUFSLENBQWUxSCxJQUFuQixFQUF5QjtBQUNyQmtVLGtCQUFVLENBQUNySSxLQUFELEVBQVE7QUFBRStILHVCQUFhLEVBQUUsQ0FBQ2pJLFlBQUQ7QUFBakIsU0FBUixDQUFWO0FBQ0g7QUFDSixLQTl6QjRDLENBZzBCN0M7OztBQUNBLGFBQVNrSixVQUFULENBQW9CaEosS0FBcEIsRUFBMkI7QUFDdkIsVUFBSTJHLFFBQVEsR0FBR0YscUJBQXFCLENBQUN6RyxLQUFLLENBQUNrRixTQUFQLENBQXBDO0FBRUEsVUFBSWpZLEVBQUUsR0FBR3lSLGNBQWMsQ0FBQ3pLLE9BQWYsQ0FBdUIwUyxRQUF2QixDQUFUO0FBQ0EsVUFBSW5aLEtBQUssR0FBR2tSLGNBQWMsQ0FBQzFLLFlBQWYsQ0FBNEIvRyxFQUE1QixDQUFaO0FBRUFzRixZQUFNLENBQUM2SyxJQUFQLENBQVkyQixZQUFaLEVBQTBCL0MsT0FBMUIsQ0FBa0MsVUFBU2lOLFdBQVQsRUFBc0I7QUFDcEQsWUFBSSxZQUFZQSxXQUFXLENBQUN0WSxLQUFaLENBQWtCLEdBQWxCLEVBQXVCLENBQXZCLENBQWhCLEVBQTJDO0FBQ3ZDb08sc0JBQVksQ0FBQ2tLLFdBQUQsQ0FBWixDQUEwQmpOLE9BQTFCLENBQWtDLFVBQVM0SSxRQUFULEVBQW1CO0FBQ2pEQSxvQkFBUSxDQUFDbUIsSUFBVCxDQUFjL0csVUFBZCxFQUEwQnhSLEtBQTFCO0FBQ0gsV0FGRDtBQUdIO0FBQ0osT0FORDtBQU9ILEtBOTBCNEMsQ0FnMUI3QztBQUNBOzs7QUFDQSxhQUFTeVMsWUFBVCxDQUFzQkQsS0FBdEIsRUFBNkJGLFlBQTdCLEVBQTJDO0FBQ3ZDLFVBQUlhLGdCQUFnQixNQUFNRSxnQkFBZ0IsQ0FBQ2YsWUFBRCxDQUExQyxFQUEwRDtBQUN0RCxlQUFPLEtBQVA7QUFDSDs7QUFFRCxVQUFJb0osY0FBYyxHQUFHLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBckI7QUFDQSxVQUFJQyxZQUFZLEdBQUcsQ0FBQyxNQUFELEVBQVMsSUFBVCxDQUFuQjtBQUNBLFVBQUlDLGFBQWEsR0FBRyxDQUFDLFVBQUQsRUFBYSxRQUFiLENBQXBCO0FBQ0EsVUFBSUMsUUFBUSxHQUFHLENBQUMsTUFBRCxFQUFTLEtBQVQsQ0FBZjs7QUFFQSxVQUFJdk0sT0FBTyxDQUFDdkIsR0FBUixJQUFlLENBQUN1QixPQUFPLENBQUNqQyxHQUE1QixFQUFpQztBQUM3QjtBQUNBcU8sc0JBQWMsQ0FBQ0ksT0FBZjtBQUNILE9BSEQsTUFHTyxJQUFJeE0sT0FBTyxDQUFDakMsR0FBUixJQUFlLENBQUNpQyxPQUFPLENBQUN2QixHQUE1QixFQUFpQztBQUNwQztBQUNBNE4sb0JBQVksQ0FBQ0csT0FBYjtBQUNBRixxQkFBYSxDQUFDRSxPQUFkO0FBQ0gsT0FqQnNDLENBbUJ2Qzs7O0FBQ0EsVUFBSTFNLEdBQUcsR0FBR29ELEtBQUssQ0FBQ3BELEdBQU4sQ0FBVTVMLE9BQVYsQ0FBa0IsT0FBbEIsRUFBMkIsRUFBM0IsQ0FBVjtBQUVBLFVBQUl1WSxXQUFXLEdBQUczTSxHQUFHLEtBQUt3TSxhQUFhLENBQUMsQ0FBRCxDQUF2QztBQUNBLFVBQUlJLFNBQVMsR0FBRzVNLEdBQUcsS0FBS3dNLGFBQWEsQ0FBQyxDQUFELENBQXJDO0FBQ0EsVUFBSTFTLE1BQU0sR0FBR2tHLEdBQUcsS0FBS3VNLFlBQVksQ0FBQyxDQUFELENBQXBCLElBQTJCdk0sR0FBRyxLQUFLc00sY0FBYyxDQUFDLENBQUQsQ0FBakQsSUFBd0RLLFdBQXJFO0FBQ0EsVUFBSUUsSUFBSSxHQUFHN00sR0FBRyxLQUFLdU0sWUFBWSxDQUFDLENBQUQsQ0FBcEIsSUFBMkJ2TSxHQUFHLEtBQUtzTSxjQUFjLENBQUMsQ0FBRCxDQUFqRCxJQUF3RE0sU0FBbkU7QUFDQSxVQUFJRSxLQUFLLEdBQUc5TSxHQUFHLEtBQUt5TSxRQUFRLENBQUMsQ0FBRCxDQUE1QjtBQUNBLFVBQUlNLEtBQUssR0FBRy9NLEdBQUcsS0FBS3lNLFFBQVEsQ0FBQyxDQUFELENBQTVCOztBQUVBLFVBQUksQ0FBQzNTLE1BQUQsSUFBVyxDQUFDK1MsSUFBWixJQUFvQixDQUFDQyxLQUFyQixJQUE4QixDQUFDQyxLQUFuQyxFQUEwQztBQUN0QyxlQUFPLElBQVA7QUFDSDs7QUFFRDNKLFdBQUssQ0FBQ3RTLGNBQU47QUFFQSxVQUFJVCxFQUFKOztBQUVBLFVBQUl3YyxJQUFJLElBQUkvUyxNQUFaLEVBQW9CO0FBQ2hCLFlBQUlrVCxVQUFVLEdBQUc5TSxPQUFPLENBQUMvQyxzQkFBekI7QUFDQSxZQUFJL0QsU0FBUyxHQUFHVSxNQUFNLEdBQUcsQ0FBSCxHQUFPLENBQTdCO0FBQ0EsWUFBSTJNLEtBQUssR0FBR3dHLHFCQUFxQixDQUFDL0osWUFBRCxDQUFqQztBQUNBLFlBQUl4SyxJQUFJLEdBQUcrTixLQUFLLENBQUNyTixTQUFELENBQWhCLENBSmdCLENBTWhCOztBQUNBLFlBQUlWLElBQUksS0FBSyxJQUFiLEVBQW1CO0FBQ2YsaUJBQU8sS0FBUDtBQUNILFNBVGUsQ0FXaEI7OztBQUNBLFlBQUlBLElBQUksS0FBSyxLQUFiLEVBQW9CO0FBQ2hCQSxjQUFJLEdBQUdvSixjQUFjLENBQUNqSSxjQUFmLENBQ0htSSxlQUFlLENBQUNrQixZQUFELENBRFosRUFFSHBKLE1BRkcsRUFHSG9HLE9BQU8sQ0FBQzdDLG1CQUhMLENBQVA7QUFLSDs7QUFFRCxZQUFJdVAsU0FBUyxJQUFJRCxXQUFqQixFQUE4QjtBQUMxQmpVLGNBQUksSUFBSXNVLFVBQVI7QUFDSCxTQXRCZSxDQXdCaEI7OztBQUNBdFUsWUFBSSxHQUFHckgsSUFBSSxDQUFDaUMsR0FBTCxDQUFTb0YsSUFBVCxFQUFlLFNBQWYsQ0FBUCxDQXpCZ0IsQ0EyQmhCOztBQUNBQSxZQUFJLEdBQUcsQ0FBQ29CLE1BQU0sR0FBRyxDQUFDLENBQUosR0FBUSxDQUFmLElBQW9CcEIsSUFBM0I7QUFFQXJJLFVBQUUsR0FBRzBSLFlBQVksQ0FBQ21CLFlBQUQsQ0FBWixHQUE2QnhLLElBQWxDO0FBQ0gsT0EvQkQsTUErQk8sSUFBSXFVLEtBQUosRUFBVztBQUNkO0FBQ0ExYyxVQUFFLEdBQUc2UCxPQUFPLENBQUMzQyxRQUFSLENBQWlCeEcsSUFBakIsQ0FBc0JtSixPQUFPLENBQUMzQyxRQUFSLENBQWlCeEcsSUFBakIsQ0FBc0IvQyxNQUF0QixHQUErQixDQUFyRCxDQUFMO0FBQ0gsT0FITSxNQUdBO0FBQ0g7QUFDQTNELFVBQUUsR0FBRzZQLE9BQU8sQ0FBQzNDLFFBQVIsQ0FBaUJ4RyxJQUFqQixDQUFzQixDQUF0QixDQUFMO0FBQ0g7O0FBRURvVixlQUFTLENBQUNqSixZQUFELEVBQWVwQixjQUFjLENBQUNoTCxVQUFmLENBQTBCekcsRUFBMUIsQ0FBZixFQUE4QyxJQUE5QyxFQUFvRCxJQUFwRCxDQUFUO0FBRUFtYixlQUFTLENBQUMsT0FBRCxFQUFVdEksWUFBVixDQUFUO0FBQ0FzSSxlQUFTLENBQUMsUUFBRCxFQUFXdEksWUFBWCxDQUFUO0FBQ0FzSSxlQUFTLENBQUMsUUFBRCxFQUFXdEksWUFBWCxDQUFUO0FBQ0FzSSxlQUFTLENBQUMsS0FBRCxFQUFRdEksWUFBUixDQUFUO0FBRUEsYUFBTyxLQUFQO0FBQ0gsS0F0NkI0QyxDQXc2QjdDOzs7QUFDQSxhQUFTZ0ssZ0JBQVQsQ0FBMEI1TSxTQUExQixFQUFxQztBQUNqQztBQUNBLFVBQUksQ0FBQ0EsU0FBUyxDQUFDeEIsS0FBZixFQUFzQjtBQUNsQjRDLHFCQUFhLENBQUN0QyxPQUFkLENBQXNCLFVBQVNyRSxNQUFULEVBQWlCckQsS0FBakIsRUFBd0I7QUFDMUM7QUFDQTtBQUNBcVEscUJBQVcsQ0FBQ3pHLE9BQU8sQ0FBQ2xNLEtBQVQsRUFBZ0IyRixNQUFNLENBQUNnSyxRQUFQLENBQWdCLENBQWhCLENBQWhCLEVBQW9DMEcsVUFBcEMsRUFBZ0Q7QUFDdkROLHlCQUFhLEVBQUUsQ0FBQ3pULEtBQUQ7QUFEd0MsV0FBaEQsQ0FBWDtBQUdILFNBTkQ7QUFPSCxPQVZnQyxDQVlqQzs7O0FBQ0EsVUFBSTRJLFNBQVMsQ0FBQ3hFLEdBQWQsRUFBbUI7QUFDZmlNLG1CQUFXLENBQUN6RyxPQUFPLENBQUNsTSxLQUFULEVBQWdCcU0sVUFBaEIsRUFBNEJ5SyxRQUE1QixFQUFzQyxFQUF0QyxDQUFYO0FBQ0gsT0FmZ0MsQ0FpQmpDOzs7QUFDQSxVQUFJNUwsU0FBUyxDQUFDdkIsS0FBZCxFQUFxQjtBQUNqQmdKLG1CQUFXLENBQUN6RyxPQUFPLENBQUNqTSxJQUFULEVBQWVvTSxVQUFmLEVBQTJCMkssVUFBM0IsRUFBdUM7QUFDOUNyTixlQUFLLEVBQUU7QUFEdUMsU0FBdkMsQ0FBWDtBQUdILE9BdEJnQyxDQXdCakM7OztBQUNBLFVBQUl1QixTQUFTLENBQUN6RSxJQUFkLEVBQW9CO0FBQ2hCOEYsc0JBQWMsQ0FBQ3ZDLE9BQWYsQ0FBdUIsVUFBUzlELE9BQVQsRUFBa0I1RCxLQUFsQixFQUF5QjtBQUM1QyxjQUFJNEQsT0FBTyxLQUFLLEtBQVosSUFBcUI1RCxLQUFLLEtBQUssQ0FBL0IsSUFBb0NBLEtBQUssS0FBS2lLLGNBQWMsQ0FBQzNOLE1BQWYsR0FBd0IsQ0FBMUUsRUFBNkU7QUFDekU7QUFDSDs7QUFFRCxjQUFJbVosWUFBWSxHQUFHekwsYUFBYSxDQUFDaEssS0FBSyxHQUFHLENBQVQsQ0FBaEM7QUFDQSxjQUFJMFYsV0FBVyxHQUFHMUwsYUFBYSxDQUFDaEssS0FBRCxDQUEvQjtBQUNBLGNBQUkyVixZQUFZLEdBQUcsQ0FBQy9SLE9BQUQsQ0FBbkI7QUFFQXBJLGtCQUFRLENBQUNvSSxPQUFELEVBQVU0RSxPQUFPLENBQUN2RixVQUFSLENBQW1CaUIsU0FBN0IsQ0FBUixDQVQ0QyxDQVc1QztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxjQUFJMEUsU0FBUyxDQUFDeEIsS0FBZCxFQUFxQjtBQUNqQnVPLHdCQUFZLENBQUN0VixJQUFiLENBQWtCb1YsWUFBWSxDQUFDcEksUUFBYixDQUFzQixDQUF0QixDQUFsQjtBQUNBc0ksd0JBQVksQ0FBQ3RWLElBQWIsQ0FBa0JxVixXQUFXLENBQUNySSxRQUFaLENBQXFCLENBQXJCLENBQWxCO0FBQ0g7O0FBRURzSSxzQkFBWSxDQUFDak8sT0FBYixDQUFxQixVQUFTa08sV0FBVCxFQUFzQjtBQUN2Q3ZGLHVCQUFXLENBQUN6RyxPQUFPLENBQUNsTSxLQUFULEVBQWdCa1ksV0FBaEIsRUFBNkI3QixVQUE3QixFQUF5QztBQUNoRGhPLHFCQUFPLEVBQUUsQ0FBQzBQLFlBQUQsRUFBZUMsV0FBZixDQUR1QztBQUVoRGpDLDJCQUFhLEVBQUUsQ0FBQ3pULEtBQUssR0FBRyxDQUFULEVBQVlBLEtBQVo7QUFGaUMsYUFBekMsQ0FBWDtBQUlILFdBTEQ7QUFNSCxTQTFCRDtBQTJCSDtBQUNKLEtBLzlCNEMsQ0FpK0I3Qzs7O0FBQ0EsYUFBUzJNLFNBQVQsQ0FBbUJrSixlQUFuQixFQUFvQ3ZGLFFBQXBDLEVBQThDO0FBQzFDN0Ysa0JBQVksQ0FBQ29MLGVBQUQsQ0FBWixHQUFnQ3BMLFlBQVksQ0FBQ29MLGVBQUQsQ0FBWixJQUFpQyxFQUFqRTtBQUNBcEwsa0JBQVksQ0FBQ29MLGVBQUQsQ0FBWixDQUE4QnhWLElBQTlCLENBQW1DaVEsUUFBbkMsRUFGMEMsQ0FJMUM7O0FBQ0EsVUFBSXVGLGVBQWUsQ0FBQ3haLEtBQWhCLENBQXNCLEdBQXRCLEVBQTJCLENBQTNCLE1BQWtDLFFBQXRDLEVBQWdEO0FBQzVDMk4scUJBQWEsQ0FBQ3RDLE9BQWQsQ0FBc0IsVUFBU2pPLENBQVQsRUFBWXVHLEtBQVosRUFBbUI7QUFDckM4VCxtQkFBUyxDQUFDLFFBQUQsRUFBVzlULEtBQVgsQ0FBVDtBQUNILFNBRkQ7QUFHSDtBQUNKLEtBNStCNEMsQ0E4K0I3Qzs7O0FBQ0EsYUFBUzBNLFdBQVQsQ0FBcUJtSixlQUFyQixFQUFzQztBQUNsQyxVQUFJbkssS0FBSyxHQUFHbUssZUFBZSxJQUFJQSxlQUFlLENBQUN4WixLQUFoQixDQUFzQixHQUF0QixFQUEyQixDQUEzQixDQUEvQjtBQUNBLFVBQUl5WixTQUFTLEdBQUdwSyxLQUFLLElBQUltSyxlQUFlLENBQUNFLFNBQWhCLENBQTBCckssS0FBSyxDQUFDcFAsTUFBaEMsQ0FBekI7QUFFQTJCLFlBQU0sQ0FBQzZLLElBQVAsQ0FBWTJCLFlBQVosRUFBMEIvQyxPQUExQixDQUFrQyxVQUFTc08sSUFBVCxFQUFlO0FBQzdDLFlBQUlDLE1BQU0sR0FBR0QsSUFBSSxDQUFDM1osS0FBTCxDQUFXLEdBQVgsRUFBZ0IsQ0FBaEIsQ0FBYjtBQUNBLFlBQUk2WixVQUFVLEdBQUdGLElBQUksQ0FBQ0QsU0FBTCxDQUFlRSxNQUFNLENBQUMzWixNQUF0QixDQUFqQjs7QUFFQSxZQUFJLENBQUMsQ0FBQ29QLEtBQUQsSUFBVUEsS0FBSyxLQUFLdUssTUFBckIsTUFBaUMsQ0FBQ0gsU0FBRCxJQUFjQSxTQUFTLEtBQUtJLFVBQTdELENBQUosRUFBOEU7QUFDMUUsaUJBQU96TCxZQUFZLENBQUN1TCxJQUFELENBQW5CO0FBQ0g7QUFDSixPQVBEO0FBUUgsS0EzL0I0QyxDQTYvQjdDOzs7QUFDQSxhQUFTbEMsU0FBVCxDQUFtQi9DLFNBQW5CLEVBQThCdkYsWUFBOUIsRUFBNENwSCxHQUE1QyxFQUFpRDtBQUM3Q25HLFlBQU0sQ0FBQzZLLElBQVAsQ0FBWTJCLFlBQVosRUFBMEIvQyxPQUExQixDQUFrQyxVQUFTaU4sV0FBVCxFQUFzQjtBQUNwRCxZQUFJd0IsU0FBUyxHQUFHeEIsV0FBVyxDQUFDdFksS0FBWixDQUFrQixHQUFsQixFQUF1QixDQUF2QixDQUFoQjs7QUFFQSxZQUFJMFUsU0FBUyxLQUFLb0YsU0FBbEIsRUFBNkI7QUFDekIxTCxzQkFBWSxDQUFDa0ssV0FBRCxDQUFaLENBQTBCak4sT0FBMUIsQ0FBa0MsVUFBUzRJLFFBQVQsRUFBbUI7QUFDakRBLG9CQUFRLENBQUNtQixJQUFULEVBQ0k7QUFDQS9HLHNCQUZKLEVBR0k7QUFDQUwsd0JBQVksQ0FBQ3hILEdBQWIsQ0FBaUIyRixPQUFPLENBQUNULE1BQVIsQ0FBZXBQLEVBQWhDLENBSkosRUFLSTtBQUNBNlMsd0JBTkosRUFPSTtBQUNBbkIsd0JBQVksQ0FBQzlLLEtBQWIsRUFSSixFQVNJO0FBQ0E2RSxlQUFHLElBQUksS0FWWCxFQVdJO0FBQ0FrRywyQkFBZSxDQUFDL0ssS0FBaEIsRUFaSixFQWFJO0FBQ0FtTCxzQkFkSjtBQWdCSCxXQWpCRDtBQWtCSDtBQUNKLE9BdkJEO0FBd0JILEtBdmhDNEMsQ0F5aEM3Qzs7O0FBQ0EsYUFBU3dDLG1CQUFULENBQTZCa0osU0FBN0IsRUFBd0M1SyxZQUF4QyxFQUFzRDdTLEVBQXRELEVBQTBEMGQsWUFBMUQsRUFBd0VDLFdBQXhFLEVBQXFGQyxRQUFyRixFQUErRjtBQUMzRixVQUFJQyxRQUFKLENBRDJGLENBRzNGO0FBQ0E7O0FBQ0EsVUFBSXhNLGFBQWEsQ0FBQzFOLE1BQWQsR0FBdUIsQ0FBdkIsSUFBNEIsQ0FBQ2tNLE9BQU8sQ0FBQ2pCLE1BQVIsQ0FBZUQsYUFBaEQsRUFBK0Q7QUFDM0QsWUFBSStPLFlBQVksSUFBSTdLLFlBQVksR0FBRyxDQUFuQyxFQUFzQztBQUNsQ2dMLGtCQUFRLEdBQUdwTSxjQUFjLENBQUMzSSxtQkFBZixDQUFtQzJVLFNBQVMsQ0FBQzVLLFlBQVksR0FBRyxDQUFoQixDQUE1QyxFQUFnRWhELE9BQU8sQ0FBQy9CLE1BQXhFLEVBQWdGLENBQWhGLENBQVg7QUFDQTlOLFlBQUUsR0FBR2dCLElBQUksQ0FBQ2lDLEdBQUwsQ0FBU2pELEVBQVQsRUFBYTZkLFFBQWIsQ0FBTDtBQUNIOztBQUVELFlBQUlGLFdBQVcsSUFBSTlLLFlBQVksR0FBR3hCLGFBQWEsQ0FBQzFOLE1BQWQsR0FBdUIsQ0FBekQsRUFBNEQ7QUFDeERrYSxrQkFBUSxHQUFHcE0sY0FBYyxDQUFDM0ksbUJBQWYsQ0FBbUMyVSxTQUFTLENBQUM1SyxZQUFZLEdBQUcsQ0FBaEIsQ0FBNUMsRUFBZ0VoRCxPQUFPLENBQUMvQixNQUF4RSxFQUFnRixDQUFoRixDQUFYO0FBQ0E5TixZQUFFLEdBQUdnQixJQUFJLENBQUNrQyxHQUFMLENBQVNsRCxFQUFULEVBQWE2ZCxRQUFiLENBQUw7QUFDSDtBQUNKLE9BZjBGLENBaUIzRjtBQUNBO0FBQ0E7OztBQUNBLFVBQUl4TSxhQUFhLENBQUMxTixNQUFkLEdBQXVCLENBQXZCLElBQTRCa00sT0FBTyxDQUFDN00sS0FBeEMsRUFBK0M7QUFDM0MsWUFBSTBhLFlBQVksSUFBSTdLLFlBQVksR0FBRyxDQUFuQyxFQUFzQztBQUNsQ2dMLGtCQUFRLEdBQUdwTSxjQUFjLENBQUMzSSxtQkFBZixDQUFtQzJVLFNBQVMsQ0FBQzVLLFlBQVksR0FBRyxDQUFoQixDQUE1QyxFQUFnRWhELE9BQU8sQ0FBQzdNLEtBQXhFLEVBQStFLENBQS9FLENBQVg7QUFDQWhELFlBQUUsR0FBR2dCLElBQUksQ0FBQ2tDLEdBQUwsQ0FBU2xELEVBQVQsRUFBYTZkLFFBQWIsQ0FBTDtBQUNIOztBQUVELFlBQUlGLFdBQVcsSUFBSTlLLFlBQVksR0FBR3hCLGFBQWEsQ0FBQzFOLE1BQWQsR0FBdUIsQ0FBekQsRUFBNEQ7QUFDeERrYSxrQkFBUSxHQUFHcE0sY0FBYyxDQUFDM0ksbUJBQWYsQ0FBbUMyVSxTQUFTLENBQUM1SyxZQUFZLEdBQUcsQ0FBaEIsQ0FBNUMsRUFBZ0VoRCxPQUFPLENBQUM3TSxLQUF4RSxFQUErRSxDQUEvRSxDQUFYO0FBQ0FoRCxZQUFFLEdBQUdnQixJQUFJLENBQUNpQyxHQUFMLENBQVNqRCxFQUFULEVBQWE2ZCxRQUFiLENBQUw7QUFDSDtBQUNKLE9BOUIwRixDQWdDM0Y7QUFDQTs7O0FBQ0EsVUFBSWhPLE9BQU8sQ0FBQzVCLE9BQVosRUFBcUI7QUFDakIsWUFBSTRFLFlBQVksS0FBSyxDQUFyQixFQUF3QjtBQUNwQmdMLGtCQUFRLEdBQUdwTSxjQUFjLENBQUMzSSxtQkFBZixDQUFtQyxDQUFuQyxFQUFzQytHLE9BQU8sQ0FBQzVCLE9BQVIsQ0FBZ0IsQ0FBaEIsQ0FBdEMsRUFBMEQsQ0FBMUQsQ0FBWDtBQUNBak8sWUFBRSxHQUFHZ0IsSUFBSSxDQUFDaUMsR0FBTCxDQUFTakQsRUFBVCxFQUFhNmQsUUFBYixDQUFMO0FBQ0g7O0FBRUQsWUFBSWhMLFlBQVksS0FBS3hCLGFBQWEsQ0FBQzFOLE1BQWQsR0FBdUIsQ0FBNUMsRUFBK0M7QUFDM0NrYSxrQkFBUSxHQUFHcE0sY0FBYyxDQUFDM0ksbUJBQWYsQ0FBbUMsR0FBbkMsRUFBd0MrRyxPQUFPLENBQUM1QixPQUFSLENBQWdCLENBQWhCLENBQXhDLEVBQTRELENBQTVELENBQVg7QUFDQWpPLFlBQUUsR0FBR2dCLElBQUksQ0FBQ2tDLEdBQUwsQ0FBU2xELEVBQVQsRUFBYTZkLFFBQWIsQ0FBTDtBQUNIO0FBQ0o7O0FBRUQ3ZCxRQUFFLEdBQUd5UixjQUFjLENBQUN6SyxPQUFmLENBQXVCaEgsRUFBdkIsQ0FBTCxDQTlDMkYsQ0FnRDNGOztBQUNBQSxRQUFFLEdBQUdnRCxLQUFLLENBQUNoRCxFQUFELENBQVYsQ0FqRDJGLENBbUQzRjs7QUFDQSxVQUFJQSxFQUFFLEtBQUt5ZCxTQUFTLENBQUM1SyxZQUFELENBQWhCLElBQWtDLENBQUMrSyxRQUF2QyxFQUFpRDtBQUM3QyxlQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFPNWQsRUFBUDtBQUNILEtBbmxDNEMsQ0FxbEM3Qzs7O0FBQ0EsYUFBUzhkLFdBQVQsQ0FBcUJDLENBQXJCLEVBQXdCamQsQ0FBeEIsRUFBMkI7QUFDdkIsVUFBSWtkLENBQUMsR0FBR25PLE9BQU8sQ0FBQ2pDLEdBQWhCO0FBQ0EsYUFBTyxDQUFDb1EsQ0FBQyxHQUFHbGQsQ0FBSCxHQUFPaWQsQ0FBVCxJQUFjLElBQWQsSUFBc0JDLENBQUMsR0FBR0QsQ0FBSCxHQUFPamQsQ0FBOUIsQ0FBUDtBQUNILEtBemxDNEMsQ0EybEM3QztBQUNBOzs7QUFDQSxhQUFTOFosV0FBVCxDQUFxQnFELE1BQXJCLEVBQTZCdkUsUUFBN0IsRUFBdUNtQixTQUF2QyxFQUFrREMsYUFBbEQsRUFBaUU7QUFDN0QsVUFBSW9ELFNBQVMsR0FBR3JELFNBQVMsQ0FBQ2pVLEtBQVYsRUFBaEI7QUFFQSxVQUFJTyxDQUFDLEdBQUcsQ0FBQyxDQUFDOFcsTUFBRixFQUFVQSxNQUFWLENBQVI7QUFDQSxVQUFJRSxDQUFDLEdBQUcsQ0FBQ0YsTUFBRCxFQUFTLENBQUNBLE1BQVYsQ0FBUixDQUo2RCxDQU03RDs7QUFDQW5ELG1CQUFhLEdBQUdBLGFBQWEsQ0FBQ2xVLEtBQWQsRUFBaEIsQ0FQNkQsQ0FTN0Q7QUFDQTs7QUFDQSxVQUFJcVgsTUFBSixFQUFZO0FBQ1JuRCxxQkFBYSxDQUFDdUIsT0FBZDtBQUNILE9BYjRELENBZTdEOzs7QUFDQSxVQUFJdkIsYUFBYSxDQUFDblgsTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUMxQm1YLHFCQUFhLENBQUMvTCxPQUFkLENBQXNCLFVBQVM4RCxZQUFULEVBQXVCbUwsQ0FBdkIsRUFBMEI7QUFDNUMsY0FBSWhlLEVBQUUsR0FBR3VVLG1CQUFtQixDQUN4QjJKLFNBRHdCLEVBRXhCckwsWUFGd0IsRUFHeEJxTCxTQUFTLENBQUNyTCxZQUFELENBQVQsR0FBMEI2RyxRQUhGLEVBSXhCdlMsQ0FBQyxDQUFDNlcsQ0FBRCxDQUp1QixFQUt4QkcsQ0FBQyxDQUFDSCxDQUFELENBTHVCLEVBTXhCLEtBTndCLENBQTVCLENBRDRDLENBVTVDOztBQUNBLGNBQUloZSxFQUFFLEtBQUssS0FBWCxFQUFrQjtBQUNkMFosb0JBQVEsR0FBRyxDQUFYO0FBQ0gsV0FGRCxNQUVPO0FBQ0hBLG9CQUFRLEdBQUcxWixFQUFFLEdBQUdrZSxTQUFTLENBQUNyTCxZQUFELENBQXpCO0FBQ0FxTCxxQkFBUyxDQUFDckwsWUFBRCxDQUFULEdBQTBCN1MsRUFBMUI7QUFDSDtBQUNKLFNBakJEO0FBa0JILE9BbkJELENBcUJBO0FBckJBLFdBc0JLO0FBQ0RtSCxXQUFDLEdBQUdnWCxDQUFDLEdBQUcsQ0FBQyxJQUFELENBQVI7QUFDSDs7QUFFRCxVQUFJQyxLQUFLLEdBQUcsS0FBWixDQTFDNkQsQ0E0QzdEOztBQUNBdEQsbUJBQWEsQ0FBQy9MLE9BQWQsQ0FBc0IsVUFBUzhELFlBQVQsRUFBdUJtTCxDQUF2QixFQUEwQjtBQUM1Q0ksYUFBSyxHQUFHdEMsU0FBUyxDQUFDakosWUFBRCxFQUFlZ0ksU0FBUyxDQUFDaEksWUFBRCxDQUFULEdBQTBCNkcsUUFBekMsRUFBbUR2UyxDQUFDLENBQUM2VyxDQUFELENBQXBELEVBQXlERyxDQUFDLENBQUNILENBQUQsQ0FBMUQsQ0FBVCxJQUEyRUksS0FBbkY7QUFDSCxPQUZELEVBN0M2RCxDQWlEN0Q7O0FBQ0EsVUFBSUEsS0FBSixFQUFXO0FBQ1B0RCxxQkFBYSxDQUFDL0wsT0FBZCxDQUFzQixVQUFTOEQsWUFBVCxFQUF1QjtBQUN6Q3NJLG1CQUFTLENBQUMsUUFBRCxFQUFXdEksWUFBWCxDQUFUO0FBQ0FzSSxtQkFBUyxDQUFDLE9BQUQsRUFBVXRJLFlBQVYsQ0FBVDtBQUNILFNBSEQ7QUFJSDtBQUNKLEtBcnBDNEMsQ0F1cEM3QztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsYUFBU3dMLGtCQUFULENBQTRCdmQsQ0FBNUIsRUFBK0JxRyxDQUEvQixFQUFrQztBQUM5QixhQUFPMEksT0FBTyxDQUFDdkIsR0FBUixHQUFjLE1BQU14TixDQUFOLEdBQVVxRyxDQUF4QixHQUE0QnJHLENBQW5DO0FBQ0gsS0E3cEM0QyxDQStwQzdDOzs7QUFDQSxhQUFTd2Qsb0JBQVQsQ0FBOEJ6TCxZQUE5QixFQUE0QzdTLEVBQTVDLEVBQWdEO0FBQzVDO0FBQ0EyUixxQkFBZSxDQUFDa0IsWUFBRCxDQUFmLEdBQWdDN1MsRUFBaEMsQ0FGNEMsQ0FJNUM7O0FBQ0EwUixrQkFBWSxDQUFDbUIsWUFBRCxDQUFaLEdBQTZCcEIsY0FBYyxDQUFDMUssWUFBZixDQUE0Qi9HLEVBQTVCLENBQTdCO0FBRUEsVUFBSXVlLFdBQVcsR0FBRyxNQUFNRixrQkFBa0IsQ0FBQ3JlLEVBQUQsRUFBSyxDQUFMLENBQWxCLEdBQTRCdVMsZUFBbEMsQ0FBbEI7QUFDQSxVQUFJaU0sYUFBYSxHQUFHLGVBQWVWLFdBQVcsQ0FBQ1MsV0FBVyxHQUFHLEdBQWYsRUFBb0IsR0FBcEIsQ0FBMUIsR0FBcUQsR0FBekU7QUFFQWxOLG1CQUFhLENBQUN3QixZQUFELENBQWIsQ0FBNEJwQyxLQUE1QixDQUFrQ1osT0FBTyxDQUFDZ0IsYUFBMUMsSUFBMkQyTixhQUEzRDtBQUVBQyxtQkFBYSxDQUFDNUwsWUFBRCxDQUFiO0FBQ0E0TCxtQkFBYSxDQUFDNUwsWUFBWSxHQUFHLENBQWhCLENBQWI7QUFDSCxLQTlxQzRDLENBZ3JDN0M7QUFDQTtBQUNBOzs7QUFDQSxhQUFTcUksU0FBVCxHQUFxQjtBQUNqQnRKLHlCQUFtQixDQUFDN0MsT0FBcEIsQ0FBNEIsVUFBUzhELFlBQVQsRUFBdUI7QUFDL0MsWUFBSXZFLEdBQUcsR0FBR3FELGVBQWUsQ0FBQ2tCLFlBQUQsQ0FBZixHQUFnQyxFQUFoQyxHQUFxQyxDQUFDLENBQXRDLEdBQTBDLENBQXBEO0FBQ0EsWUFBSTZMLE1BQU0sR0FBRyxLQUFLck4sYUFBYSxDQUFDMU4sTUFBZCxHQUF1QjJLLEdBQUcsR0FBR3VFLFlBQWxDLENBQWI7QUFDQXhCLHFCQUFhLENBQUN3QixZQUFELENBQWIsQ0FBNEJwQyxLQUE1QixDQUFrQ2lPLE1BQWxDLEdBQTJDQSxNQUEzQztBQUNILE9BSkQ7QUFLSCxLQXpyQzRDLENBMnJDN0M7OztBQUNBLGFBQVM1QyxTQUFULENBQW1CakosWUFBbkIsRUFBaUM3UyxFQUFqQyxFQUFxQzBkLFlBQXJDLEVBQW1EQyxXQUFuRCxFQUFnRTtBQUM1RDNkLFFBQUUsR0FBR3VVLG1CQUFtQixDQUFDNUMsZUFBRCxFQUFrQmtCLFlBQWxCLEVBQWdDN1MsRUFBaEMsRUFBb0MwZCxZQUFwQyxFQUFrREMsV0FBbEQsRUFBK0QsS0FBL0QsQ0FBeEI7O0FBRUEsVUFBSTNkLEVBQUUsS0FBSyxLQUFYLEVBQWtCO0FBQ2QsZUFBTyxLQUFQO0FBQ0g7O0FBRURzZSwwQkFBb0IsQ0FBQ3pMLFlBQUQsRUFBZTdTLEVBQWYsQ0FBcEI7QUFFQSxhQUFPLElBQVA7QUFDSCxLQXRzQzRDLENBd3NDN0M7OztBQUNBLGFBQVN5ZSxhQUFULENBQXVCcFgsS0FBdkIsRUFBOEI7QUFDMUI7QUFDQSxVQUFJLENBQUNpSyxjQUFjLENBQUNqSyxLQUFELENBQW5CLEVBQTRCO0FBQ3hCO0FBQ0g7O0FBRUQsVUFBSXNYLENBQUMsR0FBRyxDQUFSO0FBQ0EsVUFBSUMsQ0FBQyxHQUFHLEdBQVI7O0FBRUEsVUFBSXZYLEtBQUssS0FBSyxDQUFkLEVBQWlCO0FBQ2JzWCxTQUFDLEdBQUdoTixlQUFlLENBQUN0SyxLQUFLLEdBQUcsQ0FBVCxDQUFuQjtBQUNIOztBQUVELFVBQUlBLEtBQUssS0FBS2lLLGNBQWMsQ0FBQzNOLE1BQWYsR0FBd0IsQ0FBdEMsRUFBeUM7QUFDckNpYixTQUFDLEdBQUdqTixlQUFlLENBQUN0SyxLQUFELENBQW5CO0FBQ0gsT0FmeUIsQ0FpQjFCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJd1gsWUFBWSxHQUFHRCxDQUFDLEdBQUdELENBQXZCO0FBQ0EsVUFBSUgsYUFBYSxHQUFHLGVBQWVWLFdBQVcsQ0FBQ08sa0JBQWtCLENBQUNNLENBQUQsRUFBSUUsWUFBSixDQUFsQixHQUFzQyxHQUF2QyxFQUE0QyxHQUE1QyxDQUExQixHQUE2RSxHQUFqRztBQUNBLFVBQUlDLFNBQVMsR0FBRyxXQUFXaEIsV0FBVyxDQUFDZSxZQUFZLEdBQUcsR0FBaEIsRUFBcUIsR0FBckIsQ0FBdEIsR0FBa0QsR0FBbEU7QUFFQXZOLG9CQUFjLENBQUNqSyxLQUFELENBQWQsQ0FBc0JvSixLQUF0QixDQUE0QlosT0FBTyxDQUFDZ0IsYUFBcEMsSUFBcUQyTixhQUFhLEdBQUcsR0FBaEIsR0FBc0JNLFNBQTNFO0FBQ0gsS0FudUM0QyxDQXF1QzdDOzs7QUFDQSxhQUFTQyxjQUFULENBQXdCL2UsRUFBeEIsRUFBNEI2UyxZQUE1QixFQUEwQztBQUN0QztBQUNBO0FBQ0EsVUFBSTdTLEVBQUUsS0FBSyxJQUFQLElBQWVBLEVBQUUsS0FBSyxLQUF0QixJQUErQkEsRUFBRSxLQUFLUSxTQUExQyxFQUFxRDtBQUNqRCxlQUFPbVIsZUFBZSxDQUFDa0IsWUFBRCxDQUF0QjtBQUNILE9BTHFDLENBT3RDOzs7QUFDQSxVQUFJLE9BQU83UyxFQUFQLEtBQWMsUUFBbEIsRUFBNEI7QUFDeEJBLFVBQUUsR0FBR3dELE1BQU0sQ0FBQ3hELEVBQUQsQ0FBWDtBQUNIOztBQUVEQSxRQUFFLEdBQUc2UCxPQUFPLENBQUNULE1BQVIsQ0FBZW5QLElBQWYsQ0FBb0JELEVBQXBCLENBQUw7QUFDQUEsUUFBRSxHQUFHeVIsY0FBYyxDQUFDaEwsVUFBZixDQUEwQnpHLEVBQTFCLENBQUwsQ0Fic0MsQ0FldEM7O0FBQ0EsVUFBSUEsRUFBRSxLQUFLLEtBQVAsSUFBZ0J1QyxLQUFLLENBQUN2QyxFQUFELENBQXpCLEVBQStCO0FBQzNCLGVBQU8yUixlQUFlLENBQUNrQixZQUFELENBQXRCO0FBQ0g7O0FBRUQsYUFBTzdTLEVBQVA7QUFDSCxLQTN2QzRDLENBNnZDN0M7OztBQUNBLGFBQVNnZixRQUFULENBQWtCQyxLQUFsQixFQUF5QkMsWUFBekIsRUFBdUM7QUFDbkMsVUFBSWpMLE1BQU0sR0FBRzlRLE9BQU8sQ0FBQzhiLEtBQUQsQ0FBcEI7QUFDQSxVQUFJRSxNQUFNLEdBQUd4TixlQUFlLENBQUMsQ0FBRCxDQUFmLEtBQXVCblIsU0FBcEMsQ0FGbUMsQ0FJbkM7O0FBQ0EwZSxrQkFBWSxHQUFHQSxZQUFZLEtBQUsxZSxTQUFqQixHQUE2QixJQUE3QixHQUFvQyxDQUFDLENBQUMwZSxZQUFyRCxDQUxtQyxDQU9uQztBQUNBOztBQUNBLFVBQUlyUCxPQUFPLENBQUN0QyxPQUFSLElBQW1CLENBQUM0UixNQUF4QixFQUFnQztBQUM1QjFjLG1CQUFXLENBQUMwTyxZQUFELEVBQWV0QixPQUFPLENBQUN2RixVQUFSLENBQW1CbUIsR0FBbEMsRUFBdUNvRSxPQUFPLENBQUNwQyxpQkFBL0MsQ0FBWDtBQUNILE9BWGtDLENBYW5DOzs7QUFDQW1FLHlCQUFtQixDQUFDN0MsT0FBcEIsQ0FBNEIsVUFBUzhELFlBQVQsRUFBdUI7QUFDL0NpSixpQkFBUyxDQUFDakosWUFBRCxFQUFla00sY0FBYyxDQUFDOUssTUFBTSxDQUFDcEIsWUFBRCxDQUFQLEVBQXVCQSxZQUF2QixDQUE3QixFQUFtRSxJQUFuRSxFQUF5RSxLQUF6RSxDQUFUO0FBQ0gsT0FGRDtBQUlBLFVBQUloTCxDQUFDLEdBQUcrSixtQkFBbUIsQ0FBQ2pPLE1BQXBCLEtBQStCLENBQS9CLEdBQW1DLENBQW5DLEdBQXVDLENBQS9DLENBbEJtQyxDQW9CbkM7QUFDQTs7QUFDQSxhQUFPa0UsQ0FBQyxHQUFHK0osbUJBQW1CLENBQUNqTyxNQUEvQixFQUF1QyxFQUFFa0UsQ0FBekMsRUFBNEM7QUFDeEMrSiwyQkFBbUIsQ0FBQzdDLE9BQXBCLENBQTRCLFVBQVM4RCxZQUFULEVBQXVCO0FBQy9DaUosbUJBQVMsQ0FBQ2pKLFlBQUQsRUFBZWxCLGVBQWUsQ0FBQ2tCLFlBQUQsQ0FBOUIsRUFBOEMsSUFBOUMsRUFBb0QsSUFBcEQsQ0FBVDtBQUNILFNBRkQ7QUFHSDs7QUFFRHFJLGVBQVM7QUFFVHRKLHlCQUFtQixDQUFDN0MsT0FBcEIsQ0FBNEIsVUFBUzhELFlBQVQsRUFBdUI7QUFDL0NzSSxpQkFBUyxDQUFDLFFBQUQsRUFBV3RJLFlBQVgsQ0FBVCxDQUQrQyxDQUcvQzs7QUFDQSxZQUFJb0IsTUFBTSxDQUFDcEIsWUFBRCxDQUFOLEtBQXlCLElBQXpCLElBQWlDcU0sWUFBckMsRUFBbUQ7QUFDL0MvRCxtQkFBUyxDQUFDLEtBQUQsRUFBUXRJLFlBQVIsQ0FBVDtBQUNIO0FBQ0osT0FQRDtBQVFILEtBcHlDNEMsQ0FzeUM3Qzs7O0FBQ0EsYUFBU3VNLFVBQVQsQ0FBb0JGLFlBQXBCLEVBQWtDO0FBQzlCRixjQUFRLENBQUNuUCxPQUFPLENBQUM5SyxLQUFULEVBQWdCbWEsWUFBaEIsQ0FBUjtBQUNILEtBenlDNEMsQ0EyeUM3Qzs7O0FBQ0EsYUFBU0csY0FBVCxDQUF3QnhNLFlBQXhCLEVBQXNDdFMsS0FBdEMsRUFBNkMyZSxZQUE3QyxFQUEyRDtBQUN2RDtBQUNBck0sa0JBQVksR0FBRzFLLE1BQU0sQ0FBQzBLLFlBQUQsQ0FBckI7O0FBRUEsVUFBSSxFQUFFQSxZQUFZLElBQUksQ0FBaEIsSUFBcUJBLFlBQVksR0FBR2pCLG1CQUFtQixDQUFDak8sTUFBMUQsQ0FBSixFQUF1RTtBQUNuRSxjQUFNLElBQUk2RCxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsaUNBQTNCLEdBQStEZ1QsWUFBekUsQ0FBTjtBQUNILE9BTnNELENBUXZEOzs7QUFDQWlKLGVBQVMsQ0FBQ2pKLFlBQUQsRUFBZWtNLGNBQWMsQ0FBQ3hlLEtBQUQsRUFBUXNTLFlBQVIsQ0FBN0IsRUFBb0QsSUFBcEQsRUFBMEQsSUFBMUQsQ0FBVDtBQUVBc0ksZUFBUyxDQUFDLFFBQUQsRUFBV3RJLFlBQVgsQ0FBVDs7QUFFQSxVQUFJcU0sWUFBSixFQUFrQjtBQUNkL0QsaUJBQVMsQ0FBQyxLQUFELEVBQVF0SSxZQUFSLENBQVQ7QUFDSDtBQUNKLEtBNXpDNEMsQ0E4ekM3Qzs7O0FBQ0EsYUFBU3lNLFFBQVQsR0FBb0I7QUFDaEIsVUFBSXJMLE1BQU0sR0FBR3ZDLFlBQVksQ0FBQ3hILEdBQWIsQ0FBaUIyRixPQUFPLENBQUNULE1BQVIsQ0FBZXBQLEVBQWhDLENBQWIsQ0FEZ0IsQ0FHaEI7O0FBQ0EsVUFBSWlVLE1BQU0sQ0FBQ3RRLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsZUFBT3NRLE1BQU0sQ0FBQyxDQUFELENBQWI7QUFDSDs7QUFFRCxhQUFPQSxNQUFQO0FBQ0gsS0F4MEM0QyxDQTAwQzdDOzs7QUFDQSxhQUFTc0wsT0FBVCxHQUFtQjtBQUNmLFdBQUssSUFBSTVQLEdBQVQsSUFBZ0JFLE9BQU8sQ0FBQ3ZGLFVBQXhCLEVBQW9DO0FBQ2hDLFlBQUksQ0FBQ3VGLE9BQU8sQ0FBQ3ZGLFVBQVIsQ0FBbUI3QixjQUFuQixDQUFrQ2tILEdBQWxDLENBQUwsRUFBNkM7QUFDekM7QUFDSDs7QUFDRDVNLG1CQUFXLENBQUNvTyxZQUFELEVBQWV0QixPQUFPLENBQUN2RixVQUFSLENBQW1CcUYsR0FBbkIsQ0FBZixDQUFYO0FBQ0g7O0FBRUQsYUFBT3dCLFlBQVksQ0FBQ3NDLFVBQXBCLEVBQWdDO0FBQzVCdEMsb0JBQVksQ0FBQzlRLFdBQWIsQ0FBeUI4USxZQUFZLENBQUNzQyxVQUF0QztBQUNIOztBQUVELGFBQU90QyxZQUFZLENBQUNxTyxVQUFwQjtBQUNIOztBQUVELGFBQVM1QyxxQkFBVCxDQUErQi9KLFlBQS9CLEVBQTZDO0FBQ3pDLFVBQUk0RyxRQUFRLEdBQUc5SCxlQUFlLENBQUNrQixZQUFELENBQTlCO0FBQ0EsVUFBSTRNLFdBQVcsR0FBR2hPLGNBQWMsQ0FBQzlILGNBQWYsQ0FBOEI4UCxRQUE5QixDQUFsQjtBQUNBLFVBQUlsWixLQUFLLEdBQUdtUixZQUFZLENBQUNtQixZQUFELENBQXhCO0FBQ0EsVUFBSXVDLFNBQVMsR0FBR3FLLFdBQVcsQ0FBQzNWLFFBQVosQ0FBcUJ6QixJQUFyQztBQUNBLFVBQUlxWCxTQUFTLEdBQUcsSUFBaEIsQ0FMeUMsQ0FPekM7O0FBQ0EsVUFBSTdQLE9BQU8sQ0FBQzNJLElBQVosRUFBa0I7QUFDZCxlQUFPLENBQ0gzRyxLQUFLLEdBQUdrZixXQUFXLENBQUM3VixVQUFaLENBQXVCQyxVQUEvQixJQUE2QyxJQUQxQyxFQUVINFYsV0FBVyxDQUFDMVYsU0FBWixDQUFzQkYsVUFBdEIsR0FBbUN0SixLQUFuQyxJQUE0QyxJQUZ6QyxDQUFQO0FBSUgsT0Fid0MsQ0FlekM7QUFDQTs7O0FBQ0EsVUFBSTZVLFNBQVMsS0FBSyxLQUFsQixFQUF5QjtBQUNyQixZQUFJN1UsS0FBSyxHQUFHNlUsU0FBUixHQUFvQnFLLFdBQVcsQ0FBQzFWLFNBQVosQ0FBc0JGLFVBQTlDLEVBQTBEO0FBQ3REdUwsbUJBQVMsR0FBR3FLLFdBQVcsQ0FBQzFWLFNBQVosQ0FBc0JGLFVBQXRCLEdBQW1DdEosS0FBL0M7QUFDSDtBQUNKLE9BckJ3QyxDQXVCekM7OztBQUNBLFVBQUlBLEtBQUssR0FBR2tmLFdBQVcsQ0FBQzNWLFFBQVosQ0FBcUJELFVBQWpDLEVBQTZDO0FBQ3pDNlYsaUJBQVMsR0FBR0QsV0FBVyxDQUFDM1YsUUFBWixDQUFxQnpCLElBQWpDO0FBQ0gsT0FGRCxNQUVPLElBQUlvWCxXQUFXLENBQUM3VixVQUFaLENBQXVCdkIsSUFBdkIsS0FBZ0MsS0FBcEMsRUFBMkM7QUFDOUNxWCxpQkFBUyxHQUFHLEtBQVo7QUFDSCxPQUZNLENBSVA7QUFKTyxXQUtGO0FBQ0RBLG1CQUFTLEdBQUduZixLQUFLLEdBQUdrZixXQUFXLENBQUM3VixVQUFaLENBQXVCM0IsV0FBM0M7QUFDSCxTQWpDd0MsQ0FtQ3pDOzs7QUFDQSxVQUFJd1IsUUFBUSxLQUFLLEdBQWpCLEVBQXNCO0FBQ2xCckUsaUJBQVMsR0FBRyxJQUFaO0FBQ0gsT0FGRCxNQUVPLElBQUlxRSxRQUFRLEtBQUssQ0FBakIsRUFBb0I7QUFDdkJpRyxpQkFBUyxHQUFHLElBQVo7QUFDSCxPQXhDd0MsQ0EwQ3pDOzs7QUFDQSxVQUFJelYsWUFBWSxHQUFHd0gsY0FBYyxDQUFDekgsaUJBQWYsRUFBbkIsQ0EzQ3lDLENBNkN6Qzs7QUFDQSxVQUFJb0wsU0FBUyxLQUFLLElBQWQsSUFBc0JBLFNBQVMsS0FBSyxLQUF4QyxFQUErQztBQUMzQ0EsaUJBQVMsR0FBR2pOLE1BQU0sQ0FBQ2lOLFNBQVMsQ0FBQ2hOLE9BQVYsQ0FBa0I2QixZQUFsQixDQUFELENBQWxCO0FBQ0g7O0FBRUQsVUFBSXlWLFNBQVMsS0FBSyxJQUFkLElBQXNCQSxTQUFTLEtBQUssS0FBeEMsRUFBK0M7QUFDM0NBLGlCQUFTLEdBQUd2WCxNQUFNLENBQUN1WCxTQUFTLENBQUN0WCxPQUFWLENBQWtCNkIsWUFBbEIsQ0FBRCxDQUFsQjtBQUNIOztBQUVELGFBQU8sQ0FBQ3lWLFNBQUQsRUFBWXRLLFNBQVosQ0FBUDtBQUNILEtBajVDNEMsQ0FtNUM3Qzs7O0FBQ0EsYUFBU3VLLFlBQVQsR0FBd0I7QUFDcEIsYUFBTy9OLG1CQUFtQixDQUFDMUgsR0FBcEIsQ0FBd0IwUyxxQkFBeEIsQ0FBUDtBQUNILEtBdDVDNEMsQ0F3NUM3Qzs7O0FBQ0EsYUFBU2dELGFBQVQsQ0FBdUJDLGVBQXZCLEVBQXdDWCxZQUF4QyxFQUFzRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFJbkIsQ0FBQyxHQUFHdUIsUUFBUSxFQUFoQjtBQUVBLFVBQUlRLFVBQVUsR0FBRyxDQUNiLFFBRGEsRUFFYixPQUZhLEVBR2IsU0FIYSxFQUliLE9BSmEsRUFLYixTQUxhLEVBTWIsTUFOYSxFQU9iLE1BUGEsRUFRYixRQVJhLEVBU2IsTUFUYSxFQVViLFVBVmEsQ0FBakIsQ0FOa0QsQ0FtQmxEOztBQUNBQSxnQkFBVSxDQUFDL1EsT0FBWCxDQUFtQixVQUFTcUIsSUFBVCxFQUFlO0FBQzlCO0FBQ0EsWUFBSXlQLGVBQWUsQ0FBQ3pQLElBQUQsQ0FBZixLQUEwQjVQLFNBQTlCLEVBQXlDO0FBQ3JDd1EseUJBQWUsQ0FBQ1osSUFBRCxDQUFmLEdBQXdCeVAsZUFBZSxDQUFDelAsSUFBRCxDQUF2QztBQUNIO0FBQ0osT0FMRDtBQU9BLFVBQUkyUCxVQUFVLEdBQUduUSxXQUFXLENBQUNvQixlQUFELENBQTVCLENBM0JrRCxDQTZCbEQ7O0FBQ0E4TyxnQkFBVSxDQUFDL1EsT0FBWCxDQUFtQixVQUFTcUIsSUFBVCxFQUFlO0FBQzlCLFlBQUl5UCxlQUFlLENBQUN6UCxJQUFELENBQWYsS0FBMEI1UCxTQUE5QixFQUF5QztBQUNyQ3FQLGlCQUFPLENBQUNPLElBQUQsQ0FBUCxHQUFnQjJQLFVBQVUsQ0FBQzNQLElBQUQsQ0FBMUI7QUFDSDtBQUNKLE9BSkQ7QUFNQXFCLG9CQUFjLEdBQUdzTyxVQUFVLENBQUM3UyxRQUE1QixDQXBDa0QsQ0FzQ2xEOztBQUNBMkMsYUFBTyxDQUFDL0IsTUFBUixHQUFpQmlTLFVBQVUsQ0FBQ2pTLE1BQTVCO0FBQ0ErQixhQUFPLENBQUM3TSxLQUFSLEdBQWdCK2MsVUFBVSxDQUFDL2MsS0FBM0I7QUFDQTZNLGFBQU8sQ0FBQzVCLE9BQVIsR0FBa0I4UixVQUFVLENBQUM5UixPQUE3QixDQXpDa0QsQ0EyQ2xEOztBQUNBLFVBQUk0QixPQUFPLENBQUNqRSxJQUFaLEVBQWtCO0FBQ2RBLFlBQUksQ0FBQ2lFLE9BQU8sQ0FBQ2pFLElBQVQsQ0FBSjtBQUNILE9BRkQsTUFFTztBQUNId0wsa0JBQVU7QUFDYixPQWhEaUQsQ0FrRGxEOzs7QUFDQSxVQUFJdkgsT0FBTyxDQUFDZixRQUFaLEVBQXNCO0FBQ2xCQSxnQkFBUTtBQUNYLE9BRkQsTUFFTztBQUNIZ0Ysc0JBQWM7QUFDakIsT0F2RGlELENBeURsRDs7O0FBQ0FuQyxxQkFBZSxHQUFHLEVBQWxCO0FBQ0FxTixjQUFRLENBQUNhLGVBQWUsQ0FBQzlhLEtBQWhCLElBQXlCZ1osQ0FBMUIsRUFBNkJtQixZQUE3QixDQUFSO0FBQ0gsS0FyOUM0QyxDQXU5QzdDOzs7QUFDQSxhQUFTYyxXQUFULEdBQXVCO0FBQ25CO0FBQ0E7QUFDQTVPLGdCQUFVLEdBQUdpQyxTQUFTLENBQUNsQyxZQUFELENBQXRCO0FBRUErQixpQkFBVyxDQUFDckQsT0FBTyxDQUFDNUUsT0FBVCxFQUFrQm1HLFVBQWxCLENBQVgsQ0FMbUIsQ0FPbkI7O0FBQ0F5TCxzQkFBZ0IsQ0FBQ2hOLE9BQU8sQ0FBQ2pCLE1BQVQsQ0FBaEIsQ0FSbUIsQ0FVbkI7O0FBQ0FvUSxjQUFRLENBQUNuUCxPQUFPLENBQUM5SyxLQUFULENBQVI7O0FBRUEsVUFBSThLLE9BQU8sQ0FBQ2pFLElBQVosRUFBa0I7QUFDZEEsWUFBSSxDQUFDaUUsT0FBTyxDQUFDakUsSUFBVCxDQUFKO0FBQ0g7O0FBRUQsVUFBSWlFLE9BQU8sQ0FBQ2YsUUFBWixFQUFzQjtBQUNsQkEsZ0JBQVE7QUFDWDs7QUFFRHVGLFVBQUk7QUFDUDs7QUFFRDJMLGVBQVcsR0FoL0NrQyxDQWsvQzdDOztBQUNBak8sY0FBVSxHQUFHO0FBQ1R3TixhQUFPLEVBQUVBLE9BREE7QUFFVG5KLFdBQUssRUFBRXVKLFlBRkU7QUFHVE0sUUFBRSxFQUFFak0sU0FISztBQUlUa00sU0FBRyxFQUFFbk0sV0FKSTtBQUtUdk8sU0FBRyxFQUFFOFosUUFMSTtBQU1UYSxTQUFHLEVBQUVuQixRQU5JO0FBT1RsRCxlQUFTLEVBQUV1RCxjQVBGO0FBUVRlLFdBQUssRUFBRWhCLFVBUkU7QUFTVDtBQUNBaUIsbUJBQWEsRUFBRSxVQUFTdmYsQ0FBVCxFQUFZcUcsQ0FBWixFQUFlNlQsQ0FBZixFQUFrQjtBQUM3QkosbUJBQVcsQ0FBQzlaLENBQUQsRUFBSXFHLENBQUosRUFBT3dLLGVBQVAsRUFBd0JxSixDQUF4QixDQUFYO0FBQ0gsT0FaUTtBQWFUbkwsYUFBTyxFQUFFbUIsZUFiQTtBQWFpQjtBQUMxQjRPLG1CQUFhLEVBQUVBLGFBZE47QUFlVHJWLFlBQU0sRUFBRTRHLFlBZkM7QUFlYTtBQUN0QmlHLGdCQUFVLEVBQUVBLFVBaEJIO0FBaUJUdEQsb0JBQWMsRUFBRUEsY0FqQlA7QUFrQlR3TSxpQkFBVyxFQUFFLFlBQVc7QUFDcEIsZUFBTzlPLGNBQVA7QUFDSCxPQXBCUTtBQXFCVCtPLGdCQUFVLEVBQUUsWUFBVztBQUNuQixlQUFPbFAsYUFBUDtBQUNILE9BdkJRO0FBd0JUekYsVUFBSSxFQUFFQSxJQXhCRyxDQXdCRTs7QUF4QkYsS0FBYjtBQTJCQSxXQUFPbUcsVUFBUDtBQUNILEdBL2pGUyxDQWlrRlY7OztBQUNBLFdBQVN5TyxVQUFULENBQW9CalcsTUFBcEIsRUFBNEJ5RyxlQUE1QixFQUE2QztBQUN6QyxRQUFJLENBQUN6RyxNQUFELElBQVcsQ0FBQ0EsTUFBTSxDQUFDNlAsUUFBdkIsRUFBaUM7QUFDN0IsWUFBTSxJQUFJNVMsS0FBSixDQUFVLGlCQUFpQjNILE9BQWpCLEdBQTJCLDRDQUEzQixHQUEwRTBLLE1BQXBGLENBQU47QUFDSCxLQUh3QyxDQUt6Qzs7O0FBQ0EsUUFBSUEsTUFBTSxDQUFDaVYsVUFBWCxFQUF1QjtBQUNuQixZQUFNLElBQUloWSxLQUFKLENBQVUsaUJBQWlCM0gsT0FBakIsR0FBMkIsb0NBQXJDLENBQU47QUFDSCxLQVJ3QyxDQVV6Qzs7O0FBQ0EsUUFBSWdRLE9BQU8sR0FBR0QsV0FBVyxDQUFDb0IsZUFBRCxFQUFrQnpHLE1BQWxCLENBQXpCO0FBQ0EsUUFBSWtXLEdBQUcsR0FBRzFQLEtBQUssQ0FBQ3hHLE1BQUQsRUFBU3NGLE9BQVQsRUFBa0JtQixlQUFsQixDQUFmO0FBRUF6RyxVQUFNLENBQUNpVixVQUFQLEdBQW9CaUIsR0FBcEI7QUFFQSxXQUFPQSxHQUFQO0FBQ0gsR0FubEZTLENBcWxGVjs7O0FBQ0EsU0FBTztBQUNIO0FBQ0FDLGNBQVUsRUFBRXBZLFFBRlQ7QUFHSHFZLFdBQU8sRUFBRTlnQixPQUhOO0FBSUg7QUFDQTtBQUNBeUssY0FBVSxFQUFFQSxVQU5UO0FBT0hzVyxVQUFNLEVBQUVKO0FBUEwsR0FBUDtBQVNILENBMW1GRCIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vdWlzbGlkZXIgLSAxNC42LjAgLSA2LzI3LzIwMjAgKi9cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHdpbmRvdy5ub1VpU2xpZGVyID0gZmFjdG9yeSgpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFZFUlNJT04gPSBcIjE0LjYuMFwiO1xuXG4gICAgLy9yZWdpb24gSGVscGVyIE1ldGhvZHNcblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQmluZGFibGUgdmVyc2lvblxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LlxuICAgIGZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1thXSA/ICh0aGlzW2FdID0gdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIC8vIFJvdW5kIGEgdmFsdWUgdG8gdGhlIGNsb3Nlc3QgJ3RvJy5cbiAgICBmdW5jdGlvbiBjbG9zZXN0KHZhbHVlLCB0bykge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHRvKSAqIHRvO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0sIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcblxuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY29udGFpbnMgbGVmdCBzY3JvbGwgaW4gQ2hyb21lIG9uIEFuZHJvaWQuXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcbiAgICAgICAgLy8gc2NlbmFyaW8gb24gbWlzLW1hdGNoOiB0aGUgJ3RhcCcgZmVhdHVyZSBvbiBob3Jpem9udGFsIHNsaWRlcnMgYnJlYWtzLlxuICAgICAgICBpZiAoL3dlYmtpdC4qQ2hyb21lLipNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uXG4gICAgICAgICAgICA/IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3BcbiAgICAgICAgICAgIDogcmVjdC5sZWZ0ICsgcGFnZU9mZnNldC54IC0gZG9jRWxlbS5jbGllbnRMZWZ0O1xuICAgIH1cblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYSkgJiYgaXNGaW5pdGUoYSk7XG4gICAgfVxuXG4gICAgLy8gU2V0cyBhIGNsYXNzIGFuZCByZW1vdmVzIGl0IGFmdGVyIFtkdXJhdGlvbl0gbXMuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3NGb3IoZWxlbWVudCwgY2xhc3NOYW1lLCBkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGltaXRzIGEgdmFsdWUgdG8gMCAtIDEwMFxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGEsIDEwMCksIDApO1xuICAgIH1cblxuICAgIC8vIFdyYXBzIGEgdmFyaWFibGUgYXMgYW4gYXJyYXksIGlmIGl0IGlzbid0IG9uZSB5ZXQuXG4gICAgLy8gTm90ZSB0aGF0IGFuIGlucHV0IGFycmF5IGlzIHJldHVybmVkIGJ5IHJlZmVyZW5jZSFcbiAgICBmdW5jdGlvbiBhc0FycmF5KGEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIH1cblxuICAgIC8vIENvdW50cyBkZWNpbWFsc1xuICAgIGZ1bmN0aW9uIGNvdW50RGVjaW1hbHMobnVtU3RyKSB7XG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xuICAgICAgICB2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcy5sZW5ndGggPiAxID8gcGllY2VzWzFdLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI2FkZF9jbGFzc1xuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwOi8veW91bWlnaHRub3RuZWVkanF1ZXJ5LmNvbS8jcmVtb3ZlX2NsYXNzXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmICEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxuICAgICAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0XG4gICAgICAgICAgICA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgICAgICA6IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xhc3NOYW1lICsgXCJcXFxcYlwiKS50ZXN0KGVsLmNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zY3JvbGxZI05vdGVzXG4gICAgZnVuY3Rpb24gZ2V0UGFnZU9mZnNldChkb2MpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc0NTUzFDb21wYXQgPSAoZG9jLmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiO1xuICAgICAgICB2YXIgeCA9IHN1cHBvcnRQYWdlT2Zmc2V0XG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxuICAgICAgICAgICAgOiBpc0NTUzFDb21wYXRcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBzdXBwb3J0UGFnZU9mZnNldFxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBjb21wdXRlIGNvbnN0YW50cyBpbnN0ZWFkXG4gICAgLy8gb2YgYWNjZXNzaW5nIHdpbmRvdy4qIGFzIHNvb24gYXMgdGhlIG1vZHVsZSBuZWVkcyBpdFxuICAgIC8vIHNvIHRoYXQgd2UgZG8gbm90IGNvbXB1dGUgYW55dGhpbmcgaWYgbm90IG5lZWRlZFxuICAgIGZ1bmN0aW9uIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIC8vIERldGVybWluZSB0aGUgZXZlbnRzIHRvIGJpbmQuIElFMTEgaW1wbGVtZW50cyBwb2ludGVyRXZlbnRzIHdpdGhvdXRcbiAgICAgICAgLy8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgICAgICAgICAgICBtb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gICAgICAgICAgICAgICAgICBlbmQ6IFwicG9pbnRlcnVwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogXCJtb3VzZXVwIHRvdWNoZW5kXCJcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAvLyBJc3N1ZSAjNzg1XG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNQYXNzaXZlKCkge1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgIH1cblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICAvL3JlZ2lvbiBSYW5nZSBDYWxjdWxhdGlvblxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cbiAgICBmdW5jdGlvbiBzdWJSYW5nZVJhdGlvKHBhLCBwYikge1xuICAgICAgICByZXR1cm4gMTAwIC8gKHBiIC0gcGEpO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBIb3cgbWFueSBwZXJjZW50IGlzIHRoaXMgdmFsdWUgb2YgdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBmcm9tUGVyY2VudGFnZShyYW5nZSwgdmFsdWUsIHN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAqIDEwMCkgLyAocmFuZ2Vbc3RhcnRSYW5nZSArIDFdIC0gcmFuZ2Vbc3RhcnRSYW5nZV0pO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBXaGVyZSBpcyB0aGlzIHZhbHVlIG9uIHRoaXMgcmFuZ2U/XG4gICAgZnVuY3Rpb24gdG9QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHJhbmdlWzBdIDwgMCA/IHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDogdmFsdWUgLSByYW5nZVswXSwgMCk7XG4gICAgfVxuXG4gICAgLy8gKHZhbHVlKSBIb3cgbXVjaCBpcyB0aGlzIHBlcmNlbnRhZ2Ugb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBpc1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Sih2YWx1ZSwgYXJyKSB7XG4gICAgICAgIHZhciBqID0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gYXJyW2pdKSB7XG4gICAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICAvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cbiAgICBmdW5jdGlvbiB0b1N0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFZhbCk7XG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xuICAgICAgICB2YXIgcGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcblxuICAgICAgICByZXR1cm4gcGEgKyB0b1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sIHZhbHVlKSAvIHN1YlJhbmdlUmF0aW8ocGEsIHBiKTtcbiAgICB9XG5cbiAgICAvLyAodmFsdWUpIElucHV0IGEgcGVyY2VudGFnZSwgZmluZCB3aGVyZSBpdCBpcyBvbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgIGZ1bmN0aW9uIGZyb21TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXG4gICAgICAgIGlmICh2YWx1ZSA+PSAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiB4VmFsLnNsaWNlKC0xKVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xuICAgICAgICB2YXIgcGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcblxuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvKHBhLCBwYikpO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cbiAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XG4gICAgICAgIHZhciBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBiID0geFBjdFtqXTtcblxuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgheFN0ZXBzW2ogLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhQY3RbaiAtIDFdICsgY2xvc2VzdCh2YWx1ZSAtIHhQY3RbaiAtIDFdLCB4U3RlcHNbaiAtIDFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbnRyeVBvaW50KGluZGV4LCB2YWx1ZSwgdGhhdCkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZTtcblxuICAgICAgICAvLyBXcmFwIG51bWVyaWNhbCBpbnB1dCBpbiBhbiBhcnJheS5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVqZWN0IGFueSBpbnZhbGlkIGlucHV0LCBieSB0ZXN0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBjb250YWlucyBpbnZhbGlkIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXG4gICAgICAgIGlmIChpbmRleCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKCFpc051bWVyaWMocGVyY2VudGFnZSkgfHwgIWlzTnVtZXJpYyh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyB2YWx1ZSBpc24ndCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHZhbHVlcy5cbiAgICAgICAgdGhhdC54UGN0LnB1c2gocGVyY2VudGFnZSk7XG4gICAgICAgIHRoYXQueFZhbC5wdXNoKHZhbHVlWzBdKTtcblxuICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXG4gICAgICAgIC8vIGxvZ2dpbmcgY2xlYXIsIHNldCBzdGVwIGV4cGxpY2l0bHkuIE1ha2Ugc3VyZVxuICAgICAgICAvLyBub3QgdG8gb3ZlcnJpZGUgdGhlICdzdGVwJyBzZXR0aW5nIHdpdGggZmFsc2UuXG4gICAgICAgIGlmICghcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnhTdGVwc1swXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC54U3RlcHMucHVzaChpc05hTih2YWx1ZVsxXSkgPyBmYWxzZSA6IHZhbHVlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXAucHVzaCgwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdGVwUG9pbnQoaSwgbiwgdGhhdCkge1xuICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcbiAgICAgICAgaWYgKHRoYXQueFZhbFtpXSA9PT0gdGhhdC54VmFsW2kgKyAxXSkge1xuICAgICAgICAgICAgdGhhdC54U3RlcHNbaV0gPSB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gdGhhdC54VmFsW2ldO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cbiAgICAgICAgdGhhdC54U3RlcHNbaV0gPVxuICAgICAgICAgICAgZnJvbVBlcmNlbnRhZ2UoW3RoYXQueFZhbFtpXSwgdGhhdC54VmFsW2kgKyAxXV0sIG4sIDApIC8gc3ViUmFuZ2VSYXRpbyh0aGF0LnhQY3RbaV0sIHRoYXQueFBjdFtpICsgMV0pO1xuXG4gICAgICAgIHZhciB0b3RhbFN0ZXBzID0gKHRoYXQueFZhbFtpICsgMV0gLSB0aGF0LnhWYWxbaV0pIC8gdGhhdC54TnVtU3RlcHNbaV07XG4gICAgICAgIHZhciBoaWdoZXN0U3RlcCA9IE1hdGguY2VpbChOdW1iZXIodG90YWxTdGVwcy50b0ZpeGVkKDMpKSAtIDEpO1xuICAgICAgICB2YXIgc3RlcCA9IHRoYXQueFZhbFtpXSArIHRoYXQueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XG5cbiAgICAgICAgdGhhdC54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHN0ZXA7XG4gICAgfVxuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIC8vcmVnaW9uIFNwZWN0cnVtXG5cbiAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xuICAgICAgICB0aGlzLnhQY3QgPSBbXTtcbiAgICAgICAgdGhpcy54VmFsID0gW107XG4gICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xuICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IFtmYWxzZV07XG4gICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcblxuICAgICAgICB0aGlzLnNuYXAgPSBzbmFwO1xuXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTsgLy8gWzAsICdtaW4nXSwgWzEsICc1MCUnXSwgWzIsICdtYXgnXVxuXG4gICAgICAgIC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXG4gICAgICAgIGZvciAoaW5kZXggaW4gZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXG4gICAgICAgIGlmIChvcmRlcmVkLmxlbmd0aCAmJiB0eXBlb2Ygb3JkZXJlZFswXVswXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBlbnRyaWVzIHRvIHN1YnJhbmdlcy5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhY3R1YWwgc3RlcCB2YWx1ZXMuXG4gICAgICAgIC8vIHhTdGVwcyBpcyBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgeFBjdCBhbmQgeFZhbC5cbiAgICAgICAgdGhpcy54TnVtU3RlcHMgPSB0aGlzLnhTdGVwcy5zbGljZSgwKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBoYW5kbGVTdGVwUG9pbnQoaW5kZXgsIHRoaXMueE51bVN0ZXBzW2luZGV4XSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMueE51bVN0ZXBzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgJiYgKHZhbHVlIC8gc3RlcCkgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnLCAnbWFyZ2luJyBhbmQgJ3BhZGRpbmcnIG9mIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueFBjdFtpbmRleF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIlIHJhbmdlIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHN0ZXAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudHVhbCBkaXN0YW5jZSBpbiBjdXJyZW50IHJhbmdlIG9mIGxpbWl0LCBtYXJnaW4gb3IgcGFkZGluZ1xuICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvdmVyIHRoZSB3aG9sZSBzY2FsZSBvZiByYW5nZXMuXG4gICAgLy8gZGlyZWN0aW9uOiAwID0gYmFja3dhcmRzIC8gMSA9IGZvcndhcmRzXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldEFic29sdXRlRGlzdGFuY2UgPSBmdW5jdGlvbih2YWx1ZSwgZGlzdGFuY2VzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHhQY3RfaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSByYW5nZSB3aGVyZSB0byBzdGFydCBjYWxjdWxhdGlvblxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgPiB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgICAgeFBjdF9pbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4ID0gdGhpcy54UGN0Lmxlbmd0aCAtIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsb29raW5nIGJhY2t3YXJkcyBhbmQgdGhlIHZhbHVlIGlzIGV4YWN0bHkgYXQgYSByYW5nZSBzZXBhcmF0b3IgdGhlbiBsb29rIG9uZSByYW5nZSBmdXJ0aGVyXG4gICAgICAgIGlmICghZGlyZWN0aW9uICYmIHZhbHVlID09PSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRfZmFjdG9yO1xuICAgICAgICB2YXIgcmVzdF9mYWN0b3IgPSAxO1xuXG4gICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcblxuICAgICAgICB2YXIgcmFuZ2VfcGN0ID0gMDtcblxuICAgICAgICB2YXIgcmVsX3JhbmdlX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIGFic19kaXN0YW5jZV9jb3VudGVyID0gMDtcbiAgICAgICAgdmFyIHJhbmdlX2NvdW50ZXIgPSAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGF0IHBhcnQgb2YgdGhlIHN0YXJ0IHJhbmdlIHRoZSB2YWx1ZSBpc1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodmFsdWUgLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB2YWx1ZSkgLyAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyB1bnRpbCB0aGUgY29tcGxldGUgZGlzdGFuY2UgYWNyb3NzIHJhbmdlcyBpcyBjYWxjdWxhdGVkXG4gICAgICAgIHdoaWxlIChyZXN0X3JlbF9kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiB0b3RhbCByYW5nZVxuICAgICAgICAgICAgcmFuZ2VfcGN0ID0gdGhpcy54UGN0W3hQY3RfaW5kZXggKyAxICsgcmFuZ2VfY291bnRlcl0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdO1xuXG4gICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIG1hcmdpbiwgcGFkZGluZyBvciBsaW1pdCBpcyBsYXJnZXIgdGhlbiB0aGUgY3VycmVudCByYW5nZSBhbmQgY2FsY3VsYXRlXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yICsgMTAwIC0gc3RhcnRfZmFjdG9yICogMTAwID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFyZ2VyIHRoZW4gdGFrZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvZiB0aGUgd2hvbGUgcmFuZ2VcbiAgICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgLy8gUmVzdCBmYWN0b3Igb2YgcmVsYXRpdmUgcGVyY2VudHVhbCBkaXN0YW5jZSBzdGlsbCB0byBiZSBjYWxjdWxhdGVkXG4gICAgICAgICAgICAgICAgcmVzdF9mYWN0b3IgPSAocmVzdF9yZWxfZGlzdGFuY2UgLSAxMDAgKiBzdGFydF9mYWN0b3IpIC8gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3RhcnQgZmFjdG9yIHRvIDEgYXMgZm9yIG5leHQgcmFuZ2UgaXQgZG9lcyBub3QgYXBwbHkuXG4gICAgICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc21hbGxlciBvciBlcXVhbCB0aGVuIHRha2UgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb2YgdGhlIGNhbGN1bGF0ZSBwZXJjZW50dWFsIHBhcnQgb2YgdGhhdCByYW5nZVxuICAgICAgICAgICAgICAgIHJlbF9yYW5nZV9kaXN0YW5jZSA9ICgoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJhbmdlX3BjdCkgLyAxMDApICogcmVzdF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdCBsZWZ0IGFzIHRoZSByZXN0IGZpdHMgaW4gY3VycmVudCByYW5nZVxuICAgICAgICAgICAgICAgIHJlc3RfZmFjdG9yID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgLSByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gZmlyc3QgcmFuZ2Ugd2hlbiBkaXN0YW5jZSBiZWNvbWVzIG91dHNpZGUgb2YgbWluaW11bSByYW5nZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoICsgcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgKyByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gbGFzdCByYW5nZSB3aGVuIGRpc3RhbmNlIGJlY29tZXMgb3V0c2lkZSBvZiBtYXhpbXVtIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueFBjdC5sZW5ndGggLSByYW5nZV9jb3VudGVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VfY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdCBvZiByZWxhdGl2ZSBwZXJjZW50dWFsIGRpc3RhbmNlIHN0aWxsIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIHJlc3RfcmVsX2Rpc3RhbmNlID0gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgYWJzX2Rpc3RhbmNlX2NvdW50ZXI7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZnJvbVN0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdGVwcGluZyh0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0U3RlcCh0aGlzLnhQY3QsIHRoaXMueFN0ZXBzLCB0aGlzLnNuYXAsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuXG4gICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDAgfHwgKGlzRG93biAmJiB2YWx1ZSA9PT0gdGhpcy54UGN0W2ogLSAxXSkpIHtcbiAgICAgICAgICAgIGogPSBNYXRoLm1heChqIC0gMSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMueFZhbFtqXSAtIHRoaXMueFZhbFtqIC0gMV0pIC8gc2l6ZTtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2ogLSAyXSxcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMl0sXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1N0ZXA6IHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDFdLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAxXSxcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGVwQWZ0ZXI6IHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbal0sXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbal0sXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbal1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmNvdW50U3RlcERlY2ltYWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGVwRGVjaW1hbHMgPSB0aGlzLnhOdW1TdGVwcy5tYXAoY291bnREZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBzdGVwRGVjaW1hbHMpO1xuICAgIH07XG5cbiAgICAvLyBPdXRzaWRlIHRlc3RpbmdcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICAvL3JlZ2lvbiBPcHRpb25zXG5cbiAgICAvKlx0RXZlcnkgaW5wdXQgb3B0aW9uIGlzIHRlc3RlZCBhbmQgcGFyc2VkLiBUaGlzJ2xsIHByZXZlbnRcbiAgICAgICAgZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxuICAgICAgICBzdHJ1Y3R1cmVkIHdpdGggYW4gaXRlbSBmb3IgZXZlcnkgb3B0aW9uIGF2YWlsYWJsZS4gQW5cbiAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAgICAgICAgLSBUaGUgcHJvdmlkZWQgdmFsdWUgZm9yIHRoZSBvcHRpb247XG4gICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcbiAgICAgICAgICAgIC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XG5cbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxuICAgICAgICBvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cbiAgICAgICAgb2JqZWN0LCB0byBtYWtlIHN1cmUgYWxsIHZhbHVlcyBjYW4gYmUgY29ycmVjdGx5IGxvb3BlZCBlbHNld2hlcmUuICovXG5cbiAgICAvL3JlZ2lvbiBEZWZhdWx0c1xuXG4gICAgdmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSB7XG4gICAgICAgIHRvOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9GaXhlZCgyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbTogTnVtYmVyXG4gICAgfTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0ge1xuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIGJhc2U6IFwiYmFzZVwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcbiAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXG4gICAgICAgIGhhbmRsZVVwcGVyOiBcImhhbmRsZS11cHBlclwiLFxuICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxuICAgICAgICBob3Jpem9udGFsOiBcImhvcml6b250YWxcIixcbiAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbm5lY3Q6IFwiY29ubmVjdFwiLFxuICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxuICAgICAgICBsdHI6IFwibHRyXCIsXG4gICAgICAgIHJ0bDogXCJydGxcIixcbiAgICAgICAgdGV4dERpcmVjdGlvbkx0cjogXCJ0eHQtZGlyLWx0clwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uUnRsOiBcInR4dC1kaXItcnRsXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXG4gICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcbiAgICAgICAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcbiAgICAgICAgcGlwczogXCJwaXBzXCIsXG4gICAgICAgIHBpcHNIb3Jpem9udGFsOiBcInBpcHMtaG9yaXpvbnRhbFwiLFxuICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXG4gICAgICAgIG1hcmtlckhvcml6b250YWw6IFwibWFya2VyLWhvcml6b250YWxcIixcbiAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXG4gICAgICAgIG1hcmtlckxhcmdlOiBcIm1hcmtlci1sYXJnZVwiLFxuICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6IFwidmFsdWUtaG9yaXpvbnRhbFwiLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXG4gICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxuICAgICAgICB2YWx1ZUxhcmdlOiBcInZhbHVlLWxhcmdlXCIsXG4gICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiXG4gICAgfTtcblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChlbnRyeSkge1xuICAgICAgICAvLyBBbnkgb2JqZWN0IHdpdGggYSB0byBhbmQgZnJvbSBtZXRob2QgaXMgc3VwcG9ydGVkLlxuICAgICAgICBpZiAoaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZm9ybWF0JyByZXF1aXJlcyAndG8nIGFuZCAnZnJvbScgbWV0aG9kcy5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3N0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcbiAgICAgICAgLy8gZm9yIGxpbmVhciBzbGlkZXJzLiBPdmVyd3JpdHRlbiBpZiBzZXQgaW4gJ3JhbmdlJy5cbiAgICAgICAgcGFyc2VkLnNpbmdsZVN0ZXAgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmRQYWdlTXVsdGlwbGllcihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkUGFnZU11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmREZWZhdWx0U3RlcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkRGVmYXVsdFN0ZXAgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0UmFuZ2UocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXRjaCBtaXNzaW5nIHN0YXJ0IG9yIGVuZC5cbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXRjaCBlcXVhbCBzdGFydCBvciBlbmQuXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IGVudHJ5Lm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLnNwZWN0cnVtID0gbmV3IFNwZWN0cnVtKGVudHJ5LCBwYXJzZWQuc25hcCwgcGFyc2VkLnNpbmdsZVN0ZXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTdGFydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXQuIFZhbHVlcyBhcmVuJ3QgdGVzdGVkLCBhcyB0aGUgcHVibGljIC52YWwgbWV0aG9kXG4gICAgICAgIC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgbnVtYmVyIG9mIGhhbmRsZXMuXG4gICAgICAgIHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXG4gICAgICAgIHBhcnNlZC5zdGFydCA9IGVudHJ5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTbmFwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QW5pbWF0ZShwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxuICAgICAgICBwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEFuaW1hdGlvbkR1cmF0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmFuaW1hdGlvbkR1cmF0aW9uID0gZW50cnk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RDb25uZWN0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBbZmFsc2VdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBNYXAgbGVnYWN5IG9wdGlvbnNcbiAgICAgICAgaWYgKGVudHJ5ID09PSBcImxvd2VyXCIpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gXCJ1cHBlclwiKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBlbnRyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29ubmVjdC5wdXNoKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoIHx8IGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMgKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjb25uZWN0JyBvcHRpb24gZG9lc24ndCBtYXRjaCBoYW5kbGUgY291bnQuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdCA9IGVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmNvbm5lY3QgPSBjb25uZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBvcmllbnRhdGlvbiB0byBhbiBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeVxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQub3J0ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RNYXJnaW4ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJc3N1ZSAjNTgyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdExpbWl0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQubGltaXQgPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuXG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgK1xuICAgICAgICAgICAgICAgICAgICBWRVJTSU9OICtcbiAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFBhZGRpbmcocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICB2YXIgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpICYmICFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSAmJiAhKGVudHJ5Lmxlbmd0aCA9PT0gMiB8fCBpc051bWVyaWMoZW50cnlbMF0pIHx8IGlzTnVtZXJpYyhlbnRyeVsxXSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2dldERpc3RhbmNlJyByZXR1cm5zIGZhbHNlIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgcGFyc2VkLnBhZGRpbmcgPSBbcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzBdKSwgcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzFdKV07XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFyc2VkLnNwZWN0cnVtLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhZGRpbmdbMF1baW5kZXhdIDwgMCB8fCBwYXJzZWQucGFkZGluZ1sxXVtpbmRleF0gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIocykuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsUGFkZGluZyA9IGVudHJ5WzBdICsgZW50cnlbMV07XG4gICAgICAgIHZhciBmaXJzdFZhbHVlID0gcGFyc2VkLnNwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFtwYXJzZWQuc3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodG90YWxQYWRkaW5nIC8gKGxhc3RWYWx1ZSAtIGZpcnN0VmFsdWUpID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3Qgbm90IGV4Y2VlZCAxMDAlIG9mIHRoZSByYW5nZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0RGlyZWN0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gU2V0IGRpcmVjdGlvbiBhcyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeSBwYXJzaW5nLlxuICAgICAgICAvLyBJbnZlcnQgY29ubmVjdGlvbiBmb3IgUlRMIHNsaWRlcnMsIHNvIHRoYXQgdGhlIHByb3BlclxuICAgICAgICAvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsdHJcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydGxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxuICAgICAgICAvLyBOb25lIGFyZSByZXF1aXJlZC5cbiAgICAgICAgdmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoXCJ0YXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWcgPSBlbnRyeS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAwO1xuICAgICAgICB2YXIgZml4ZWQgPSBlbnRyeS5pbmRleE9mKFwiZml4ZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKFwic25hcFwiKSA+PSAwO1xuICAgICAgICB2YXIgaG92ZXIgPSBlbnRyeS5pbmRleE9mKFwiaG92ZXJcIikgPj0gMDtcbiAgICAgICAgdmFyIHVuY29uc3RyYWluZWQgPSBlbnRyeS5pbmRleE9mKFwidW5jb25zdHJhaW5lZFwiKSA+PSAwO1xuXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5oYW5kbGVzICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZml4ZWQnIGJlaGF2aW91ciBtdXN0IGJlIHVzZWQgd2l0aCAyIGhhbmRsZXNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBtYXJnaW4gdG8gZW5mb3JjZSBmaXhlZCBzdGF0ZVxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5jb25zdHJhaW5lZCAmJiAocGFyc2VkLm1hcmdpbiB8fCBwYXJzZWQubGltaXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd1bmNvbnN0cmFpbmVkJyBiZWhhdmlvdXIgY2Fubm90IGJlIHVzZWQgd2l0aCBtYXJnaW4gb3IgbGltaXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5ldmVudHMgPSB7XG4gICAgICAgICAgICB0YXA6IHRhcCB8fCBzbmFwLFxuICAgICAgICAgICAgZHJhZzogZHJhZyxcbiAgICAgICAgICAgIGZpeGVkOiBmaXhlZCxcbiAgICAgICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgICAgICBob3ZlcjogaG92ZXIsXG4gICAgICAgICAgICB1bmNvbnN0cmFpbmVkOiB1bmNvbnN0cmFpbmVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFRvb2x0aXBzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBhc0FycmF5KGVudHJ5KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBtdXN0IHBhc3MgYSBmb3JtYXR0ZXIgZm9yIGFsbCBoYW5kbGVzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24oZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZm9ybWF0dGVyICE9PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGZvcm1hdHRlciAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZm9ybWF0dGVyLnRvICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RBcmlhRm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmFyaWFGb3JtYXQgPSBlbnRyeTtcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQoZW50cnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBwYXJzZWQuZm9ybWF0ID0gZW50cnk7XG4gICAgICAgIHZhbGlkYXRlRm9ybWF0KGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmRTdXBwb3J0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmtleWJvYXJkU3VwcG9ydCA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdrZXlib2FyZFN1cHBvcnQnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0RG9jdW1lbnRFbGVtZW50KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhZHZhbmNlZCBvcHRpb24uIFBhc3NlZCB2YWx1ZXMgYXJlIHVzZWQgd2l0aG91dCB2YWxpZGF0aW9uLlxuICAgICAgICBwYXJzZWQuZG9jdW1lbnRFbGVtZW50ID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdENzc1ByZWZpeChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIgJiYgZW50cnkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NQcmVmaXgnIG11c3QgYmUgYSBzdHJpbmcgb3IgYGZhbHNlYC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuY3NzUHJlZml4ID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdENzc0NsYXNzZXMocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5jc3NDbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIHRlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVG8gcHJvdmUgYSBmaXggZm9yICM1MzcsIGZyZWV6ZSBvcHRpb25zIGhlcmUuXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAgICAvLyBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBsaW1pdDogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHByZXNlbnRlZCBoZXJlLlxuICAgICAgICB2YXIgdGVzdHMgPSB7XG4gICAgICAgICAgICBzdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxuICAgICAgICAgICAga2V5Ym9hcmRQYWdlTXVsdGlwbGllcjogeyByOiBmYWxzZSwgdDogdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIgfSxcbiAgICAgICAgICAgIGtleWJvYXJkRGVmYXVsdFN0ZXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RLZXlib2FyZERlZmF1bHRTdGVwIH0sXG4gICAgICAgICAgICBzdGFydDogeyByOiB0cnVlLCB0OiB0ZXN0U3RhcnQgfSxcbiAgICAgICAgICAgIGNvbm5lY3Q6IHsgcjogdHJ1ZSwgdDogdGVzdENvbm5lY3QgfSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogeyByOiB0cnVlLCB0OiB0ZXN0RGlyZWN0aW9uIH0sXG4gICAgICAgICAgICBzbmFwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U25hcCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGUgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24gfSxcbiAgICAgICAgICAgIHJhbmdlOiB7IHI6IHRydWUsIHQ6IHRlc3RSYW5nZSB9LFxuICAgICAgICAgICAgb3JpZW50YXRpb246IHsgcjogZmFsc2UsIHQ6IHRlc3RPcmllbnRhdGlvbiB9LFxuICAgICAgICAgICAgbWFyZ2luOiB7IHI6IGZhbHNlLCB0OiB0ZXN0TWFyZ2luIH0sXG4gICAgICAgICAgICBsaW1pdDogeyByOiBmYWxzZSwgdDogdGVzdExpbWl0IH0sXG4gICAgICAgICAgICBwYWRkaW5nOiB7IHI6IGZhbHNlLCB0OiB0ZXN0UGFkZGluZyB9LFxuICAgICAgICAgICAgYmVoYXZpb3VyOiB7IHI6IHRydWUsIHQ6IHRlc3RCZWhhdmlvdXIgfSxcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RBcmlhRm9ybWF0IH0sXG4gICAgICAgICAgICBmb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RGb3JtYXQgfSxcbiAgICAgICAgICAgIHRvb2x0aXBzOiB7IHI6IGZhbHNlLCB0OiB0ZXN0VG9vbHRpcHMgfSxcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogeyByOiB0cnVlLCB0OiB0ZXN0S2V5Ym9hcmRTdXBwb3J0IH0sXG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQ6IHsgcjogZmFsc2UsIHQ6IHRlc3REb2N1bWVudEVsZW1lbnQgfSxcbiAgICAgICAgICAgIGNzc1ByZWZpeDogeyByOiB0cnVlLCB0OiB0ZXN0Q3NzUHJlZml4IH0sXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7IHI6IHRydWUsIHQ6IHRlc3RDc3NDbGFzc2VzIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGJlaGF2aW91cjogXCJ0YXBcIixcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgIGNzc1ByZWZpeDogXCJub1VpLVwiLFxuICAgICAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgICAgIGtleWJvYXJkUGFnZU11bHRpcGxpZXI6IDUsXG4gICAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiAxMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFyaWFGb3JtYXQgZGVmYXVsdHMgdG8gcmVndWxhciBmb3JtYXQsIGlmIGFueS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYXJpYUZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIGFsbCBvcHRpb25zIHRocm91Z2ggYSB0ZXN0aW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgY29ycmVjdFxuICAgICAgICAvLyBpbnB1dC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgb3B0aW9ucyBtaWdodCBnZXQgbW9kaWZpZWQgdG9cbiAgICAgICAgLy8gYmUgaGFuZGxlZCBwcm9wZXJseS4gRS5nLiB3cmFwcGluZyBpbnRlZ2VycyBpbiBhcnJheXMuXG4gICAgICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXNuJ3Qgc2V0LCBidXQgaXQgaXMgcmVxdWlyZWQsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFpc1NldChvcHRpb25zW25hbWVdKSAmJiBkZWZhdWx0c1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RzW25hbWVdLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVzdHNbbmFtZV0udChwYXJzZWQsICFpc1NldChvcHRpb25zW25hbWVdKSA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvcndhcmQgcGlwcyBvcHRpb25zXG4gICAgICAgIHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xuXG4gICAgICAgIC8vIEFsbCByZWNlbnQgYnJvd3NlcnMgYWNjZXB0IHVucHJlZml4ZWQgdHJhbnNmb3JtLlxuICAgICAgICAvLyBXZSBuZWVkIC1tcy0gZm9yIElFOSBhbmQgLXdlYmtpdC0gZm9yIG9sZGVyIEFuZHJvaWQ7XG4gICAgICAgIC8vIEFzc3VtZSB1c2Ugb2YgLXdlYmtpdC0gaWYgdW5wcmVmaXhlZCBhbmQgLW1zLSBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD10cmFuc2Zvcm1zMmRcbiAgICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbXNQcmVmaXggPSBkLnN0eWxlLm1zVHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBub1ByZWZpeCA9IGQuc3R5bGUudHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcGFyc2VkLnRyYW5zZm9ybVJ1bGUgPSBub1ByZWZpeCA/IFwidHJhbnNmb3JtXCIgOiBtc1ByZWZpeCA/IFwibXNUcmFuc2Zvcm1cIiA6IFwid2Via2l0VHJhbnNmb3JtXCI7XG5cbiAgICAgICAgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cbiAgICAgICAgdmFyIHN0eWxlcyA9IFtbXCJsZWZ0XCIsIFwidG9wXCJdLCBbXCJyaWdodFwiLCBcImJvdHRvbVwiXV07XG5cbiAgICAgICAgcGFyc2VkLnN0eWxlID0gc3R5bGVzW3BhcnNlZC5kaXJdW3BhcnNlZC5vcnRdO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIGZ1bmN0aW9uIHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgICAgICB2YXIgc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPSBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpO1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgJiYgZ2V0U3VwcG9ydHNQYXNzaXZlKCk7XG5cbiAgICAgICAgLy8gQWxsIHZhcmlhYmxlcyBsb2NhbCB0byAnc2NvcGUnIGFyZSBwcmVmaXhlZCB3aXRoICdzY29wZV8nXG5cbiAgICAgICAgLy8gU2xpZGVyIERPTSBOb2Rlc1xuICAgICAgICB2YXIgc2NvcGVfVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgc2NvcGVfQmFzZTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZXM7XG4gICAgICAgIHZhciBzY29wZV9Db25uZWN0cztcbiAgICAgICAgdmFyIHNjb3BlX1BpcHM7XG4gICAgICAgIHZhciBzY29wZV9Ub29sdGlwcztcblxuICAgICAgICAvLyBTbGlkZXIgc3RhdGUgdmFsdWVzXG4gICAgICAgIHZhciBzY29wZV9TcGVjdHJ1bSA9IG9wdGlvbnMuc3BlY3RydW07XG4gICAgICAgIHZhciBzY29wZV9WYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc2NvcGVfSGFuZGxlTnVtYmVycyA9IFtdO1xuICAgICAgICB2YXIgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHNjb3BlX0V2ZW50cyA9IHt9O1xuXG4gICAgICAgIC8vIEV4cG9zZWQgQVBJXG4gICAgICAgIHZhciBzY29wZV9TZWxmO1xuXG4gICAgICAgIC8vIERvY3VtZW50IE5vZGVzXG4gICAgICAgIHZhciBzY29wZV9Eb2N1bWVudCA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgc2NvcGVfQm9keSA9IHNjb3BlX0RvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgLy8gUGlwcyBjb25zdGFudHNcbiAgICAgICAgdmFyIFBJUFNfTk9ORSA9IC0xO1xuICAgICAgICB2YXIgUElQU19OT19WQUxVRSA9IDA7XG4gICAgICAgIHZhciBQSVBTX0xBUkdFX1ZBTFVFID0gMTtcbiAgICAgICAgdmFyIFBJUFNfU01BTExfVkFMVUUgPSAyO1xuXG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcbiAgICAgICAgLy8gbWFrZSAubm9VaS1vcmlnaW4gb3ZlcmZsb3cgdG8gdGhlIGxlZnQgc28gdGhlIGRvY3VtZW50IGRvZXNuJ3Qgc2Nyb2xsLlxuICAgICAgICB2YXIgc2NvcGVfRGlyT2Zmc2V0ID0gc2NvcGVfRG9jdW1lbnQuZGlyID09PSBcInJ0bFwiIHx8IG9wdGlvbnMub3J0ID09PSAxID8gMCA6IDEwMDtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgbm9kZSwgYWRkcyBpdCB0byB0YXJnZXQsIHJldHVybnMgdGhlIG5ldyBub2RlLlxuICAgICAgICBmdW5jdGlvbiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIG9yaWdpbiB0byB0aGUgYmFzZVxuICAgICAgICBmdW5jdGlvbiBhZGRPcmlnaW4oYmFzZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5vcmlnaW4pO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZE5vZGVUbyhvcmlnaW4sIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGUpO1xuXG4gICAgICAgICAgICBhZGROb2RlVG8oaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMudG91Y2hBcmVhKTtcblxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGFuZGxlXCIsIGhhbmRsZU51bWJlcik7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgICAgICAgICAgICAgICAvLyAwID0gZm9jdXNhYmxlIGFuZCByZWFjaGFibGVcbiAgICAgICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNsaWRlclwiKTtcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVOdW1iZXIgPT09IG9wdGlvbnMuaGFuZGxlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgbm9kZXMgZm9yIGNvbm5lY3QgZWxlbWVudHNcbiAgICAgICAgZnVuY3Rpb24gYWRkQ29ubmVjdChiYXNlLCBhZGQpIHtcbiAgICAgICAgICAgIGlmICghYWRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBoYW5kbGVzIHRvIHRoZSBzbGlkZXIgYmFzZS5cbiAgICAgICAgZnVuY3Rpb24gYWRkRWxlbWVudHMoY29ubmVjdE9wdGlvbnMsIGJhc2UpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0QmFzZSA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzID0gW107XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xuXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zWzBdKSk7XG5cbiAgICAgICAgICAgIC8vIFs6Ojo6Tz09PT1PPT09PU89PT09XVxuICAgICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnNbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGEgc2luZ2xlIHNsaWRlci5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGVyKGFkZFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyBhbmQgZGF0YSB0byB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMubHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMucnRsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3J0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHREaXJlY3Rpb24gPSBnZXRDb21wdXRlZFN0eWxlKGFkZFRhcmdldCkuZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAodGV4dERpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25SdGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50ZXh0RGlyZWN0aW9uTHRyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvb2x0aXAoaGFuZGxlLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGhhbmRsZS5maXJzdENoaWxkLCBvcHRpb25zLmNzc0NsYXNzZXMudG9vbHRpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1NsaWRlckRpc2FibGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNsaWRlciBkcmFnZ2luZyBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT3JpZ2luID0gc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9yaWdpbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXBzKCkge1xuICAgICAgICAgICAgaWYgKHNjb3BlX1Rvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQoXCJ1cGRhdGUudG9vbHRpcHNcIik7XG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbih0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcbiAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG5cbiAgICAgICAgICAgIC8vIFRvb2x0aXBzIGFyZSBhZGRlZCB3aXRoIG9wdGlvbnMudG9vbHRpcHMgaW4gb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgICAgICBzY29wZV9Ub29sdGlwcyA9IHNjb3BlX0hhbmRsZXMubWFwKGFkZFRvb2x0aXApO1xuXG4gICAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGUudG9vbHRpcHNcIiwgZnVuY3Rpb24odmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCkge1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVfVG9vbHRpcHNbaGFuZGxlTnVtYmVyXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdmFsdWVzW2hhbmRsZU51bWJlcl07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcmlhKCkge1xuICAgICAgICAgICAgYmluZEV2ZW50KFwidXBkYXRlXCIsIGZ1bmN0aW9uKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFyaWEgVmFsdWVzIGZvciBhbGwgaGFuZGxlcywgYXMgYSBjaGFuZ2UgaW4gb25lIGNoYW5nZXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmV4dC5cbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGluZGV4LCAxMDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gcG9zaXRpb25zW2luZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgdmFsdWUgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBvcHRpb25zLmFyaWFGb3JtYXQudG8odW5lbmNvZGVkW2luZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHRvIHNsaWRlciByYW5nZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgbWluID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1pbikudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1heCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICAgICAgbm93ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG5vdykudG9GaXhlZCgxKTtcblxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiLCBtYXgpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBub3cpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEdyb3VwKG1vZGUsIHZhbHVlcywgc3RlcHBlZCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSByYW5nZS5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInJhbmdlXCIgfHwgbW9kZSA9PT0gXCJzdGVwc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLnhWYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd2YWx1ZXMnICg+PSAyKSByZXF1aXJlZCBmb3IgbW9kZSAnY291bnQnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgMCAtIDEwMCBpbiAnY291bnQnIHBhcnRzLlxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHZhbHVlcyAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZCA9IDEwMCAvIGludGVydmFsO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBMaXN0IHRoZXNlIHBhcnRzIGFuZCBoYXZlIHRoZW0gaGFuZGxlZCBhcyAncG9zaXRpb25zJy5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJ2YWwtLSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goMTAwKTtcblxuICAgICAgICAgICAgICAgIG1vZGUgPSBcInBvc2l0aW9uc1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJwb3NpdGlvbnNcIikge1xuICAgICAgICAgICAgICAgIC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc3RlcHBlZCA/IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ2YWx1ZXNcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBtdXN0IGJlIHN0ZXBwZWQsIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHBlcmNlbnRhZ2UgZmlyc3QuXG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGVyY2VudGFnZSwgYXBwbHkgc3RlcCwgcmV0dXJuIHRvIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVTcHJlYWQoZGVuc2l0eSwgbW9kZSwgZ3JvdXApIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVJbmNyZW1lbnQodmFsdWUsIGluY3JlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGZsb2F0aW5nIHBvaW50IHZhcmlhbmNlIGJ5IGRyb3BwaW5nIHRoZSBzbWFsbGVzdCBkZWNpbWFsIHBsYWNlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICsgaW5jcmVtZW50KS50b0ZpeGVkKDcpIC8gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGlnbm9yZUZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHByZXZQY3QgPSAwO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBncm91cCA9IHVuaXF1ZShcbiAgICAgICAgICAgICAgICBncm91cC5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmFuZ2Ugc3RhcnRzIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoZ3JvdXBbMF0gIT09IGZpcnN0SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZ25vcmVGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICBpZiAoZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV0gIT09IGxhc3RJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XG4gICAgICAgICAgICAgICAgaWdub3JlTGFzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24oY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RlcCBhbmQgdGhlIGxvd2VyICsgdXBwZXIgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBxO1xuICAgICAgICAgICAgICAgIHZhciBsb3cgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHZhciBoaWdoID0gZ3JvdXBbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UGN0O1xuICAgICAgICAgICAgICAgIHZhciBwY3REaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIHZhciBwY3RQb3M7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzO1xuICAgICAgICAgICAgICAgIHZhciByZWFsU3RlcHM7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgIHZhciBpc1N0ZXBzID0gbW9kZSA9PT0gXCJzdGVwc1wiO1xuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBzdGVwIG9uIHRvIHRoZSBuZXh0IHN1YnJhbmdlLlxuICAgICAgICAgICAgICAgIGlmIChpc1N0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gYSAnZnVsbCcgc3RlcC5cbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IGhpZ2ggLSBsb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG93IGNhbiBiZSAwLCBzbyB0ZXN0IGZvciBmYWxzZS4gSWYgaGlnaCBpcyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIGF0IHRoZSBsYXN0IHN1YnJhbmdlLiBJbmRleCAwIGlzIGFscmVhZHkgaGFuZGxlZC5cbiAgICAgICAgICAgICAgICBpZiAobG93ID09PSBmYWxzZSB8fCBoaWdoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXG4gICAgICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIG5ld1BjdCA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcoaSk7XG4gICAgICAgICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xuXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gcGN0RGlmZmVyZW5jZSAvIGRlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxTdGVwcyA9IE1hdGgucm91bmQoc3RlcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmF0aW8gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHBlcmNlbnRhZ2Utc3BhY2UgYSBwb2ludCBpbmRpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGl2aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IHRvIGFuIGV2ZW4gbnVtYmVyLCB0aGVuIGRpdmlkZSBieSB0d29cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3ByZWFkIHRoZSBvZmZzZXQgb24gYm90aCBzaWRlcyBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gcGN0RGlmZmVyZW5jZSAvIHJlYWxTdGVwcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXZpZGUgYWxsIHBvaW50cyBldmVubHksIGFkZGluZyB0aGUgY29ycmVjdCBudW1iZXIgdG8gdGhpcyBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDw9IHNvIHRoYXQgMTAwJSBnZXRzIGEgcG9pbnQsIGV2ZW50IGlmIGlnbm9yZUxhc3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAxOyBxIDw9IHJlYWxTdGVwczsgcSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgcm91bmRlZCB2YWx1ZSBhbmQgdGhlIGFjdHVhbCBzaXplIG1pZ2h0IGJlIH4xJSBvZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsbCByYW5nZSwgMiBmb3IgNTAsIDQgZm9yIDI1LCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1twY3RQb3MudG9GaXhlZCg1KV0gPSBbc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHBjdFBvcyksIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb2ludCB0eXBlLlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gZ3JvdXAuaW5kZXhPZihpKSA+IC0xID8gUElQU19MQVJHRV9WQUxVRSA6IGlzU3RlcHMgPyBQSVBTX1NNQUxMX1ZBTFVFIDogUElQU19OT19WQUxVRTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIHRoZSAnaWdub3JlRmlyc3QnIG9wdGlvbiBieSBvdmVyd3JpdGluZyB0aGUgdHlwZSBmb3IgMC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmRleCAmJiBpZ25vcmVGaXJzdCAmJiBpICE9PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPT09IGhpZ2ggJiYgaWdub3JlTGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwZXJjZW50YWdlIGNvdW50LlxuICAgICAgICAgICAgICAgICAgICBwcmV2UGN0ID0gbmV3UGN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlU2l6ZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19OT19WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWw7XG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfTEFSR0VfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlTGFyZ2U7XG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViO1xuXG4gICAgICAgICAgICB2YXIgbWFya2VyU2l6ZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTk9fVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbDtcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTEFSR0VfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckxhcmdlO1xuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19TTUFMTF9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyU3ViO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xuICAgICAgICAgICAgdmFyIG1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMubWFya2VySG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclZlcnRpY2FsXTtcblxuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHMpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5vcnQgPT09IDAgPyBvcHRpb25zLmNzc0NsYXNzZXMucGlwc0hvcml6b250YWwgOiBvcHRpb25zLmNzc0NsYXNzZXMucGlwc1ZlcnRpY2FsKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3Nlcyh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHNvdXJjZSA9PT0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICAgICAgdmFyIHNpemVDbGFzc2VzID0gYSA/IHZhbHVlU2l6ZUNsYXNzZXMgOiBtYXJrZXJTaXplQ2xhc3NlcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgKyBcIiBcIiArIG9yaWVudGF0aW9uQ2xhc3Nlc1tvcHRpb25zLm9ydF0gKyBcIiBcIiArIHNpemVDbGFzc2VzW3R5cGVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRTcHJlYWQob2Zmc2V0LCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgZnVuY3Rpb24sIGlmIGl0IGlzIHNldC5cbiAgICAgICAgICAgICAgICB0eXBlID0gZmlsdGVyRnVuYyA/IGZpbHRlckZ1bmModmFsdWUsIHR5cGUpIDogdHlwZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBQSVBTX05PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhIG1hcmtlciBmb3IgZXZlcnkgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIpO1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcblxuICAgICAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgb25seSBhcHBlbmRlZCBmb3IgcG9pbnRzIG1hcmtlZCAnMScgb3IgJzInLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlID4gUElQU19OT19WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBmb3JtYXR0ZXIudG8odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwZW5kIGFsbCBwb2ludHMuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcHJlYWQpLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYWRkU3ByZWFkKG9mZnNldCwgc3ByZWFkW29mZnNldF1bMF0sIHNwcmVhZFtvZmZzZXRdWzFdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBpcHMoKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVfUGlwcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQoc2NvcGVfUGlwcyk7XG4gICAgICAgICAgICAgICAgc2NvcGVfUGlwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwaXBzKGdyaWQpIHtcbiAgICAgICAgICAgIC8vIEZpeCAjNjY5XG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XG5cbiAgICAgICAgICAgIHZhciBtb2RlID0gZ3JpZC5tb2RlO1xuICAgICAgICAgICAgdmFyIGRlbnNpdHkgPSBncmlkLmRlbnNpdHkgfHwgMTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBncmlkLmZpbHRlciB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBncmlkLnZhbHVlcyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdGVwcGVkID0gZ3JpZC5zdGVwcGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ2V0R3JvdXAobW9kZSwgdmFsdWVzLCBzdGVwcGVkKTtcbiAgICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xuICAgICAgICAgICAgICAgIHRvOiBNYXRoLnJvdW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfUGlwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxuICAgICAgICBmdW5jdGlvbiBiYXNlU2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2NvcGVfQmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBhbHQgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMub3J0ID09PSAwID8gcmVjdC53aWR0aCB8fCBzY29wZV9CYXNlW2FsdF0gOiByZWN0LmhlaWdodCB8fCBzY29wZV9CYXNlW2FsdF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVyIGZvciBhdHRhY2hpbmcgZXZlbnRzIHRyb3VnaCBhIHByb3h5LlxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvICdmaWx0ZXInIGV2ZW50cyB0byB0aGUgc2xpZGVyLlxuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhIG5vZGUsIG5vdCBhIG5vZGVMaXN0XG5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGZpeEV2ZW50KGUsIGRhdGEucGFnZU9mZnNldCwgZGF0YS50YXJnZXQgfHwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXhFdmVudCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgaGFzIGEgZGlmZmVyZW50IHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gaGFuZGxpbmcgKG11bHRpLSkgdG91Y2ggZXZlbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG9Ob3RSZWplY3QgaXMgcGFzc2VkIGJ5IGFsbCBlbmQgZXZlbnRzIHRvIG1ha2Ugc3VyZSByZWxlYXNlZCB0b3VjaGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgYW4gYWN0aXZlICd0YXAnIHRyYW5zaXRpb24gaXMgdGFraW5nIHBsYWNlLlxuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXApICYmICFkYXRhLmRvTm90UmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gYWN0aW9ucy5zdGFydCAmJiBlLmJ1dHRvbnMgIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnc3VwcG9ydHNQYXNzaXZlJyBpcyBvbmx5IHRydWUgaWYgYSBicm93c2VyIGFsc28gc3VwcG9ydHMgdG91Y2gtYWN0aW9uOiBub25lIGluIENTUy5cbiAgICAgICAgICAgICAgICAvLyBpT1Mgc2FmYXJpIGRvZXMgbm90LCBzbyBpdCBkb2Vzbid0IGdldCB0byBiZW5lZml0IGZyb20gcGFzc2l2ZSBzY3JvbGxpbmcuIGlPUyBkb2VzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLyB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbiwgYnV0IHRoYXQgYWxsb3dzIHBhbm5pbmcsIHdoaWNoIGJyZWFrc1xuICAgICAgICAgICAgICAgIC8vIHNsaWRlcnMgYWZ0ZXIgem9vbWluZy9vbiBub24tcmVzcG9uc2l2ZSBwYWdlcy5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzMxMTJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZS5jYWxjUG9pbnQgPSBlLnBvaW50c1tvcHRpb25zLm9ydF07XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBtZXRob2QsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpO1xuICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICBmdW5jdGlvbiBmaXhFdmVudChlLCBwYWdlT2Zmc2V0LCBldmVudFRhcmdldCkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPT09IDA7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIC8vIElFMTAgaW1wbGVtZW50ZWQgcG9pbnRlciBldmVudHMgd2l0aCBhIHByZWZpeDtcbiAgICAgICAgICAgIGlmIChlLnR5cGUuaW5kZXhPZihcIk1TUG9pbnRlclwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgb25seSB0aGluZyBvbmUgaGFuZGxlIHNob3VsZCBiZSBjb25jZXJuZWQgYWJvdXQgaXMgdGhlIHRvdWNoZXMgdGhhdCBvcmlnaW5hdGVkIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaE9uVGFyZ2V0ID0gZnVuY3Rpb24oY2hlY2tUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb3VjaC50YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5jb250YWlucyhjaGVja1RvdWNoLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja1RvdWNoLnRhcmdldC5zaGFkb3dSb290ICYmIGNoZWNrVG91Y2gudGFyZ2V0LnNoYWRvd1Jvb3QuY29udGFpbnMoZXZlbnRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0b3VjaHN0YXJ0IGV2ZW50cywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlcmUgaXMgc3RpbGwgbm8gbW9yZSB0aGFuIG9uZVxuICAgICAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gb25lIHRvdWNoIHBlciBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGlmIHRoZSB0YXJnZXQgdG91Y2ggaGFzIG5vdCBtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IHRhcmdldFRvdWNoLnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2gucGFnZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KHNjb3BlX0RvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xuICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBwYWdlT2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XG4gICAgICAgICAgICBlLnBvaW50cyA9IFt4LCB5XTtcbiAgICAgICAgICAgIGUuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcblxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2xhdGUgYSBjb29yZGluYXRlIGluIHRoZSBkb2N1bWVudCB0byBhIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuICAgICAgICBmdW5jdGlvbiBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoY2FsY1BvaW50KSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjYWxjUG9pbnQgLSBvZmZzZXQoc2NvcGVfQmFzZSwgb3B0aW9ucy5vcnQpO1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKGxvY2F0aW9uICogMTAwKSAvIGJhc2VTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIENsYW1wIHByb3Bvc2FsIGJldHdlZW4gMCUgYW5kIDEwMCVcbiAgICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xuICAgICAgICAgICAgLy8gYXJlIHVzZWQgKGUuZy4gY29udGFpbmVkIGhhbmRsZXMgZmVhdHVyZSlcbiAgICAgICAgICAgIHByb3Bvc2FsID0gbGltaXQocHJvcG9zYWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBoYW5kbGUgY2xvc2VzdCB0byBhIGNlcnRhaW4gcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXG4gICAgICAgIGZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUoY2xpY2tlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc21hbGxlc3REaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVQb3NpdGlvbiA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9IE1hdGguYWJzKGhhbmRsZVBvc2l0aW9uIC0gY2xpY2tlZFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tBdEVkZ2UgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPT09IDEwMCAmJiBzbWFsbGVzdERpZmZlcmVuY2UgPT09IDEwMDtcblxuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB0aGlzIGhhbmRsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzbHkgY2hlY2tlZCBoYW5kbGVcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPCBzbWFsbGVzdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2xvc2VyQWZ0ZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPD0gc21hbGxlc3REaWZmZXJlbmNlICYmIGNsaWNrZWRQb3NpdGlvbiA+IGhhbmRsZVBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2VyIHx8IGlzQ2xvc2VyQWZ0ZXIgfHwgY2xpY2tBdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0RGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU51bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudExlYXZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJIVE1MXCIgJiYgZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW5kKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxuICAgICAgICBmdW5jdGlvbiBldmVudE1vdmUoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEZpeCAjNDk4XG4gICAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXG4gICAgICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cbiAgICAgICAgICAgIC8vIElFOSBoYXMgLmJ1dHRvbnMgYW5kIC53aGljaCB6ZXJvIG9uIG1vdXNlbW92ZS5cbiAgICAgICAgICAgIC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJNU0lFIDlcIikgPT09IC0xICYmIGV2ZW50LmJ1dHRvbnMgPT09IDAgJiYgZGF0YS5idXR0b25zUHJvcGVydHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgbW92aW5nIHVwIG9yIGRvd25cbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG1vdmVtZW50IGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgd2lkdGgvaGVpZ2h0XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSAobW92ZW1lbnQgKiAxMDApIC8gZGF0YS5iYXNlU2l6ZTtcblxuICAgICAgICAgICAgbW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxuICAgICAgICBmdW5jdGlvbiBldmVudEVuZChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZGF0YS5oYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxuICAgICAgICAgICAgZGF0YS5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfRG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY1swXSwgY1sxXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkcmFnZ2luZyBjbGFzcy5cbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgICAgICBzZXRaaW5kZXgoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImVuZFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBldmVudFN0YXJ0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXZlbnQgc3RhcnQnKTtcbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudCBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLnNvbWUoaXNIYW5kbGVEaXNhYmxlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGU7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGhhbmRsZU9yaWdpbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIGhhbmRsZSBhcyAnYWN0aXZlJyBzbyBpdCBjYW4gYmUgc3R5bGVkLlxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxuICAgICAgICAgICAgdmFyIG1vdmVFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudE1vdmUsIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgdGFyZ2V0IGhhcyBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcHJvcGFnYXRlIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCB3ZSBrZWVwXG4gICAgICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q2FsY1BvaW50OiBldmVudC5jYWxjUG9pbnQsXG4gICAgICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplKCksXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGRvTm90UmVqZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvdXRFdmVudCA9IGF0dGFjaEV2ZW50KFwibW91c2VvdXRcIiwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudExlYXZlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogZGF0YS5oYW5kbGVOdW1iZXJzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAgIC8vIGEgbmV3IG9uZSBhcyBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIGlzbid0IGFuIGlzc3VlIG9uIHRvdWNoIGRldmljZXMsXG4gICAgICAgICAgICAvLyBzbyBhZGRpbmcgY3Vyc29yIHN0eWxlcyBjYW4gYmUgc2tpcHBlZC5cbiAgICAgICAgICAgIGlmIChldmVudC5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSAnSScgY3Vyc29yIGFuZCBleHRlbmQgdGhlIHJhbmdlLWRyYWcgY3Vyc29yLlxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIHRhcmdldCB3aXRoIGEgZHJhZ2dpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmcgdGhlIGhhbmRsZXMuXG4gICAgICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIG9ubHkgaG9sZG91dCBpcyBpT1MgU2FmYXJpLiBUaGlzIGRvZXNuJ3QgbWF0dGVyOiB0ZXh0IHNlbGVjdGlvbiBpc24ndCB0cmlnZ2VyZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInN0YXJ0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuICAgICAgICBmdW5jdGlvbiBldmVudFRhcChldmVudCkge1xuICAgICAgICAgICAgLy8gRXJyb25lb3VzIGV2ZW50cyBzZWVtIHRvIGJlIHBhc3NlZCBpbiBvY2Nhc2lvbmFsbHkgb24gaU9TL2lQYWRPUyBhZnRlciB1c2VyIGZpbmlzaGVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBzbGlkZXIuIFRoZXkgYXBwZWFyIHRvIGJlIG9mIHR5cGUgTW91c2VFdmVudCwgeWV0IHRoZXkgZG9uJ3QgaGF2ZSB1c3VhbCBwcm9wZXJ0aWVzIHNldC4gSWdub3JlIHRhcFxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgaGF2ZSBubyB0b3VjaGVzIG9yIGJ1dHRvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZW0uXG4gICAgICAgICAgICBpZiAoIWV2ZW50LmJ1dHRvbnMgJiYgIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSB0YXAgZXZlbnQgc2hvdWxkbid0IHByb3BhZ2F0ZSB1cFxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xuXG4gICAgICAgICAgICAvLyBUYWNrbGUgdGhlIGNhc2UgdGhhdCBhbGwgaGFuZGxlcyBhcmUgJ2Rpc2FibGVkJy5cbiAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGFnIHRoZSBzbGlkZXIgYXMgaXQgaXMgbm93IGluIGEgdHJhbnNpdGlvbmFsIHN0YXRlLlxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5ldmVudHMuc25hcCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgc2V0WmluZGV4KCk7XG5cbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRTdGFydChldmVudCwgeyBoYW5kbGVOdW1iZXJzOiBbaGFuZGxlTnVtYmVyXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcmVzIGEgJ2hvdmVyJyBldmVudCBmb3IgYSBob3ZlcmVkIG1vdXNlL3BlbiBwb3NpdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XG5cbiAgICAgICAgICAgIHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZV9TZWxmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlcyBrZXlkb3duIG9uIGZvY3VzZWQgaGFuZGxlc1xuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoaXNTbGlkZXJEaXNhYmxlZCgpIHx8IGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsS2V5cyA9IFtcIkRvd25cIiwgXCJVcFwiXTtcbiAgICAgICAgICAgIHZhciBsYXJnZVN0ZXBLZXlzID0gW1wiUGFnZURvd25cIiwgXCJQYWdlVXBcIl07XG4gICAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXIgJiYgIW9wdGlvbnMub3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcnQgJiYgIW9wdGlvbnMuZGlyKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gYSB0b3AtdG8tYm90dG9tIHNsaWRlciwgdGhlIHVwIGFuZCBkb3duIGtleXMgYWN0IGludmVydGVkXG4gICAgICAgICAgICAgICAgdmVydGljYWxLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBsYXJnZVN0ZXBLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgXCJBcnJvd1wiIGZvciBJRSBjb21wYXRpYmlsaXR5LiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgaXNMYXJnZURvd24gPSBrZXkgPT09IGxhcmdlU3RlcEtleXNbMF07XG4gICAgICAgICAgICB2YXIgaXNMYXJnZVVwID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzFdO1xuICAgICAgICAgICAgdmFyIGlzRG93biA9IGtleSA9PT0gdmVydGljYWxLZXlzWzBdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMF0gfHwgaXNMYXJnZURvd247XG4gICAgICAgICAgICB2YXIgaXNVcCA9IGtleSA9PT0gdmVydGljYWxLZXlzWzFdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMV0gfHwgaXNMYXJnZVVwO1xuICAgICAgICAgICAgdmFyIGlzTWluID0ga2V5ID09PSBlZGdlS2V5c1swXTtcbiAgICAgICAgICAgIHZhciBpc01heCA9IGtleSA9PT0gZWRnZUtleXNbMV07XG5cbiAgICAgICAgICAgIGlmICghaXNEb3duICYmICFpc1VwICYmICFpc01pbiAmJiAhaXNNYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIHRvO1xuXG4gICAgICAgICAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMua2V5Ym9hcmRQYWdlTXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gaXNEb3duID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tkaXJlY3Rpb25dO1xuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVkZ2Ugb2YgYSBzbGlkZXIsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm8gc3RlcCBzZXQsIHVzZSB0aGUgZGVmYXVsdCBvZiAxMCUgb2YgdGhlIHN1Yi1yYW5nZVxuICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0uZ2V0RGVmYXVsdFN0ZXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgb3ZlciB6ZXJvLWxlbmd0aCByYW5nZXMgKCM5NDgpO1xuICAgICAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heChzdGVwLCAwLjAwMDAwMDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVjcmVtZW50IGZvciBkb3duIHN0ZXBzXG4gICAgICAgICAgICAgICAgc3RlcCA9IChpc0Rvd24gPyAtMSA6IDEpICogc3RlcDtcblxuICAgICAgICAgICAgICAgIHRvID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01heCkge1xuICAgICAgICAgICAgICAgIC8vIEVuZCBrZXlcbiAgICAgICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFtvcHRpb25zLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvbWUga2V5XG4gICAgICAgICAgICAgICAgdG8gPSBvcHRpb25zLnNwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cbiAgICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSBvbmx5IGJvdW5kIHRvIHRoZSB2aXN1YWwgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQsIG5vdCB0aGUgJ3JlYWwnIG9yaWdpbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgdGFwIGV2ZW50IHRvIHRoZSBzbGlkZXIgYmFzZS5cbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIudGFwKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgc2NvcGVfQmFzZSwgZXZlbnRUYXAsIHt9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZSBob3ZlciBldmVudHNcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuaG92ZXIpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLm1vdmUsIHNjb3BlX0Jhc2UsIGV2ZW50SG92ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmFuZ2UgZHJhZ2dhYmxlLlxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVCZWZvcmUgPSBzY29wZV9IYW5kbGVzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVBZnRlciA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xuXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGNvbm5lY3QsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnZ2FibGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHJhbmdlIGlzIGZpeGVkLCB0aGUgZW50aXJlIHJhbmdlIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBkcmFnZ2VkIGJ5IHRoZSBoYW5kbGVzLiBUaGUgaGFuZGxlIGluIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IG5lZWRzIHRvIGJlIGJvdW5kIG1hbnVhbGx5IG9uIHRoZSBvdGhlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBldmVudEhvbGRlciwgZXZlbnRTdGFydCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IFtoYW5kbGVCZWZvcmUsIGhhbmRsZUFmdGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXggLSAxLCBpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBldmVudCBib3VuZCBpcyAndXBkYXRlLCcgZmlyZSBpdCBpbW1lZGlhdGVseSBmb3IgYWxsIGhhbmRsZXMuXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlZEV2ZW50LnNwbGl0KFwiLlwiKVswXSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50KG5hbWVzcGFjZWRFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZXZlbnQgJiYgbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oYmluZCkge1xuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NvcGVfRXZlbnRzW2JpbmRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcbiAgICAgICAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlTnVtYmVyLCB0YXApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2xpZGVyIHB1YmxpYyBBUEkgYXMgdGhlIHNjb3BlICgndGhpcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbmRleCwgMCBvciAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuLWZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgaXMgZmlyZWQgYnkgdGFwLCB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFwIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgb2Zmc2V0IG9mIHRoZSBoYW5kbGUsIGluIHJlbGF0aW9uIHRvIHRoZSBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsaWRlciBwdWJsaWMgQVBJIHRvIGFuIGFjY2Vzc2libGUgcGFyYW1ldGVyIHdoZW4gdGhpcyBpcyB1bmF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1NlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBoYW5kbGUgcG9zaXRpb25pbmcgbG9naWMgc28gdGhlIE1vdmUgZXZlbnQgY2FuIHVzZSBpdCwgdG9vXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSGFuZGxlUG9zaXRpb24ocmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBnZXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBGb3Igc2xpZGVycyB3aXRoIG11bHRpcGxlIGhhbmRsZXMsIGxpbWl0IG1vdmVtZW50IHRvIHRoZSBvdGhlciBoYW5kbGUuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgbWFyZ2luIG9wdGlvbiBieSBhZGRpbmcgaXQgdG8gdGhlIGhhbmRsZSBwb3NpdGlvbnMuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrd2FyZCAmJiBoYW5kbGVOdW1iZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0sIG9wdGlvbnMubWFyZ2luLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5tYXJnaW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGltaXQgb3B0aW9uIGhhcyB0aGUgb3Bwb3NpdGUgZWZmZWN0LCBsaW1pdGluZyBoYW5kbGVzIHRvIGFcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92YWJsZS5cbiAgICAgICAgICAgIGlmIChzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciAtIDFdLCBvcHRpb25zLmxpbWl0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5saW1pdCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGVkZ2VzIG9mIHRoZSBzbGlkZXIuIFBhZGRpbmcgbXVzdCBiZSA+IDAuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMCwgb3B0aW9ucy5wYWRkaW5nWzBdLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMTAwLCBvcHRpb25zLnBhZGRpbmdbMV0sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xuXG4gICAgICAgICAgICAvLyBMaW1pdCBwZXJjZW50YWdlIHRvIHRoZSAwIC0gMTAwIHJhbmdlXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIGhhbmRsZSBjYW4ndCBtb3ZlXG4gICAgICAgICAgICBpZiAodG8gPT09IHJlZmVyZW5jZVtoYW5kbGVOdW1iZXJdICYmICFnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlcyBzbGlkZXIgb3JpZW50YXRpb24gdG8gY3JlYXRlIENTUyBydWxlcy4gYSA9IGJhc2UgdmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGluUnVsZU9yZGVyKHYsIGEpIHtcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XG4gICAgICAgICAgICByZXR1cm4gKG8gPyBhIDogdikgKyBcIiwgXCIgKyAobyA/IHYgOiBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmVzIGhhbmRsZShzKSBieSBhIHBlcmNlbnRhZ2VcbiAgICAgICAgLy8gKGJvb2wsICUgdG8gbW92ZSwgWyUgd2hlcmUgaGFuZGxlIHN0YXJ0ZWQsIC4uLl0sIFtpbmRleCBpbiBzY29wZV9IYW5kbGVzLCAuLi5dKVxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbHMgPSBsb2NhdGlvbnMuc2xpY2UoKTtcblxuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcbiAgICAgICAgICAgIHZhciBmID0gW3Vwd2FyZCwgIXVwd2FyZF07XG5cbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMgPSBoYW5kbGVOdW1iZXJzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSB3aGljaCBoYW5kbGUgaXMgJ2xlYWRpbmcnLlxuICAgICAgICAgICAgLy8gSWYgdGhhdCBvbmUgY2FuJ3QgbW92ZSB0aGUgc2Vjb25kIGNhbid0IGVpdGhlci5cbiAgICAgICAgICAgIGlmICh1cHdhcmQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBiW29dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZltvXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxzW2hhbmRsZU51bWJlcl0gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB1c2luZyBvbmUgaGFuZGxlLCBjaGVjayBiYWNrd2FyZCBBTkQgZm9yd2FyZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDI6IFRyeSB0byBzZXQgdGhlIGhhbmRsZXMgd2l0aCB0aGUgZm91bmQgcGVyY2VudGFnZVxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgbG9jYXRpb25zW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSkgfHwgc3RhdGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3RlcCAzOiBJZiBhIGhhbmRsZSBtb3ZlZCwgZmlyZSBldmVudHNcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlcyBhIGJhc2UgdmFsdWUgYW5kIGFuIG9mZnNldC4gVGhpcyBvZmZzZXQgaXMgdXNlZCBmb3IgdGhlIGNvbm5lY3QgYmFyIHNpemUuXG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIGRlc2lnbiBmb3IgdGhpcyBmZWF0dXJlLCB0aGUgb3JpZ2luIGVsZW1lbnQgd2FzIDElIHdpZGUuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gaW4gdGhpcyBtYW5uZXI6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc5ODIyM1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyID8gMTAwIC0gYSAtIGIgOiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0bykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2F0aW9ucy5cbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IDEwICogKHRyYW5zZm9ybURpcmVjdGlvbih0bywgMCkgLSBzY29wZV9EaXJPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVJ1bGUgPSBcInRyYW5zbGF0ZShcIiArIGluUnVsZU9yZGVyKHRyYW5zbGF0aW9uICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGVbb3B0aW9ucy50cmFuc2Zvcm1SdWxlXSA9IHRyYW5zbGF0ZVJ1bGU7XG5cbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVzIGJlZm9yZSB0aGUgc2xpZGVyIG1pZGRsZSBhcmUgc3RhY2tlZCBsYXRlciA9IGhpZ2hlcixcbiAgICAgICAgLy8gSGFuZGxlcyBhZnRlciB0aGUgbWlkZGxlIGxhdGVyIGlzIGxvd2VyXG4gICAgICAgIC8vIFtbN10gWzhdIC4uLi4uLi4uLi4gfCAuLi4uLi4uLi4uIFs1XSBbNF1cbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA+IDUwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHZhciB6SW5kZXggPSAzICsgKHNjb3BlX0hhbmRsZXMubGVuZ3RoICsgZGlyICogaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cbiAgICAgICAgZnVuY3Rpb24gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQpIHtcbiAgICAgICAgICAgIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlcyBzdHlsZSBhdHRyaWJ1dGUgZm9yIGNvbm5lY3Qgbm9kZXNcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdChpbmRleCkge1xuICAgICAgICAgICAgLy8gU2tpcCBjb25uZWN0cyBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2NvcGVfQ29ubmVjdHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgICAgICB2YXIgaCA9IDEwMDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBoID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgdXNlIHR3byBydWxlczpcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xuICAgICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gQXMgdGhlIGVsZW1lbnQgaGFzIGEgd2lkdGggb2YgMTAwJSwgYSB0cmFuc2xhdGlvbiBvZiAxMDAlIGlzIGVxdWFsIHRvIDEwMCUgb2YgdGhlIHBhcmVudCAoLm5vVWktYmFzZSlcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2Zvcm1EaXJlY3Rpb24obCwgY29ubmVjdFdpZHRoKSArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBzY2FsZVJ1bGUgPSBcInNjYWxlKFwiICsgaW5SdWxlT3JkZXIoY29ubmVjdFdpZHRoIC8gMTAwLCBcIjFcIikgKyBcIilcIjtcblxuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHNbaW5kZXhdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlICsgXCIgXCIgKyBzY2FsZVJ1bGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZXMgdmFsdWUgcGFzc2VkIHRvIC5zZXQgbWV0aG9kLiBSZXR1cm5zIGN1cnJlbnQgdmFsdWUgaWYgbm90IHBhcnNlLWFibGUuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVUb1ZhbHVlKHRvLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cbiAgICAgICAgICAgIC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAodG8gPT09IG51bGwgfHwgdG8gPT09IGZhbHNlIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0byA9IFN0cmluZyh0byk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xuXG4gICAgICAgICAgICAvLyBJZiBwYXJzaW5nIHRoZSBudW1iZXIgZmFpbGVkLCB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzbGlkZXIgdmFsdWUuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0KGlucHV0LCBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBhc0FycmF5KGlucHV0KTtcbiAgICAgICAgICAgIHZhciBpc0luaXQgPSBzY29wZV9Mb2NhdGlvbnNbMF0gPT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgZmlyZVNldEV2ZW50ID0gZmlyZVNldEV2ZW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFmaXJlU2V0RXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5pdGlhbCB2YWx1ZXMgd2VyZSBzZXQgYmVmb3JlIHVzaW5nIGFuaW1hdGVkIHBsYWNlbWVudC5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgJiYgIWlzSW5pdCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MsIHdpdGhvdXQgbG9va0FoZWFkIGJ1dCB3aXRoIGxvb2tCYWNrd2FyZC4gVmFsdWVzIGFyZSBzZXQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGkgPSBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSA/IDAgOiAxO1xuXG4gICAgICAgICAgICAvLyBTZWNvbmRhcnkgcGFzc2VzLiBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHMuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBoYW5kbGVzIHRvIGVuc3VyZSBjb25zdHJhaW50cyBhcmUgYXBwbGllZCBmb3IgdGhlIGVudGlyZSBzbGlkZXIgKElzc3VlICMxMDA5KVxuICAgICAgICAgICAgZm9yICg7IGkgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFppbmRleCgpO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSBldmVudCBvbmx5IGZvciBoYW5kbGVzIHRoYXQgcmVjZWl2ZWQgYSBuZXcgdmFsdWUsIGFzIHBlciAjNTc5XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1toYW5kbGVOdW1iZXJdICE9PSBudWxsICYmIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xuICAgICAgICBmdW5jdGlvbiB2YWx1ZVJlc2V0KGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9ucy5zdGFydCwgZmlyZVNldEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG51bWVyaWMgaW5wdXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICBpZiAoIShoYW5kbGVOdW1iZXIgPj0gMCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGludmFsaWQgaGFuZGxlIG51bWJlciwgZ290OiBcIiArIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvb2sgYm90aCBiYWNrd2FyZCBhbmQgZm9yd2FyZCwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGhhbmRsZSB0byBcInB1c2hcIiBvdGhlciBoYW5kbGVzICgjOTYwKTtcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG5cbiAgICAgICAgICAgIGlmIChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAgICBmdW5jdGlvbiB2YWx1ZUdldCgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKTtcblxuICAgICAgICAgICAgLy8gSWYgb25seSBvbmUgaGFuZGxlIGlzIHVzZWQsIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZXMgY2xhc3NlcyBmcm9tIHRoZSByb290IGFuZCBlbXB0aWVzIGl0LlxuICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY3NzQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jc3NDbGFzc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9UYXJnZXQucmVtb3ZlQ2hpbGQoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgc2NvcGVfVGFyZ2V0Lm5vVWlTbGlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHNGb3JIYW5kbGUoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHZhciBuZWFyYnlTdGVwcyA9IHNjb3BlX1NwZWN0cnVtLmdldE5lYXJieVN0ZXBzKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1ZhbHVlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgc25hcHBlZCwgZGlyZWN0bHkgdXNlIGRlZmluZWQgc3RlcCB2YWx1ZVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc25hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIC0gbmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGFydFZhbHVlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWUgfHwgbnVsbFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXG4gICAgICAgICAgICAvLyB0aGUgaW5jcmVtZW50IGlzIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBzdGVwIC0gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGVwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIGhhbmRsZSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBzdGVwLCBpdCBhbHdheXMgc3RlcHMgYmFjayBpbnRvIHRoZSBwcmV2aW91cyBzdGVwIGZpcnN0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuaGlnaGVzdFN0ZXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm8gaW4vZGVjcmVtZW50XG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IDEwMCkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXMgcGVyICMzOTEsIHRoZSBjb21wYXJpc29uIGZvciB0aGUgZGVjcmVtZW50IHN0ZXAgY2FuIGhhdmUgc29tZSByb3VuZGluZyBpc3N1ZXMuXG4gICAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcblxuICAgICAgICAgICAgLy8gUm91bmQgcGVyICMzOTFcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IG51bGwgJiYgaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IE51bWJlcihpbmNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gTnVtYmVyKGRlY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2RlY3JlbWVudCwgaW5jcmVtZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIHNpemUgZm9yIHRoZSBzbGlkZXIuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwcygpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVOdW1iZXJzLm1hcChnZXROZXh0U3RlcHNGb3JIYW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlYWJsZTogbWFyZ2luLCBsaW1pdCwgcGFkZGluZywgc3RlcCwgcmFuZ2UsIGFuaW1hdGUsIHNuYXBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgLy8gU3BlY3RydW0gaXMgY3JlYXRlZCB1c2luZyB0aGUgcmFuZ2UsIHNuYXAsIGRpcmVjdGlvbiBhbmQgc3RlcCBvcHRpb25zLlxuICAgICAgICAgICAgLy8gJ3NuYXAnIGFuZCAnc3RlcCcgY2FuIGJlIHVwZGF0ZWQuXG4gICAgICAgICAgICAvLyBJZiAnc25hcCcgYW5kICdzdGVwJyBhcmUgbm90IHBhc3NlZCwgdGhleSBzaG91bGQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVHZXQoKTtcblxuICAgICAgICAgICAgdmFyIHVwZGF0ZUFibGUgPSBbXG4gICAgICAgICAgICAgICAgXCJtYXJnaW5cIixcbiAgICAgICAgICAgICAgICBcImxpbWl0XCIsXG4gICAgICAgICAgICAgICAgXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiLFxuICAgICAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICAgICAgICAgIFwic25hcFwiLFxuICAgICAgICAgICAgICAgIFwic3RlcFwiLFxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgXCJwaXBzXCIsXG4gICAgICAgICAgICAgICAgXCJ0b29sdGlwc1wiXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVuZGVmaW5lZC4gbnVsbCByZW1vdmVzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgbmV3IG9wdGlvbnMgaW50byB0aGUgc2xpZGVyIHN0YXRlXG4gICAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gbmV3T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2NvcGVfU3BlY3RydW0gPSBuZXdPcHRpb25zLnNwZWN0cnVtO1xuXG4gICAgICAgICAgICAvLyBMaW1pdCwgbWFyZ2luIGFuZCBwYWRkaW5nIGRlcGVuZCBvbiB0aGUgc3BlY3RydW0gYnV0IGFyZSBzdG9yZWQgb3V0c2lkZSBvZiBpdC4gKCM2NzcpXG4gICAgICAgICAgICBvcHRpb25zLm1hcmdpbiA9IG5ld09wdGlvbnMubWFyZ2luO1xuICAgICAgICAgICAgb3B0aW9ucy5saW1pdCA9IG5ld09wdGlvbnMubGltaXQ7XG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwaXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlUGlwcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGN1cnJlbnQgcG9zaXRpb25pbmcgc28gdmFsdWVTZXQgZm9yY2VzIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9uc1RvVXBkYXRlLnN0YXJ0IHx8IHYsIGZpcmVTZXRFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xuICAgICAgICBmdW5jdGlvbiBzZXR1cFNsaWRlcigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYmFzZSBlbGVtZW50LCBpbml0aWFsaXplIEhUTUwgYW5kIHNldCBjbGFzc2VzLlxuICAgICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXG4gICAgICAgICAgICBzY29wZV9CYXNlID0gYWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XG5cbiAgICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCB1c2VyIGV2ZW50cy5cbiAgICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHMpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcmlhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR1cFNsaWRlcigpO1xuXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgc2NvcGVfU2VsZiA9IHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICBzdGVwczogZ2V0TmV4dFN0ZXBzLFxuICAgICAgICAgICAgb246IGJpbmRFdmVudCxcbiAgICAgICAgICAgIG9mZjogcmVtb3ZlRXZlbnQsXG4gICAgICAgICAgICBnZXQ6IHZhbHVlR2V0LFxuICAgICAgICAgICAgc2V0OiB2YWx1ZVNldCxcbiAgICAgICAgICAgIHNldEhhbmRsZTogdmFsdWVTZXRIYW5kbGUsXG4gICAgICAgICAgICByZXNldDogdmFsdWVSZXNldCxcbiAgICAgICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIF9fbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgICAgICAgICBtb3ZlSGFuZGxlcyhhLCBiLCBzY29wZV9Mb2NhdGlvbnMsIGMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucywgLy8gSXNzdWUgIzYwMCwgIzY3OFxuICAgICAgICAgICAgdXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIHRhcmdldDogc2NvcGVfVGFyZ2V0LCAvLyBJc3N1ZSAjNTk3XG4gICAgICAgICAgICByZW1vdmVQaXBzOiByZW1vdmVQaXBzLFxuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxuICAgICAgICAgICAgZ2V0VG9vbHRpcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPcmlnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfSGFuZGxlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaXBzOiBwaXBzIC8vIElzc3VlICM1OTRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2NvcGVfU2VsZjtcbiAgICB9XG5cbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSh0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGNyZWF0ZSByZXF1aXJlcyBhIHNpbmdsZSBlbGVtZW50LCBnb3Q6IFwiICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBzbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICh0YXJnZXQubm9VaVNsaWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCB0aGUgb3B0aW9ucyBhbmQgY3JlYXRlIHRoZSBzbGlkZXIgZW52aXJvbm1lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zLCB0YXJnZXQpO1xuICAgICAgICB2YXIgYXBpID0gc2NvcGUodGFyZ2V0LCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMpO1xuXG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgLy8gVXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gZm9yIGZ1dHVyZSBleHBhbmRhYmlsaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgX19zcGVjdHJ1bTogU3BlY3RydW0sXG4gICAgICAgIHZlcnNpb246IFZFUlNJT04sXG4gICAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IGNsYXNzZXMsIGFsbG93cyBnbG9iYWwgY2hhbmdlcy5cbiAgICAgICAgLy8gVXNlIHRoZSBjc3NDbGFzc2VzIG9wdGlvbiBmb3IgY2hhbmdlcyB0byBvbmUgc2xpZGVyLlxuICAgICAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzLFxuICAgICAgICBjcmVhdGU6IGluaXRpYWxpemVcbiAgICB9O1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},,,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuY3NzPzQzMDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * Russian translation for bootstrap-datepicker\n * Victor Taranenko <darwin@snowdale.com>\n */\n/* harmony default export */ __webpack_exports__["a"] = ({\n  ru: {\n    days: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"],\n    daysShort: ["Вск", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Суб"],\n    daysMin: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],\n    months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],\n    monthsShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],\n    today: "Сегодня",\n    clear: "Очистить",\n    format: "dd.mm.yyyy",\n    weekStart: 1,\n    monthsTitle: \'Месяцы\'\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvaTE4bi9sb2NhbGVzL3J1LmpzPzg2NzMiXSwibmFtZXMiOlsicnUiLCJkYXlzIiwiZGF5c1Nob3J0IiwiZGF5c01pbiIsIm1vbnRocyIsIm1vbnRoc1Nob3J0IiwidG9kYXkiLCJjbGVhciIsImZvcm1hdCIsIndlZWtTdGFydCIsIm1vbnRoc1RpdGxlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztBQUllO0FBQ2JBLElBQUUsRUFBRTtBQUNGQyxRQUFJLEVBQUUsQ0FBQyxhQUFELEVBQWdCLGFBQWhCLEVBQStCLFNBQS9CLEVBQTBDLE9BQTFDLEVBQW1ELFNBQW5ELEVBQThELFNBQTlELEVBQXlFLFNBQXpFLENBREo7QUFFRkMsYUFBUyxFQUFFLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLEtBQTdCLEVBQW9DLEtBQXBDLEVBQTJDLEtBQTNDLENBRlQ7QUFHRkMsV0FBTyxFQUFFLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLEVBQXFDLElBQXJDLENBSFA7QUFJRkMsVUFBTSxFQUFFLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsTUFBdEIsRUFBOEIsUUFBOUIsRUFBd0MsS0FBeEMsRUFBK0MsTUFBL0MsRUFBdUQsTUFBdkQsRUFBK0QsUUFBL0QsRUFBeUUsVUFBekUsRUFBcUYsU0FBckYsRUFBZ0csUUFBaEcsRUFBMEcsU0FBMUcsQ0FKTjtBQUtGQyxlQUFXLEVBQUUsQ0FBQyxLQUFELEVBQVEsS0FBUixFQUFlLEtBQWYsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0MsS0FBcEMsRUFBMkMsS0FBM0MsRUFBa0QsS0FBbEQsRUFBeUQsS0FBekQsRUFBZ0UsS0FBaEUsRUFBdUUsS0FBdkUsRUFBOEUsS0FBOUUsQ0FMWDtBQU1GQyxTQUFLLEVBQUUsU0FOTDtBQU9GQyxTQUFLLEVBQUUsVUFQTDtBQVFGQyxVQUFNLEVBQUUsWUFSTjtBQVNGQyxhQUFTLEVBQUUsQ0FUVDtBQVVGQyxlQUFXLEVBQUU7QUFWWDtBQURTLENBQWYiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJ1c3NpYW4gdHJhbnNsYXRpb24gZm9yIGJvb3RzdHJhcC1kYXRlcGlja2VyXG4gKiBWaWN0b3IgVGFyYW5lbmtvIDxkYXJ3aW5Ac25vd2RhbGUuY29tPlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJ1OiB7XG4gICAgZGF5czogW1wi0JLQvtGB0LrRgNC10YHQtdC90YzQtVwiLCBcItCf0L7QvdC10LTQtdC70YzQvdC40LpcIiwgXCLQktGC0L7RgNC90LjQulwiLCBcItCh0YDQtdC00LBcIiwgXCLQp9C10YLQstC10YDQs1wiLCBcItCf0Y/RgtC90LjRhtCwXCIsIFwi0KHRg9Cx0LHQvtGC0LBcIl0sXG4gICAgZGF5c1Nob3J0OiBbXCLQktGB0LpcIiwgXCLQn9C90LRcIiwgXCLQktGC0YBcIiwgXCLQodGA0LRcIiwgXCLQp9GC0LJcIiwgXCLQn9GC0L1cIiwgXCLQodGD0LFcIl0sXG4gICAgZGF5c01pbjogW1wi0JLRgVwiLCBcItCf0L1cIiwgXCLQktGCXCIsIFwi0KHRgFwiLCBcItCn0YJcIiwgXCLQn9GCXCIsIFwi0KHQsVwiXSxcbiAgICBtb250aHM6IFtcItCv0L3QstCw0YDRjFwiLCBcItCk0LXQstGA0LDQu9GMXCIsIFwi0JzQsNGA0YJcIiwgXCLQkNC/0YDQtdC70YxcIiwgXCLQnNCw0LlcIiwgXCLQmNGO0L3RjFwiLCBcItCY0Y7Qu9GMXCIsIFwi0JDQstCz0YPRgdGCXCIsIFwi0KHQtdC90YLRj9Cx0YDRjFwiLCBcItCe0LrRgtGP0LHRgNGMXCIsIFwi0J3QvtGP0LHRgNGMXCIsIFwi0JTQtdC60LDQsdGA0YxcIl0sXG4gICAgbW9udGhzU2hvcnQ6IFtcItCv0L3QslwiLCBcItCk0LXQslwiLCBcItCc0LDRgFwiLCBcItCQ0L/RgFwiLCBcItCc0LDQuVwiLCBcItCY0Y7QvVwiLCBcItCY0Y7Qu1wiLCBcItCQ0LLQs1wiLCBcItCh0LXQvVwiLCBcItCe0LrRglwiLCBcItCd0L7Rj1wiLCBcItCU0LXQulwiXSxcbiAgICB0b2RheTogXCLQodC10LPQvtC00L3Rj1wiLFxuICAgIGNsZWFyOiBcItCe0YfQuNGB0YLQuNGC0YxcIixcbiAgICBmb3JtYXQ6IFwiZGQubW0ueXl5eVwiLFxuICAgIHdlZWtTdGFydDogMSxcbiAgICBtb250aHNUaXRsZTogJ9Cc0LXRgdGP0YbRiydcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ DateRangePicker_DateRangePicker; });\n\n// UNUSED EXPORTS: Datepicker\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/Datepicker.js + 16 modules\nvar Datepicker = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/event.js\nvar lib_event = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/vanillajs-datepicker/js/lib/date-format.js\nvar date_format = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/DateRangePicker.js\n\n\n // filter out the config options inapproprite to pass to Datepicker\n\nfunction filterOptions(options) {\n  const newOpts = Object.assign({}, options);\n  delete newOpts.inputs;\n  delete newOpts.allowOneSidedRange;\n  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n  return newOpts;\n}\n\nfunction setupDatepicker(rangepicker, changeDateListener, el, options) {\n  Object(lib_event["b" /* registerListeners */])(rangepicker, [[el, \'changeDate\', changeDateListener]]);\n  return new Datepicker["a" /* default */](el, options, rangepicker);\n}\n\nfunction onChangeDate(rangepicker, ev) {\n  // to prevent both datepickers trigger the other side\'s update each other\n  if (rangepicker.updating) {\n    return;\n  }\n\n  rangepicker.updating = true;\n  const target = ev.target;\n\n  if (target.datepicker === undefined) {\n    return;\n  }\n\n  const datepickers = rangepicker.datepickers;\n  const setDateOptions = {\n    render: false\n  };\n  const changedSide = rangepicker.inputs.indexOf(target);\n  const otherSide = changedSide === 0 ? 1 : 0;\n  const changedDate = datepickers[changedSide].dates[0];\n  const otherDate = datepickers[otherSide].dates[0];\n\n  if (changedDate !== undefined && otherDate !== undefined) {\n    // if the start of the range > the end, swap them\n    if (changedSide === 0 && changedDate > otherDate) {\n      datepickers[0].setDate(otherDate, setDateOptions);\n      datepickers[1].setDate(changedDate, setDateOptions);\n    } else if (changedSide === 1 && changedDate < otherDate) {\n      datepickers[0].setDate(changedDate, setDateOptions);\n      datepickers[1].setDate(otherDate, setDateOptions);\n    }\n  } else if (!rangepicker.allowOneSidedRange) {\n    // to prevent the range from becoming one-sided, copy changed side\'s\n    // selection (no matter if it\'s empty) to the other side\n    if (changedDate !== undefined || otherDate !== undefined) {\n      setDateOptions.clear = true;\n      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n    }\n  }\n\n  datepickers[0].picker.update().render();\n  datepickers[1].picker.update().render();\n  delete rangepicker.updating;\n}\n/**\n * Class representing a date range picker\n */\n\n\nclass DateRangePicker_DateRangePicker {\n  /**\n   * Create a date range picker\n   * @param  {Element} element - element to bind a date range picker\n   * @param  {Object} [options] - config options\n   */\n  constructor(element, options = {}) {\n    const inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll(\'input\'));\n\n    if (inputs.length < 2) {\n      return;\n    }\n\n    element.rangepicker = this;\n    this.element = element;\n    this.inputs = inputs.slice(0, 2);\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n    const changeDateListener = onChangeDate.bind(null, this);\n    const cleanOptions = filterOptions(options);\n    this.datepickers = [setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions), setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions)]; // normalize the range if inital dates are given\n\n    if (this.dates[0] !== undefined) {\n      onChangeDate(this, {\n        target: this.inputs[0]\n      });\n    } else if (this.dates[1] !== undefined) {\n      onChangeDate(this, {\n        target: this.inputs[1]\n      });\n    }\n  }\n  /**\n   * @type {Array} - selected date of the linked date pickers\n   */\n\n\n  get dates() {\n    if (this.datepickers) {\n      return [this.datepickers[0].dates[0], this.datepickers[1].dates[0]];\n    }\n  }\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n\n\n  setOptions(options) {\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n    const cleanOptions = filterOptions(options);\n    this.datepickers[0].setOptions(cleanOptions);\n    this.datepickers[1].setOptions(cleanOptions);\n  }\n  /**\n   * Destroy the DateRangePicker instance\n   * @return {DateRangePicker} - the instance destroyed\n   */\n\n\n  destroy() {\n    this.datepickers[0].destroy();\n    this.datepickers[1].destroy();\n    Object(lib_event["c" /* unregisterListeners */])(this);\n    delete this.element.rangepicker;\n  }\n  /**\n   * Get the start and end dates of the date range\n   *\n   * The method returns Date objects by default. If format string is passed,\n   * it returns date strings formatted in given format.\n   * The result array always contains 2 items (start date/end date) and\n   * undifined is used for unselected side. (e.g. If none is selected,\n   * the result will be [undifined, undifined]. If only the end date is set\n   * when allowOneSidedRange config option is true, [undifined, endDate] will\n   * be returned.)\n   *\n   * @param  {String} [format] - Format string to stringify the dates\n   * @return {Array} - Start and end dates\n   */\n\n\n  getDates(format = undefined) {\n    const callback = format ? date => Object(date_format["a" /* formatDate */])(date, format, this.datepickers[0].config.locale) : date => new Date(date);\n    return this.dates.map(date => date === undefined ? date : callback(date));\n  }\n\n}\n// CONCATENATED MODULE: ./node_modules/vanillajs-datepicker/js/main.js\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFuaWxsYWpzLWRhdGVwaWNrZXIvanMvRGF0ZVJhbmdlUGlja2VyLmpzP2M5ZDYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbmlsbGFqcy1kYXRlcGlja2VyL2pzL21haW4uanM/YTM5OCJdLCJuYW1lcyI6WyJmaWx0ZXJPcHRpb25zIiwib3B0aW9ucyIsIm5ld09wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbnB1dHMiLCJhbGxvd09uZVNpZGVkUmFuZ2UiLCJtYXhOdW1iZXJPZkRhdGVzIiwic2V0dXBEYXRlcGlja2VyIiwicmFuZ2VwaWNrZXIiLCJjaGFuZ2VEYXRlTGlzdGVuZXIiLCJlbCIsInJlZ2lzdGVyTGlzdGVuZXJzIiwiRGF0ZXBpY2tlciIsIm9uQ2hhbmdlRGF0ZSIsImV2IiwidXBkYXRpbmciLCJ0YXJnZXQiLCJkYXRlcGlja2VyIiwidW5kZWZpbmVkIiwiZGF0ZXBpY2tlcnMiLCJzZXREYXRlT3B0aW9ucyIsInJlbmRlciIsImNoYW5nZWRTaWRlIiwiaW5kZXhPZiIsIm90aGVyU2lkZSIsImNoYW5nZWREYXRlIiwiZGF0ZXMiLCJvdGhlckRhdGUiLCJzZXREYXRlIiwiY2xlYXIiLCJwaWNrZXIiLCJ1cGRhdGUiLCJEYXRlUmFuZ2VQaWNrZXIiLCJjb25zdHJ1Y3RvciIsImVsZW1lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsInNsaWNlIiwiYmluZCIsImNsZWFuT3B0aW9ucyIsInNldE9wdGlvbnMiLCJkZXN0cm95IiwidW5yZWdpc3Rlckxpc3RlbmVycyIsImdldERhdGVzIiwiZm9ybWF0IiwiY2FsbGJhY2siLCJkYXRlIiwiZm9ybWF0RGF0ZSIsImNvbmZpZyIsImxvY2FsZSIsIkRhdGUiLCJtYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0NBR0E7O0FBQ0EsU0FBU0EsYUFBVCxDQUF1QkMs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QUFuQjtBQUNBLFdBQU8sS0FBS1gsT0FBTCxDQUFhMUIsV0FBcEI7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0FzQyxVQUFRLENBQUNDLE1BQU0sR0FBRzdCLFNBQVYsRUFBcUI7QUFDM0IsVUFBTThCLFFBQVEsR0FBR0QsTUFBTSxHQUNuQkUsSUFBSSxJQUFJQyx5Q0FBVSxDQUFDRCxJQUFELEVBQU9GLE1BQVAsRUFBZSxLQUFLNUIsV0FBTCxDQUFpQixDQUFqQixFQUFvQmdDLE1BQXBCLENBQTJCQyxNQUExQyxDQURDLEdBRW5CSCxJQUFJLElBQUksSUFBSUksSUFBSixDQUFTSixJQUFULENBRlo7QUFJQSxXQUFPLEtBQUt2QixLQUFMLENBQVc0QixHQUFYLENBQWVMLElBQUksSUFBSUEsSUFBSSxLQUFLL0IsU0FBVCxHQUFxQitCLElBQXJCLEdBQTRCRCxRQUFRLENBQUNDLElBQUQsQ0FBM0QsQ0FBUDtBQUNEOztBQXhGbUMsQzs7QUNsRXRDO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3JlZ2lzdGVyTGlzdGVuZXJzLCB1bnJlZ2lzdGVyTGlzdGVuZXJzfSBmcm9tICcuL2xpYi9ldmVudC5qcyc7XG5pbXBvcnQge2Zvcm1hdERhdGV9IGZyb20gJy4vbGliL2RhdGUtZm9ybWF0LmpzJztcbmltcG9ydCBEYXRlcGlja2VyIGZyb20gJy4vRGF0ZXBpY2tlci5qcyc7XG5cbi8vIGZpbHRlciBvdXQgdGhlIGNvbmZpZyBvcHRpb25zIGluYXBwcm9wcml0ZSB0byBwYXNzIHRvIERhdGVwaWNrZXJcbmZ1bmN0aW9uIGZpbHRlck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBuZXdPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgZGVsZXRlIG5ld09wdHMuaW5wdXRzO1xuICBkZWxldGUgbmV3T3B0cy5hbGxvd09uZVNpZGVkUmFuZ2U7XG4gIGRlbGV0ZSBuZXdPcHRzLm1heE51bWJlck9mRGF0ZXM7IC8vIHRvIGVuc3VyZSBlYWNoIGRhdGVwaWNrZXIgaGFuZGxlcyBhIHNpbmdsZSBkYXRlXG5cbiAgcmV0dXJuIG5ld09wdHM7XG59XG5cbmZ1bmN0aW9uIHNldHVwRGF0ZXBpY2tlcihyYW5nZXBpY2tlciwgY2hhbmdlRGF0ZUxpc3RlbmVyLCBlbCwgb3B0aW9ucykge1xuICByZWdpc3Rlckxpc3RlbmVycyhyYW5nZXBpY2tlciwgW1xuICAgIFtlbCwgJ2NoYW5nZURhdGUnLCBjaGFuZ2VEYXRlTGlzdGVuZXJdLFxuICBdKTtcbiAgcmV0dXJuIG5ldyBEYXRlcGlja2VyKGVsLCBvcHRpb25zLCByYW5nZXBpY2tlcik7XG59XG5cbmZ1bmN0aW9uIG9uQ2hhbmdlRGF0ZShyYW5nZXBpY2tlciwgZXYpIHtcbiAgLy8gdG8gcHJldmVudCBib3RoIGRhdGVwaWNrZXJzIHRyaWdnZXIgdGhlIG90aGVyIHNpZGUncyB1cGRhdGUgZWFjaCBvdGhlclxuICBpZiAocmFuZ2VwaWNrZXIudXBkYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmFuZ2VwaWNrZXIudXBkYXRpbmcgPSB0cnVlO1xuXG4gIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcbiAgaWYgKHRhcmdldC5kYXRlcGlja2VyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkYXRlcGlja2VycyA9IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzO1xuICBjb25zdCBzZXREYXRlT3B0aW9ucyA9IHtyZW5kZXI6IGZhbHNlfTtcbiAgY29uc3QgY2hhbmdlZFNpZGUgPSByYW5nZXBpY2tlci5pbnB1dHMuaW5kZXhPZih0YXJnZXQpO1xuICBjb25zdCBvdGhlclNpZGUgPSBjaGFuZ2VkU2lkZSA9PT0gMCA/IDEgOiAwO1xuICBjb25zdCBjaGFuZ2VkRGF0ZSA9IGRhdGVwaWNrZXJzW2NoYW5nZWRTaWRlXS5kYXRlc1swXTtcbiAgY29uc3Qgb3RoZXJEYXRlID0gZGF0ZXBpY2tlcnNbb3RoZXJTaWRlXS5kYXRlc1swXTtcblxuICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCAmJiBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlmIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgPiB0aGUgZW5kLCBzd2FwIHRoZW1cbiAgICBpZiAoY2hhbmdlZFNpZGUgPT09IDAgJiYgY2hhbmdlZERhdGUgPiBvdGhlckRhdGUpIHtcbiAgICAgIGRhdGVwaWNrZXJzWzBdLnNldERhdGUob3RoZXJEYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgICBkYXRlcGlja2Vyc1sxXS5zZXREYXRlKGNoYW5nZWREYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2VkU2lkZSA9PT0gMSAmJiBjaGFuZ2VkRGF0ZSA8IG90aGVyRGF0ZSkge1xuICAgICAgZGF0ZXBpY2tlcnNbMF0uc2V0RGF0ZShjaGFuZ2VkRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xuICAgICAgZGF0ZXBpY2tlcnNbMV0uc2V0RGF0ZShvdGhlckRhdGUsIHNldERhdGVPcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXJhbmdlcGlja2VyLmFsbG93T25lU2lkZWRSYW5nZSkge1xuICAgIC8vIHRvIHByZXZlbnQgdGhlIHJhbmdlIGZyb20gYmVjb21pbmcgb25lLXNpZGVkLCBjb3B5IGNoYW5nZWQgc2lkZSdzXG4gICAgLy8gc2VsZWN0aW9uIChubyBtYXR0ZXIgaWYgaXQncyBlbXB0eSkgdG8gdGhlIG90aGVyIHNpZGVcbiAgICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCB8fCBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0RGF0ZU9wdGlvbnMuY2xlYXIgPSB0cnVlO1xuICAgICAgZGF0ZXBpY2tlcnNbb3RoZXJTaWRlXS5zZXREYXRlKGRhdGVwaWNrZXJzW2NoYW5nZWRTaWRlXS5kYXRlcywgc2V0RGF0ZU9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBkYXRlcGlja2Vyc1swXS5waWNrZXIudXBkYXRlKCkucmVuZGVyKCk7XG4gIGRhdGVwaWNrZXJzWzFdLnBpY2tlci51cGRhdGUoKS5yZW5kZXIoKTtcbiAgZGVsZXRlIHJhbmdlcGlja2VyLnVwZGF0aW5nO1xufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcmFuZ2UgcGlja2VyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVSYW5nZVBpY2tlciAge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0ZSByYW5nZSBwaWNrZXJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcmFuZ2UgcGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnB1dHMpXG4gICAgICA/IG9wdGlvbnMuaW5wdXRzXG4gICAgICA6IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50LnJhbmdlcGlja2VyID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzLnNsaWNlKDAsIDIpO1xuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcblxuICAgIGNvbnN0IGNoYW5nZURhdGVMaXN0ZW5lciA9IG9uQ2hhbmdlRGF0ZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgIGNvbnN0IGNsZWFuT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5kYXRlcGlja2VycyA9IFtcbiAgICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzBdLCBjbGVhbk9wdGlvbnMpLFxuICAgICAgc2V0dXBEYXRlcGlja2VyKHRoaXMsIGNoYW5nZURhdGVMaXN0ZW5lciwgdGhpcy5pbnB1dHNbMV0sIGNsZWFuT3B0aW9ucyksXG4gICAgXTtcbiAgICAvLyBub3JtYWxpemUgdGhlIHJhbmdlIGlmIGluaXRhbCBkYXRlcyBhcmUgZ2l2ZW5cbiAgICBpZiAodGhpcy5kYXRlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvbkNoYW5nZURhdGUodGhpcywge3RhcmdldDogdGhpcy5pbnB1dHNbMF19KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0ZXNbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheX0gLSBzZWxlY3RlZCBkYXRlIG9mIHRoZSBsaW5rZWQgZGF0ZSBwaWNrZXJzXG4gICAqL1xuICBnZXQgZGF0ZXMoKSB7XG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlcnMpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uZGF0ZXNbMF0sXG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlcnNbMV0uZGF0ZXNbMF0sXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IHZhbHVlcyB0byB0aGUgY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcbiAgICovXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcblxuICAgIGNvbnN0IGNsZWFuT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5kYXRlcGlja2Vyc1swXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XG4gICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgRGF0ZVJhbmdlUGlja2VyIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uZGVzdHJveSgpO1xuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMV0uZGVzdHJveSgpO1xuICAgIHVucmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5yYW5nZXBpY2tlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICpcbiAgICogVGhlIG1ldGhvZCByZXR1cm5zIERhdGUgb2JqZWN0cyBieSBkZWZhdWx0LiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZ3MgZm9ybWF0dGVkIGluIGdpdmVuIGZvcm1hdC5cbiAgICogVGhlIHJlc3VsdCBhcnJheSBhbHdheXMgY29udGFpbnMgMiBpdGVtcyAoc3RhcnQgZGF0ZS9lbmQgZGF0ZSkgYW5kXG4gICAqIHVuZGlmaW5lZCBpcyB1c2VkIGZvciB1bnNlbGVjdGVkIHNpZGUuIChlLmcuIElmIG5vbmUgaXMgc2VsZWN0ZWQsXG4gICAqIHRoZSByZXN1bHQgd2lsbCBiZSBbdW5kaWZpbmVkLCB1bmRpZmluZWRdLiBJZiBvbmx5IHRoZSBlbmQgZGF0ZSBpcyBzZXRcbiAgICogd2hlbiBhbGxvd09uZVNpZGVkUmFuZ2UgY29uZmlnIG9wdGlvbiBpcyB0cnVlLCBbdW5kaWZpbmVkLCBlbmREYXRlXSB3aWxsXG4gICAqIGJlIHJldHVybmVkLilcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZm9ybWF0XSAtIEZvcm1hdCBzdHJpbmcgdG8gc3RyaW5naWZ5IHRoZSBkYXRlc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTdGFydCBhbmQgZW5kIGRhdGVzXG4gICAqL1xuICBnZXREYXRlcyhmb3JtYXQgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxuICAgICAgPyBkYXRlID0+IGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLmRhdGVwaWNrZXJzWzBdLmNvbmZpZy5sb2NhbGUpXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoZGF0ZSA9PiBkYXRlID09PSB1bmRlZmluZWQgPyBkYXRlIDogY2FsbGJhY2soZGF0ZSkpO1xuICB9XG59XG4iLCJpbXBvcnQgRGF0ZXBpY2tlciBmcm9tICcuL0RhdGVwaWNrZXIuanMnO1xuaW1wb3J0IERhdGVSYW5nZVBpY2tlciBmcm9tICcuL0RhdGVSYW5nZVBpY2tlci5qcyc7XG5cbmV4cG9ydCB7RGF0ZXBpY2tlciwgRGF0ZVJhbmdlUGlja2VyfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n')},,function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzP2ZiNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n")}]]);